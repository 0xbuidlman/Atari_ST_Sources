@width 80
@author "Emanuel Mîcklin"
@database "PEACEBUG Dokumentation Deutsch"
@subject Debugger
@$ver: 1.32 (31.03.95)
@default "Inhaltsverzeichnis"
@help %PEACEBUG


@remark *******************************************************************
@remark * Inhaltsverzeichnis                                              *
@remark *******************************************************************

@node Inhaltsverzeichnis
@next "öber PEACEBUG"

@image g:\peacebug\peacebug\doc\peacebug.img 29 1 3





                               @{U}Inhaltsverzeichnis@{u}


     1  öber PEACEBUG
     2  Starten von PEACEBUG
     3  Editor
          3.1  Bildschirmaufbau
          3.2  Tastaturbelegung
          3.3  Funktionstasten
          3.4  Maus
     4  Befehle
          4.1  Syntax
          4.2  Formelauswertung
          4.3  Listende Befehle
          4.4  Ausgabenumlenkung
          4.5  Diskoperationen
     5  Symbole
          5.1  PEACEBUG.SYM
          5.2  Lexecute
          5.3  Resident Symbol Driver
     6  Vektoren
          6.1  XBRA
          6.2  Ein Wort regelt alles
                 6.2.1  Das hîherwertige Byte
                 6.2.2  Das niederwertige Byte
          6.3  Vektoren, in eigener Sache
     7  Trace & Breakpoints
     8  Resetfest & Resetresident
     9  Cache
     10 Schnittstelle
          10.1  Cookieeintrag
          10.2  Bildschirmschnittstelle
          10.3  Userroutinen
          10.4  Debuggeraufruf
          10.5  Vektorkonfiguration
          10.6  Diverse Parameter
@endnode


@remark *******************************************************************
@remark * öber PEACEBUG                                                   *
@remark *******************************************************************

@node "öber PEACEBUG"
@toc Inhaltsverzeichnis
@prev Inhaltsverzeichnis
     @{U}1  öber PEACEBUG@{u}



@symbol ari Konzept
     @{U}Allgemeines@{u}

     PEACEBUG ist ein Low Level Debugger. UrsprÅnglich als Hintergrundde-
     bugger konzipiert, ist er in der vorliegenden Version voll symbolisch
     und fÑhig Programme zu laden. Trotzdem liegen seine StÑrken vor allem
     im Debuggen aus dem Hintergrund. Wenn unvorhergesehene Exceptions auf-
     treten, die normalerweise Bomben produzieren, tritt PEACEBUG auf den
     Plan und bietet dem Assemblerkundigen die Mîglichkeit, diese Fehler zu
     meistern, ohne den Rechner neu booten zu mÅssen. PEACEBUG ist nicht
     fÅr den Durchschnittsbenutzer konzipiert und es wird im folgenden
     davon ausgegangen, dass der geneigte Benutzer Åber Grundkenntnisse in
     Sachen Assembler verfÅgt.


@symbol ari Features
     @{U}Features@{u}

     - Erkennt und unterstÅtzt die CPU's MC68000/10/20/30/40
     - Erkennt und unterstÅtzt die FPU's MC68881/2
     - LÑuft auf allen ST(e)'s, TT's und auf dem F030
     - LÑuft mit allen TOS-Versionen, Multigem, MagiC, MinT/Multitos
     - LÑuft auf jeder planeorientierten Auflîsung und 16 Bit True Color
     - LÑuft im ST- und TT-Ram
     - MC680x0/MC6888x Disassembler
     - MC680x0 Assembler
     - Resetfest
     - Resetresident
     - Komfortable OberflÑche
     - Mausbedienung
     - Voll symbolisch
     - Umfangreiche und dokumentierte Schnittstelle
     - UnabhÑngig vom Betriebsystem
     - SYSMON UnterstÅtzung (V1.0.9, 24.04.1994)
     - DEVPAC UnterstÅtzung
     - ST-GUIDE Hypertext Dokumentation
     - Schnell(er)


@symbol ari Shareware
     @{U}Shareware@{u}

     PEACEBUG ist Shareware und darf beliebig weiterkopiert werden. Bei
     regelmÑssiger Benutzung ist eine SharewaregebÅhr von 30 SFr zu Åber-
     weisen.
     WICHTIG: Schicken Sie mir bitte keine Checks in FremdwÑhrung, sondern
     nur in Schweizer Franken (SFr), da ich sonst 10 SFr. GebÅhr bezahlen
     muss, was immerhin ein Drittel der SharewaregebÅhr ausmacht.
     Registrierte User kînnen mir eine Diskette und ein frankiertes RÅck-
     antwortcouvert schicken und erhalten dann die neuste Version.

@symbol ari Autor
     SharewaregebÅhr an:
         Emanuel Mîcklin
         Rainfussweg 7
         CH-8038 ZÅrich

@symbol ari E-Mail
     Kritik und Anregungen an:
         Internet: peace@soziologie.unizh.ch
         Decnet: ezinfo::peace
@endnode


@remark *******************************************************************
@remark * Starten von PEACEBUG                                            *
@remark *******************************************************************

@node "Starten von PEACEBUG"
@toc Inhaltsverzeichnis
     @{U}2  Starten von PEACEBUG @{u}



     @{U}Resident oder Programm@{u}

     Es gibt zwei verschiedene Arten PEACEBUG zu starten: Resident oder als
     Programm.
     1. Resident: Bedeutet, dass PEACEBUG sich installiert und mit Ptermres
        beendet (@{TSR link %TSR}). Er kann dann jederzeit Åber Tastatur aufgerufen wer-
        den. Default: Alternate+F10 oder Alternate+Control+F10. Diese
        Tastenkombinationen kînnen Sie Ihren WÅnschen anpassen, mehr dazu
        im Kapitel "Schnittstelle". Falls eine Exception auftritt, meldet
        sich der Debugger ebenfalls, damit Sie entsprechende Massnahmen er-
        greifen kînnen. Die residente Version installiert einen Cookieein-
        trag mit der Kennung "PBUG" und eine Doppelseite.
     2. Programm: Bedeutet, dass PEACEBUG sich installiert und gleich auf-
        gerufen wird. Sie kînnen den Debugger dann Åber QUIT beenden, er
        entfernt sich anschliessend vollstÑndig aus dem Speicher. Die Pro-
        grammversion installiert weder einen Cookieeintrag noch eine Dop-
        pelseite. Der als Programm installierte Debugger stellt zusÑtzlich
        den Befehl RESIDENT zur VerfÅgung.


     @{U}Autoordner@{u}

     Falls der Debugger aus dem Autoordner gestartet wird, installiert er
     sich automatisch resident. Wird er hingegen vom Desktop gestartet,
     meldet er sich als Programm, es sei denn Sie halten Control gedrÅckt,
     dann wird er ebenfalls resident installiert. Wenn Sie Alternate ge-
     drÅckt halten, verhindern Sie ein Installieren des Debuggers. Der als
     Programm gestartete Debugger kann mit dem Befehl RESIDENT nachtrÑglich
     resident installiert werden.


     @{U}Symboltabelle@{u}

     Wenn sich im Verzeichnis, aus dem PEACEBUG gestartet wird, eine Datei
     PEACEBUG.SYM befindet, wird diese als Symboltabelle interpretiert und
     nachgeladen. NÑheres dazu finden Sie im Kapitel "Symbole".


     @{U}Cookies@{u}

     Der Debugger verlÑsst sich darauf, dass der _MCH Cookie korrekt ist.
     Falls er keinen findet, geht er von einem ST aus. CPU und FPU werden
     selbststÑndig, d.h. unabhÑngig von den _CPU und _FPU Cookies erkannt.


     @{U}Mehrfachinstallation@{u}

     Beachten Sie, dass der Debugger auch mehrmals installiert werden kann.
     Dies ist Absicht und auch sinnvoll, z.B. wenn Sie PEACEBUG selber de-
     buggen oder wenn Sie mit verschiedenen Konfigurationen arbeiten
     wollen.


@symbol ari SYSMON
     @{U}SYSMON@{u}

     Wenn SYSMON nach PEACEBUG gestartet wird, dann kînnen die I- (In) und
     O-Funktionen (Out) von SYSMON benutzt werden. Ausserdem kann PEACEBUG
     von SYSMON direkt Åber Shift-Links Help aufgerufen werden. Wenn Sie
     TT-High benutzen, dann teilen sich die beiden Programme den Bild-
     schirm, so dass Sie 153600 Bytes Speicher sparen.


@symbol ari DEVPAC
     @{U}DEVPAC@{u}

     PEACEBUG kann auch zusammen mit DEVPAC benutzt werden, nur mÅssen Sie
     dann auf Sourcelevel Debugging verzichten. Um PEACEBUG anstelle von
     MONxx zu benutzen, benennen Sie PEACEBUG.PRG in MON.PRG um und ko-
     pieren diese Datei ins Verzeichnis, aus dem DEVPAC den Debugger lÑdt.


@symbol ari VRAM OUTSIDE
     @{U}VRAM & OUTSIDE@{u}

     Bei vorhandender virtueller Speicherverwaltung wird der vom Debugger
     belegte Speicher vor dem Auslagern geschÅtzt.
@endnode


@remark *******************************************************************
@remark * Editor                                                          *
@remark *******************************************************************

@node Editor
@toc Inhaltsverzeichnis
     @{U}3  Editor@{u}


     Die Bedienung von PEACEBUG orientierte sich ursprÅnglich an derjenigen
     von BUGABOO. Viele der Funktionen wurden allerdings optimiert und ge-
     statten ein schnelleres und effizienteres Arbeiten. Die OberflÑche
     orientiert sich an den Anwendern, die keine Zeit mit unnîtigen Ab-
     fragen verlieren wollen. Die Funktionstasten- und Tastaturbelegung
     unterscheidet sich mittlerweile betrÑchtlich vom Original. Ebenso hat
     die Maus zusÑtzliche Funktionen bekommen.
@autorefoff
     Der Debugger benutzt keine Betriebsystemfunktionen. Sowohl der
     Tastatur- als auch der Bildschirmtreiber ist unabhÑngig vom Betrieb-
     system.
@autorefon
@endnode

@node Bildschirmaufbau
@symbol ari OberflÑche
@toc Inhaltsverzeichnis
     @{U}3.1  Bildschirmaufbau@{u}


@image g:\peacebug\peacebug\doc\gui.img 6 70 20






















     @{U}@{Funktionstasten ignore}@{u}

     Die beiden ersten Zeilen zeigen das FunktionstastenmenÅ. Die erste
     Zeile (F1-F10) wird Åber F1-F10, die zweite (F11-F20) Åber Shift F1-
     F10 angesprochen. Die entsprechenden Funktionen kînnen auch durch An-
     klicken mit der Maus aufgerufen werden.


     @{U}Die Uhr@{u}

     Anstelle von F20 befindet sich eine Uhr. Diese zeigt zwar die Zeit an,
     hat aber sonst die gleiche Funktion wie F19, Go PC.
     Falls keine Echtzeituhr eingebaut ist, wird direkt die IKBD Uhr abge-
     fragt. Auf einem Mega ST und einem TT wird die eingebaute Uhr abge-
     fragt. Die Erkennung der Echtzeituhren ist sehr zuverlÑssig und auch
     in ST's nachtrÑglich eingebaute Uhren werden korrekt erkannt.


     @{U}Register@{u}

     Unter dem FunktionstastenmenÅ werden die aktuellen Registerinhalte
     dargestellt, wobei sich diese Anzeige aus PlatzgrÅnden auf die
     wichtigsten Register beschrÑnkt, die fehlenden kînnen jederzeit Åber
     den Befehl REGISTER angezeigt werden.

     - PC  = @{U}P@{u}rogramm@{U}c@{u}ounter
     - USP = @{U}U@{u}ser@{U}s@{u}tack@{U}p@{u}ointer
     - ISP = @{U}I@{u}nterrupt@{U}s@{u}tack@{U}p@{u}ointer (oder SSP = @{U}S@{u}upervisor@{U}s@{u}tack@{U}p@{u}ointer)
     - MSP = @{U}M@{u}aster@{U}s@{u}tack@{U}p@{u}ointer
     - SR  = @{U}S@{u}tatus@{U}r@{u}egister. Die Bedeutung der einzelnen Flags/Bits kînnen
       Sie in jedem Buch Åber die MX680x0 Prozessoren entnehmen. Hell dar-
       gestellte Flags sind gelîscht und kînnen durch Anklicken mit der
       Maus gesetzt bzw. gelîscht werden. Beim Scrollen durch den Cache
       wird die SR-Anzeige ersetzt durch den Opcode, der sich an der
       PC-Adresse befindet. Dieser Opocde verschwindet automatisch, wenn
       Sie die Maus bewegen oder wenn Sie eine Taste drÅcken.
     - Die nÑchsten beiden Zeilen stellen D0-D7 und A0-A7 dar. A7 enthÑlt
       immer den Wert des aktuellen Stackpointers (USP, ISP oder MSP) in
       AbhÑngigkeit der S- und M-Bits des Statusregisters.


     @{U}Diverses@{u}

     Die Register kînnen editiert werden, jedoch sind dabei die Editiermîg-
     lichkeiten eingeschrÑnkt, z.B. wird immer der öberschreibmodus be-
     nutzt.
     Neben den Registern befinden sich zwei Pfeile, eventuell ein Close
     Zeichen (@{ASCII ignore} 5) und zwei Cacheanzeigen. NÑheres zu diesem Thema
     finden Sie im Kapitel "Cache".
     Darunter befindet sich Ihre ArbeitsflÑche, in der Sie Befehle eingeben
     und wo Ausgaben normalerweise stattfinden.
@endnode

@node Tastaturbelegung
@toc Inhaltsverzeichnis
     @{U}3.2  Tastaturbelegung@{u}


     @{U}Cursor bewegen@{u}

     - Cursor Rechts: Bewegt den Cursor nach rechts, in der rechten unteren
       Ecke wird gescrollt.

     - Cursor Links: Bewegt den Cursor nach links, in der linken oberen
       Ecke wird gescrollt.

     - Control Cursor Rechts: Bewegt den Cursor ans Ende der Zeile oder
       falls sich der Cursor auf einer Zeilenadresse befindet, hinter den
       Prompt.

     - Control Cursor Links: Bewegt den Cursor an den Anfang der Zeile oder
       falls sich der Cursor hinter dem Prompt befindet, auf die Zeilen-
       adresse.

     - Clr Home: Bewegt den Cursor in die linke obere Ecke.

     - Alternate Cursor Auf: Hat nur in der obersten Zeile eine Bedeutung.
       Damit bewegen Sie den Cursor ins Registerfeld.


     @{U}Scrollen@{u}

     - Cursor Auf: Der Cursor bewegt sich eine Zeile nach oben, in der
       obersten Zeile wird gescrollt.

     - Cursor Ab: Der Cursor bewegt sich eine Zeile nach unten, in der
       untersten Zeile wird gescrollt.

     - Shift Cursor Auf: Wie Cursor Auf. Beim Scrollen wird allerdings
       immer nur 2 Bytes gescrollt. Dies ist nÅtzlich, wenn beim zurÅck-
       scrollen nicht ab der richtigen Adresse disassembliert wurde, weil
       es verschiedene sinnvolle Mîglichkeiten gab (der Debugger ist
       schliesslich auch nur ein Mensch). Solche "Fehler" kînnen Sie damit
       schnell korrigieren.

     - Shift Cursor Ab: Es wird 2 Bytes nach unten gescrollt (ab der ober-
       sten Adresse).

     - Control Cursor Auf: Es wird eine ganze Seite nach oben gescrollt,
       wobei bei disassemblierter Ausgabe, die SeitenlÑnge nur geschÑtzt
       werden kann.

     - Control Cursor Ab: Es wird eine ganze Seite nach unten gescrollt,
       hier kann immer die exakte SeitenlÑnge bestimmt werden.


     @{U}Lîschen&EinfÅgen@{u}

     - Insert: FÅgt ein Leerzeichen oder eine Null ein (letzteres wenn sich
       der Cursor im Registerfeld oder auf einer Adresse befindet).

     - Shift Insert: Schaltet zwischen Insert- und öberschreibmodus um.

     - Control Insert: FÅgt eine Leerzeile ein.

     - Delete: Lîscht ein Zeichen.

     - Shift Delete: Lîscht den Rest der Zeile (ab der Cursorposition).

     - Control Delete: Lîscht eine Zeile.

     - Backspace: Lîscht das Zeichen links vom Cursor. Beachten Sie den
       Unterschied Insert-/öberschreibmodus.

     - Escape: Lîscht die aktuelle Zeile. Beachten Sie die Unterschiede je
       nach Cursorposition (Zeilenadresse).

     - Shift Clr Home: Lîscht den ganzen Arbeitsbereich und bewegt den Cur-
       sor in die linke obere Ecke.


     @{U}Cachefunktionen@{u}

     - Alternate Cursor Rechts: Damit scrollen Sie im Cache vorwÑrts. Den
       gleichen Effekt erzielen Sie durch Anklicken des Pfeiles in der 5ten
       Zeile.

     - Alternate Cursor Links: Damit scrollen Sie im Cache zurÅck. Den
       gleichen Effekt erzielen Sie durch Anklicken des Pfeiles in der 4ten
       Zeile.

     - Alternate Clr Home: Bewegt den Cache zum ersten Eintrag (Nummer 0).
       Den gleichen Effekt erzielen Sie durch Anklicken des Close Zeichens
       in der 3ten Zeile.

@symbol r AI
     - Alternate Insert: Wechselt zum andern Cache.

@symbol r SAI
     - Shift Alternate Insert: Wechselt zum andern Cache, kopiert den
       Inhalt des alten in den neuen @{Cache ignore}.


     @{U}Historyfunktionen@{u}

     - Undo: Holt den zuletzt eingegebenen Befehl aus dem Historypuffer.

     - Shift Cursor Rechts: Holt den nÑchsten Eintrag aus dem History-
       puffer.

     - Shift Cursor Links: Holt den vorhergehenden Eintrag aus dem History-
       puffer.


     @{U}Marken@{u}

     - Control 1, 2, ..., 0: Der Debugger setzt eine Marke an die Adresse
       am Anfang der Zeile, d.h. im Gegensatz zu BUGABOO, der gleich den
       ganzen Screen puffert, merkt sich PEACEBUG aus RÅcksicht auf
       speicherarme User nur die Zeilenadresse. Mit 1, 2, ... sind Åbrigens
       nicht die Zahlen des Zahlenblocks gemeint.

     - Alternate 1, 2, ..., 0: Es wird ab der angegebenen Marke aufge-
       listet.


     @{U}Controlfunktionen@{u}

     - Control P: Setzt den PC auf die Zeilenadresse.

     - Control B 0, 1, ...: Setzt einen der zehn Breakpoints auf die
       Zeilenadresse.

     - Control G: Entspricht dem Befehl Go auf die Zeilenadresse.

     - Control Q: Entspricht dem Befehl QUIT.

     - Control T: Entspricht der Taste @{F1 link Funktionstasten F1}.

     - Control C: Entspricht der Taste @{F2 link Funktionstasten F2}.

     - Control R: Entspricht der Taste @{F3 link Funktionstasten F3}.

     - Control X: Entspricht der Taste @{F4 link Funktionstasten F4}.

     - Control S: Entspricht der Taste @{F5 link Funktionstasten F5}.

     - Control A: Entspricht der Taste @{F6 link Funktionstasten F6}.

     - Control H: Entspricht der Taste @{F7 link Funktionstasten F7}.

     - Control D: Entspricht der Taste @{F8 link Funktionstasten F8}.

     - Control L: Entspricht der Taste @{F9 link Funktionstasten F9}.

     - Control W: Entspricht der Taste @{F10 link Funktionstasten F10}.


     @{U}Diverses@{u}

     - Return/Enter: Die aktuelle Zeile wird ausgewertet, siehe Kapitel
       "Befehle".

     - Help: Entspricht dem Befehl HELP ohne Parameter.

     - Shift Help: Der Debugger reserviert fÅr den Bildschirm (Ascii) so-
       viel Speicher, wie fÅr den Gebrauch des 8*8 Fonts gebraucht wird.
       Wenn Sie den 8*16 Font benutzen (was die Regel sein wird), dann
       liegt die HÑlfte dieses Speichers brach, mit Help kînnen Sie diesen
       aktivieren, Sie haben dann zwei unabhÑngige Screens zur VerfÅgung.

     - Alternate Zahl: Bei gedrÅckter Alternate Taste kînnen Sie ein Zei-
       chen durch Eingeben des Asciicodes erreichen. Die Zahl muss auf dem
       Zahlenblock eingegeben werden.
@endnode

@node Funktionstasten
@toc Inhaltsverzeichnis
     @{U}3.3  Funktionstasten@{u}


@symbol r F1
     @{U}F1-Trace@{u}

     FÅhrt einen einzelnen Befehl aus. Ein Trace bewirkt ein vollstÑndiges
     Verlassen des Debuggers, d.h. der Bildschirm wird umgeschaltet, Regi-
     ster werden zurÅckgeschrieben, Vektoren restauriert. Linea, Trapv und
     Trap 0-15 werden wie einzelne Befehle behandelt. Wenn Sie diese trotz-
     dem tracen wollen, benutzen Sie F4-Texcept.


@symbol r F2
     @{U}F2-Do PC@{u}

     Hinter dem aktuellen Befehl wird ein Breakpoint gesetzt und der Befehl
     angesprungen. Diese Funktion ist vor allem bei dbcc's sinnvoll. Wenn
     der Befehl ein bsr oder jsr ist, wird kein Breakpoint gesetzt sondern
     die RÅcksprungadresse manipuliert, was schliesslich den gleichen
     Effekt hat. Die Funktion funktioniert auch im ROM (siehe Kapitel
     "Trace & Breakpoints").


@symbol r F3
     @{U}F3-Tracrts@{u}

     Das Programm wird bis zum nÑchsten rts fortgesetzt. Damit dies funkt-
     ioniert, muss vorher ein bsr oder jsr ausgefÅhrt worden sein. Mit
     dieser Funktion kînnen Sie Subroutinen, in die Sie beim Tracen irrtÅm-
     licherweise geraten sind, wieder verlassen.


@symbol r F4
     @{U}F4-Texcept@{u}

     Entspricht F1-Trace, nur dass auch Traps (Trap 0-15, Trapv), der
     Linea- und der Illegal Opcode Handler getraced werden.


@symbol r F5
     @{U}F5-Skip PC@{u}

     öberspringt den aktuellen Befehl und erzeugt einen Cacheeintrag.


@symbol r F6
     @{U}F6-Ascii@{u}

     Listet ab dem PC im Asciimodus.


@symbol r F7
     @{U}F7-Hexdump@{u}

     Listet ab dem PC im Hexdumpmodus.


@symbol r F8
     @{U}F8-Disassm@{u}

     Listet ab dem PC im Disassembliermodus.


@symbol r F9
     @{U}F9-List@{u}

     Listet ab dem PC im Listmodus.


@symbol r F10
     @{U}F10-Switch@{u}

     Schaltet zwischen Debugger- und Programmscreen hin und her. Wenn Sie
     derart auf den Programmscreen wechseln, dann wird auch nach Verlassen
     und erneutem Einspringen in den Debugger nicht mehr auf den Debugger-
     screen umgeschaltet. Dies erlaubt Ihnen beim Tracen, immer den Pro-
     grammscreen im Auge zu behalten, kann allerdings zu Verwirrung fÅhren,
     da auch bei Auftreten einer Exception nicht umgeschaltet wird. Falls
     Sie also einmal das GefÅhl haben, der Rechner habe sich aufgehÑngt,
     drÅcken Sie zuerst F10, bevor Sie reseten.


     @{U}F11-Tr68020@{u}

     Simuliert den Tracemodus des MC68020/30/40, d.h. nur bei Befehlen, die
     den PC verÑndern (change of flow), wie Sprungbefehlen, rts/rte/rtr und
     Traps wird das Programm unterbrochen.


     @{U}F12-Tnosubs@{u}

     Entspricht F1-Trace, nur dass Subroutinen, die mittels bsr oder jsr
     aufgerufen werden wie einzelne Befehle behandelt werden, d.h. anstatt
     in die Subroutine zu springen, unterbricht der Debugger das Programm
     erst wieder, wenn die Subroutine ausgefÅhrt worden ist.


     @{U}F13-Tracrte@{u}

     Das Programm wird bis zum nÑchsten rte fortgesetzt. Damit dies funkt-
     ioniert, muss vorher eine Exception aufgetreten sein oder auf eine
     andere Weise ein gÅltiger Stackframe erzeugt worden sein. Mit dieser
     Funktion kînnen Sie Exceptionroutinen, in die Sie beim Tracen irrtÅm-
     licherweise geraten sind, wieder verlassen.
     ACHTUNG: Falls die Exceptionroutine den PC, der auf dem Stack liegt,
     benÅtzt, darf diese Funktion natÅrlich nicht aufgerufen werden. Dies
     ist z.B. bei Linea-Exceptions der Fall. Sie kînnen daher nicht mittels
     F4 ein Linea tracen und dann unmittelbar mit F13 weiterfahren. Dies
     ist erst erlaubt, wenn sich die Routine den Opcode Åber den auf dem
     Stack liegenden PC geholt hat.


     @{U}F14-GoTraps@{u}

     Setzt das Programm fort, bis dieses ein Betriebsystemaufruf tÑtigt
     (Trap 1/2/13/14, d.h. Gemdos/AES/VDI/Bios/Xbios). Dies ist praktisch,
     wenn Sie sich nur fÅr die wichtigen Stellen eines Programms interes-
     sieren und das sind hÑufig die Betriebsystemaufrufe. Dies funktioniert
     auch unter Multitasking Betriebsystemen, der Debugger muss dazu auch
     nicht in die Vektoren eingehÑngt sein.


     @{U}F15-Breakpt@{u}

     Setzt oder lîscht auf der aktuellen Adresse einen Breakpoint. Im
     Gegensatz zu Control B kînnen Sie die Breakpointnummer nicht angeben,
     es wird automatisch die erste freie Nummer genommen und eine Meldung
     ausgegeben:
     "Stop Breakpoint $5 set" oder
     "Stop Breakpoint $5 cleared"


     @{U}F16-Font@{u}

     Schaltet um zwischen 8*8 und 8*16 Font. Bei gesetzter SCREEN_LOCK
     Semaphore (Schnittstelle) kann diese Funktion nicht aufgerufen werden.


     @{U}F17-@{Symbol ignore} + - /@{u}

     Hier kînnen Sie festlegen, ob PEACEBUG symbolisch oder nichtsymbolisch
     arbeiten soll (Disassembler/Formelinterpreter).
     - @{Symbol ignore} + bedeutet, dass er alle @{Symbole ignore} benutzt.
     - @{Symbol ignore} / bedeutet, dass er nur die eigenen @{Symbole ignore} benutzt und
       diejenigen des @{"Resident Symbol Drivers" link "Resident Symbol Driver"} ignoriert.
     - @{Symbol ignore} - bedeutet, dass er gar keine @{Symbole ignore} benutzt.


     @{U}F18-Insert + -@{u}

     Schaltet zwischen dem öberschreib- und dem EinfÅgemodus hin und her
     (Insert+ bzw. Insert-).


     @{U}F19-@{GO ignore} PC@{u}

     Setzt das Programm beim aktuellen PC fort.


     @{U}F20-@{GO ignore} PC@{u}

     Setzt das Programm beim aktuellen PC fort. Diese Funktionstaste ist
     nicht beschriftet, da sich dort die Uhr befindet.
@endnode

@node Maus
@toc Inhaltsverzeichnis
     @{U}3.4  Maus@{u}


     Die Maus hat folgende Funktionen:

     1. Positionieren des Cursors. Der Cursor kann auch auf ein Register
        gesetzt werden.

     2. Bedienung der Cacheelemente (Pfeile, Close).

     3. AnwÑhlen der Funktionstasten.

     4. Wenn Sie die rechte Maustaste drÅcken, wird der unter der Maus ste-
        hende Text an die aktuelle Cursorposition kopiert. Es werden aller-
        dings nur die Zeichen $ % . o 0 1 2 3 4 5 6 7 8 9 A B C D E und F
        kopiert. Wenn Sie zusÑtzlich eine Shifttaste drÅcken, sind auch die
        Zeichen , - ( ) [ ] { } * # : _ und / zugelassen. Damit kînnen Sie
        komfortabel Adressen/Zahlen (ohne Shift) bzw. Opcodes (mit Shift)
        kopieren.

     5. Wenn Sie mit der linken Maustaste auf eine Zahl oder ein Symbol
        doppelklicken, listet der Debugger ab dieser Adresse (Ascii, Hex-
        dump, Disassembly oder List Modus).
@endnode


@remark *******************************************************************
@remark * Befehle                                                         *
@remark *******************************************************************

@node Befehle
@toc Inhaltsverzeichnis
     @{U}4  Befehle@{u}



     @{U}Allgemeines@{u}

     Im folgenden sehen Sie eine Liste aller Befehle. Um diese voll zu
     verstehen, sollten sie vorher die fÅnf Kapitel "Syntax",
     "Formelauswertung", "Listende Befehle", "Ausgabenumlenkung" und
     "Diskoperationen" lesen.


@symbol ari BefehlsÅbersicht
     @{U}BefehlsÅbersicht@{u}

     @{Ascii link %ASCII} [From][,To|#Lines|[Bytes]|.]
     @{ASCFind link %ASCFIND}[.w|.l] [From],[To],String
     @{Breakpoints link %BREAKPOINTS} [-|Number-|Number|Number=Address[,Number|,*|,=[Value]]]
     @{Call link %CALL} [Address]
     @{CD link %CD} [Path]
     @{CHecksumme link %CHECKSUMME} [Address][,Checksum][,Number]
     @{CLr link %CLR} [From][,To]
     @{COld link %COLD}
     @{COMpare link %COMPARE}[.b|.w|.l] [From],[To],Destination
     @{COOkie link %COOKIE}
     @{COPy link %COPY} [From],[To],Destination
     @{Disassemble link %DISASSEMBLE} [From][,To|#Lines|[Bytes]|.]|:[CPUs]
     @{DFree link %DFREE} [Drive:]
     @{DIRectory link %DIRECTORY} [Path]
     @{DO link %DO} [Address]
     @{DUmp link %DUMP} [From][,To|#Lines|[Bytes]|.]
     @{Exit link %EXIT} [Value]
     @{Find link %FIND}[.b|.w|.l] [From],[To],Term{,Term}
     @{FILl link %FILL} [From],[To],Term{,Term}
     @{FRee link %FREE}
     @{Go link %GO} [Address][,Breakpoint]
     @{Help link %HELP} [Command]
     @{HUnt link %HUNT} [From],[To],Term{,Term}
     @{Info link %INFO}
     @{List link %LIST} [From][,To|#Lines|[Bytes]|.]
     @{LAst link %LAST}
     @{LEt link %LET} Register=Value
     @{LEXecute link %LEXECUTE} Filename
     @{LOad link %LOAD} Filename[,Start[,End]]|-
     @{LS link %LS} [Pfad]
     @{Memory link %MEMORY} [From][,To|#Lines|[Bytes]|.]
     @{MKdirectory link %MKDIRECTORY} Directory
     @{Newformat link %NEWFORMAT}
     @{Observe link %OBSERVE} [-|+|[Address][,Bytes]]
     @{Page link %PAGE}
     @{PRograms link %PROGRAMS}
     @{Quit link %QUIT} [Value]
     @{Readsector link %READSECTOR} [Track][,Sector][,Side][,Address][,Drive]
     @{REGister link %REGISTER} [Register]
     @{RESident link %RESIDENT}
     @{RMdirectory link %RMDIRECTORY} Directory|File
     @{Save link %SAVE} Filename[,Start,End]
     @{SEt link %SET} Register=Value
     @{SHowmemory link %SHOWMEMORY} [-|Number-|Number|Term[,List]]
     @{SLow link %SLOW} [+|-]
     @{SWitch link %SWITCH} [ResolutionDebugger][,ResolutionProgram]
     @{SYmbol link %SYMBOL} [From][,To]
     @{SYSinfo link %SYSINFO}
     @{Trace link %TRACE} [Number|+|-|*|/]
     @{Warm link %WARM}
     @{WRitesector link %WRITESECTOR} [Track][,Sector][,Side][,Address][,Drive]
     @{Xbra link %XBRA} [FirstVector][,LastVector][,ID]
     @{? link %?} Term{,Term}
     @{/ link %/} [.b|.w|.a|.l] [Term]{,Term}
     @{! link %!} Opcode
     @{, link %,} [.b|.w|.a|.l] [Term]{,Term}
     @{) link %)} String
     @{: link %:} Address[,Term]{,Term}
@endnode

@node Syntax
@toc Inhaltsverzeichnis
     @{U}4.1  Syntax@{u}


     @{U}Allgemeines@{u}

     - Jeder Befehl kann abgekÅrzt werden, solange er eindeutig bleibt. Die
       signifikanten Zeichen sind in Grossbuchstaben geschrieben und bezei-
       chnen die kÅrzeste Form, die Sie benÅtzen dÅrfen. Es ist allerdings
       immer erlaubt, mehr Zeichen einzugeben als nîtig (h=he=hel=help).

     - Die Auswertung Ihrer Eingaben wurde so flexibel wie mîglich program-
       miert, z.B. werden ÅberflÅssige Eingaben ignoriert. Es kann vorkom-
       men, dass ein von Ihnen falsch eingegebener Ausdruck trotzdem als
       korrekt interpretiert wird, weil z.B. eine kÅrzere korrekte Form
       gefunden wird. Um zu vermeiden, dass Sie nicht bemerken, dass der
       Debugger etwas anderes als das von Ihnen intendierte ausgewertet
       hat, wird alles gelîscht, was sich hinter dem zuletzt ausgewerteten
       Zeichen befindet. Gleiches gilt, falls der Debugger einen Fehler
       findet. Es wird dann ab dem Zeichen gelîscht, das der Debugger noch
       auswerten konnte.
       Beispiel: Sie geben ein: "l 10+p.flack"  ---> "l 10+p." mit der
       Fehlermeldung "Expression required" ---> Sie erkennen sofort, dass
       das eingegebene Symbol falsch sein muss (richtig wÑre wohl .flock).

     - Werte in eckigen Klammern sind optional, z.B. Help [Command] oder
       CLr [From][,To]. Wenn Sie keine Eingabe machen, wird ein Defaultwert
       angenommen. Bei Adressen gilt folgende Regel:
       - Den PC als Defaultadresse nehmen die Befehle ASCII, DISASSEMBLE,
         DUMP, LIST, CALL, DO und GO.
       - CHECKSUMME nimmt die Sektorpufferadressse als Default.
       - Alle andern Befehle nehmen als Defaultadresse(n) die Anfangs-/End-
         adressen eines mittels LOAD oder LEXECUTE geladenen Files, falls
         denn ein solches geladen wurde.

     - Werte in geschweiften Klammern sind optional und beliebig oft wie-
       derholbar, z.B. ? Term{,Term}.

     - Bei einigen Befehlen kann eine Extension in der Form [.b|.w|.l] an-
       gegeben werden. Dies ist in der Regel die Schrittweite (suchen, ver-
       gleichen usw.) und kann sein: Byte, Word, Long. NÑheres dazu finden
       Sie bei den Beschreibungen der entsprechenden Befehle.

     - Alle Befehle, die OS Routinen aufrufen sind mit einem Asterix *
       gekennzeichnet.


     @{U}Beispiele@{u}

     1. Input: "d^a7#1! *MOVE.L    D0,-(A0)"
        Effekt: Disassembliert eine Zeile ab dem aktuellen SP.

     2. Input: "com 60,70,10"                           oder
               "Compare 60,70,10"                       oder
               "cOMp . b 60 , 70 , 10"
        Effekt: Vergleicht 16 Bytes von $60 mit $10 in Byteschritten.

     3. Input: "sh ^mmusr , 3"                          oder
               "showm ^psr,3"
        Effekt: Showmemory im Hexdumpmodus ab dem Wert des MMUSR.

     4. Input: "ascF p84,p .ramtop,'*PMOVE*'"           oder
               "ASCFIN pl84,p.ramtop,'**PMOVE**'"
        Effekt: Durchsucht den Bereich von p84 bis ramtop nach PMOVE's.
@endnode

@node Formelauswertung
@toc Inhaltsverzeichnis
     @{U}4.2  Formelauswertung@{u}


     @{U}Zahlenbasen@{u}

        %         BinÑr
        .         Dezimal
        $         Hexadezimal
        o         Oktal
        ' oder "  Ascii

     Wird kein Prefix verwendet, wird die Defaultbasis verwendet (normaler-
     weise 16). Diese kann Åber die Cookieschnittstelle verÑndert werden.


     @{U}Vorzeichen@{u}

        + Plus
        - 2er Komplement
        ~ 1er Komplement


     @{U}VerknÅpfungen@{u}

        + Addition
        - Subtraktion
        * Multiplikation (32 Bit)
        / Division (32 Bit)
        | Odern
        & Anden
        ^ Eoren
        > Shift Right ---> ACHTUNG: wurde ersatzlos gestrichen.
        < Shift Left       BenÅtzen Sie anstatt < mit negativem Operanden.
        % Modulo

     Die PrioritÑten der VerknÅpfungen und der Vorzeichen kînnen Åber die
     Schnittstelle verÑndert werden. Beispielsweise ist so Strich- vor
     Punktrechnung realisierbar, wenngleich wohl kaum sinnvoll.


     @{U}Referenzen@{u}

     - ^Register: Register werden immer mit einem ^ angesprochen. Es sind
       folgende Register mîglich:
          D0-D7/A0-A7
          SP (Stack Pointer)
          USP (User Stack Pointer)
          SSP (Supervisor Stack Pointer)
          ISP (Interrupt Stack Pointer)
          MSP (Master Stack Pointer)
          PC (Program Counter)
          SR (Status Register)
          CCR (Condition Code Register)
          SFC (Source Function Code)
          DFC (Destination Function Code)
          VBR (Vector Base Register)
          CAAR (CAche Adress Register)
          CACR (CAche Control Register)
          MMUSR (MMU Status Register)
          PSR=MMUSR (PSR ist 68851 Notation)
          TT0 (Transparent Translation 0)
          TT1 (Transparent Translation 1)
          TC (Translation Control)
          URP (User Root Pointer)
          DTT0 (Data Transparent Translation Register 0)
          DTT1 (Data Transparent Translation Register 1)
          ITT0 (Instruction Transparent Translation Register 0)
          ITT1 (Instruction Transparent Translation Register 1)
     Die beiden Register SRP (Supervisor Root Pointer) und CRP (CPU Root
     Pointer) kînnen nicht benutzt werden, da es sich dabei um 64 Bit Regi-
     ster handelt und der Debugger nur 32 Bit Arithmetik beherrscht.

     - pb, pw, pl, p Pointer: Der dem Pointer folgende Ausdruck wird als
       Adresse interpretiert und deren Inhalt ausgelesen. Mit pb erfolgt
       dies als Byte, mit pw als Word und mit pl oder p als Long.

     - @{.Symbol ignore}: Alle Symbole werden Åber ein . als Prefix referenziert.


     @{U}Beispiele@{u}

     1. Input: "l p(^vbr+.trace)"
        Effekt: Listet die Traceroutine auf.

     2. Input: "l p(p.trap_1-4)"
        Effekt: Listet die Routine auf, die als zweite im Gemdosvektor
        hÑngt (falls die erste XBRA benutzt).
@endnode

@node "Listende Befehle"
@toc Inhaltsverzeichnis
     @{U}4.3  Listende @{Befehle ignore}@{u}


     Alle Befehle, die irgendwelche Ausgaben machen, kînnen unterbrochen
     oder angehalten werden:
     - Escape: Abruch, keine weiteren Ausgaben mehr. Funktioniert zu jedem
       Zeitpunkt, wenn der Cheatmode nicht aktiv ist.
     - Space: Die Ausgabe wird angehalten, sie kann durch einen beliebigen
       Tastendruck fortgesetzt werden.
     - Control: Solange die Controltaste gedrÅckt gehalten wird, wird die
       Ausgabe angehalten.

     Falls eine Ausgabe lÑnger als eine Zeile ist, wird am Ende der Zeile
     der Asciicode 3 geprintet (Asciicode 3 sollte ein Pfeil sein). Dies
     soll Ihnen anzeigen, dass nicht der ganze String sichtbar ist.
@endnode

@node Ausgabenumlenkung
@toc Inhaltsverzeichnis
     @{U}4.4  Ausgabenumlenkung@{u}


     @{U}Allgemeines@{u}

     Ausgaben erfolgen meistens auf dem Screen.
     Durch anhÑngen eines >device: kînnen diese allerdings umgelenkt wer-
     den. Es sind im Moment drei Devices verfÅgbar: midi: (MIDI), prn:
     (Centronics) und aux: (Seriell).
     Aber nicht nur Devices kînnen Sie angeben, auch Dateien sind erlaubt:
     - >file erzeugt eine Datei namens "file" und schreibt alle Ausgaben in
       dieses File. Wenn die Datei schon existiert, wird sie zuerst ge-
       lîscht.
     - >>file îffnet eine Datei und schreibt die Ausgaben ans Ende der Da-
       tei. Wenn Sie noch nicht existiert, wird sie erzeugt.


     @{U}Beispiele@{u}

     1. Input: "d fc0000,fc0000+.192000 >m:rom_dis"
        Effekt: Disassembliert das ROM in eine Datei auf Laufwerk m.

     2. Input: "help >help\helpfile"
        Effekt: Schreibt die Ausgaben von help in eine Datei helpfile im
        Ordner help.
@endnode

@node Diskoperationen
     @{U}4.5  Diskoperationen@{u}


     @{U}Allgemeines@{u}

     Alle Funktionen mit Ausnahme der Diskoperationen sind unabhÑngig vom
     Betriebsystem. Wenn Sie per Tastatur in den Debugger einspringen, be-
     deutet das, dass der Debugger im Interrupt lÑuft. Wenn Sie dann ir-
     gendwelche Betriebsystemfunktionen aufrufen, ist die Wahrscheinlich-
     keit, dass das dem Rechner nicht wohlbekommt, ziemlich hoch. Sollten
     Sie also diese Absicht haben, so rufen Sie den Debugger mit Vorteil
     Åber CALLPB_1 auf (im Ordner PEACEBUG\UTILLITY).
     Wenn Fehler bei Diskoperationen auftreten, erscheinen normalerweise
     Alertboxen, was z.B. in Tosprogrammen eher lÑstig ist, steht doch kei-
     ne Maus zur VerfÅgung. Um dies im Debugger zu verhindern, installiert
     er einen eigenen etv_critic Handler, es erscheint dann anstatt einer
     Box, eine Meldung wie: Seek Error: (A)bort, (R)etry, (I)gnore?


     @{U}Fehlermeldungen@{u}

     -1: Error: Es ist ein Fehler aufgetreten, der nicht genauer spezifi-
         ziert werden kann.
     -2: Drive not ready: Angesprochenes GerÑt ist nicht angeschlossen,
         nicht funktionsbereit oder reagiert nicht innerhalb der gesetzten
         Frist (Timeout).
     -3: Unknown Command: Dem angesprochenen PeripheriegerÑt ist das gege-
         bene Kommando unbekannt.
     -4: CRC Error: Beim Lesen eines Sektors ist ein CRC-Fehler aufgetre-
         ten.
     -5: Bad request: Das PeripheriegerÑt kann das Kommando nicht aus-
         fÅhren.
     -6: Seek Error: Der angesprochene Track konnte vom Laufwerk nicht er-
         reicht werden.
     -7: Unknown Media: Leseversuch gescheitert, da das Medium keinen kor-
         rekten Bootsektor besitzt.
     -8: Sector not found: Der betreffende Sektor wurde nicht gefunden.
     -9: Out of Paper: Drucker nicht betriebsbereit.
     -10:Write fault: Fehler bei Schreiboperation aufgetreten.
     -11:Read fault: Fehler bei Leseoperation aufgetreten.
     -12:General Error: Allgemeiner Fehler, "reserved for future catastro-
         phes".
     -13:Write on write-protected media: Es wurde versucht, auf ein
         schreibgeschÅtztes Medium zu schreiben.
     -14:Media change detected: Seit der letzten Schreiboperation wurde das
         Medium gewechselt.
     -15:Unknown device: Das angesprochene GerÑt ist dem Betriebsystem un-
         bekannt.
     -16:Bad sectors on format: Beim Formatiervorgang wurden defekte Sekto-
         ren entdeckt.
     -17:Insert other disk request: Eine andere Diskette muss eingelegt
         werden. Tritt nur auf, wenn Laufwerk B angesprochen wird, ohne an-
         geschlossen zu sein.
     -18:Insert Disk: Meta-DOS-Fehler: Medium einlegen.
     -19:Device not responding: Meta-DOS-Fehler: GerÑt antwortet nicht.
@endnode

@node %ASCII "Befehl: ASCII"
@symbol ar ASCII
@symbol i %ASCII
@toc Befehle
     @{U}4.6.1  ASCII@{u}


     Syntax

     Ascii [From][,To|#Lines|[Bytes]|.]


     @{U}Beschreibung@{u}

     Gibt einen Speicherbereich als Asciidump aus:
     - From: Ab dieser Adresse wird ausgegeben.
     - To: Bis zu dieser Adresse wird ausgegeben, wie bei allen Befehlen
       exklusive "To", d.h. a $10,$20 gibt bis und mit $1f aus.
     - #Lines: Anstelle einer Endadresse kann die Anzahl Zeilen bestimmt
       werden, die ausgegeben werden sollen.
     - [Bytes]: Damit geben Sie die Anzahl Bytes an, die ausgegeben werden.
       Die schliessende Klammer ist optional.
     - .: Die Ausgabe erfolgt endlos und muss "von Hand" abgebrochen wer-
       den (Escape).
     Wenn Sie weder To, #Lines, [Bytes] noch . angegeben, werden default-
     mÑssig 16 Zeilen ausgegeben.


     @{U}Beispiele@{u}

     $00100000>asc#2               ; Zwei Zeilen ab dem PC ausgeben
     $00100000>a[30                ; 30 Bytes ab dem PC ausgeben
     $00100000>ascii ^A7,^A7+10    ; 10 Bytes ab dem Stackpointer ausgeben
     $00100000>as^A4[20]           ; 20 Bytes ab A4 ausgeben
     $00100000>asci p(.trap_d)-c   ; gibt 16 Zeilen ab Bioshandler-12 aus
     $00100000>a.                  ; gibt ab dem PC endlos aus
@endnode

@node %ASCFIND "Befehl: ASCFIND"
@symbol ar ASCFIND
@symbol i %ASCFIND
@toc Befehle
     @{U}4.6.2  ASCFIND@{u}


     Syntax

     ASCFind[.w|.l] [From],[To],String


     @{U}Beschreibung@{u}

     Disassembliert einen Speicherbereich und vergleicht "String" mit dem
     vom Disassembler erzeugten String. Der Vergleich erfolgt Casesensi-
     tive und es sind die Quantoren ? bzw. * zugelassen. Die LÑngenangaben
     .w und .l geben an, in welchen Schritten der angegebene Speicherbe-
     reich disassembliert wird, nÑmlich in 2er respektive 4er Schritten.
     Ist weder .w noch .l angegeben, dann wird der Speicherbereich kontinu-
     ierlich disassembliert, d.h. Opcode fÅr Opcode. Dies ist sinnvoll,
     wenn Sie Programmcode durchsuchen und ist schneller als in 2er Schrit-
     ten. Der Nachteil ist allerdings, dass es so vorkommen kann, dass Be-
     fehle nicht gefunden werden, falls "From" nicht mit einer Opcode-
     adresse Åbereinstimmt.
     Befindet sich der gefundene Befehl innerhalb des Debuggers oder in
     einem von diesem allozierten Speicherbereich, wird er mit einem *
     gekennzeichnet.
     Defaultadressen fÅr "From" und "To", sind die Anfangs- bzw. Endadres-
     sen eines mit LEXECUTE oder LOAD geladenen Files.


     @{U}Beispiele@{u}

     $00100000>ascf e00000,e00000+.10000,'*PMOVE*'
     $00E00068>! PMOVE    $E36040,TC
     $00E00070>! PMOVE    $E36040,TT0
     $00E00078>! PMOVE    $E36040,TT1
     $00E01702>! PMOVE    $E3654C,CRP
     $00E0170A>! PMOVE    $E36554,TC
     $00E01712>! PMOVE    $E36558,TT0
     $00E0171A>! PMOVE    $E3655C,TT1

     $00100000>ascfind 0,80,"MOVE.W*(A?)+*D?"
     $00000012>! MOVE.W   (A6)+,D7
@endnode

@node %BREAKPOINTS "Befehl: BREAKPOINTS"
@symbol ar BREAKPOINTS
@symbol i %BREAKPOINTS
@toc Befehle
     @{U}4.6.3  BREAKPOINTS@{u}


     Syntax

     Breakpoints [-|Number-|Number|Number=Address[,Number|,*|,=[Value]]]


     @{U}Beschreibung@{u}

     1. Stopbreakpoints: Dieser Breakpoint muss eine bestimmte Anzahl mal
        durchlaufen werden, bis das Programm unterbrochen und der Break-
        point gelîscht wird. Normale Breakpoints (F15 oder Control B) sind
        Stopbreakpoints mit Startwert 1. Die Anzeige mit b gibt aus, wie
        oft der Breakpoint noch durchlaufen werden muss.
     2. ZÑhlerbreakpoint: Dieser Breakpoint erhîht jedesmal, wenn er durch-
        laufen wird einen ZÑhler, das Programm wird nie unterbrochen. Die
        Anzeige mit b gibt aus, wie oft der Breakpoint schon durchlaufen
        wurde.
     3. Permanentbreakpoint: Dieser Breakpoint unterbricht das Programm
        bei jedem Durchlaufen und wird im Gegensatz zum Stopbreakpoint
        nicht gelîscht. Er kann nur manuel mit B- oder B Nummer- entfernt
        werden.

     - Breakpoints ohne Parameter: Zeigt alle gesetzten Breakpoints.
     - Breakpoints -: Lîscht alle Breakpoints.
     - Breakpoints Number-: Lîscht einen Breakpoint.
     - Breakpoints Number: Zeigt einen Breakpoint an.
     - Breakpoints Number=Address: Setzt einen Stopbreakpoint mit Start-
       wert 1.
     - Breakpoints Number=Address,Number: Setzt einen Stopbreakpoint mit
       Startwert "Number".
     - Breakpoints Number=Address,*: Setzt einen Permanentbreakpoint.
     - Breakpoints Number=Address,=: Setzt einen ZÑhlerbreakpoint mit
       Startwert 0.
     - Breakpoints Number=Address,=Value: Setzt einen ZÑhlerbreakpoint mit
       Startwert "Value".

     Breakpoints dÅrfen auch im ROM gesetzt werden, dann wird das Programm
     allerdings im Tracemodus durchlaufen. NÑheres zu dem Thema siehe
     Kapitel "Trace & Breakpoints".


     @{U}Beispiele@{u}

     $00100000>b0=1000,*
     $00100000>b7=2000,=
     $00100000>b5=3000,20
     $00100000>b
      Breakpoint $0=$1000,*       ; Permanent Breakpoint
      Breakpoint $5=$3000,$20     ; Stop Breakpoint (ZÑhler=20)
      Breakpoint $7=$2000,=$0     ; ZÑhler Breakpoint (ZÑhler=0)

     $00100000>b5-
     $00100000>b7
      Breakpoint $7=$2000,=$0
@endnode

@node %CALL "Befehl: CALL"
@symbol ar CALL
@toc Befehle
     @{U}4.6.4  CALL@{u}


     Syntax

     Call [Address]


     @{U}Beschreibung@{u}

     Ruft ein Unterprogramm auf, das mittels rts abgeschlossen sein muss.
     Default fÅr Address ist der aktuelle PC.
@endnode

@node %CD "Befehl: CD"
@symbol ar CD
@symbol i %CD
@toc Befehle
     @{U}4.6.5  CD *@{u}


     Syntax

     CD [Path]


     @{U}Beschreibung@{u}

     CD ohne Parameter: Gibt den aktuellen Pfadnamen aus.
     CD Pfad: Wechselt den aktuellen Pfad.


     @{U}Beispiele@{u}

     $00100000>cd j:PEACEBUG
      J:\PEACEBUG\

     $00100000>cd c:
      C:\GEMINI\GEMINI\

     $00100000>cd
      C:\GEMINI\GEMINI\
@endnode

@node %CHECKSUMME "Befehl: CHECKSUMME"
@symbol ar CHECKSUMME
@symbol i %CHECKSUMME
@toc Befehle
     @{U}4.6.6  CHECKSUMME@{u}


     Syntax

     CHeckumme [Address][,Checksum][,Number]


     @{U}Beschreibung@{u}

     Addiert eine bestimmte Anzahl Worte ab der Anfangsadresse und gibt die
     Differenz zur angegebenen Checksumme an.
     Mit diesem Befehl kînnen Sie z.B. Bootsektoren oder Doppelseiten auf
     ihre AusfÅhrbarkeit ÅberprÅfen.
     DefaultmÑssig sind alle drei Parameter so eingestellt, dass ein
     mittels READSECTOR geladener Bootsektor auf AusfÅhrbarkeit ÅberprÅft
     wird (Address=Sektorpuffer, Checksum=$1234, Number=256).


     @{U}Beispiele@{u}

     $00100000>ch 600
      Checksum: $1234
     $00100000>: 600,pw600+1234          ; addiert $1234 an die Adresse $600
     $00100000>ch 600
      Checksum: $0

     $00100000>readsector
      Sectorbuffer:   $10532c6
     $00100000>ch                        ; Bootsektor testen
      Checksum: $0                       ; ---> ausfÅhrbar
     $00100000>ch $10532c6,$1234,.256    ; nochmals das gleiche explizit
      Checksum: $0

     $00100000>page
      Resident program at $E6000
     $00100000>ch $E6000,$5678        ; Doppelseite testen
      Checksum: $0                       ; ---> ausfÅhrbar
@endnode

@node %CLR "Befehl: CLR"
@symbol ar CLR
@symbol i %CLR
@toc Befehle
     @{U}4.6.7  CLR@{u}


     Syntax

     CLr [From][,To]


     @{U}Beschreibung@{u}

     Lîscht den angegebenen Speicherbereich. Wie immer wird "To" selber
     nicht gelîscht, d.h. clr 100,200 lîscht bis und mit Adresse $1ff.
     Defaultadressen fÅr "From" und "To", sind die Anfangs- bzw. Endadres-
     sen eines mit LEXECUTE oder LOAD geladenen Files.
@endnode

@node %COLD "Befehl: COLD"
@symbol ar COLD
@symbol i %COLD
@toc Befehle
     @{U}4.6.8  COLD@{u}


     Syntax

     COld


     @{U}Beschreibung@{u}

     Der Rechner fÅhrt einen Kaltstart aus. Der Debugger entfernt sich
     unwiderruflich aus dem System.
@endnode

@node %COMPARE "Befehl: COMPARE"
@symbol ar COMPARE
@symbol i %COMPARE
@toc Befehle
     @{U}4.6.9  COMPARE@{u}


     Syntax

     COMpare[.b|.w|.l] [From],[To],Destination


     @{U}Beschreibung@{u}

     Vergleicht zwei Speicherbereiche und gibt die Adressen aus, deren
     Inhalt nicht Åbereinstimmt. Das Inkrement betrÑgt .b=Byte, .w=Word
     oder .l=long, wobei dann natÅrlich auch der Vergleich byte, word oder
     long erfolgt. DefaultmÑssig wird byteweise verglichen.
     Defaultadressen fÅr "From" und "To", sind die Anfangs- bzw. Endadres-
     sen eines mit LEXECUTE oder LOAD geladenen Files.


     @{U}Beispiele@{u}

     $00100000>com 0,10,fc0000
      $FC0009 $FC000A $FC000B $FC000D $FC000E $FC000F

     $00100000>comp.w 0,10,fc0000
      $FC0008 $FC000A $FC000C $FC000E

     $00100000>compa.l 0,10,fc0000
      $FC0008 $FC000C
@endnode

@node %COOKIE "Befehl: COOKIE"
@symbol ar COOKIE
@symbol i %COOKIE
@toc Befehle
     @{U}4.6.10  COOKIE@{u}


     Syntax

     COOkie


     @{U}Beschreibung@{u}

     Gibt eine Liste aller CookieeintrÑge aus. Der Eintrag des Debuggers
     mit der Kennung "PBUG" wird mit einem Asterix * gekennzeichnet, was
     nÅtzlich ist, wenn zwei Debugger installiert sind.
@endnode

@node %COPY "Befehl: COPY"
@symbol ar COPY
@symbol i %COPY
@toc Befehle
     @{U}4.6.11  COPY@{u}


     Syntax

     COPy [From],[To],Destination


     @{U}Beschreibung@{u}

     Kopiert einen Speicherbereich. öberlappende Bereiche werden korrekt
     kopiert.
     Defaultadressen fÅr "From" und "To", sind die Anfangs- bzw. Endadres-
     sen eines mit LEXECUTE oder LOAD geladenen Files.


     @{U}Beispiel@{u}

     $00100000>cop 600,700,700           ; kopiert $600-$6ff nach $700
@endnode

@node %DISASSEMBLE "Befehl: DISASSEMBLE"
@symbol ar DISASSEMBLE
@symbol i %DISASSEMBLE
@toc Befehle
     @{U}4.6.12  DISASSEMBLE@{u}


     Syntax

     Disassemble [From][,To|#Lines|[Bytes]|.]|:[CPUs]


     @{U}Beschreibung@{u}

     1. Gibt einen Speicherbereich in disassemblierter Form aus. Die Para-
        meter entsprechen denjenigen des Befehls ASCII, mit Ausnahme von:
        - d: Hiermit erfahren Sie, fÅr welche Prozessoren der Disassembler
          bzw. der Assembler konfiguriert ist. Bei Programmstart ist das
          immer der Prozessor, der real im Rechner arbeitet.
        - d:CPUs: Hiermit kînnen Sie den Disassembler veranlassen, Code fÅr
          bestimmte CPU's zu erzeugen. CPU ist wie folgt kodiert:
            Bit 0=MC68000
            Bit 1=MC68010
            Bit 2=MC68020
            Bit 3=MC68030
            Bit 4=MC68040
            Bit 6=MC68881/2
          Diese Bits kînnen gleichzeitig gesetzt sein, dann wird Code fÅr
          mehr als eine CPU erzeugt. Bei Mehrdeutigkeiten wird der "hîher-
          wertige" Prozessor bevorzugt, z.B. wird $60FF als "BRA.L *2" und
          nicht als "BRA.S *1" Åbersetzt.

     2. Wenn sich die disassemblierte Adresse innerhalb des Debuggers be-
        findet, wird das Disassembly mit einem Asterix * gekennzeichnet.

     3. Negative Zahlen werden normalerweise als vorzeichenlose Zahlen aus-
       gegeben, mit Ausnahme derjenigen zwischen -1 und -9. Z.B. wird -.100
       als $9C, -5 aber als -5 ausgegeben.

     4. Beachten Sie, dass das Basedisplacement in der auf Atari unÅblichen
        Schreibweise innerhalb der Klammer ausgegeben wird. Dies ist offi-
        zielle Motorola Notation. Auch der Assembler akzeptiert Basedis-
        placements nur in dieser Schreibweise.

     5. Wenn der Disassembler drei Fragezeichen hinter das Disassembly
        schreibt, dann wurde ein Befehl gefunden, der zwar erlaubt, aber
        nicht sinnvoll ist. Im Moment tut er dies aber nur bei SprÅngen auf
        ungerade Adressen (bsr/bcc/jsr/jmp/fbcc usw.)

     6. Falls der Disassembler ? hinter das Disassembly schreibt, heisst
        dies, dass ein Befehl gefunden wurde, der offiziell nicht erlaubt
        ist, in der angegebenen Form aber trotzdem funktioniert.
        - Dies ist z.B. der Fall bei der Adressierungsart "Memory Indirect
          Post-indexed with @{Index ignore} Suppress". Diese Adressierungsart ist
          gemÑss Motorola "reserved" (respektive dessen Codierung). Ver-
          suche haben aber gezeigt, dass der Befehl trotzdem ausgefÅhrt
          wird und zwar erwartungsgemÑss wie "Memory Indirect Pre-Indexed
          with @{Index ignore} Suppress".
       - Ein FBcc mit conditional predicate 1XXXXX ist gemÑss Motorola
         reserviert (Zitat: "Not used, redunant encodings with 0XXXXX"),
         wird von PEACEBUG aber Åbersetzt, da er funktioniert.
       - und einige mehr...
       Falls Sie wirklich das VergnÅgen haben sollten, auf ein ? zu stos-
       sen, dann nehmen Sie ein User's Manual hervor und schauen sich die
       Codierung des Befehls an.
       Das öbersetzen dieser Befehle scheint mir deswegen sinnvoll, weil es
       vielleicht Programme gibt, die diese Befehle absichtlich benÅtzen.


     @{U}Beispiele@{u}

     $001CDAEA>d:%1111
      Disassembler/Assembler active for MC68000/10/20/30
     $001CDAEA>d 1cdace #5
     $001CDACE>/ 4E7A                       ; *???      $4E7A
     $001CDAD0>/ 0003,3100                  ; *ORI.B    #0,D3
     $001CDAD4>/ 4E75                       ; *RTS
     $001CDAD6>/ 5148                       ; *SUBQ.W   #8,A0
     $001CDAD8>/ F010,4A00                  ; *PMOVE    SRP,(A0)

     $001CDADC>d:%11111
      Disassembler/Assembler active for MC68000/10/20/30/40
     $001CDACE>/ 4E7A,0003                  ; *MOVEC    TC,D0
     $001CDAD2>/ 3100                       ; *MOVE.W   D0,-(A0)
     $001CDAD4>/ 4E75                       ; *RTS
     $001CDAD6>/ 5148                       ; *SUBQ.W   #8,A0
     $001CDAD8>/ F010,4A00                  ; *PMOVE    SRP,(A0)
@endnode

@node %DFREE "Befehl: DFREE"
@symbol ar DFREE
@symbol i %DFREE
@toc Befehle
     @{U}4.6.13  DFREE *@{u}


     Syntax

     DFree [Drive:]


     @{U}Beschreibung@{u}

     Berechnet den freien Speicherplatz eines Laufwerkes. Defaultlaufwerk
     ist das aktuelle Laufwerk (zu erfahren mit CD).


     @{U}Beispiel@{u}

     $00100000>dfreea:
      Drive A: 1239 K used, 184 K free, 1423 K totally
@endnode

@node %DIRECTORY "Befehl: DIRECTORY"
@symbol ar DIRECTORY
@symbol i %DIRECTORY
@toc Befehle
     @{U}4.6.14  DIRECTORY *@{u}


     Syntax

     DIRectory [Path]


     @{U}Beschreibung@{u}

     Dient zum Anzeigen des Inhaltsverzeichnisses eines Laufwerks. Momentan
     kînnen nur Pfade angegeben werden und keine Suchmasken (z.B. *.PRG).
     Auch erfolgt die Ausgabe noch unsortiert. LS ist identisch mit DIR.


     @{U}Beispiele@{u}

     $00100000>dir
      G:\PEACEBUG\

      CD   "."            ;.0           16:08:12  19.06.1994
      @{CD ignore}   ".."           ;.0           16:08:12  19.06.1994
      @{CD ignore}   "PBUGCONF"     ;.0           02:06:16  22.10.1994
      @{CD ignore}   "PEACEBUG"     ;.0           02:07:28  22.10.1994
      @{CD ignore}   "REMOTE"       ;.0           02:06:34  22.10.1994
      @{CD ignore}   "UTILLITY"     ;.0           02:06:38  22.10.1994
      @{CD ignore}   "WINDOW"       ;.0           02:06:42  22.10.1994
      LOAD "ADRESSEN"     ;.272         23:40:12  24.09.2041
      @{LOAD ignore} "WHATSNEW"     ;.32019       03:03:22  14.01.1995
      @{LOAD ignore} "MAUS.RSC"     ;.318         01:04:48  04.01.1980
      @{LOAD ignore} "RESET"        ;.2350        23:45:04  07.12.1993
      @{LOAD ignore} "WHATSNEW.LIN" ;.166         03:03:22  14.01.1995

      7 directories    5 file(s)    35125 byte(s)

     $00100000>dir ..
      G:\

       @{CD ignore}  "COMPRESS"     ;.0           11:07:54  22.04.1994
       @{CD ignore}  "LIBRARY"      ;.0           10:53:54  22.04.1994
       @{CD ignore}  "M_MAUS"       ;.0           11:03:54  22.04.1994
       @{CD ignore}  "M_SPOOL"      ;.0           11:04:08  22.04.1994
       @{CD ignore}  "M_STONES"     ;.0           11:05:34  22.04.1994
       @{CD ignore}  "PEACEASM"     ;.0           10:55:14  22.04.1994
       @{CD ignore}  "PEACEBUG"     ;.0           11:06:24  22.04.1994
       @{CD ignore}  "SOURCES"      ;.0           10:56:30  22.04.1994

      8 directories    0 file(s)    0 byte(s)
@endnode

@node %DO "Befehl: DO"
@symbol ar DO
@symbol i %DO
@toc Befehle
     @{U}4.6.15  DO@{u}


     Syntax

     DO [Address]


     @{U}Beschreibung@{u}

     FÅhrt einen einzelnen Befehl aus. Dazu wird hinter den Befehl an der
     angegebenen Adresse ein Breakpoint gesetzt (funktioniert auch im ROM).
     Defaultadresse ist der aktuelle PC (was einem F2-Do PC gleichkommt).
@endnode

@node %DUMP "Befehl: DUMP"
@symbol ar DUMP
@symbol i %DUMP
@toc Befehle
     @{U}4.6.16  DUMP@{u}


     Syntax

     DUmp [From][,To|#Lines|[Bytes]|.]


     @{U}Beschreibung@{u}

     Gibt einen Speicherbereich im Hexdumpmodus aus. Die Parameter entspre-
     chen denjenigen des Befehls ASCII. MEMORY ist identisch mit DUMP.
@endnode

@node %EXIT "Befehl: EXIT"
@symbol ar EXIT
@symbol i %EXIT
@toc Befehle
     @{U}4.6.17  EXIT@{u}


     Syntax

     Exit [Value]


     @{U}Beschreibung@{u}

     Wurde der Debugger als Programm gestartet, kann er mit EXIT beendet
     werden. Ist der Debugger hingegen resident, wird ein Pterm ausgefÅhrt
     (Gemdos 76), wobei der RÅckgabewert defaultmÑssig -1 ist. Wenn ein
     Programm abstÅrzt und Sie den Fehler nicht beheben kînnen, kann mit
     EXIT manchmal weitergefahren werden. QUIT ist identisch mit EXIT.
@endnode

@node %FIND "Befehl: FIND"
@symbol ar FIND
@symbol i %FIND
@toc Befehle
     @{U}4.6.18  FIND@{u}


     Syntax

     Find[.b|.w|.l] [From],[To],Term{,Term}


     @{U}Beschreibung@{u}

     Durchsucht den Speicher und zeigt alle Adressen an, die Term,{Term}
     enthalten. Term ist ein Ausdruck, dem zusÑtzlich durch AnhÑngen von
     .b, .w, .a oder .l eine bestimmte LÑnge gegeben werden kann:
      1.b = $01          1 Byte
      1.w = $0001        2 Bytes
      1.a = $000001      3 Bytes
      1.l = $00000001    4 Bytes
     Wenn keine LÑnge angegeben wird, erweitert der Debugger die Zahl auf
     die kÅrzest mîgliche LÑnge, wobei Zahlen >$FFFF immer auf vier und
     nicht drei Bytes erweitert werden.
     Term kann auch ein beliebig langer String sein (normalerweise sind
     Strings nur 4 Zeichen lang).
     Der Debugger kreiert aus Term{,Term} einen einzigen String und sucht
     diesen, wobei natÅrlich wieder das Inkrement beim Suchen bestimmt wer-
     den kann (.b=byte, .w=word, .l=long). DefaultmÑssig wird in Einer-
     schritten inkrementiert. Suchen Sie z.B. nach Opcodes, kann das
     verwenden von Wordinkrementen aber sinnvoller sein, da Opcodes nur an
     geraden Adressen liegen kînnen.
     Befindet sich die gefundene Adresse innerhalb des Debuggers oder in
     einem von diesem allozierten Speicherbereich, wird die Ausgabe mit
     einem Asterix * gekennzeichnet.
     Defaultadressen fÅr "From" und "To", sind die Anfangs- bzw. Endadres-
     sen eines mit LEXECUTE oder LOAD geladenen Files.


     @{U}Beispiele@{u}

     $00100000>m #1
     $00100000>, 00,00,00,00,00,00,FC,00,30,00,00,00,00,FF,C4,3B,46
     $00100000>f 0,10,fc0030    ^^^^^^^^^^^
      $100005
     $00100000>f 0,10,fc0030.a     ^^^^^^^^
      $100006
     $00100000>f 100000,100000+20,ff.w,c4,";F"       ^^^^^^^^^^^^^^
      $10000C

     $00100000>fi fc0000,fc0000+.192000,'Atari'
      $FEBC31
@endnode

@node %FILL "Befehl: FILL"
@symbol ar FILL
@symbol i %FILL
@toc Befehle
     @{U}4.6.19  FILL@{u}


     Syntax

     FILl [From],[To],Term{,Term}



     @{U}Beschreibung@{u}

     FÅllt einen Speicherbereich mit Term{,Term}, wobei Term aufgebaut ist,
     wie beim Befehl FIND beschrieben.
     Defaultadressen fÅr "From" und "To", sind die Anfangs- bzw. Endadres-
     sen eines mit LEXECUTE oder LOAD geladenen Files.


     @{U}Beispiel@{u}

     $00100000>fill 600,700,10,10.w,10.a,10.l,'PEACEBUG'
      FÅllt den Bereich von $600 bis $6FF mit:
      10,00,10,00,00,10,00,00,00,10,50,65,61,63,65,62,75,67
         \_  _/\__  __/\____  ____/\__________  __________/
           \/     \/        \/                \/
      10  10.w   10.a     10.l            "PEACEBUG"
@endnode

@node %FREE "Befehl: FREE"
@symbol ar FREE
@symbol i %FREE
@toc Befehle
     @{U}4.6.20  FREE *@{u}


     Syntax

     FRee


     @{U}Beschreibung@{u}

     Dieser Befehl gibt eine Liste aller freien Speicherblîcke und deren
     Grîssen aus. Der letzte Speicherblock entspricht dem grîssten allo-
     zierbaren Block. Das Total in KB entspricht Åbrigens nicht dem Total
     aller BlocklÑngen in KB sondern dem Total aller BlocklÑngen in Bytes
     dividiert durch 1024. Das sieht dann etwa so aus:

      Address        Length Bytes   Length KB

      $109C2D2           16 Bytes
      $103B6AC          174 Bytes
      $11D6608         5292 Bytes        5 KB
      $11D370C         9128 Bytes        8 KB
      $10BDD2        846126 Bytes      826 KB
      $11F8BB0     18527312 Bytes    18093 KB

      Total:       19388048 Bytes    18933 KB
@endnode

@node %GO "Befehl: GO"
@symbol ar GO
@symbol i %GO
@toc Befehle
     @{U}4.6.21  GO@{u}


     Syntax

     Go [Address][,Breakpoint]


     @{U}Beschreibung@{u}

     Springt zur angegebenen Adresse. Defaultadresse ist der aktuelle PC.
     ZusÑtzlich kann ein Breakpoint angegeben werden, bis zu dem das
     Programm ausgefÅhrt wird.


     @{U}Beispiele@{u}

     $00100000>g ,^pc+10
      Startet das Programm und setzt 16 Bytes hinter dem PC einen Break-
      point.

     $00100000>go p(b4),p(b4)
      Setzt den PC auf den Bioshandler. Beachten Sie, dass die Klammern
      nîtig sind, weil ein pb4 als pb 4 (Bytepointer Adresse 4) und nicht
      als p b4 (Longpointer Adresse $b4) ausgewertet wird.
@endnode

@node %HELP "Befehl: HELP"
@symbol ar HELP
@symbol i %HELP
@toc Befehle
     @{U}4.6.22  HELP@{u}


     Syntax

     Help [Command]



     @{U}Beschreibung@{u}

     Gibt die Syntax der Befehle aus. Wird kein Befehl angegeben, werden
     alle @{Befehle ignore} aufgelistet.


     @{U}Beispiele@{u}

     $00100000>h d
      Disassemble [From][,To|#Lines|[Bytes]|.]|:[CPUs]

     $00100000>he hun
      HUnt [From],[To],Term{,Term}
@endnode

@node %HUNT "Befehl: HUNT"
@symbol ar HUNT
@symbol i %HUNT
@toc Befehle
     @{U}4.6.23  HUNT@{u}


     Syntax

     HUnt [From],[To],Term{,Term}


     @{U}Beschreibung@{u}

     Entspricht dem Befehl find.w, weshalb er sich insbesondere zum Suchen
     von Opcodes eignet. Dieser Befehl existiert vorallem aus Kompatibili-
     tÑtsgrÅnden (BUGABOO).
@endnode

@node %INFO "Befehl: INFO"
@symbol ar INFO
@symbol i %INFO
@toc Befehle
     @{U}4.6.24  INFO@{u}


     Syntax

     Info


     @{U}Beschreibung@{u}

     Gibt Angaben zu einem mit LOAD oder LEXECUTE geladenen File und dem
     Debugger aus, als da wÑren: TEXT-, DATA-, BSS-Segment und /-LÑnge,
     Fastload/Fastmem, MP-Flag, z.B.:

      Filename:       @{E:\DEBUGGER\SYSMON\SYS_MON.109\SYS_MON.PRG ignore}
      Programstart:   $11FD39C  Length: 216336
      TEXT-Segment:   $11FD49C  Length: 145162
      DATA-Segment:   $1220BA6  Length: 46164
      BSS-Segment:    $122BFFA  Length: 24754
      - Fastloadbit is set
      - Program may load into alternative RAM
      - Malloc calls may be satisfied from alternative RAM
      - Privatemode. Only the process itself (and the OS) can use the memory

      Debuggerstart:  $11DC84A  Length: 109322
      TEXT-Segment:   $11DC94A  Length: 69218
      DATA-Segment:   $11ED7AC  Length: 15206
      BSS-Segment:    $11F1312  Length: 24642
      Cookie:         $11E5C16
      Sectorbuffer:   $11F421E

     ACHTUNG: Debuggerstart ist der Anfang der Basepage und muss nicht
     zwingend 256 Bytes vor dem Textsegment liegen. Dies erlaubt es, den
     Debugger mittels Pexec 3 in den Speicher zu laden, mittels Pexec 5
     eine Basepage zu erzeugen, mittels Pexec 4/6 auszufÅhren und dies
     mehrmals nacheinander (wie dies z.B. DEVPAC tut).
@endnode

@node %LIST "Befehl: LIST"
@symbol ar LIST
@symbol i %LIST
@toc Befehle
     @{U}4.6.25  LIST@{u}


     Syntax

     List [From][,To|#Lines|[Bytes]|.]


     @{U}Beschreibung@{u}

     Gibt einen Speicherbereich im Listmodus aus. Die Parameter entsprechen
     denjenigen des Befehls ASCII. Falls ein Programm geladen wurde, dass
     Labels enthÑlt, wird dies in der Ausgabe berÅcksichtigt. Ist der RSD
     installiert, wird zusÑtzlich der Programmname ausgegeben, z.B.:
      $01057536>! [GEMRAM]   RTS                                  ; 4E75
@endnode

@node %LAST "Befehl: LAST"
@symbol ar LAST
@symbol i %LAST
@toc Befehle
     @{U}4.6.26  LAST@{u}


     Syntax

     LAst


     @{U}Beschreibung@{u}

     Gibt die jeweils letzte Einsprungsmeldung aus. Das ist die Meldung,
     die jeweils in der ersten Zeile erscheint. Dieser Befehl ist prak-
     tisch,, wenn Sie vergessen haben, was fÅr Angaben z.B. die Anzeige
     eines Buserrors enthalten hat.
@endnode

@node %LET "Befehl: LET"
@symbol ar LET
@symbol i %LET
@toc Befehle
     @{U}4.6.27  LET@{u}


     Syntax

     LEt Register=Value


     @{U}Beschreibung@{u}

     Setzt den Wert eines Registers. Es sind alle Register erlaubt, wie sie
     schon unter Formelauswertung beschrieben wurden. Beim CRP und beim
     SRP kînnen momentan nur die unteren 32 Bits gesetzt werden. Beachten
     Sie, dass bei diesem Befehl die Register ohne ^ angesprochen werden.
     SET entspricht dem Befehl LET.


     @{U}Beispiele@{u}

     $00100000>letpc=pe0
      Setzt den PC auf den Handler fÅr einen PMMU Configuration Error.

     $00100000>letccr=^sr&ff
      Es passiert gar nichts.
@endnode

@node %LEXECUTE "Befehl: LEXECUTE"
@symbol ar LEXECUTE
@symbol i %LEXECUTE
@toc Befehle
     @{U}4.6.28  LEXECUTE *@{u}


     Syntax

     LEXecute Filename


     @{U}Beschreibung@{u}

     LÑdt ein ausfÅhrbares Programm mittels Pexec. Der PC wird automatisch
     auf den Anfang des geladenen Programms gesetzt. Eine Symboltabelle im
     GST-/DRI-Format wird geladen, allerdings werden nur segmentrelative
     Symbole berÅcksichtigt, alle andern werden gelîscht (insbesondere die
     Konstanten). Debugger, die dies nicht tun, erzeugen meist ziemlich
     seltsame Disassemblies was die Labels anbelangt.

     Vier @{Symbole ignore} werden grundsÑtzlich immer erzeugt: BP, TEXT, DATA und
     BSS (bzw. bp, text, data und bss). Diese zeigen auf den Anfang der
     Basepage=BP, des TEXT-Segments=TEXT, des DATA-Segments=DATA und des
     BSS-Segments=BSS.

@symbol ari "Shift-Shift"
     Wenn Sie ein geladenes Programm starten, kann dieses mit Shift-Shift
     unterbrochen werden. Dies hat gegenÅber dem Unterbrechen mit der
     Tastenkombination Alt+F10 oder Alt+Cntl+F10 den Vorteil, dass immer
     innerhalb des Programmcodes unterbrochen wird und nicht in irgend-
     welchen uninteressanten OS Routinen. Shift-Shift wird vom VBL Handler
     ÅberprÅft.
@endnode

@node %LOAD "Befehl: LOAD"
@symbol ar LOAD
@symbol i %LOAD
@toc Befehle
     @{U}4.6.29  LOAD *@{u}


     Syntax

     LOad Filename[,Start[,End]]|-


     @{U}Beschreibung@{u}

     - LOAD Filename: Eine Datei wird vollstÑndig in den Speicher geladen.
       Der benîtigte Speicher wird, falls keine Startadresse angegeben ist,
       mittels Malloc reserviert. Wenn Sie eine Endadresse angeben, wird
       nicht die ganze Datei geladen, sondern nur "End"-"Start" Anzahl
       Bytes ("End" ist das erste nicht mehr benutzte Byte).
       Es wird ab dem Fileanfang aufgelistet aber der PC wird nicht auf
       diese Adresse gesetzt.
       Es werden zwei Symbole erzeugt: START und END (bzw. start und end),
       die auf den Anfang bzw. das Ende der Datei zeigen.
     - LOAD -: Gibt den mittels Malloc reservierten Speicher wieder frei.
       Wurde mittels LEXECUTE ein Programm geladen wird dieses beendet.

     Beim Laden von Dateien werden immer zwei Symbole erzeugt: START und
     END (bzw. start und end). START zeigt auf das erste benutzte Byte, END
     auf das erste nicht mehr benutzte Byte der Datei.


     @{U}Beispiele@{u}

     $00100000>load m:\test.prg
      Filename:       M:\TEST.PRG
      Programstart:  $1E3858 Length: 1379

     $00100000>load m:\test.prg,100000
      Filename:       M:\TEST.PRG
      Programstart:  $100000  Length: 1379

     $00100000>load m:\test.prg,100000,100200
      Filename:       M:\TEST.PRG
      Programstart:  $100000  Length: 512
@endnode

@node %LS "Befehl: LS"
@symbol ar LS
@symbol i %LS
@toc Befehle
     @{U}4.6.30  LS *@{u}


     Syntax

     LS [Path]


     @{U}Beschreibung@{u}

     Dient zum Anzeigen des Inhaltsverzeichnisses eines Laufwerks. Momentan
     kînnen nur Pfade angegeben werden und keine Suchmasken (z.B. *.PRG).
     Auch erfolgt die Ausgabe noch unsortiert. DIR ist identisch mit LS.
@endnode

@node %MEMORY "Befehl: MEMORY"
@symbol ar MEMORY
@symbol i %MEMORY
@toc Befehle
     @{U}4.6.31  MEMORY@{u}


     Syntax

     Memory [From][,To|#Lines|[Bytes]|.]


     @{U}Beschreibung@{u}

     Gibt einen Speicherbereich im Hexdumpmodus aus. Die Parameter entspre-
     chen denjenigen des Befehls ASCII. DUMP ist identisch mit MEMORY.
@endnode

@node %MKDIRECTORY "Befehl: MKDIRECTORY"
@symbol ar MKDIRECTORY
@symbol i %MKDIRECTORY
@toc Befehle
     @{U}4.6.32  MKDIRECTORY *@{u}


     Syntax

     MKdirectory Directory


     @{U}Beschreibung@{u}

     Legt einen neuen Ordner an. Es kann auch ein ganzes Verzeichnis ange-
     geben werden.


     @{U}Beispiel@{u}

     $00100000>mk m:\PEACEBUG\testit
      Legt im Ordner PEACEBUG aud Drive m einen Ordner namens "testit" an.
@endnode

@node %NEWFORMAT "Befehl: NEWFORMAT"
@symbol ar NEWFORMAT
@symbol i %NEWFORMAT
@toc Befehle
     @{U}4.6.33  NEWFORMAT@{u}


     Syntax

     Newformat


     @{U}Beschreibung@{u}

     Diese Funktion initialisiert den Bildschirm neu:

     1. Auf Programmscreen schalten.
     2. CLEAR_SCREEN aufrufen.
     3. GET_PARAMETER aufrufen.
     4. NEW_FORMAT aufrufen.
     5. PRINT_SCREEN aufrufen.
     6. Auf Debuggerscreen schalten.

     Diese Funktion passt also die Debuggerauflîsung an diejenige des rest-
     lichen Systems an und wird vor allem nach einem Auflîsungswechsel be-
     nutzt (siehe auch SWITCH). Einen Auflîsungswechsel des Programms igno-
     riert der Debugger, denn schliesslich wollen auch Programme debuggt
     sein, die Auflîsungen wechseln wie z.B. Spiele. Wenn Sie nun aber die
     Auflîsung des ganzen Systems wechseln, dann dÅrfte das Flimmern beim
     Umschalten zwischen Programm und Debugger eher stîrend sein.
     ACHTUNG: Da GET_PARAMETER auf Lineavariablen zugreift, sollte NEW-
     FORMAT nicht benÅtzt werden, wenn ein Programm die Auflîsung selber
     umgeschaltet hat, da die Lineavariablen dann normalerweise nicht ge-
     setzt werden (wie es z.B. bei Spielen hÑufig der Fall ist).
@endnode

@node %OBSERVE "Befehl: OBSERVE"
@symbol ar OBSERVE
@symbol i %OBSERVE
@toc Befehle
     @{U}4.6.34  OBSERVE@{u}


     Syntax

     Observe [-|+|[Address][,Bytes]]


     @{U}Beschreibung@{u}

     Observe erlaubt es, VerÑnderungen im Speicher festzustellen und
     gegebenenfalls anzuzeigen. Dazu wird der 200HZ Timer benutzt.

     - Observe -: Schaltet die Observefunktion aus.
     - Observe +: Schaltet die Observefunktion ein.
     - Observe ohne Parameter: Gibt aus, welchen Speicher sie gerade Åber-
       wachen lassen.
     - Observe Address,Bytes: Schaltet die Observefunktion ein und setzt
       den zu Åberwachenden Bereich fest. "Bytes" kann Werte zwischen 1 und
       1024 annehmen. Defaultwert ist der zuletzt benutzte Wert. Falls noch
       keiner benutzt wurde, ist der Defaultwert 1.

     Wenn eine VerÑnderung festgestellt wurde, wird dies angezeigt und die
     Funktion ausgeschaltet, damit der Debugger nicht endlos VerÑnderungen
     feststellt (z.B. wenn Sie Timeradressen Åberwachen). Weiter "Observen"
     kînnen Sie dann mittels O+. Da der Bereich im Interrupt ÅberprÅft
     wird, kann natÅrlich die genaue Adresse, an der die VerÑnderung statt-
     fand, nicht exakt angezeigt werden. Sollte dies nîtig, mÅssen Sie auf
     eine Usertraceroutine zurÅckgreifen.


     @{U}Beispiele@{u}

     $00100000>o+
      Observing $1 byte(s) at address $0

     $00100000>o ,.1024
      Observing $400 byte(s) at address $0

     $00100000>o 10000
      Observing $400 byte(s) at address $10000

     $00100000>o
      Observing $400 byte(s) at address $10000
@endnode

@node %PAGE "Befehl: PAGE"
@symbol ar PAGE
@symbol i %PAGE
@toc Befehle
     @{U}4.6.35  PAGE@{u}


     Syntax

     Page


     @{U}Beschreibung@{u}

     Page sucht den Speicher nach Doppelseiten ab.
@symbol ari Doppelseite
@symbol a Doppelseiten
     Eine Doppelseite ist ein 512 Byte langer Bereich im ST-RAM, der auf
     einer durch 512 teilbaren Adresse und zwischen den Adressen $600 und
     phystop liegen muss. Das erste Long enthÑlt das Magic $12123456, das
     zweite Long ist ein Pointer auf die Seite selber. Und schliesslich ist
     die PrÅfsumme (Word) Åber diesen Bereich $5678. Diese Doppelseiten
     werden nach einem Warmstart vom Betriebsystem gesucht und angesprung-
     en. Dadurch lassen sich resetresidente Programme schreiben, Dieses
     Feature ist zwar undokumentiert, bisher allerdings in jeder TOS-
     Version enthalten.
     Die Behauptung im Profibuch, der Speicher werde durch die Gemdosinit-
     ialisierung gelîscht, so dass nur die Seite an Adresse $600 Åbrig-
     bleibe, stimmt natÅrlich nicht. Richtig ist, dass der Speicher logisch
     freigegeben wird und in der Doppelseite neu reserviert werden muss,
     damit er nicht durch das erste Autoordnerprogramm, das gleich nach dem
     Suchen und AusfÅhren der Doppelseiten gestartet wird, Åberschrieben
     wird. Probleme kann es allerdings mit dem HD-Treiber geben, da dieser
     noch vor den Doppelseitenprogrammen ausgefÅhrt wird.
@endnode

@node %PROGRAMS "Befehl: PROGRAMS"
@symbol ar PROGRAMS
@symbol i %PROGRAMS
@toc Befehle
     @{U}4.6.36  PROGRAMS@{u}


     Syntax

     PRograms


     @{U}Beschreibung@{u}

     Dieser Befehl funktioniert nur, wenn der Resident Symbol Driver in-
     stalliert ist (siehe Kapitel "Symbole"). Er gibt eine Liste aller ge-
     starteten Programme und ein paar zusÑtzliche Angaben zu diesen aus.


     @{U}Beispiel@{u}

     $00100000>pr
      Name:         HDX.PRG
      Basepage:     $117502E
      TEXT-Segment: $117512E
      Length:       $26C94
      Symbols:      $216

      Name:         PEACEBUG.PRG
      Basepage:     $8B44E
      TEXT-Segment: $8B54E
      Length:       $1555A
      Symbols:      $0
@endnode

@node %QUIT "Befehl: QUIT"
@symbol ar QUIT
@symbol i %QUIT
@toc Befehle
     @{U}4.6.37  QUIT *@{u}


     Syntax

     Quit [Value]


     @{U}Beschreibung@{u}

     Wurde der Debugger als Programm gestartet, kann er mit QUIT beendet
     werden. Ist der Debugger hingegen resident, wird ein Pterm ausgefÅhrt
     (Gemdos 76), wobei der RÅckgabewert defaultmÑssig -1 ist. Wenn ein
     Programm abstÅrzt und Sie den Fehler nicht beheben kînnen, kann mit
     QUIT manchmal weitergefahren werden. EXIT ist identisch mit QUIT.
@endnode

@node %READSECTOR "Befehl: READSECTOR"
@symbol ar READSECTOR
@symbol i %READSECTOR
@toc Befehle
     @{U}4.6.38  READSECTOR *@{u}


     Syntax

     Readsector [Track][,Sector][,Side][,Address][,Drive]


     @{U}Beschreibung@{u}

     LÑdt einen Sektor mittels XBIOS 8.
     DefaultmÑssig werden die zuletzt benutzten Parameter verwendet. Wenn
     keine solche existieren, weil Sie den Befehl noch nicht benutzt haben,
     werden defaultmÑssig folgende Werte angenommen: Track=0, Sector=1,
     Side=0, Address=Sectorpuffer (wird vom Debugger zur VerfÅgung gestellt
     und ist 1024 Bytes lang), Drive=0. READSECTOR benutzt die gleichen
     Werte wie WRITESECTOR.


     @{U}Beispiele@{u}

     $00100000>r
      Sectorbuffer:   $1D752A
      Liest den Bootsektor von Laufwerk A in den internen Puffer.

     $00100000>r ,,,600,1
      Sectorbuffer:   $1D752A
      Liest den Bootsektor von Laufwerk B an die Adresse $600.
@endnode

@node %REGISTER "Befehl: REGISTER"
@symbol ar REGISTER
@symbol i %REGISTER
@toc Befehle
     @{U}4.6.39  REGISTER@{u}


     Syntax

     REGister [Register]


     @{U}Beschreibung@{u}

     Gibt den Inhalt eines Registers aus. Es sind alle Register erlaubt,
     wie sie schon unter Formelauswertung beschrieben wurden. Register wer-
     den wie bei LET ohne ^ angesprochen. Wird kein gÅltiges Register ange-
     geben, werden alle Register der aktuellen CPU angezeigt.


     @{U}Beispiele@{u}

     $00100000>reg ccr
      01

     $00100000>reg srp
      40018100D97F005C
@endnode

@node %RESIDENT "Befehl: RESIDENT"
@symbol ar RESIDENT
@symbol i %RESIDENT
@toc Befehle
     @{U}4.6.40  RESIDENT *@{u}


     Syntax

     RESident


     @{U}Beschreibung@{u}

     Falls der Debugger als Programm gestartet wurde, kann er mittels die-
     sem Befehl resident gemacht werden. Der Debugger installiert zu diesem
     Zweck nachtrÑglich einen Cookieeintrag und eine Doppelseite. Darauf
     beendet er sich und kann nun jederzeit Åber Tastatur aktiviert werden.
     Ist der Debugger schon resident, kann dieser Befehl nicht aufgerufen
     werden.
@endnode

@node %RMDIRECTORY "Befehl: RMDIRECTORY"
@symbol ar RMDIRECTORY
@symbol i %RMDIRECTORY
@toc Befehle
     @{U}4.6.41  RMDIRECTORY *@{u}


     Syntax

     RMdirectory Directory|File


     @{U}Beschreibung@{u}

     Lîscht einen Ordner oder eine Datei. Im Gegensatz zu andern CLIs, ist
     der Befehl fÅr Ordner und Dateien identisch. Es kann auch ein komplet-
     ter Pfad angegeben werden.
@endnode

@node %SAVE "Befehl: SAVE"
@symbol ar SAVE
@symbol i %SAVE
@toc Befehle
     @{U}4.6.42  SAVE *@{u}


     Syntax

     Save Filename[,Start,End]


     @{U}Beschreibung@{u}

     Speichert einen Speicherbereich. Werden "Start" und "End" nicht ange-
     geben, benutzt SAVE die gleichen Parameter, wie beim letzten Laden
     eines Files mittels LOAD.


     @{U}Beispiele@{u}

     $00100000>save m:\test.prg,fc0000,fc0000+.1000
      Speichert 1000 Bytes ab Adresse fc0000 in der Datei "M:\TEST.PRG".

     $00100000>load m:\test.prg
     $00100000>save c:\test2
      Speichert "test.prg" unter dem neuen Namen "c:\test2".
      Man beachte dass sich so auch Files kopieren lassen.
@endnode

@node %SET "Befehl: SET"
@symbol ar SET
@symbol i %SET
@toc Befehle
     @{U}4.6.43  SET@{u}


     Syntax

     SEt Register=Value


     @{U}Beschreibung@{u}

     Setzt den Wert eines Registers. Es sind alle Register erlaubt, wie sie
     schon unter Formelauswertung beschrieben wurden. Beim CRP und beim
     SRP kînnen momentan nur die unteren 32 Bits gesetzt werden. Beachten
     Sie, dass bei diesem Befehl die Register ohne ^ angesprochen werden.
     LET entspricht dem Befehl SET.
@endnode

@node %SHOWMEMORY "Befehl: SHOWMEMORY"
@symbol ar SHOWMEMORY
@symbol i %SHOWMEMORY
@toc Befehle
     @{U}4.6.44  SHOWMEMORY@{u}


     Syntax

     SHowmemory [-|Number-|Number|Term[,List]]


     @{U}Beschreibung@{u}

     Durch diesen Befehl kînnen Sie sich wichtige Speicherbereiche stÑndig
     anzeigen lassen. Term kann ein Ausdruck beliebiger KomplexitÑt sein,
     d.h. er kann Register, Symbole und Adressen enthalten. Die Anzeige
     wird immer dann aktualisiert, wenn sich entweder ein Ausdruck in Term
     oder der Inhalt der Speicheradresse, auf die Term zeigt, verÑndert
     haben. Es kînnen maximal 10 Bereiche gleichzeitig angezeigt werden.
     Jedem Bereich wird eine Zeile unterhalb der Registeranzeige geopfert.

     - SHOWMEMORY: Gibt eine Liste aller Bereiche aus, die momentan ange-
       zeigt werden, d.h. welche Adressen werden in welchem Modus ange-
       zeigt.
     - SHOWMEMORY -: Es werden keine Speicherbereiche mehr angezeigt.
     - SHOWMEMORY Nummer-: Der angegebene Speicherbereich wird fortan nicht
       mehr angezeigt.
     - SHOWMEMORY Nummer: Gibt den angegebenen Speicherbereich aus, d.h.
       welche Adresse wird in welchem Modus angezeigt.
     - SHOWMEMORY Term,List: Der in Term spezifizierte Speicherbereich wird
       ab sofort in einer Zeile unterhalb der Register angezeigt. List kann
       die Werte 1,2,3 oder 4 annehmen und ist defaultmÑssig 3. Diese Werte
       stehen fÅr die verschiedenen Arten, wie die Speicherbereiche ange-
       zeigt werden:
        1=Listmodus
        2=Disassemblymodus
        3=Hexdumpmodus      ---> Default
        4=Asciimodus


     @{U}Beispiele@{u}

     $00100000>sh ^a7,4
      Zeigt den Inhalt des Stacks im Asciimodus.
     $00100000>sh ^d0
      Zeigt den Bereich, auf den d0 zeigt, im Hexdumpmodus.
     $00100000>sh
      0,4:^a7
      1,3:^d0
      | |  \___ Was wird angezeigt.
      |  \_____ In welchem Modus wird angezeigt (4=Ascii, 3=Hexdump).
       \_______ Nummer, Åber die die einzelnen Anzeigen angesprochen werden.
     $00100000>show 0-
      Anzeige Nummer 0 lîschen.
     $00100000>sh
      1,3:^d0
@endnode

@node %SLow "Befehl: SLOW"
@symbol ar SLOW
@symbol i %SLOW
@toc Befehle
     @{U}4.6.45  SLOW@{u}


     Syntax

     SLow [+|-]


     @{U}Beschreibung@{u}

     Diese Funktion erlaubt es, den Rechner in Slowmotion laufen zu lassen.
     Slow ohne Parameter gibt aus, ob die Slowmotionfunktion aktiv ist oder
     nicht. Mit Slow- schalten Sie den Slowmodus aus, mit Slow+ an. Mit den
     Tasten +/- (Zahlenblock) kînnen Sie den Rechner dann verlangsamen (+),
     respektive wieder beschleunigen (-). Zusammen mit einer Shifttaste ge-
     drÅckt, bewirken die gleichen Tasten eine VerÑnderung der Verzîgerung
     in einer 8 mal feineren Abstufung, d.h. + Ñndert den Verzîgerungs-
     zÑhler in 8 mal grîsseren Schritten, als Shift +. Mit der Taste * wird
     die Verzîgerung auf Null zurÅckgesetzt, der Rechner lÑuft dann wieder
     in Originalgeschwindigkeit, die Slowmotionfunktion bleibt aber aktiv.
@endnode

@node %SWITCH "Befehl: SWITCH"
@symbol ar SWITCH
@symbol i %SWITCH
@toc Befehle
     @{U}4.6.46  SWITCH@{u}


     Syntax

     SWitch [ResolutionDebugger][,ResolutionProgram]


     @{U}Beschreibung@{u}

     Mit dieser Funktion kînnen Sie den Debugger/das Programm auf eine
     Standardauflîsung umschalten. Die Werte entsprechen denjenigen von
     Getrez:

     0: 320*200*4  ST-Low
     1: 640*200*2  ST-Mid
     2: 640*400*1  ST-High
     4: 640*480*4  TT-Mid
     6: 1280*960*1 TT-High
     7: 320*480*8  TT-Low

     - ResolutionDebugger: Der Debuggerscreen wird neu initialisiert aber
       nicht neu reserviert, deshalb sollte nur umgeschalten werden, wenn
       die neue Auflîsung nicht mehr Bildspeicher benîtigt als die alte.
       Mittels NEWFORMAT kînnen Sie den Debuggerscreen wieder auf die vom
       restlichen System benutzte Auflîsung schalten.

     - ResolutionProgram: Das Umschalten der Programmauflîsung geschieht
       durch Beschreiben des Shiftmoderegisters. Den Auflîsungswechsel be-
       kommt das restliche System natÅrlich nichts mit, daher ist das Um-
       schalten der Programmauflîsung nur sinnvoll, wenn diese durch ein
       anderes Programm fÑlschlicherweise verÑndert wurde.

     ACHTUNG: Dieser Befehl existiert auf dem F030 nicht.
@endnode

@node %SYMBOL "Befehl: SYMBOL"
@symbol ar SYMBOL
@symbol i %SYMBOL
@toc Befehle
     @{U}4.6.47  SYMBOL@{u}


     Syntax

     SYmbol [From][,To]


     @{U}Beschreibung@{u}

     Gibt eine nach Symbolwert sortierte Liste der Symbole aus, die PEACE-
     BUG bei Programmstart geladen hat. Mittels "From" und "To" kînnen Sie
     die Ausgabe auf einen bestimmten Bereich beschrÑnken, es werden dann
     nur die @{Symbole ignore} ausgegeben, deren Werte zwischen "From" und "To"
     liegen. Wenn ein Programm nachgeladen wurde, an das eine Symboltabelle
     angehÑngt war, werden nur die @{Symbole ignore} dieses Programms ausgegeben.


     @{U}Beispiele@{u}

     $00100000>sy fa0000,ffff8001
      $FA0000 = cart_port
      $FC0000 = os_start_old
      $9241991 = os_date
      $41484449 = P_cookie
      $FFFF8001 = memconf

     $00100000>symb 500,510
      $502 = scr_dump
      $506 = prv_lsto
      $50A = prv_lst
      $50E = prv_auxo
@endnode

@node %SYSINFO "Befehl: SYSINFO"
@symbol ar SYSINFO
@symbol i %SYSINFO
@toc Befehle
     @{U}4.6.48  SYSINFO@{u}


     Syntax

     SYSinfo


     @{U}Beschreibung@{u}

     Gibt einige Informationen zum benutzten System aus:

      OS_Base:          $E00000
      OS_Start:         $E00030
      OS_Membot:        $8316
      TOS-Version:      PAL-SWG 03.06 vom 24.09.1991
      GEMDOS-Version:   00.20
      METADOS-Version:  Metados not installed
      AES-Version:      03.20
      VDI-Version:      GDOS installed
@endnode

@node %TRACE "Befehl: TRACE"
@symbol ar TRACE
@symbol i %TRACE
@toc Befehle
     @{U}4.6.49  TRACE@{u}


     Syntax

     Trace [Number|+|-|*|/]


     @{U}Beschreibung@{u}

     - Trace ohne Parameter entspricht F1, also der normalen Tracefunktion.
     - Trace Number: FÅhrt die angegebene Anzahl @{Befehle ignore} aus, bevor in den
       Debugger zurÅckgesprungen wird. Dabei werden wie bei F1 gewisse Op-
       codes als ein Befehl angesehen.
     - Trace +: LÑsst das Programm im Tracemodus laufen und ruft nach jedem
       Befehl die Usertraceroutine auf, die entscheidet, ob in den Debugger
       gesprungen, das Tracen fortgesetzt oder ausgeschaltet wird. Gleich-
       zeitig wird auch ein Cacheeintrag erzeugt. Es wird nicht getraced,
       wenn flock gesetzt oder die Interruptmaske 7 ist. Traps werden
       getraced.
     - Trace -: Wie Trace +, nur dass kein Cacheeintrag erzeugt wird
       (schneller).
     - Trace *: Wie Trace +, nur das immer getraced wird, d.h. auch wenn
       flock gesetzt oder die Interruptmaske 7 ist. Lesen Sie diesbezÅglich
       auch Kapitel "Trace & Breakpoints".
     - Trace /: Erlaubt es, eine Åber ein externes Programm installierte
       Usertraceroutine auszuhÑngen. Es wird dann wieder die Defaultroutine
       eingehÑngt, die nichts anderes tut, als das N-Bit des Statusregi-
       sters zu setzen, was bewirkt, dass das Tracen nie unterbrochen wird,
       es sei denn durch Aufrufen des Debuggers.
@endnode

@node %WARM "Befehl: WARM"
@symbol ar WARM
@symbol i %WARM
@toc Befehle
     @{U}4.6.50  WARM@{u}


     Syntax

     Warm


     @{U}Beschreibung@{u}

     FÅhrt einen Warmstart aus. Die "magics" werden gesetzt (memvalid
     etc.). Der Debugger kann noch Åber die Doppelseite gerettet werden.
@endnode

@node %WRITESECTOR "Befehl: WRITESECTOR"
@symbol ar WRITESECTOR
@symbol i %WRITESECTOR
@toc Befehle
     @{U}4.6.51  WRITESECTOR *@{u}


     Syntax

     WRitesector [Track][,Sector][,Side][,Address][,Drive]


     @{U}Beschreibung@{u}

     Schreibt einen Sektor mittels XBIOS 9.
     DefaultmÑssig werden die zuletzt benutzten Parameter verwendet. Wenn
     keine solche existieren, weil Sie den Befehl noch nicht benutzt haben,
     werden defaultmÑssig folgende Werte angenommen: Track=0, Sector=1,
     Side=0, Address=Sectorpuffer (wird vom Debugger zur VerfÅgung gestellt
     und ist 1024 Bytes lang), Drive=0. WRITESECTOR benutzt die gleichen
     Werte wie READSECTOR.


     @{U}Beispiele@{u}

     $00100000>wr
      Schreibt den Bootsektor von Laufwerk A aus dem internen Puffer.

     $00100000>write ,,,600,1
      Schreibt den Bootsektor von Laufwerk B aus Adresse 600.
@endnode

@node %XBRA "Befehl: XBRA"
@symbol i %XBRA
@toc Befehle
     @{U}4.6.52  @{XBRA ignore}@{u}


     Syntax

     Xbra [FirstVector][,LastVector][,ID]


     @{U}Beschreibung@{u}

     Dieser Befehl sucht im Bereich zwischen "FirstVector" und "LastVector"
     nach Vektoren und gibt deren XBRA-Verkettungen aus. "FirstVector" ist
     defaultmÑssig $8, "LastVector" $1000. Wenn Sie nur "FirstVector" ein-
     geben, dann wird "LastVector"="FirstVector" gesetzt. Dies ist prak-
     tisch, denn dadurch verkÅrzt sich z.B. die Schreibweise von "x 84,84"
     zu "x 84".
     Der Debugger inkrementiert bei der Suche nach @{Vektoren ignore} normalerweise
     in Viererschritten, erkennt aber selber, wenn Einer-, Zweier- oder
     Dreierschritte notwendig sind (siehe Beispiele). Sie kînnen getrost
     davon ausgehen, dass der Debugger immer alle @{Vektoren ignore} im angegebenen
     Bereich findet.
     Zeiger auf sich selber werden ebenso erkannt wie Endlosverkettungen.
     Wird ID angegeben, dann werden nur Verkettungen angezeigt, in denen
     diese @{XBRA-ID ignore} vorkommt. Diese wird dann mit einem Pfeil  markiert.
     Die Routine des Debuggers wird mit einem Asterix * markiert.
     Falls das VBR (VectorBaseRegister) ungleich Null ist, wird eine War-
     nung ausgegeben, denn theoretisch mÅsste dieser Wert zu den @{Vektor- ignore}
     adressen dazugezÑhlt werden, was aber auf dem Atari bisher nicht sinn-
     voll ist, da das VBR nur von wenigen Programmen benutzt wird, die
     obendrein kein @{XBRA ignore} benutzen.
     Wenn Sie den Befehl ohne jegliche Parameter aufrufen, werden keine
     @{XBRA-Verkettungen ignore} angezeigt, sondern eine sortierte Liste aller
     gefundenen ID's mit einer Liste der @{Vektoren ignore}, in denen diese IDs
     gefunden wurden. Gesucht wird dann immer zwischen $8 und $1000.


     @{U}Beispiele@{u}

     $00100000>x 10
      Zeigt nur gerade die Verkettung fÅr den Vektor $10 an.

     $00100000>x ,20
      Zeigt die Verkettungen der @{Vektoren ignore} im Bereich zwischen $8 und
      $20 an.

     $00100000>x ,,'PBUG'
      Zeigt die Verkettungen der @{Vektoren ignore} im Bereich zwischen $8 und
      $1000 an, die mindestens einmal die Kennung "PBUG" enthalten.

     $00100000>x 81,88
      ATTENTION: the VectorBaseRegister points to $1017B00!
      @{XBRA ignore} links for $81:
      $E0121C01 without @{XBRA ignore}

      @{XBRA ignore} links for $84 = .trap_1:
      $0107CE34 "WINX" points to $01032B52
      $01032B52 "NVDI" points to $00E13632
      $E13632 without @{XBRA ignore}

      @{XBRA ignore} links for $88 = .trap_2:
      $0102DF5E "NVDI" points to $01044D1E
      $01044D1E "PBUG" points to $0107E9E0*
      $0107E9E0 "LTMF" points to $0108729E
      $0108729E "SLCT" points to $0106B062
      $106B062 without @{XBRA ignore}

     $00100000>x 0,100,'LTMF'
      ATTENTION: the VectorBaseRegister points to $1017B00!
      @{XBRA ignore} links for $88 = .trap_2:
      $0102DF5E "NVDI" points to $01044D1E
      $01044D1E "PBUG" points to $0107E9E0*
      $0107E9E0 "LTMF" points to $0108729E
      $0108729E "SLCT" points to $0106B062
      $106B062 without @{XBRA ignore}

      @{XBRA ignore} links for $B4 = .trap_d:
      $010873CC "SLCT" points to $0107EDFC
      $0107EDFC "LTMF" points to $01044DB4
      $01044DB4 "PBUG" points to $01032F1E*
      $01032F1E "NVDI" points to $00E00DA2
      $E00DA2 without @{XBRA ignore}
@endnode

@node %? "Befehl: ?"
@symbol i %?
@toc Befehle
     @{U}4.6.53  ?@{u}


     Syntax

     ? Term{,Term}


     @{U}Beschreibung@{u}

     Gibt den vorzeichenlosen Wert von "Term" in allen Zahlensystemen
     (Hexadezimal, Dezimal, BinÑr, Oktal) und als String aus. Ist der Wert
     negativ, wird zusÑtzlich der vorzeichenbehaftete Wert im Hexadezimal-
     und im Dezimalsystem ausgegeben.


     @{U}Beispiel@{u}

     $00100000>?-1,"PBUG"
      $FFFFFFFF .4294967295 %11111111111111111111111111111111 o37777777777
      "ˇˇˇˇ" -$1 -.1
      $50425547 .1346524487 %1010000010000100101010101000111 o12020452507
      "PBUG"
@endnode

@node %/ "Befehl: /"
@symbol i %/
@toc Befehle
     @{U}4.6.54  /@{u}


     Syntax

     / [.b|.w|.a|.l] [Term]{,Term}


     @{U}Beschreibung@{u}

     / ist das Pendant zum Befehl DISASSEMBLE. Er schreibt die angegebenen
     Terme an die aktuelle Zeilenadresse. Term ist aufgebaut wie beim Be-
     fehl FIND. Wenn Sie dem / eine LÑngenangabe (.b=1 Byte, .w=2 Bytes,
     .a=3 Bytes, .l=4 Bytes) anhÑngen, dann werden alle Terme entweder auf
     diese LÑnge erweitert oder gekÅrzt. DefaultmÑssig ist die LÑngenangabe
     .w, d.h. / ist bis auf diesen Punkt identisch mit dem Befehl @{, link %,}.


     @{U}Beispiele@{u}

     $00100000>/ 12,1234.a
      Schreibt an die Adresse $100000 den Wert $0012,$1234 (4 Bytes).

     $00100000>/.a 12,12345678
      Schreibt an die Adresse $100000 den Wert $000012,$345678 (6 Bytes).

     $00100000>/.l 12,1234.a
      Schreibt an die Adresse $100000 den Wert $00000012,$00001234 (8
      Bytes).
@endnode

@node %! "Befehl: !"
@symbol i %!
@toc Befehle
     @{U}4.6.55  !@{u}


     Syntax

     ! Opcode


     @{U}Beschreibung@{u}

     ! ist das Pendant zum Befehl LIST. Er assembliert den angegebenen
     Befehl und schreibt ihn an die aktuelle Zeilenadresse. Der Assembler
     arbeitet symbolisch und Åbersetzt alle MC680x0 Befehle incl. die er-
     weiterten Adressierungsarten (ohne MC68060).

     Ein Basedisplacement wird nur in der offiziellen Motorolasyntax inner-
     halb der Klammer akzeptiert, also anstatt -1(sp) nur (-1,sp).

     Ein Befehl wird so kurz wie mîglich codiert, d.h. Displacements und
     SprÅnge werden auf die kÅrzestmîgliche Form gebracht. NatÅrlich kînnen
     Sie die LÑnge der Displacements auch wÑhlen indem Sie ein .w oder ein
     .l anhÑngen. Ein clr ([-1,a0],10) wird z.B. vier Bytes kÅrzer codiert
     als ein clr ([-1.l,a0],10.l).

     Die Eingabe ist sehr flexibel gehalten, so wird z.B. ein
     "adda ( [- 10z sp d0 . l * 8-1.lsp       *clr" korrekt als
     "ADDA.W   ([$FFF0,ZA7,D0.L*8],-1),A7" oder ein
     "clr ([10za1sp-1" als
     "@{CLR.W ignore}   ([$10,ZA1,A7.W],-1)" Åbersetzt.

     Beachten Sie, dass der Assembler gleichzeitig mit vorzeichenbehafteten
     und vorzeichenlosen Zahlen arbeitet. Im Positiven wird mit vorzeichen-
     losen, im Negativen mit vorzeichenbehafteten Zahlen gearbeit (Zahlen-
     theoretiker mîgen mir dies verzeihen). Eine Zahl umfasst so den Be-
     reich -2147483648 bis 4294967295 oder -32768 bis 65535 oder -128 bis
     255, je nachdem ob es sich um ein Long, ein Word oder ein Byte han-
     delt.
@endnode

@node %, "Befehl: ,"
@symbol i %,
@toc Befehle
     @{U}4.6.56  ,@{u}


     Syntax

     , [.b|.w|.a|.l] [Term]{,Term}


     @{U}Beschreibung@{u}

     , ist das Pendant zum Befehl DUMP. Er schreibt die angegebenen Terme
     an die aktuelle Zeilenadresse. Term ist aufgebaut wie beim Befehl
     FIND. Wenn Sie dem , eine LÑngenangabe (.b=1 Byte, .w=2 Bytes, .a=3
     Bytes, .l=4 Bytes) anhÑngen, dann werden alle Terme entweder auf diese
     LÑnge erweitert oder gekÅrzt.. Wenn die LÑngenangabe fehlt, wird jeder
     Term in der LÑnge geschrieben, wie Sie ihn eingegeben haben, d.h. ,
     ist bis auf diesen Punkt identisch mit dem Befehl @{/ link %/}


     @{U}Beispiele@{u}

     $00100000>, 1,1234.a
      Schreibt an die Adresse $100000 den Wert $01,$001234 (4 Bytes).

     $00100000>,.a 12,12345678
      Schreibt an die Adresse $100000 den Wert $000012,$345678 (6 Bytes).

     $00100000>,.l 12,1234.a
      Schreibt an die Adresse $100000 den Wert $00000012,$00001234 (8
      Bytes).
@endnode

@node %) "Befehl: )"
@symbol i %)
@toc Befehle
     @{U}4.6.57  )@{u}


     Syntax

     ) String


     @{U}Beschreibung@{u}

     ) ist das Pendant zum Befehl ASCII. Er schreibt den angegebenen String
     an die aktuelle Zeilenadresse. Der String muss keine bestimmte LÑnge
     haben, er muss aber mit einem " oder ' abgeschlossen sein.
@endnode

@node %: "Befehl: :"
@symbol i %:
@toc Befehle
     @{U}4.6.58  :@{u}


     Syntax

     : Address[,Term]{,Term}


     @{U}Beschreibung@{u}

     : schreibt die Terme an die angegebene Adresse. Term ist aufgebaut wie
     beim Befehl FIND. Dieser Befehl wurde vorallen aus nostalgischen GrÅn-
     den implementiert (TEMPLMON).


     @{U}Beispiele@{u}

     $00100000>:^pc,1,1234.a
      Schreibt an die PC Adresse den Wert $01,$001234 (4 Bytes).

     $00100000>:^pc,1.a,12345678
      Schreibt an die PC Adresse den Wert $000001,$12345678 (7 Bytes).

     $00100000>: 600,"this is a string"
      Schreibt an die Adresse $600 den String "this is a string".
@endnode


@remark *******************************************************************
@remark * Symbole                                                         *
@remark *******************************************************************

@node Symbole
@toc Inhaltsverzeichnis
@symbol ar Symbol
     @{U}5  Symbole@{u}



     PEACEBUG unterstÅtzt verschiedene Symbole:

     1. PEACEBUG.SYM: Konstanten, die bei Programmstart geladen werden.

     2. Lexecute: Wird ein Programm mit angehÑngter GST-/DRI-Symboltabelle
        geladen, werden diese Symbole benutzt.

     3. Resident Symbol Driver: Ist der @{RSD ignore} installiert, werden sowohl
        dessen Symbol- als auch dessen Programmdaten benutzt.
@endnode
@node PEACEBUG.SYM
@toc Inhaltsverzeichnis
@autorefoff
     @{U}5.1  PEACEBUG.SYM@{u}


     @{U}Allgemeines@{u}

     Bei Programmstart wird die Datei PEACEBUG.SYM geladen, falls Sie sich
     im gleichen Verzeichnis befindet, wie der Debugger. Diese Datei ent-
     hÑlt symbolische Konstanten, die beim Disassemblieren und vom Formel-
     interpreter benutzt werden.


     @{U}Aufbau der Datei@{u}

     PEACEBUG.SYM ist eine reine ASCII Datei und kann daher von jedem Edi-
     tos verÑndert werden. Die Symboldefinitionen erfolgen in der Form:
        Symbolname=Wert             ; Kommentar
     Dabei gelten folgende Regeln:
     - Leerzeichen werden immer ignoriert, egal wo sie sich befinden.
     - Zeilen mÅssen mit CR/LF abgeschlossen sein.
     - Die Datei darf keine Nullbytes enthalten.
     - Kommentarzeilen beginnen mit einem Asterix *.
     - Die Symbolnamen kînnen bis zu 32767 Zeichen lang sein.
     - "Symbolname" kann ausser den Zeichen Ascii 0 und = alle Zeichen ent-
       halten. Das erste Zeichen darf kein Asterix * sein.
     - "Wert" ist ein beliebiger Ausdruck, wie er vom Formelinterpreter des
       Debuggers verarbeitet wird, also z.B. pw(p4f2+2) (=os_version). Es
       ist allerdings sinnlos, Register oder Symbole darin zu verwenden, da
       diese im Zeitpunkt der Symbolerzeugung noch keinen definierten Wert
       haben (die erzeugten Symbole sind Konstanten).
     Die im Speicher angelegte Symboltabelle arbeitet mit variablen Symbol-
     lÑngen und braucht deshalb ein Minimum an Speicher.
@autorefon
@endnode

@node Lexecute
@toc Inhaltsverzeichnis
     @{U}5.2  Lexecute@{u}


     Wird ein Programm mittels LEXECUTE geladen und ist an dieses eine Sym-
     boltabelle im GST-/DRI-Format angehÑngt, wird diese mitgeladen. Der
     Debugger lîscht dabei alle Konstanten, weil diese beim Disassemblieren
     stîren. Der Debugger kann zwischen den verschiedenen DRI Formaten
     unterscheiden. Diese unterscheiden sich dadurch, dass Symbole relativ
     zu einem Segment vorliegen oder eben nicht. Die @{Symbole ignore} werden ins
     gleiche Format gewandelt, wie die Konstanten (PEACEBUG.SYM). Eine
     durchschnittliche @{Symboltabelle ignore} belegt so nur 19 Bytes pro @{Symbol ignore} im
     Gegensatz zu 32 Bytes bei BUGABOO.

     Vier @{Symbole ignore} werden grundsÑtzlich immer erzeugt: BP, TEXT, DATA und
     BSS (bzw. bp, text, data und bss). Diese zeigen auf den Anfang der
     Basepage=BP, des TEXT-Segments=TEXT, des DATA-Segments=DATA und des
     BSS-Segments=BSS.
     Wird mittels LOAD eine Datei geladen, werden die @{Symbole ignore} START und END
     (bzw. start und end) erzeugt.
@endnode

@node "Resident Symbol Driver"
@toc Inhaltsverzeichnis
@symbol ari RSD
@autorefoff
     @{U}5.3  Resident Symbol Driver@{u}


     @{U}Allgemeines@{u}

     - Der Resident Symbol Driver (RSD) ist ein Programm von Robert
       Federle, das @{Symboltabellen link Symbole} von Programmen anlegen kann, die ge-
       startet werden. Diese Symboltabellen werden Åber eine Cookieschnitt-
       stelle zur VerfÅgung gestellt. Damit ist es z.B. mîglich, vom
       Desktop ein Programm zu starten, das eine Symboltabelle enthÑlt,
       den Debugger, der resident installiert ist, aufzurufen und die
       Symbole des Programms zu benutzen.

     - Falls der RSD installiert ist, benÅtzt PEACEBUG zusÑtzlich zu den
       eigenen Symboltabellen, diejenigen des Treibers. Da dieser die Sym-
       bolsuche nicht exakt gleich vornimmt, kînnen Disassemblies leicht
       anders aussehen.

     - Aber damit hat es sich noch nicht. Der Befehl Programs gibt eine
       Liste aller gestarteten Programme aus, die sich der Debugger vom
       Symboltreiber holt. DarÅberhinaus fÅgt der Debugger bei der Ausgabe
       im Listmodus den Namen des Programms ein, das zur ausgegebenen
       Adresse passt:
       $01057536>! [GEMRAM]   RTS                                  ; 4E75

     - ACHTUNG: Der RSD kann nach Symbolen suchen, die * als Wildcard ent-
       halten. Diese Mîglichkeit kînnen Sie im Debugger allerdings nicht
       benÅtzen, da das * als Multiplikationszeichen verwendet wird, Ein-
       gaben deshalb zweideutig sein kînnten. Ein "l ._sys*+2" wird also
       nicht als "l ._sysbase+2" sondern als "l 2*._sys" interpretiert.


     @{U}Tips@{u}

     1. Angenommen Sie wollen Ihr Programm debuggen, das aus mehreren
        Modulen besteht, die vom Programm nachgeladen werden (z.B. XCONTROL
        oder diverse Bildschirmschoner). Um im Debugger zu erkennen, wel-
        ches Modul gerade aktiv ist, fÅgen Sie die Symboltabelle in die vom
        RSD verwaltete Liste ein (dazu lesen Sie das Readme des RSD), und
        erkennen von nun an immer, wo sie gerade debuggen.

@autorefon
     2. Benutzen Sie PEACEBUG.SYM anstatt @{SYMBOL.SMB ignore} (das ist die
        Konstantentabelle des RSD), ausser sie benutzen noch andere Prog-
        ramme, die den RSD unterstÅtzen. Grund: schnellerer Zugriff auf die
        @{Symbole ignore}, UnabhÑngigkeit des Debuggers.
@endnode


@remark *******************************************************************
@remark * Vektoren                                                        *
@remark *******************************************************************

@node Vektoren
@toc Inhaltsverzeichnis
     @{U}6  Vektoren@{u}


     Die 48 Routinen, die PEACEBUG einhÑngen kann, bilden den Kern des Pro-
     gramms. Gerade hier muss daher grîsstmîgliche FlexibilitÑt geboten
     werden. Bevor Sie sich allerdings mit den Mîglichkeiten von PEACEBUG
     diesbezÅglich beschÑftigen, lesen Sie bitte die ErlÑuterungen zum
     Thema XBRA.
@endnode

@node XBRA
@toc Inhaltsverzeichnis
     @{U}6.1  XBRA@{u}


     @{U}Allgemeines@{u}

     Jedes Programm, das sich in einen Vektor einhÑngt, sollte vor seiner
     Einsprungadresse folgende Struktur installieren:

     typedef struct
     {
          char xb_magic[4];    /* "XBRA" */
          char xb_id[4];       /* XBRA-ID des installierten Programms */
          long xb_oldvec;      /* Wert des Vektors vor dem EinhÑngen */
     } XBRA;

     oder in Assembler:
                   dc.l 'XBRA'
                   dc.l 'PBUG'
     ALTE_ROUTINE: dc.l $xxxxxxxx
     ROUTINE: ...

@autorefoff
     Wenn sich alle Programme an obige Konvention halten, ist es fÅr ein
     Programm ein leichtes, sich aus einem Vektor auszuhÑngen, ohne auch
     andere Routinen mitauszuhÑngen. Ebenfalls kînnen Programme so fest-
     stellen, ob sie sich schon in den Vektor eingehÑngt haben. Ist auch
     nur ein einziges Programm da, das kein XBRA benutzt, oder es falsch
     benutzt, funktioniert dies nicht mehr. Leider gibt es immer noch Pro-
     grammierer, die glauben, da sich ihr Programm eh nicht aushÑngen muss,
     brauche es auch kein XBRA zu benÅtzen. In der Regel geht es aber nicht
     um das eigene Programm, sondern um fremde. Eines davon ist PEACEBUG.


     @{U}Der Resetvektor@{u}

     Es ist trotz XBRA nicht mîglich, sich sauber aus dem Resetvektor aus-
     zuhÑngen, da resvalid Åber XBRA nicht zugÑnglich ist und nicht bei
     allen in diesem Vektor hÑngenden Programmen zwingend $31415926 sein
     muss (insbesondere nicht beim ersten Programm, das sich einhÑngt).
     Meine Lîsung ist einfach und wirksam: Jedes Programm testet vor dem zu-
     rÅckspringen ins TOS, ob noch ein anderes Programm im Vektor hÑngt.
     Wenn ja, wird resvalid mit dem magic beschrieben, andernfalls ge-
     lîscht. Diese Methode erlaubt es Programmen, sich gefahrlos auszuhÑn-
     gen und sÑhe in etwa so aus:

                             DC.L 'XBRA'
                             DC.L _ID
     OLD_RESET:              DC.L 0
     RESET:          MOVE.W      SR,-(SP)
                     ORI.W       #$700,SR
                     MOVE.L      A0,-(SP)
                     MOVE.L      SP,SAVE_SP_RESET
                     MOVE.L      $08.w,SAVE_BUS_RESET
                     MOVE.L      $0C.w,SAVE_ADDRESS_RESET
                     MOVE.L      #_RESET,$08.w
                     MOVE.L      #_RESET,$0C.w
                     MOVE.L      #$31415926,RESVALID.w
                     MOVEA.L     OLD_RESET(PC),A0
                     MOVE.L      A0,RESVECTOR.w
                     CMPI.L      #'XBRA',-12(A0)
                     BEQ.S       ANOTHER_ONE
     _RESET:         CLR.L       RESVALID.w
     ANOTHER_ONE:    *here you go*
                     MOVE.L      SAVE_ADDRESS_RESET(PC),$0C.w
                     MOVE.L      SAVE_BUS_RESET(PC),$08.w
                     MOVEA.L     SAVE_SP_RESET(PC),SP
                     MOVEA.L     (SP)+,A0
                     MOVE.W      (SP)+,SR
                     JMP         (A6)

     SAVE_BUS_RESET:         DS.L 1
     SAVE_ADDRESS_RESET:     DS.L 1
     SAVE_SP_RESET:          DS.L 1
@autorefon
@endnode

@node "Ein Wort regelt alles"
@toc Inhaltsverzeichnis
     @{U}6.2  Ein Wort regelt alles@{u}


     Bei jedem Einsprung in den Debugger, beim Aufruf einer Funktion Åber
     Return oder beim DrÅcken einer Funktionstaste wird die Routine @{VEKTOR link %VEKTOR}
     aufgerufen. Diese dient dazu, Exceptionroutinen einzuhÑngen, auszuhÑn-
     gen, an die erste Position zu hÑngen und dergleichen mehr.
     Jeder der 48 Routinen ist ein Wort zugeordnet, das genau festlegt, wie
     diese Routine von VEKTOR behandelt wird. Gleichzeitig dient dieses
     Wort dazu, festzulegen, was der Debugger bei Auftreten der entsprech-
     enden Exception tun darf/soll/muss.
     Das ganze ist so flexibel gehalten, dass Sie beinahe alles machen kîn-
     nen. Beispielsweise kînnen Sie PEACEBUG zweimal installieren (zwei
     identische aber verschieden konfigurierte Versionen) und den einen mit
     dem andern debuggen.

     Im den nÑchsten beiden Kapiteln wird beschrieben, wie dieses ominîse
     Wort kodiert ist und was diese Kodierungen bedeuten. Wo dieses Wort zu
     finden ist und wie es geÑndert werden kann, lesen sie im Kapitel
     "Vektorkonfiguration" nach.
@endnode

@node "Das hîherwertige Byte"
@toc Inhaltsverzeichnis
     @{U}6.2.1  Das hîherwertige Byte@{u}


     @{U}Allgemeines@{u}

     Das hîherwertige Byte wird von @{VEKTOR link %VEKTOR} benutzt und darf folgende Werte
     annehmen:
     -2: Die Debuggeroutine wird in der XBRA-Verkettung gesucht. Wenn sie
@autorefoff
         gefunden wird, dann wird sie ausgehÑngt und an erster Stelle
         wieder eingehÑngt.
     -1: Die Debuggeroutine wird in der XBRA-Verkettung gesucht. Wenn sie
         gefunden wird, dann wird sie ausgehÑngt und an erster Stelle
         wieder eingehÑngt. Wenn sie nicht gefunden wird, dann wird sie neu
         installiert. Letzteres kann zu Endlosverkettungen fÅhren, wenn ein
         Programm den Vektor umgelenkt hat, ohne XBRA zu benutzen.
     0:  Die Debuggeroutine wird in der XBRA-Verkettung gesucht. Wenn sie
         gefunden wird, dann wird sie ausgehÑngt.
     1:  Die Debuggeroutine wird in der XBRA-Verkettung gesucht. Wenn sie
         nicht gefunden wird, dann wird sie neu installiert.
     2:  Es passiert gar nichts.


     @{U}ErlÑuterungen@{u}

@autorefon
     1. Das AushÑngen von Vektoren kann bei PEACEBUG gefÑhrlich sein, da es
@autorefoff
        jederzeit stattfinden kann. Geschieht dies gerade in dem Moment, in
        dem der Debugger angesprungen wird, so wird die aufrufende Routine
        eventuell zweimal angesprungen und welche Routine ist schon re-
        entrant? Meine lange Erfahrung hat allerdings gezeigt, dass dieser
        Fall nie eintritt.
     2. Bei Programmstart werden alle Routinen eingehÑngt, es sei denn, das
        hîherwertige Byte ist Null.
     3. -1 bei Exceptions benutzen, die, falls sie auftreten, vom Debugger
        angezeigt werden sollen und die zwingend vom Debugger gebraucht
        werden. Siehe auch Kapitel "Vektoren, in eigener Sache".
     4. -2 bei Exceptions benutzen, die, falls sie auftreten, vom Debugger
        angezeigt werden sollen, z.B. Format Error, Privileg Error, Ring
        Indicator usw..
     5. Weniger ist mehr!
        Je weniger Routinen Sie einhÑngen, desto weniger Unheil kann PEACE-
        BUG anrichten. Nicht benutzte Vektoren, wie PMMU Illegal oder
        Coproc. Protocol Viol. sollten Sie nicht einhÑngen.
     6. Zwei spezielle Vektoren sind AES und LINEF.
        Sie sollten erst eingehÑngt werden, wenn AES installiert ist. Wird
        der Debugger vom Desktop gestartet, kann dies sofort geschehen, bei
        Start aus dem Autoordner muss abgewartet werden, bis AES instal-
        liert ist. Dies merkt PEACEBUG selber, vorausgesetzt er kann sich
        in den Biostrap einhÑngen.
        PEACEBUG kann zweimal im Trap 2 hÑngen. Dies weil bei Initialisie-
        rung der AES der Vektor vom Betriebsystem Åberschrieben wird.
        Zuerst wird also die VDI, dann die AES Routine eingehÑngt.
     7. LINEF einzuhÑngen macht nur bei Betriebsystemen Sinn, die auch
        Linef benutzen, also bei Versionen <=1.04. Bei allen andern sollten
        Sie das Flag auf Null setzen. Tip: gerade Linef-Befehle mit DoPC
        Åbertracen, ungerade normal tracen (F1).
     8. Richtig zu Konfigurieren ist nicht einfach.
        Wenn Sie dort einen Fehler machen, dann stÅrzt der Rechner ab. Dies
        passiert genau dann, wenn Sie Ihren wichtigsten Quelltext abspei-
        chern wollen. SelbstverstÑndlich wird dabei auch Ihr einziges
        Backup Åberschrieben...
@autorefon
@endnode

@node "Das niederwertige Byte"
@toc Inhaltsverzeichnis
     @{U}6.2.2  Das niederwertige Byte@{u}


     @{U}Allgemeines@{u}

     Das niederwertige Byte wird von der Exceptionroutine benutzt und ist
     folgendermassen codiert:
     Bit 0: Ist dieses Bit gesetzt und die Exception tritt auf, dann wird
            in den Debugger gesprungen und eine entsprechende Meldung
            ausgegeben.
     Bit 1: Ist dieses Bit gesetzt und die Exception tritt auf, dann wird
            versucht die Exception zu korrigieren, d.h. es wird bei dem
            Befehl weitergefahren, der demjenigen folgt, der die Exception
            ausgelîst hat oder bei dem diese ausgelîst wurde.
     Sind beide Bits gesetzt, dann hat Bit 0 hîhere PrioritÑt als Bit 1.
     Sind beide Bits gelîscht, dann springt der Debugger weiter, d.h er
     ruft die Routine auf, die nach ihm im Vektor hÑngt.


     @{U}SpezialfÑlle@{u}

     Ein spezieller Fall ist die Privilege Violation. Hier haben zwei wei-
     tere Bits eine Bedeutung:
     Auf einem 68000er gibt es den Befel move sr,<ea>, der auch im Usermo-
     dus erlaubt ist, ganz offensichtlich ein Designfehler. Dies hat Moto-
     rola erkannt und ab dem 68010 gibt es diesen Befehl im Usermodus nicht
     mehr. DafÅr gibt es zusÑtzlich den Befehl move ccr,<ea>.
     Scheinbar gibt es Programme, die diesen Befehl im Usermodus benutzen
     und deshalb nur auf einem 68000er korrekt laufen. Pikanterweise gehîrt
     z.B. Atari's HDX zu diesen öbeltÑtern ...
     Bit 4: Ist dieses Bit gesetzt und tritt bei einem move sr,<ea> eine
            Exception auf, wird der Befehl vom Exceptionhandler im Super-
            visormodus ausgefÅhrt, das Programm merkt also nicht, das eine
            Exception auftrat.
            Das macht das TOS doch schon, werden Sie einwerfen.
            Mit dieser Behauptung liegen Sie zwar nicht ganz falsch, aber
            auch nicht vîllig richtig.
            Korrekt ist, dass TOS nur einige @{Befehle ignore} im Supervisormodus
            ausfÅhren kann. Ein "move sr,([-1,za0,d0*8],-1)" kann das TOS
            nicht korrigieren, der Debugger hat auch damit keine Schwierig-
            keiten.
     Bit 5: Ist dieses Bit gesetzt und tritt bei einem move sr,<ea> eine
            Exception auf, wird der Befehl durch den entsprechenden move
            ccr,<ea> ersetzt (im Programmcode selber, die Prozessorcaches
            werden entsprechend geflusht).
     Sind beide Bits gesetzt, dann hat Bit 4 hîhere PrioritÑt als Bit 5.
     Sind beide Bits gelîscht, dann werden die Bits 0 und 1 wie oben
     beschrieben ausgewertet.

     Ein weiterer Spezialfall ist die Resetexception. Hier haben ebenfalls
     Bit 4 und 5 eine besondere Bedeutung.
     Bit 4: Ist dieses Bit gesetzt und tritt ausserhalb des Debuggers ein
            Reset auf, dann wird dieser abgefangen. Der PC zeigt dann
            auf die Stelle des Bootcodes, die die Routinen im Resetvektor
            ausfÅhrt.
     Bit 5: Ist dieses Bit gesetzt und tritt ausserhalb des Debuggers ein
            Reset auf, dann wird dieser abgefangen. Tritt innerhalb einer
            Sekunde nochmals ein Reset auf, wird dieser nicht mehr abge-
            fangen. Durch zweimaliges schnelles Reseten kînnen Sie den
            Rechner also trotz Debugger reseten.
     Sind beide Bits gesetzt, dann hat Bit 4 hîhere PrioritÑt als Bit 5.
     Sind beide Bits gelîscht, dann werden die Bits 0 und 1 wie oben
     beschrieben ausgewertet.
@endnode

@node "Vektoren, in eigener Sache"
@toc Inhaltsverzeichnis
     @{U}6.3  Vektoren, in eigener Sache@{u}


     Einige  Routinen werden fÅr eigene Zwecke missbraucht, die GÅltigkeit
     der eben beschriebenen Bits wird dadurch eingeschrÑnkt:

     - Address- und Buserrorhandler werden intern benutzt, ausserhalb des
       Debuggers gelten Ihre Einstellungen. Es ist nicht zwingend notwen-
       dig, dass der Debugger im Bus- bzw. Addresserrorhandler hÑngt, die
       entsprechenden Exceptions werden dennoch abgefangen. Da es aber
       FÑlle geben kann, in denen dies nicht funktioniert, ist es sicherer,
       wenn sich der Debugger einhÑngt. Den Debugger aus diesen Vektoren
       auszuhÑngen macht sowieso nur Sinn, wenn Sie ihn debuggen wollen.

     - Der Illegal Opcode Handler wird benutzt fÅr Breakpoints und um in
       den Supervisormodus zu schalten.

     - Die Traceexception wird immer fÅr eigene Zwecke gebraucht, die
       Einstellungen haben daher keine Wirkung

     - Ein Reset innerhalb des Debuggers wird immer abgefangen. Ein Reset
       ausserhalb wird abgefangen, wenn Bit 4 oder 5 gesetzt sind.

     - Der etv_critic Handler wird intern benutzt, ausserhalb des Debuggers
       behalten die Einstellungen ihre GÅltigkeit.

     - Der 200 Hz Timer wird fÅr die diversen internen Timer (Timeout, Key-
       repeat etc.), sowie fÅr die Observefunktion benutzt.

     - Der VBL wird fÅr die Slowmotionfunktion und fÅr Shift-Shift benutzt.

     - Der Keyboardinterrupt ignoriert die Einstellungen innerhalb des De-
       buggers. PEACEBUG hat die Eigenschaft, dass andere PEACEBUGs
       Tastatureingaben mitbekommen, andere Debugger wie TEMPLMON hingegen
       nicht. Sie kînnen deshalb PEACEBUG mittels eines zweiten PEACEBUG
       unterbrechen, nicht aber mit andern Debuggern, es sei denn, Sie
       Ñndern die Konfiguration entsprechend.
@endnode


@remark *******************************************************************
@remark * Trace & Breakpoints                                             *
@remark *******************************************************************

@node "Trace & Breakpoints"
@toc Inhaltsverzeichnis
     @{U}7  Trace & Breakpoints@{u}



     @{U}Allgemeines@{u}

     Ein an sich simples Unterfangen ist auf Motorolaprozessoren das Tracen
     von Programmen, d.h. das schrittweise AusfÅhren von Befehlen auf Ma-
     schinenebene.
     Ganz so einfach ist die Sache aber dennoch nicht, denn es sollte nicht
     getraced werden wenn (dies sind natÅrlich Atarispezifische EinschrÑn-
     kungen):
     1. flock gesetzt ist.
     2. Die Interruptmaske 7 ist.


     @{U}Trace + - *@{u}

     Die Befehle TRACE + und TRACE - tragen dem Rechnung, indem Sie den
     Tracemodus gegebenenfalls abschalten. Nun gibt es Momente, wo gerade
     in einer kritischen Routine ein Fehler zu suchen ist und deshalb immer
     getraced werden muss. @{TRACE ignore} * nimmt auf obige Bedingungen keine RÅck-
     sicht und schaltet den Tracemodus nie ab. Dies fÅhrt auf dem Atari
     aber meist schon nach kurzer Zeit zum Absturz. Welche Methode Sie ver-
     wenden, ob mit oder ohne abschalten, mÅssen Sie ausprobieren, da dies
     auch sehr stark von der benutzten TOS-Version abhÑngt.


     @{U}Breakpoints@{u}

     - ROM-Breakpoints: Alle Breakpoints im ROM benutzen den Tracemodus. Da
       auch getraced wird, wenn flock gesetzt oder die Interruptmaske 7
       ist, sind ROM-Breakpoints gefÑhrlich. Wenn die Zeitspanne bis zum
       Erreichen des Breakpoints allerdings nur kurz ist, kann diese
       Mîglichkeit getrost benutzt werden.
     - RAM-Breakpoints: ZÑhler- und Stopbreakpoints schalten den Trace fÅr
       die Dauer eines Befehls an. Dies ist aber ungefÑhrlich.


     @{U}@{Funktionstasten ignore}@{u}

     Auch diverse Funktionen, die Åber die Funktionstasten aufgerufen wer-
     den, benutzen den Tracemodus. Es ist daher angebracht, darÅber einige
     Worte zu verlieren und Sie auf mîgliche Gefahren aufmerksam zu machen.

     - F1-Trace: FÅr die Dauer eines einzelnen Befehls wird der Tracemodus
       aktiviert. Wenn dieser Befehl ein Trapv, ein Trap 0-15 oder eine
       Linea-Exception ist, die wie einzelne @{Befehle ignore} behandelt werden, wird
       der Tracemodus nicht benutzt. Diese Funktion kann dann gefÑhrlich
       sein, wenn sie in zeitkritischen Routinen ausgefÅhrt wird, z.B.
       durch mehrmaliges Tracen mit dem Befehl TRACE Number.   
     - F2-Do PC: Befindet sich der Befehl im ROM, wird der Tracemodus
       aktiviert, damit die Abbruchbedingung nicht "verpasst" wird. Meist
       ist dies ungefÑhrlich, es sei denn, es verstreiche einige Zeit bis
       zum Erreichen des Breakpoints (z.B. bei zeitintensiven Schleifen).
       Wenn der aktuelle Befehl ein bsr oder jsr, dann wird kein Breakpoint
       gesetzt, nur fÅr die Dauer eines Befehls wird der Tracemodus
       aktiviert.
     - F3-Tracerts: Der Tracemodus wird nicht benutzt.
     - F4-Texcept: Der Tracemodus wird nicht benutzt. Diese Funktion wird
       durch Emulation der Exception implementiert.
     - F11-Tr68020: Der Tracemodus wird konstant eingeschaltet und nach
       jedem Befehl wird geprÅft, ob ein "change of flow" eintreten wird,
       d.h. ob ein rts/rtr/rte, bra, jmp usw. ausgefÅhrt werden wird. Da
       die Dauer bis zum Auftreten des nÑchsten "change of flow" aber meist
       sehr kurz ist (einige @{Befehle ignore}), ist dies meist ungefÑhrlich. Tritt
       der nÑchste "change of flow" aber erst nach einer Weile auf, ist
       hîchste Vorsicht geboten. Zeitkritische Stellen sollte man nicht mit
       dieser Funktion tracen.
     - F12-Tnosubs: Entspricht F2-Do PC, wenn der PC auf ein bsr oder jsr
       zeigt, sonst dem normalen F1-Trace.
     - F13-Tracerte: Der Tracemodus wird nicht benutzt.
     - F14-GoTraps: Der Tracemodus wird nicht benutzt, es sei denn, es habe
       sich kein Programm in den Gemdos-, Gem-, Bios- oder Xbios-@{Vektor ignore}
       eingehÑngt, d.h. wenn die Vektoren ins ROM zeigen. Nur in diesem
       Fall werden auf die AnfÑnge der ROM Routinen Breakpoints gesetzt,
       die Åber den Tracemodus getestet werden mÅssen. Dies ist allerdings
       sehr selten der Fall (z.B. gleich nach dem Booten).
@endnode


@remark *******************************************************************
@remark * Resetfest & Resetresident                                       *
@remark *******************************************************************

@node "Resetfest & Resetresident"
@toc Inhaltsverzeichnis
     @{U}8  Resetfest, Resetresident@{u}



     @{U}Der Reset@{u}

     Folgende Dinge passieren im Falle eines Warmstarts (gekÅrzt):
     1. ISP und PC setzen.
     2. Reset ausfÅhren.
     3. Diagnose Cartridge ausfÅhren, falls vorhanden.
     4. Routinen im Resetvektor $42A ausfÅhren.     <---
     5. Hardwareinitialisierung.
     6. Systemvariablen setzen, Interrupts initialisieren, Bios initiali-
        sieren.
     7. Bildschirm initialisieren.
     8. Diskette booten.
     9. Harddisk booten.
     10. Doppelseiten ausfÅhren (undokumentiert).   <---
     11. COMMAND.PRG starten wenn _cmdload ungleich 0 ist.
     12. Autoordnerprogramme ausfÅhren.
     13. AES und Desktop starten.


     @{U}Resetfest@{u}

     PEACEBUG installiert sich im Resetvektor, um einen Reset mittels der
     Resettaste zu Åberleben. Dazu muss er die Hardwareinitialisierung
     selber Åbernehmen. Das ganze funktioniert allerdings nur, wenn Sie
     sich im Debugger befinden, denn andernfalls geht der PC verloren und
     der Debugger kann nicht mehr ordnungsgemÑss verlassen werden.
     Falls ein Reset ausserhalb des Debuggers stattfindet und dieser ent-
     sprechend konfiguriert ist, wird er angesprungen. Der PC zeigt dann
     auf die Stelle des Bootcodes, die die Routinen im Resetvektor aus-
     fÅhrt.
     Die Resetfestigkeit von PEACEBUG ist vor allem dann sehr nÅtzlich,
     wenn sich die Hardware "aufgehÑngt" hat, normalerweise lÑuft dann
     nichts mehr. Mit einem Reset kann dann PEACEBUG meist wiederbelebt
     werden.


     @{U}Resetresident@{u}

     PEACEBUG installiert eine Doppelseite, um einen Warmstart zu Åber-
@autorefoff
     leben. Nachdem der Harddisktreiber gestartet ist, wird PEACEBUG Åber
     die Doppelseite angesprungen. Wenn Sie in diesem Moment die linke
     Shifttaste gedrÅckt halten, bleibt der Debugger resident und instal-
     liert sich noch vor dem ersten Autoordnerprogramm. Ein als Autoordner-
     programm gestarteter PEACEBUG erkennt die residente Version und
     installiert sich nicht nochmals. Wenn Sie zusÑtzlich zur linken auch
     die rechte Shifttaste gedrÅckt halten, wird der Debugger unmittelbar
     nach dem Installieren angesprungen. Der PC zeigt dann auf die Routine,
     die die Doppelseiten sucht.
     ACHTUNG: Das von PEACEBUG benutzte System lÑsst nicht zu, dass sich
     ausser dem Debugger noch ein zweites resetresidentes Programm instal-
     liert. Auch ein zweiter PEACEBUG kann nicht resident gehalten werden.
     Das im Profibuch vorgeschlagene System hat sich nicht durchgesetzt und
     ist auch nicht zu empfehlen, da sich Atari jederzeit dazu entschlies-
     sen kann, den Bereich von $600-$6FF zu benutzten, wie dies beim
     Bereich $700-$7FF geschah.

     Um resetresident zu bleiben, geht PEACEBUG wie folgt vor:
     - Anlegen einer Doppelseite im ST-RAM, denn nur dieses wird nach
       Doppelseiten durchsucht.
     - Bei einem Warmstart werden alle allozierten Speicherbereiche frei-
       gegeben (aber nicht gelîscht). Deshalb muss neuer Speicher reser-
       viert werden.
     - Der Debugger kopiert sich selber in diesen Bereich und reloziert
       sich dort. Die Kopier- und Relozierroutinen werden auf den Stack
       ausgelagert.
     - Die Symboltabelle muss neu geladen werden, da sie bei obigem Vorgang
       leider verloren geht.
     - Dieser Vorgang erfordert einigen selbstmodifizierenden Code.
       Eventuell vorhandene Prozessorcaches werden deshalb nach getaner
       Arbeit gelîscht (MC68020/30/40).


     @{U}Tips@{u}

     FÅr diejenigen, die sich fÅr den Bootvorgang interessieren, hier
     einige Tips. Die Angaben sind je nach TOS Version leicht verschieden,
     Ñltere Versionen dÅrften ein anderes Vorgehen haben.
     Beim Einsprung in den Debugger Åber die Doppelseite zeigt der PC auf
     die Routine, die die Doppelseiten sucht, wobei die Adresse, an der ge-
     sucht wird, vom Debugger auf $600 gesetzt wird, um zu vermeiden, dass
     andere Doppelseiten ausgefÅhrt werden. Dies wÑre gefÑhrlich, da sich
     der Debugger vermutlich im Speicher verschoben hat und so andere resi-
     dente Programme beschÑdigt haben kînnte.
     Nach dieser Routine wird _cmdload getestet und gegebenenfalls ver-
     zweigt. COMMAND.PRG wird gleich nach allen Autoordnerprogrammen gestar-
     tet. Diese werden wie folgt ausgefÅhrt:
     1. Mittels PEXEC 5 (Create Basepage) legt das OS eine Basepage an,
        schreibt die Adresse einer Routine in die Basepage (Offset 8) und
        fÅhrt dann ein PEXEC 4 (Just Go) aus. Dieses PEXEC kînnen Sie nicht
        einfach so Åbertracen, weil die aufgerufene Routine direkt zurÅck-
        springt (der Stack wird neu gesetzt). Sie mÅssen also entweder den
        Trap durchtracen oder ein Breakpoint setzen (funktioniert auch im
        ROM problemlos).
     2. Die gestartete Routine geht in den Supervisormodus, setzt die DTA
        und sucht dann mittels FSFIRST/FSNEXT die Autoordnerprogramme.
     3. Die Programme werden mittels PEXEC 0 (Load and GO) gestartet.
        Nun wird _sysbase gesetzt, ein Environmentstring erzeugt (PATH=...)
        und mittels PEXEC 5, PEXEC 4 die Routine in exec_os ausgefÅhrt,
        normalerweise AES und Desktop.
@autorefon
@endnode


@remark *******************************************************************
@remark * Cache                                                           *
@remark *******************************************************************

@node Cache
@toc Inhaltsverzeichnis
     @{U}9  Cache@{u}



     @{U}Allgemeines@{u}

     PEACEBUG besitzt zwei Befehlscaches. Bei einem Trace werden die aktu-
     ellen Register (siehe unten) in einem dieser Caches gespeichert. Cache
     1 kann defaultmÑssig 20, Cache 2 deren 5 EintrÑge aufnehmen (ein Ein-
     trag entspricht einem kompletten Registerset). Diese Defaultwerte
     kînnen entweder direkt im Programmcode oder wÑhrend der Laufzeit ver-
     Ñndert werden (mittels PBUGCONF).
     In den Caches kann 'geblÑttert' werden, d.h. Sie kînnen sich anschau-
     en, was bisher getraced wurde. In der dritten Zeile wird angezeigt,
     welchen Cacheeintrag Sie sich gerade ansehen. Wenn Sie sich BUGABOO
     gewîhnt sind, dann beachten Sie, dass hier ein entscheidender Unter-
     schied besteht. Die aktuellen Register, d.h. diejenigen, die bei
     Verlassen des Debuggers zurÅckgeschrieben werden, sind immer die-
     jenigen, die sich im aktuellen Cacheeintrag befinden. Wenn Sie also
     "zurÅckblÑttern" Ñndern Sie immer auch die aktuellen Registerinhalte.
     Wenn Sie an der gleichen Stelle weiterfahren wollen, an der Sie das
     Programm unterbrochen haben, mÅssen Sie sich beim ersten Cacheeintrag
     befinden (gezÑhlt wird 0,1,2,...).
     Wenn Sie Register editieren, verÑndern Sie gleichzeitig auch den ak-
     tuellen Cacheeintrag. Sie kînnen so leicht ein ProgrammstÅck mehrmals
     mit verschiedenen Registerwerten durchlaufen, einfach zurÅckscrollen,
     Register Ñndern, nochmals tracen.


     @{U}Zwei Caches@{u}

     Doch wozu nun zwei Caches?
     Der zweite Cache ermîglicht es Ihnen mal schnell was auszuprobieren,
     ohne Gefahr zu laufen, die alten Registerinhalte zu verlieren, ein
     wenig vergleichbar also mit den Funktionen rs und rr von TEMPLMON.
     z.B. haben Sie an der Adresse xy eine Doppelseite entdeckt, die Ihnen
     verdÑchtig vorkommt:
     - @{"Shift Alternate Insert" link Tastaturbelegung SAI} (Cache wechseln mit Registerkopieren).
     - PC auf @{Doppelseite ignore} setzen.
     - Tracen.
     - @{"Alternate Insert" link Tastaturbelegung AI} (Cache wechseln ohne Registerkopieren).
     Da die beiden Caches absolut identisch sind, ist es egal auf welchem
     Sie debuggen, hauptsache Sie verlassen den Debugger mit den richtigen
     Registerwerten.


     @{U}Aufbau der Caches@{u}

     Die Caches sind als Ring organisiert und kînnen daher leicht erweitert
     werden. Ein einzelner Eintrag umfasst in der vorliegenden Version 270
     Bytes und ist die folgt aufgebaut:

     double FPn[8]             ; FP Register (96 Bit lang)
     long   FPSR               ; FP Status Register
     long   FPIAR              ; FP Instruction Address Register
     long   FPCR               ; FP Control Register
     word   TC_40              ; Translation Control Register
     long   URP                ; User Root Pointer Register
     long   DTT1               ; Data Transparent
     long   DTT0               ; Translation Register 0/1
     long   ITT1               ; Instruction Transparent
     long   ITT0               ; Translation Register 0/1
     long   TC_30              ; Translation Control Register
     long   TT1                ; Transparent Translation
     long   TT0                ; Register 0/1
     dlong  CRP                ; CPU Root Pointer Register (64 Bit Wert!)
     word   MMUSR              ; MMU Status Register
     dlong  SRP                ; Supervisor Root Pointer (40er nur 32 Bit)
     long   MSP                ; Master Stack Pointer
     long   CACR               ; Cache Control Register
     long   CAAR               ; Cache Adress Register
     long   VBR                ; @{Vektor ignore} Base Register
     long   DFC                ; Destination Function Code
     long   SFC                ; Source Function Code
     long   USP                ; User Stack Pointer
     long   ISP                ; Interrupt Stackpointer
     long   PC                 ; Program Counter
     word   STATUS             ; Status Register
     long   Dn[8]              ; D0-D7
     long   An[8]              ; A0-A6
     void   *NEXT_RECORD       ; Zeiger auf den nÑchsten Eintrag
     void   *PREVIOUS_RECORD   ; Zeiger auf den vorherigen Eintrag

@autorefoff
     ACHTUNG: beim Einsprung in den Debugger wird der aktuelle Supervisor-
     stack temporÑr benutzt, d.h. es werden Werte auf diesem Stack Åber-
     schrieben! Wenn Sie ein im Supervisormodus laufendes Programm tracen,
     kînnen darum Befehle wie rts nicht mehr wiederholt werden, weil die
     RÅcksprungadresse, die auf dem Stack lag, vermutlich Åberschrieben
     wurde. Das Gleiche gilt fÅr alle Befehle, die Werte vom Stack lesen.
@autorefon
@endnode


@remark *******************************************************************
@remark * Schnittstelle                                                   *
@remark *******************************************************************

@node Schnittstelle
@toc Inhaltsverzeichnis
     @{U}10  Schnittstelle@{u}



     @{U}Allgemeines@{u}

     PEACEBUG besitzt eine Schnittstelle, die jedem Programm zugÑnglich
     ist. Diese ist dokumentiert und wird in zukÅnftigen Programmversionen
     nicht verÑndert, nur erweitert. Programme die diese Schnittstelle kor-
     rekt benutzen, werden also auch mit spÑteren Versionen keine Probleme
     haben.
     Sollten Sie ein Programm haben, dass diese Schnittstelle benutzt und
     das von allgemeinem Interesse ist, kînnen Sie es mir zukommen lassen,
     es kann dann fester Bestandteil von PEACEBUG werden.
     Erreichbar ist die Schnittstelle Åber den Cookieeintrag mit Kennung
     'PBUG'. Beispiele von Programmen, die Åber den Cookie mit PEACEBUG
     kommunizieren, liegen mit Quelltext bei.
     ACHTUNG: Nur die residente Version installiert einen @{Cookieeintrag ignore},
     d.h. alle in diesem Kapitel beschriebenen Variablen sind nicht zugÑng-
     lich, wenn der Debugger als Programm gestartet wird.
     Desweiteren kînnen Sie aber auch die Programmdatei direkt patchen. Sie
     kînnen so Einstellungen permanent Ñndern und mÅssen dies nicht jedes-
     mal Åber die Cookieschnittstelle tun.


     @{U}Aufbau der Strukturen@{u}

     Jede Struktur, die in diesem Kapitel dokumentiert wird, hat die glei-
     che Form. Am Anfang der Zeile steht der Datentyp, dann der Variablen-
     name, der Offset in Bytes vom Anfang der Struktur und last but not
     least der Status der Variablen:

     void *CLEAR_SCREEN               Offset 0       r/l/n
       |        |                        |             \___ Variablenstatus
       |         \___ Variablenname       \________________ Offset
        \____________ Datentyp (void, void *, long, word, byte, char)


     @{U}Variablenstatus@{u}

     r=read:  Diese Variablen dÅrfen Sie lesen und auswerten. Routinen mit
              diesem Status dÅrfen aufgerufen werden (immer im Supervisor-
              modus und immer mittels jsr).
     w=write: Diese Variablen dÅrfen Sie schreiben. Routinen mit diesem
              Status dÅrfen auf eigene Routinen umgelenkt werden.
     p=patch: Diese Variablen dÅrfen im Programmcode (auf Disk/Platte)
              verÑndert werden. r und w beziehen sich nur auf den im
              Speicher installierten Debugger.
     Es gilt r<w<p, d.h. p impliziert w impliziert r (mit einer Ausnahme),
     aber nicht umgekehrt
     n=new:   Wenn Sie Variablen mit diesem Status verÑndern, mÅssen Sie
              anschliessend die Routine NEW_FORMAT aufrufen.
     l=lock:  Diese Variablen dÅrfen nicht mehr gelesen/geschrieben werden,
              wenn die Semaphore SCREEN_LOCK gesetzt ist. Gleiches gilt fÅr
              Routinen; diese dÅrfen bei gesetzter Semaphore nicht mehr
              aufgerufen werden. Wenn Sie auf Variablen/Routinen mit diesem
              Status zugreifen, muss die Semaphore gesetzt werden.


     @{U}Patchen@{u}

     Die Programmdatei kann sehr einfach gepatched werden. Zwei Bytes
     hinter dem Programmheader, d.h. in 30 Bytes Offset zum Dateianfang,
     steht eine Kennung und fÅnf Longoffsets, die angeben, wie weit vom
     Dateianfang sich die genannten Strukturen befinden:

     long _id                Offset 30           /* "PBUG" */
     void *SCREEN_PARAMETER  Offset 34
     void *PARAMETER         Offset 38
     void *FLAGS             Offset 42
     void *@{FONT_16 link %FONT_16}           Offset 46
     void *@{FONT_8 link %FONT_8}            Offset 50

     Mit handle=Fopen(fname,2), Fseek(30,handle,0), Fread(handle,24,buffer)
     bekommen Sie alle wichtigen Werte. Dannach mÅssen Sie nur noch mit
     Fseek an die entsprechende Stelle springen und kînnen dort die Werte
     patchen.
@endnode

@node Cookieeintrag
@toc Inhaltsverzeichnis
     @{U}10.1  Cookieeintrag@{u}


     Der Cookieeintrag hat die Kennung "PBUG" und zeigt auf die folgende
     Struktur:

     void *CLEAR_SCREEN      Offset 0    r/l/n      Bildschirmschnittstelle
     void *GET_PARAMETER     Offset 4    r/l/n                 "
     void *KILL_SCREEN       Offset 8    r/l/n                 "
     void *NEW_SCREEN        Offset 12   r/l/n                 "
     void *NEW_FORMAT        Offset 16   r/l                   "
     void *PRINT_SCREEN      Offset 20   r/l                   "
     void *SCREEN_PARAMETER  Offset 24   r                     "
     void *CALL_DEBUGGER_1   Offset 28   r               Debuggeraufruf
     char  @{VERSION link %VERSION}[4]        Offset 32   r
     void *PARAMETER         Offset 36   r             Diverse Parameter
     void *USERTRACE         Offset 40   r/w             Userroutinen
     void *USERENTER         Offset 44   r/w                   "
     void *USERQUIT          Offset 48   r/w                   "
     void *USERSWITCH_ENTER  Offset 52   r/w                   "
     void *USERSWITCH_QUIT   Offset 56   r/w                   "
     void *USERRESET         Offset 60   r/w                   "
     void *FLAGS             Offset 64   r             Vektorkonfiguration
     void *@{VEKTOR link %VEKTOR}            Offset 68   r                     "
     void *CALL_DEBUGGER_2   Offset 72   r               Debuggeraufruf
     void *TRACE_WITHOUT     Offset 76   r
     void *TRACE_WITH        Offset 80   r
     void *TRACE_ALWAYS      Offset 84   r
@endnode

@pnode TRACE_WITHOUT
Diese Routine schaltet
den Tracemodus an.
Es wird getraced wie
beim Befehl TRACE -.
@endnode

@pnode TRACE_WITH
Diese Routine schaltet
den Tracemodus an.
Es wird getraced wie
beim Befehl TRACE +.
@endnode

@pnode TRACE_ALWAYS
Diese Routine schaltet
den Tracemodus an.
Es wird getraced wie
beim Befehl TRACE *.
@endnode

@node Bildschirmschnittstelle
@toc Inhaltsverzeichnis
     @{U}10.2  Bildschirmschnittstelle@{u}


     Die ersten sieben Zeiger der Struktur, auf die der Cookieeintrag
     zeigt, gehîren zur Bildschirmschnittstelle. öber diese kînnen Sie den
     Bildschirmtreiber von PEACEBUG so flexibel konfigurieren, dass es so-
     gar mîglich ist, den Debugger in einem Fenster laufen zu lassen. Das
     Programm, das dies tut, liegt bei und heisst WINDOW.ACC/PRG.

     Die ersten sechs Zeiger sind Routinen, die mittels jsr aufgerufen wer-
     den (fÅr Hochsprachen konsultieren Sie bitte ihr Handbuch). Der Aufruf
     darf nur im Supervisormodus geschehen, Register werden keine ver-
     Ñndert. Es sind dies die folgenden sechs Routinen:
     - CLEAR_SCREEN
     - GET_PARAMETER
     - KILL_SCREEN
     - NEW_SCREEN
     - NEW_FORMAT
     - PRINT_SCREEN

     Der siebte Zeiger SCREEN_PARAMETER zeigt auf die diversen Parameter
     des Bildschirmtreibers, wie z.B. Anzahl Planes, ZeilenlÑnge etc.
@endnode

@node %CLEAR_SCREEN "Bildschirmschnittstelle: CLEAR_SCREEN"
@symbol ar CLEAR_SCREEN
@toc Bildschirmschnittstelle
     @{U}10.2.1  CLEAR_SCREEN@{u}


     CLEAR_SCREEN ist eine Routine, die den Debuggerbildschirm lîscht. Maus
     und Cursor werden ausgeschaltet. Diese Routine muss nicht aufgerufen
     werden, wenn Sie Åber NEW_SCREEN einen neuen Bildschirm installiert
     haben, da dieser schon gelîscht ist. Im Gegensatz dazu, sollte diese
     Routine nach einem NEW_FORMAT aufgerufen werden. Wenn Sie nachher noch
     PRINT_SCREEN aufrufen, werden Funktionstasten- und Registeranzeige
     wiederhergestellt.
@endnode

@node %GET_PARAMETER "Bildschirmschnittstelle: GET_PARAMETER"
@symbol ar GET_PARAMETER
@toc Bildschirmschnittstelle
     @{U}10.2.2  GET_PARAMETER@{u}


     GET_PARAMETER ist eine Routine, die die Bildschirmparameter mittels
     LINEA 0 ermittelt und die unter SCREEN_PARAMETER aufgefÅhrten Varia-
     blen von Offset 42 bis und mit Offset 56 setzt. Sie kann immer dann
     verwendet werden, wenn der Debugger wieder an die vom restlichen Sy-
     stem benutzte Auflîsung angepasst werden soll.
@endnode

@node %KILL_SCREEN "Bildschirmschnittstelle: KILL_SCREEN"
@symbol ar KILL_SCREEN
@toc Bildschirmschnittstelle
     @{U}10.2.3  KILL_SCREEN@{u}


     PEACEBUG reserviert bei Programmstart drei Speicherbereiche fÅr den
     Bildschirmtreiber:
     1. Den eigentlichen Bildschirmspeicher.
     2. Den Speicher fÅr die logische Darstellung des Bildschirminhalts,
        d.h. die Zeichendarstellung des Bildschirms.
     3. Den Speicher zum Puffern des Maushintergrunds.

     KILL_SCREEN ist eine Routine, Åber die diese Speicherbereiche wieder
     freigegeben werden kînnen. Dazu Åbergibt man der Routine ein Word auf
     dem Stack, von dem allerdings nur 3 Bit gebraucht werden:
       Bit 0: Bildschirmspeicher freigeben.
       Bit 1: Zeichenspeicher freigeben.
       Bit 2: Mauspuffer freigeben.

     Ein Aufruf in Assembler kann so aussehen:
     > move.w #%111,-(sp)        ; alle Bereiche freigeben
     > jsr   (a0)                ; Routine anspringen
     > addq.w #2,sp              ; und Stack korrigieren

     ACHTUNG: Speicherbereiche kînnen nach einem PTERMRES nicht mehr frei-
     gegeben werden, d.h. ein KILL_SCREEN tut eigentlich Åberhaupt nichts.
     Trotzdem muss KILL_SCREEN im Hinblick auf kommende Debuggerversionen
     aufgerufen werden, denn vielleicht wird dieses öbel von Atari einmal
     beseitigt.
@endnode

@node %NEW_SCREEN "Bildschirmschnittstelle: NEW_SCREEN"
@symbol ar NEW_SCREEN
@toc Bildschirmschnittstelle
     @{U}10.2.4  NEW_SCREEN@{u}


     NEW_SCREEN ist eine Routine, Åber die die schon bei KILL_SCREEN
     beschriebenen Speicherbereiche reserviert werden kînnen. Der Aufruf
     erfolgt genau gleich, nur dass bei NEW_SCREEN ein Wert auf dem Stack
     zurÅckgegeben wird, der angibt ob das Speicherreservieren gelungen
     ist. Wird eine Null zurÅckgegeben, ist ein Fehler aufgetreten. In
     diesem Fall sollte der Debugger nicht mehr angesprungen werden!

     Ein Aufruf in Assembler kann so aussehen:
     > move.w #%111,-(sp)        ; alle Bereiche neu reservieren
     > jsr    (a0)               ; Routine anspringen
     > tst.w  (sp)+              ; RÅckgabewert testen, Stack korrigieren
     > beq.s  error              ; Fehler aufgetreten ...
@endnode

@node %NEW_FORMAT "Bildschirmschnittstelle: NEW_FORMAT"
@symbol ar NEW_FORMAT
@toc Bildschirmschnittstelle
     @{U}10.2.5  NEW_FORMAT@{u}


     NEW_FORMAT ist eine Routine, die nach jeder VerÑnderung einer Varia-
     blen mit Status n oder nach Aufruf einer Routine mit diesem Status
     aufgerufen werden muss. Sie berechnet aus den unter SCREEN_PARAMETER
     beschriebenen Parametern alle intern nîtigen Variablen.
@endnode

@node %PRINT_SCREEN "Bildschirmschnittstelle: PRINT_SCREEN"
@symbol ar PRINT_SCREEN
@toc Bildschirmschnittstelle
     @{U}10.2.6  PRINT_SCREEN@{u}


     PRINT_SCREEN ist eine Routine, die den Bildschirm neu printet. Dies
     beinhaltet insbesondere das Restaurieren der ersten fÅnf Zeilen, d.h.
     der Funktionstasten- und der Registeranzeige. NatÅrlich wird auch der
     Rest des Bildschirms neu aufgebaut.
@endnode

@node %SCREEN_PARAMETER "Bildschirmschnittstelle: SCREEN_PARAMETER"
@symbol ar SCREEN_PARAMETER
@next Userroutinen
@toc Bildschirmschnittstelle
     @{U}10.2.7  SCREEN_PARAMETER@{u}


     SCREEN_PARAMETER ist ein Zeiger auf die im folgenden beschriebenen
     Variablen der Bildschirmschnittstelle:

     void *@{BILDSCHIRM_MALLOC link %BILDSCHIRM_MALLOC}          Offset 0        r/w/n/l
     void *@{BILDSCHIRM_ADRESSE link %BILDSCHIRM_ADRESSE}         Offset 4        r/w/n/l
     void *@{ZEICHEN_ADRESSE link %ZEICHEN_ADRESSE}            Offset 8        r/w/n/l
     void *@{MAUS_PUFFER link %MAUS_PUFFER}                Offset 12       r/w/n/l
     long reserved[4]
     void *@{FONT_16 link %FONT_16}                    Offset 32       r/w/n/l
     void *@{FONT_8 link %FONT_8}                     Offset 36       r/w/n/l
     word @{FONT_FLAG link %FONT_FLAG}                   Offset 40       r/w/p/n/l
     word @{OFFSET_X link %OFFSET_X}                    Offset 42       r/w/n/l
     word @{OFFSET_Y link %OFFSET_Y}                    Offset 44       r/w/n/l
     word @{BILD_BREITE link %BILD_BREITE}                 Offset 46       r/w/n/l
     word @{ZEILEN_LAENGE link %ZEILEN_LAENGE}               Offset 48       r/w/n/l
     word @{BILD_HOEHE link %BILD_HOEHE}                  Offset 50       r/w/n/l
     word @{SCREEN_BREITE link %SCREEN_BREITE}               Offset 52       r/w/n/l
     word @{SCREEN_HOEHE link %SCREEN_HOEHE}                Offset 54       r/w/n/l
     word @{PLANES link %PLANES}                      Offset 56       r/w/n/l
     long @{_BILDSCHIRM_LENGTH link %Vorgaben}          Offset 58       r/w/p/n/l
     long @{_ZEICHEN_LENGTH link %Vorgaben}             Offset 62       r/w/p/n/l
     long @{_MAUS_LENGTH link %Vorgaben}                Offset 66       r/w/p/n/l
     long reserved[4]
     word @{_OFFSET_X link %Vorgaben}                   Offset 86       r/w/p/n/l
     word @{_OFFSET_Y link %Vorgaben}                   Offset 88       r/w/p/n/l
     word @{_BILD_BREITE link %Vorgaben}                Offset 90       r/w/p/n/l
     word @{_BILD_HOEHE link %Vorgaben}                 Offset 92       r/w/p/n/l
     word @{_PLANES link %Vorgaben}                     Offset 94       r/w/p/n/l
     word reserved[3]
     byte @{SCREEN_LOCK link %SCREEN_LOCK}                 Offset 102      r/w/l
     byte @{SWITCH_PALETTE link %SWITCH_PALETTE}              Offset 103      r/w/p/l
     word @{OWN_PALETTE[256] link %OWN_PALETTE}            Offset 104      r/w/p/l
     byte @{SWITCH_REGISTER link %SWITCH_REGISTER}             Offset 616      r/w/p/l



@image g:\peacebug\peacebug\doc\screen.img 6 1 23
@endnode

@pnode %BILDSCHIRM_MALLOC
Adresse des durch Malloc re-
servierten Bildschirmspeichers.
Dessen LÑnge berechnet sich:
SCREEN_BREITE*SCREEN_HôHE+256.
@endnode

@pnode %BILDSCHIRM_ADRESSE
Adresse des eigentlichen Bildschirm,
die sich wie folgt berechnet:
(BILDSCHIRM_MALLOC+256) AND $FFFFFF00.
Im allgemein stimmt sie also nicht mit
BILDSCHIRM_MALLOC Åberein.
@endnode

@pnode %ZEICHEN_ADRESSE
Adresse des Zeichenbildschirm,
also des Speicherbereichs, der
den Bildschirminhalt logisch
reprÑsentiert (ASCII Zeichen).
Dessen LÑnge berechnet sich:
ZEILEN_LAENGE*BILD_HOEHE/8.
@endnode

@pnode %MAUS_PUFFER
Adresse des Speicherbereichs,
in den der Maushintergrund
gerettet wird. Dessen LÑnge
berechnet sich: PLANES*64.
@endnode

@pnode %FONT_16
Zeiger auf den 8*16 Font. Dieser ist 4096 Bytes
lang und im Programmcode integriert. Wenn Sie
einen neuen Font installieren wollen, Ñndern
Sie entweder diesen Zeiger oder Sie Åberschrei-
ben die Fontdaten selber mit den gewÅnschten
neuen. Die Fontdaten (nicht der Zeiger FONT_16)
hat also den Status r/w/p/n!).
@endnode

@pnode %FONT_8
Zeiger auf den 8*8 Font. Dieser ist 2048 Bytes
lang und im Programmcode integriert. Wenn Sie
einen neuen Font installieren wollen, Ñndern
Sie entweder diesen Zeiger oder Sie Åberschrei-
ben die Fontdaten selber mit den gewÅnschten
neuen. Die Fontdaten (nicht der Zeiger FONT_16)
hat also den Status r/w/p/n!).
@endnode

@pnode %FONT_FLAG
Hat dieses Wort den Wert 4, benutzt der
Debugger den 8*16 Font. Hat das Flag
den Wert 3, wird der 8*8 Font benutzt.
Alle andern Werte sind nicht definiert
und dÅrfen nicht benutzt werden.
@endnode

@pnode %OFFSET_X
Abstand des vom Debugger benutzten
Bildausschnitts vom linken Bildschirm-
rand in Zeichen. OFFSET_X ist nicht
gleich dem Abstand in Bytes, ausser
wenn PLANES=1 ist.
@endnode

@pnode %OFFSET_Y
Abstand des vom Debugger benutz-
ten Bildausschnitts vom oberen
Bildschirmrand in Pixeln.
@endnode

@pnode %BILD_BREITE
Breite des vom Debugger
benutzten Bildausschnitts
in Zeichen.
@endnode

@pnode %ZEILEN_LAENGE
Die vom Debugger benutzte ZeilenlÑnge. Diese muss immer >=
BILD_BREITE und durch 2 teilbar sein. Durch die Trennung von
Bildbreite und ZeilenlÑnge wird die Verwaltung virtueller
ZeilenlÑngen mîglich, wie sie nîtig ist, wenn die Bildbreite
hÑufig Ñndert (z.B. mit WINDOW.ACC). Die ZeilenlÑnge wird in
diesem Fall klugerweise auf die maximale Bildbreite gesetzt.
ACHTUNG: PEACEBUG kann eine maximale ZeilenlÑnge von 240
Zeichen verwalten, ZEILEN_LAENGE darf deshalb nie mit einem
grîsseren Wert beschrieben werden. Dies ist auch der Grund,
weshalb der Debugger bei Bildschirmauflîsungen ab 1920*yyy
Punkten nicht installiert werden kann.
@endnode

@pnode %BILD_HOEHE
Hîhe des vom Debugger
benutzten Bildausschnitts-
in Pixeln. Diese kann auch
ungerade sein.
@endnode

@pnode %SCREEN_BREITE
Breite des Bild-
schirms in Bytes.
@endnode

@pnode %SCREEN_HOEHE
Hîhe des Bild-
schirms in Pixeln.
@endnode

@pnode %PLANES
Anzahl Planes des
Bildschirms.
@endnode

@node %Vorgaben "SCREEN_PARAMETER: Vorgaben"
@next %SCREEN_PARAMETER
@prev %SCREEN_PARAMETER
@toc %SCREEN_PARAMETER
     @{U}Allgemeines@{u}

     Es kann sinnvoll sein, gewisse Bildschirmparameter nicht vom Debugger
     berechnen zu lassen, sondern diese vorzugeben. Dies ist z.B. der Fall
     bei Auflîsungswechseln, bei denen sich die LÑnge des Bildschirmspei-
     chers vergrîssert oder wenn eine Grafikkarte nach der Installation
     des Debuggers die Auflîsung umschaltet, was dazu fÅhrt, dass dieser
     nicht in derselben Auflîsung lÑuft wie das restliche System. Grund-
     sÑtzlich ist diese Mîglichkeit also sinnvoll, wenn Situationen ein-
     treten, die der Debugger nicht voraussehen kann.
     Die im folgenden beschrieben acht Variablen kînnen alle in diesem
     Sinne verwendet werden.


     @{U}58: _BILDSCHIRM_LENGTH@{u}

     Die BildschirmlÑnge wird normalerweise aus den beiden Variablen
     SCREEN_BREITE und SCREEN_HOEHE berechnet. Ist _BILDSCHIRM_LENGTH aber
     aber ungleich Null, dann bestimmt dieser Wert die BildschirmlÑnge.


     @{U}62: _ZEICHEN_LENGTH@{u}

     Die ZeichenbildschirmlÑnge berechnet sich normalerweise aus den beiden
     Variablen ZEILEN_LAENGE und BILD_HOEHE. Ist _ZEICHEN_LENGTH aber
     ungleich Null, dann bestimmt dieser Wert die ZeichenbildschirmlÑnge.


     @{U}66: _MAUS_LENGTH@{u}

     Die MauspufferlÑnge berechnet sich normalerweise als PLANES*64. Ist
     _MAUS_LENGTH aber ungleich Null, dann bestimmt dieser Wert die Puffer-
     lÑnge.


     Auf einem TT bieten sich fÅr die obigen drei Variablen die Werte
     153600,19200 und 512 an. Sie kînnen dann eine beliebige Auflîsung wÑh-
     len, ohne Angst haben zu mÅssen, die reservierten Speicherbereiche
     seien zu klein (auf einem ST reichen 32000, 4000, 256, auf einem F030
     307200, 4800, 512 ohne Screenblaster).
     Eine andere Mîglichkeit ist, dass PBUGCONF einen neuen Screen instal-
     liert, was jedoch den Nachteil hat, dass die drei Speicherbereiche bei
     jedem Auflîsungswechsel verloren gehen.


     @{U}86: _OFFSET_X@{u}

     Bei Aufruf von GET_PARAMETER wird OFFSET_X auf einen Defaultwert von
     Null gesetzt, es sei denn _OFFSET_X enthalte einen von Null verschie-
     denen Wert. In diesem Fall wird dieser nach OFFSET_X kopiert.
     Zusammen mit den folgenden 3 Variablen kann der vom Debugger benutzte
     Bildausschnitt auf einen Teil des gesamten Bildschirms beschrÑnkt wer-
     den, was mitunter auf Grossbildschirmen sinnvoll sein kann.


     @{U}88: _OFFSET_Y@{u}

     Bei Aufruf von GET_PARAMETER wird OFFSET_Y auf einen Defaultwert von
     Null gesetzt, es sei denn _OFFSET_Y enthalte einen von Null verschie-
     denen Wert. In diesem Fall wird dieser nach OFFSET_Y kopiert.


     @{U}90: _BILD_BREITE@{u}

     Bei Aufruf von GET_PARAMETER wird BILD_BREITE auf einen Defaultwert
     von Null gesetzt, ausser _BILD_BREITE enthalte einen von Null ver-
     schiedenen Wert. In diesem Fall wird dieser nach BILD_BREITE kopiert.


     @{U}92: _BILD_HOEHE@{u}
     Bei Aufruf von GET_PARAMETER wird BILD_HOEHE auf einen Defaultwert von
     Null gesetzt, es sei denn _BILD_HOEHE enthalte einen von Null ver-
     schiedenen Wert. In diesem Fall wird dieser nach BILD_HOEHE kopiert.


     @{U}94: _PLANES@{u}

     Bei Aufruf von GET_PARAMETER wird PLANES auf einen Defaultwert von
     Null gesetzt, es sei denn _PLANES enthalte einen von Null ver-
     schiedenen Wert. In diesem Fall wird dieser nach PLANES kopiert.
@endnode

@pnode %SCREEN_LOCK
Ein Programm, das auf eine Variable oder eine Rou-
tine zugreift, die Status l hat, muss diese Sema-
phore testen. Ist sie gesetzt (!=0), darf weder
eine Routine aufgerufen noch eine Variable verÑn-
dert werden. Beispielsweise setzt WINDOW.ACC diese
Semaphore, falls der Screen in das Fenster umge-
lenkt wird. Da es sich hier um eine Bytevariable
handelt, wÅrde sich die Verwendung von TAS em-
pfehlen. Da es scheinbar einen Hardwarebeschleuni-
ger gibt, der diesen Befehl falsch ausfÅhrt, ver-
zichte ich auf den Gebrauch von TAS.
@endnode

@pnode %SWITCH_PALETTE
Nur wenn diese Variable einen von
Null verschiedenen Wert hat, wird
die eigene Farbpalette beim Ein-
sprung in den Debugger gesetzt und
beim Verlassen wieder restauriert.
@endnode

@pnode %OWN_PALETTE
Diese 256 Worte enthalten die Farbpalette,
wobei beim ST nur die untersten 16 Worte
benutzt werden. Die Palette ist default-
mÑssig so gesetzt, dass es auf allen Auf-
lîsungen das gleiche ergibt (ST-High auf
einem TT ist allerdings invers). Auf einem
F030  wird eine andere Palette benutzt, so
dass diese Werte keinen Einfluss haben.
@endnode

@pnode %SWITCH_REGISTER
Nur wenn diese Variable einen von Null verschie-
denen Wert hat, werden die Videoregister beim
Einsprung in den Debugger gesetzt und beim Ver-
lassen wieder restauriert. Davon ausgenommen
sind die Videobasisregister (Bildschirmadresse)
und die Farbpalettenregister. Wenn sie wissen,
dass der Debugger auf der gleichen Auflîsung
lÑuft, wie der Rest des Systems, dann kînnen Sie
diese Variable auf Null setzen. Das verhindert
z.B. auf dem F030 das unangenehme Flimmern beim
Bildschirmumschalten.
@endnode

@node Userroutinen
@toc Inhaltsverzeichnis
@prev %SCREEN_PARAMETER
     @{U}10.3  Userroutinen@{u}


     @{U}Allgemeines@{u}

     Beim Einspringen in den Debugger und beim Verlassen, sowie nach einem
     Reset und einem Trace ruft PEACEBUG sechs verschiedene Routinen auf.
     Diese Routinen kînnen von Ihnen mit beliebigen Funktionen versehen
     werden. Sie haben so die Mîglichkeit, den Debugger an Gegebenheiten
     anzupassen, auf die er nicht vorbereitet ist. Z.B. kînnen Sie beim
     Einspringen und Verlassen zusÑtzliche Videoregister setzen bzw.
     restaurieren.


     @{U}Die Routinen@{u}

     - USERTRACE: Diese Routine ist zum Testen von Abbruchbedingungen beim
       Tracen.
     - USERENTER: Wird kurz nach dem Aufruf des Debuggers aufgerufen.
     - USERQUIT: Wird kurz vor dem Verlassen des Debuggers aufgerufen.
     - USERSWITCH_ENTER: Wird vor dem Umschalten auf den Debuggerscreen
       aufgerufen.
     - USERSWITCH_QUIT: Wird vor dem  Umschalten auf den Programmscreen
       aufgerufen.
     - USERRESET: Wird nach einem Reset aufgerufen.


     @{U}Aufbau der Routinen@{u}

     Vor der eigentlichen Routine sollten Sie folgende Stuktur anlegen:

     @{B}in C:@{b}
     typedef struct
     {
             int null;           /* Dummywert */
             char *us_message;   /* Zeiger auf Einsprungmessage */
             char xb_magic[4];   /* "XBRA" */
@autorefoff
             char xb_id[4];      /* XBRA-ID */
             long xb_oldvec;     /* Wert des Vektors vor dem einhÑngen */
     } USER;

     @{B}in Assembler:@{b}
                  dc.l MESSAGE
                  dc.l 'XBRA'
                  dc.l 'PBUG'
     OLD_ROUTINE: dc.l $xxxxxxxx
     ROUTINE: ...

     Diese Struktur kann weggelassen werden, vorausgesetzt Sie hÑngen Ihre
     Routinen selber ein. Lassen Sie dies durch PBUGCONF erledigen, dann
     muss diese Struktur vor der Routine stehen. Bei USERTRACE muss diese
     Struktur immer vorhanden sein.
     Sie dÅrfen Ihre Routinen auch aus-, vor-, umhÑngen. Verboten ist es,
     die Position des ersten Eintrags zu Ñndern. Es handelt sich dabei um
     den Eintrag des Debuggers, den Sie an der Kennung 'PBUG' erkennen.
     Sie sollten ihre Routine Åbrigens nicht mit rts beenden, sondern zur
     nÑchsten Routine springen, dies natÅrlich nur wo es sinnvoll ist (bei
     USERTRACE ist es dies nicht).
     ACHTUNG: Der Stackpointer enthÑlt natÅrlich zusÑtzlich eine RÅck-
     sprungadresse, denn Ihre Routine wird Åber ein jsr aufgerufen. Wenn
     Sie in Ihrer Routine also auf den PC und/oder das SR zugreifen wollen,
     mÅssen Sie das berÅcksichtigen (PC liegt bei 6(sp), SR bei 4(sp)).
@autorefon
@endnode

@node %USERTRACE "Userroutine: USERTRACE"
@symbol ar USERTRACE
@toc Userroutinen
     @{U}10.3.1  USERTRACE@{u}


     @{U}Allgemeines@{u}

     USERTRACE ist eine Routine, die vom Debugger dann aufgerufen wird,
     wenn Sie mittels trace [+/-/*] tracen. Mit ihr kînnen Sie nach jedem
     Befehl bestimmte Bedingungen testen und je nach Ergebnis, die Trace-
     routine veranlassen, weiterzutracen, weiterzufahren ohne Trace oder
     abzubrechen und den Debugger aufzurufen.
     Beispielsweise kînnen Sie so testen, wann ein Programm eine bestimmte
     Speicherstelle Ñndert.


     @{U}Aufruf@{u}

     USERTRACE wird mit unverÑnderten Registern angesprungen, also wie sie
     vor dem Aufrufen der Traceroutine sind. Es dÅrfen deshalb keine Re-
     gister verÑndert werden. Auch der PC und das Statusregister sind Åber
     den Stack zugÑnglich (bzw. ein Stackframe). Aufgerufen wird die Rou-
     tine wie folgt:
     > jsr USERTRACE
     > bmi.s Weiter_mit_Trace
     > bgt.s Weiter_ohne_Trace
     > beq.s Abbrechen_&_in_den_Debugger_springen
     Der Tracehandler wird also Åber das Statusregister gesteuert und kann
     dazu bewegt werden, entweder das Programm mit/ohne Trace fortzusetzen
     oder in den Debugger zu springen.


     @{U}Beispiele@{u}

     GrundsÑtzlich gibt es zwei Mîglichkeiten, wie ein solches Programm
     aussehen kann:

     1. cmp.l #1,d7                    ; Abbruchbedingung: d7.l=1
        sne  -(sp)
        tst.b (sp)+
        rts

     2. move.l a0,-(sp)                ; Abbruchbedingung: Opcode="trap #1"
        move.l 10(sp),a0               ; PC holen
        cmp.w  #$4e41,(a0)             ; "trap #1" als Opcode?
        sne    flag
        move.l (sp)+,d0
        tst.b  flag
        rts

     Die erste Mîglichkeit wird benutzt, wenn keine Register verÑndert wer-
     den, die zweite wenn das testen der Bedingung das Benutzen von Regi-
     stern bedingt. Auf dem Stack befinden sich das SR 4(sp), der PC 6(sp)
     und gegebenenfalls der Rest des Stackframes ab 10(sp).


     @{U}Tip@{u}

     Es ist sinnvoll, nach dem Installieren der Usertraceroutine entweder
     den @{"Debugger aufzurufen" link Debuggeraufruf}, damit der Tracemodus angeschaltet werden
     kann (mit dem Befehl TRACE + - *) oder Åber eine der drei Routinen
     TRACE_WITHOUT, TRACE_WITH und TRACE_ALWAYS dieses zu erledigen.
@endnode

@node %USERENTER "Userroutinen: USERENTER & USERQUIT"
@symbol ar USERENTER USERQUIT
@toc Userroutinen
     @{U}10.3.2  USERENTER & USERQUIT@{u}


     @{U}USERENTER@{u}

     Wird Åber ein jsr angesprungen noch bevor der Debugger irgendwas
     macht. Alle Register sind noch Original, auf dem Stack befinden sich
     SR 4(sp), PC 6(sp) und gegebenenfalls ein Stackframe  ab 10(sp). Wenn
     Sie das Statusregister testen wollen, benutzen Sie den Wert auf dem
     Stack, das aktuelle SR kann vom Debugger schon verÑndert worden sein.


     @{U}USERQUIT@{u}

     Wird Åber ein jsr angesprungen kurz bevor der Debugger endgÅltig ver-
     lassen wird (es wird dann noch die Traceroutine angesprungen, das
     Tracen kînnen Sie Åber diese Routinen also nicht beeinflussen). Alle
     Register sind schon Original, auf dem Stack befinden sich SR 4(sp),
     PC 6(sp) und gegebenenfalls ein Stackframe ab 10(sp).
@endnode

@node %USERSWITCH "Userroutinen: USERSWITCH_ENTER & USERSWITCH_QUIT"
@symbol ar USERSWITCH_ENTER USERSWITCH_QUIT
@toc Userroutinen
     @{U}10.3.3  USERSWITCH_ENTER & USERSWITCH_QUIT@{u}


     @{U}USERSWITCH_ENTER@{u}

     Wird aufgerufen, bevor auf den Debuggerbildschirm umgeschaltet wird.
     Diese Routine kann z.B. dazu dienen, Grafikkarten neu zu initiali-
     sieren oder die Auflîsung umzuschalten.


     @{U}USERSWITCH_QUIT@{u}

     Wird aufgerufen, bevor auf den Programmbildschirm umgeschaltet wird.
     Diese Routine kann z.B. dazu dienen, Grafikkarten neu zu initiali-
     sieren oder die Auflîsung umzuschalten.


     @{U}Tip@{u}

     Wenn Sie das Setzen der Videoregister beim Umschalten des Bildschirms
     unterbinden (siehe Kapitel "SCREEN_PARAMETER"), dann kînnen Sie das
     Umschalten Åber diese beiden Routinen auch vollstÑndig selber Åber-
     nehmen.
@endnode

@node %USERRESET "Userroutine: USERRESET"
@symbol ar USERRESET
@toc Userroutinen
     @{U}10.3.4  USERRESET@{u}


     Diese Routine wird bei einem Reset angesprungen und kann benutzt
     werden um gegebenenfalls zusÑtzliche Hardware zu initalisieren. Vom
     Debugger wird nach einem Reset nur die rechnereigene Hardware wie MFP,
     Soundchip, Acia's etc. initialisiert.
@endnode

@node "Debuggeraufruf" "Debuggeraufruf: CALL_DEBUGGER_1 & CALL_DEBUGGER_2"
@symbol ar CALL_DEBUGGER_1 CALL_DEBUGGER_2
@toc Inhaltsverzeichnis
     @{U}10.4  Debuggeraufruf@{u}


     @{U}Allgemeines@{u}

     Der Debugger kann Åber zwei Routinen aufgerufen werden, die Åber die
     Schnittstelle zugÑnglich sind. Deren Aufruf ist identisch. Auf dem
     Stack mÅssen sich 6 Bytes befinden, die vom Debugger ausgewertet und
     entfernt werden, d.h.  eine Stackkorrektur ist nicht nîtig:
       0(sp).w: SR (Statusregister)
       2(sp).l: PC (Programmcounter)
     Vor der aufgerufenen Routine befindet sich ein Zeiger auf die Meldung,
     die beim Einsprung ausgegeben wird. Diesen Zeiger dÅrfen Sie auf einen
     eigenen nullterminierten String setzen. Er muss aber vor jedem Ein-
     sprung neu gesetzt werden, sie kînnen also nicht davon ausgehen, dass
     der Zeiger in der Zwischenzeit unverÑndert geblieben ist. Der Ein-
     sprung darf nur im Supervisormodus erfolgen, z.B. so:

     > move.l   #message,-4(a0)         ; optionale Einsprungsmeldung
     > move.l   saved_pc,-(sp)          ; PC auf den Stack
     > move.w   saved_sr,-(sp)          ; SR auf den Stack
     > jmp      (a0)                    ; Debugger anspringen


     @{U}CALL_DEBUGGER_1@{u}

     Es werden grundsÑtzlich alle Register gerettet mit Ausnahme der Stack-
     pointer USP, ISP und MSP. Diese werden auf Debuggerinterne Bereiche
     gesetzt. Das ist sinnvoll, wenn sie Programm debuggen wollen, die den
     Stack durcheinanderbringen kînnen. Sie brauchen sich dann nicht selber
     um ausreichend dimensionierte Stacks zu kÅmmern.
     ACHTUNG: Nach einem solchen Aufruf kînnen Sie kein rts mehr ausfÅhren,
     d.h. Sie mÅssen entweder einen neuen Stackpointer installieren, die
     Stackpointer vor dem Aufruf retten oder nach dem Aufruf ihr Programm
     beenden.
     Um alle Klarheiten zu beseitigen: Der Debugger benutzt intern einen
     eigenen Stack, darÅberhinaus hat er einen separaten Stack fÅr OS
     Aufrufe, einen separaten Stack fÅr die Resetroutine, einen separaten
     Stack fÅr die Installation und drei Stacks fÅr das zu tracende Pro-
     gramm. Diese drei werden bei einem LEXECUTE und beim Einsprung Åber
     CALL_DEBUGGER_1 benutzt.


     @{U}CALL_DEBUGGER_2@{u}

     Es werden alle Register gerettet, so wie sie bei Aufruf der Routine
     vorgefunden werden. Benutzen Sie diese Routine, wenn Sie:
     - Ihr Programm nach dem Aufruf nicht terminieren wollen/kînnen.
     - Wenn der Debugger keine Register verÑndern darf.
     - Wenn Sie den Debugger aus einer Exception oder einem Interrupt auf-
       rufen.
@endnode

@node Vektorkonfiguration
@toc Inhaltsverzeichnis
@symbol ar FLAGS
     @{U}10.5  Vektorkonfiguration@{u}


     @{U}Allgemeines@{u}

     Der Åber die @{Cookieschnittstelle link Cookieeintrag} zugÑngliche Zeiger FLAGS zeigt auf
     eine Struktur, Åber die das Verhalten der 48 Routinen, die PEACEBUG in
     @{Vektoren ignore} einhÑngen kann, und dasjenige der Routine @{VEKTOR link %VEKTOR} gesteuert
     werden kann. Allen 48 Routinen ist ein Wort zugeordnet. Detailierte
     Informationen diesbezÅglich finden Sie in den Kapitel "Vektoren" und
     "Ein Wort regelt alles", in denen die Kodierung dieses Wortes be-
     schrieben ist. Die Worte haben alle den Status r/w/p.


     @{U}FLAGS@{u}

     byte BU_FLAG[2]     Offset 0      $8    Buserror
     byte AD_FLAG[2]     Offset 2      $C    Adress_error
     byte IL_FLAG[2]     Offset 4      $10   Illegal
     byte DI_FLAG[2]     Offset 6      $14   Division
     byte CH_FLAG[2]     Offset 8      $18   Chk
     byte TV_FLAG[2]     Offset 10     $1C   cpTrapv/cc
     byte PR_FLAG[2]     Offset 12     $20   Privileg
     byte TR_FLAG[2]     Offset 14     $24   Trace
     byte LA_FLAG[2]     Offset 16     $28   Linea
     byte LF_FLAG[2]     Offset 18     $2C   Linef
     byte CP_FLAG[2]     Offset 20     $34   Coproc. Protocol Violation
     byte FO_FLAG[2]     Offset 22     $38   Format Error
     byte IN_FLAG[2]     Offset 24     $3C   Uninitialized Interrupt
     byte SI_FLAG[2]     Offset 26     $60   Spurious
     byte VB_FLAG[2]     Offset 28     $70   VBL
     byte NM_FLAG[2]     Offset 30     $7C   NMI
     byte T0_FLAG[2]     Offset 32     $80   Trap 0
     byte GE_FLAG[2]     Offset 34     $84   GEMDOS
     byte VD_FLAG[2]     Offset 36     $88   VDI
     byte AE_FLAG[2]     Offset 38     $88   AES
     byte T3_FLAG[2]     Offset 40     $8C   Trap 3
     byte T4_FLAG[2]     Offset 42     $90   Trap 4
     byte T5_FLAG[2]     Offset 44     $94   Trap 5
     byte T6_FLAG[2]     Offset 46     $98   Trap 6
     byte T7_FLAG[2]     Offset 48     $9C   Trap 7
     byte T8_FLAG[2]     Offset 50     $A0   Trap 8
     byte T9_FLAG[2]     Offset 52     $A4   Trap 9
     byte TA_FLAG[2]     Offset 54     $A8   Trap 10
     byte TB_FLAG[2]     Offset 56     $AC   Trap 11
     byte TC_FLAG[2]     Offset 58     $B0   Trap 12
     byte BI_FLAG[2]     Offset 60     $B4   BIOS
     byte XB_FLAG[2]     Offset 62     $B8   XBIOS
     byte TF_FLAG[2]     Offset 64     $BC   Trap 15
     byte C1_FLAG[2]     Offset 66     $C0   FPU Branch or Set on Un. Cond.
     byte C2_FLAG[2]     Offset 68     $C4   FPU Inexact result
     byte C3_FLAG[2]     Offset 70     $C8   FPU Divide by Zero
     byte C4_FLAG[2]     Offset 72     $CC   FPU Underflow
     byte C5_FLAG[2]     Offset 74     $D0   FPU Operand Error
     byte C6_FLAG[2]     Offset 76     $D4   FPU Overflow
     byte C7_FLAG[2]     Offset 78     $D8   FPU Signaling NAN
     byte PC_FLAG[2]     Offset 80     $E0   PMMU Configuration
     byte PI_FLAG[2]     Offset 82     $E4   PMMU Illegal
     byte PA_FLAG[2]     Offset 84     $E8   PMMU Access Level
     byte HZ_FLAG[2]     Offset 86     $114  200HZ Timer
     byte KB_FLAG[2]     Offset 88     $118  Keyboard
     byte RI_FLAG[2]     Offset 90     $138  Ring Indicator
     byte ET_FLAG[2]     Offset 92     $404  ETV_CRITIC
     byte RE_FLAG[2]     Offset 94     $42A  RESET
@endnode

@node "Diverse Parameter"
@symbol ar PARAMETER
@toc Inhaltsverzeichnis
@next "Diverse Parameter"
     @{U}10.6  Diverse Parameter@{u}


     PARAMETER ist ein Zeiger auf die im folgenden beschriebenen Variablen:

     byte @{KEY_CODE_1 link %keyboard}              Offset 0       r/w/p         @{Keyboard link %keyboard}
     byte @{SWITCH_CODE_1 link %keyboard}           Offset 1       r/w/p             "
     byte @{KEY_CODE_2 link %keyboard}              Offset 2       r/w/p             "
     byte @{SWITCH_CODE_2 link %keyboard}           Offset 3       r/w/p             "
     byte reserved[8]
     word @{"MAUS_PARAMETER s^1" link %accelerator}      Offset 12      r/w/p     @{Mausbeschleuniger link %accelerator}
     word @{"MAUS_PARAMETER s^2" link %accelerator}      Offset 14      r/w/p             "
     word @{"MAUS_PARAMETER s^3" link %accelerator}      Offset 16      r/w/p             "
     word @{"MAUS_PARAMETER s^4" link %accelerator}      Offset 18      r/w/p             "
     word @{"MAUS_PARAMETER s^5" link %accelerator}      Offset 20      r/w/p             "
     word @{"MAUS_PARAMETER s^6" link %accelerator}      Offset 22      r/w/p             "
     word @{ZAHLEN_BASIS link %zahlenbasis}            Offset 24      r/w/p
     word @{"PRIORITAETEN +" link %priority}          Offset 26      r/w/p        @{PrioritÑten link %priority}
     word @{"PRIORITAETEN -" link %priority}          Offset 28      r/w/p             "
     word @{"PRIORITAETEN *" link %priority}          Offset 30      r/w/p             "
     word @{"PRIORITAETEN /" link %priority}          Offset 32      r/w/p             "
     word @{"PRIORITAETEN |" link %priority}          Offset 34      r/w/p             "
     word @{"PRIORITAETEN &" link %priority}          Offset 36      r/w/p             "
     word @{"PRIORITAETEN ^" link %priority}          Offset 38      r/w/p             "
     word @{"PRIORITAETEN <" link %priority}          Offset 40      r/w/p             "
     word @{"PRIORITAETEN ~" link %priority}          Offset 42      r/w/p             "
     word @{"PRIORITAETEN -" link %priority}          Offset 44      r/w/p             "
     word @{"PRIORITAETEN %" link %priority}          Offset 46      r/w/p             "
     word @{"PRIORITAETEN p" link %priority}          Offset 48      r/w/p             "
     word @{"PRIORITAETEN (" link %priority}          Offset 50      r/w/p             "
     word reserved[5]
     long @{KEY_REPEAT link %krepeat}              Offset 62      r/w/p
     long @{KEY_DELAY link %kdelay}               Offset 66      r/w/p
     long @{MOUSE_REPEAT link %mrepeat}            Offset 70      r/w/p
     long @{MOUSE_DELAY link %mdelay}             Offset 74      r/w/p
     long @{DOPPEL_KLICK link %mdouble}            Offset 78      r/w/p
     long @{PRINTER_TIMEOUT link %parallel}         Offset 82      r/w/p
     long @{RS232_TIMEOUT link %rs232}           Offset 86      r/w/p
     long @{MIDI_TIMEOUT link %midi}            Offset 90      r/w/p
     long reserved[6]
     void @{*NEW_HISTORY link %history}            Offset 118     r              @{History link %history}
     void @{*HISTORY_POINTER link %history}        Offset 122     r                 "
     long @{HISTORY_LENGTH link %history}          Offset 126     r/p               "
     long reserved[2]                                              "
     void @{*CACHE_INIT link %cache}             Offset 138     r               @{Cache link %cache}
     word @{CACHE_LENGTH link %cache}            Offset 142     r                 "
     long reserved
     word @{CACHE_LAENGE_1 link %cache}          Offset 148     r/p               "
     long reserved
     word @{CACHE_LAENGE_2 link %cache}          Offset 154     r/p               "
     byte @{INSERT_FLAG link %insert}             Offset 156     r/w/p
     byte unused
     byte @{SYMBOL_FLAG link %symbol}             Offset 158     r/w/p
@endnode

@node %keyboard "Diverse Parameter: Tastaturaufruf"
@next "Diverse Parameter"
@prev "Diverse Parameter"
@toc "Diverse Parameter"
     @{U}Allgemeines@{u}

     Die vier Variablen KEY_CODE_1, KEY_CODE_2, SWITCH_CODE_1 und
     SWITCH_CODE_2 bestimmen, Åber welche Tastenkombinationen der Debugger
     aufgerufen werden kann.


     @{U}KEY_CODE_1 & SWITCH_CODE_1@{u}

     Der Debugger wird aufgerufen, wenn die Taste mit dem Scancode
     KEY_CODE_1 gedrÅckt wird und wenn die Umschalttasten gemÑss
     SWITCH_CODE_1 gedrÅckt gehalten werden.
     ZusÑtzliche Bedingung fÅr den Aufruf ist, dass flock $43e nicht ge-
     setzt ist, da dann Diskoperationen stattfinden, die nicht gestîrt
     werden wollen,


     @{U}KEY_CODE_2 & SWITCH_CODE_2@{u}

     Der Debugger wird aufgerufen, wenn die Taste mit dem Scancode
     KEY_CODE_2 gedrÅckt wird und wenn die Umschalttasten gemÑss
     SWITCH_CODE_2 gedrÅckt gehalten werden.
     Dies funktioniert auch bei gesetzter flock Semaphore, mit dem Risiko,
     dass wichtige Diskoperationen Fehler produzieren.


     @{U}Scancode@{u}

     Wenn dieser auf Null gesetzt ist, dann werden nur die Umschalttasten
     geprÅft, d.h. Sie kînnen den Debugger dann z.B. Åber die Alternate-
     taste aufrufen. Ist hingegen das oberste Bit gesetzt, dann wird erst
     beim Loslassen der Taste eingesprungen.


     @{U}Umschalttasten@{u}

     Die Kodierung der Umschaltasten ist fast gleich wie bei KBSHIFT:
       Bit 0: Shift-Taste rechts
       Bit 1: Shift-Taste links
       Bit 2: Control-Taste
       Bit 3: Alternate-Taste
       Bit 5: Rechte Maustaste
       Bit 6: Linke Maustaste
     CapsLock wird absichtlich ausmaskiert, deren Status spielt also keine
     Rolle.


     @{U}Shift-Shift@{u}

     Ein mittels LEXECUTE geladenes Programm kînnen Sie mit Shift-Shift
     unterbrechen. Dies hat gegenÅber dem Aufruf Åber die in obigen Vari-
     ablen kodierte Tastenkombination den Vorteil, dass immer innerhalb
     des Programmcodes unterbrochen wird und nicht in irgendwelchen un-
     interessanten OS Routinen. Shift-Shift wird vom VBL Handler ÅberprÅft.
@endnode

@pnode %accelerator
PEACEBUG hat einen im Maustreiber integrierten
Mausbeschleuniger. Dieser berechnet die Geschwin-
digkeit der Maus auf dem Bildschirm als Funktion
der Geschwindigkeit der Maus auf dem Tisch. Diese
Funktion ist ein Polynom 6. Grades, dessen Koef-
fizienten die Variablen MAUS_PARAMETER s^1-6 sind.
Die Koeffizienten kînnen in Schritten von 1/128tel
verÑndert werden. Eine unbeschleunige Maus erhal-
ten Sie durch die Koeffizienten (128,0,0,0,0,0).
@endnode

@pnode %zahlenbasis
ZAHLEN_BASIS gibt an, welche Zahlenbasis defaultmÑssig
verwendet wird, d.h. ohne Verwendung eines Prefix.
Normalerweise wird 16 als Zahlenbasis benutzt. öber
diese Variable kînnen Sie jede andere Zahlenbasis im
Bereich von 2-36 wÑhlen (im 36er System benutzen Sie
die Ziffern 0-9 und die Buchstaben A-Z). Die Åblichen
Zahlenbasen kînnen Sie unabhÑngig von diesem Wert Åber
einen Prefix benutzen (%=BinÑr, o=Oktal, .=Dezimal und
$=Hexadezimal oder Sedezimal).
@endnode

@pnode %priority
Diese 13 Worte werden vom Formelinterpreter benutzt. Sie
geben an, wie stark der nachfolgende Ausdruck an einen
Operator gebunden wird. Beispielsweise bindet die Addition
weniger stark als die Multiplikation, was auch sinnvoll
ist, da normalerweise Punkt vor Strichrechnung gilt. Ein-
parametrige Operatoren (Vorzeichen, Pointer) binden
natÅrlich stÑrker als zweiparametrige. Sinnvoll erscheint
mir eine VerÑnderung der vorgegebenen Werte nur beim Oper-
ator p (Pointer). Wenn Sie dessen PrioritÑt auf z.B. 2
hinuntersetzen, werden AusdrÅcke wie "p ^a0-4" ausgewertet,
wie wenn Sie bei defaultmÑssigen Einstellungen "p(^a0-4)"
eingeben, d.h. das Minus bindet dann stÑrker als das p.
@endnode

@pnode %krepeat
Tastaturrepeat in
1/200tel Sekunden.
@endnode

@pnode %kdelay
Tastaturverzîgerung in
1/200tel Sekunden. Dies
ist die Zeit, die nach
dem ersten Tastendruck
gewartet wird, bis der
Tastaturrepeat einsetzt.
@endnode

@pnode %mrepeat
Mausklickrepeat in
1/200tel Sekunden.
@endnode

@pnode %mdelay
Mausklickverzîgerung in
1/200tel Sekunden. Dies
ist die Zeit, die nach
dem ersten Mausklick
gewartet wird, bis der
Mausklickrepeat einsetzt.
@endnode

@pnode %mdouble
Zeit, die zwischen zwei
Mausklicks verstreichen
darf, so dass sie noch
als Doppelklick erkannt
werden.
@endnode

@pnode %parallel
Zeit in 1/200tel Sekunden,
bis ein Timeout an der
Centronics Schnittstelle
gemeldet wird.
@endnode

@pnode %rs232
Zeit in 1/200tel Sekunden,
bis ein Timeout an der
RS232 Schnittstelle ge-
meldet wird.
@endnode

@pnode %midi
Zeit in 1/200tel Sekunden,
bis ein Timeout an der MIDI
Schnittstelle gemeldet wird.
@endnode

@node %history
@next "Diverse Parameter"
@prev "Diverse Parameter"
@toc "Diverse Parameter"
     @{U}NEW_HISTORY@{u}

     Diese Routine muss aufgerufen werden, wenn Sie den Historypuffer ver-
     grîssern wollen. Dieser wird dynamisch verwaltet, so dass die Anzahl
     verfÅgbarer EintrÑge von der verwendeten ZeilenlÑnge abhÑngt. Auf dem
     Stack Åbergeben Sie die neue HistorylÑnge in Bytes. Ist der RÅckgabe-
     wert Null, dann ist beim Reservieren ein Fehler aufgetreten.
     Beispiel:
     > pea  8000.w               ; 8000 Bytes reservieren
     > jsr  (a0)                 ; Routine anspringen
     > tst.l (sp)+               ; Fehler aufgetreten?
     > beq.s  error


     @{U}HISTORY_POINTER@{u}

     Dies ist der Zeiger auf den reservierten Speicherbereich.


     @{U}HISTORY_LENGTH@{u}

     Dieser Wert gibt die aktuelle HistorylÑnge in Bytes an. Er darf nicht
     geschrieben werden, dies tut die Routine NEW_HISTORY. Der Wert im Pro-
     grammcode gibt darÅberhinaus an, wie gross der Historypuffer bei
     Programmmstart sein soll.
@endnode

@node %cache
@next "Diverse Parameter"
@prev "Diverse Parameter"
@toc "Diverse Parameter"
     @{U}CACHE_INIT@{u}

     Diese Routine dient dazu, die beiden Caches zu erweitern oder zu ver-
     kleiner (ob letzteres sinnvoll ist, sei dahingestellt). Da die Caches
     als Ring organisiert sind, kînnen jederzeit neue EintrÑge hinzugefÅgt
     werden, ohne dass gleich der ganze Cache neu reserviert werden muss,
@autorefoff
     wie das beim Historypuffer der Fall ist. Auf dem Stack werden fÅr
     jeden Cache die gewÅnschten neuen LÑngen Åbergeben, die Routine er-
     kennt selbstÑndig ob EintrÑge gelîscht oder neu reserviert werden
     mÅssen. Ist der RÅckgabewert Null, dann ist beim Reservieren ein Feh-
     ler aufgetreten.
     Beispiel:
     > move.w #50,-(sp)          ; 50 EintrÑge fÅr Cache 1
     > move.w #30,-(sp)          ; 30 EintrÑge fÅr Cache 2
     > jsr    (a0)               ; Routine anspringen
     > tst.l (sp)+               ; Fehler aufgetreten?
     > beq.s error


     @{U}CACHE_LENGTH@{u}

     Dieser Wert gibt die LÑnge eines einzelnen Cacheeintrags an (momentan
     270 Bytes). Sie kînnen so abschÑtzen, wieviel Speicher Sie fÅr eine
     bestimmte Anzahl EintrÑge opfern mÅssen.


     @{U}CACHE_LAENGE_1 & CACHE_LAENGE_2@{u}

     Diese beiden Werte geben an, wieviele EintrÑge die jeweiligen Caches
     umfassen. Beide dÅrfen nur gelesen, aber nicht geschrieben werden,
     dies tut die Routine CACHE_INIT. Die Werte im Programmcode geben da-
     rÅberhinaus an, wieviele EintrÑge bei Programmstart reserviert werden.
@autorefon
@endnode

@pnode %insert
-1: EinfÅgemodus.
 0: öberschreibmodus.
@endnode

@pnode %symbol
PEACEBUG benutzt diverse Symbol-
tabellen beim Disassemblieren
und im Formelinterpreter:
  -1: Alle Symboltabellen.
   0: Keine Symboltabellen.
   1: Die debuggereigenen
      Symboltabllen ohne
      diejenigen des RSD.
Bei installiertem RSD wird im
Listmodus der Programmname dem
Disassembly vorangestellt, wenn
SYMBOL_FLAG ungleich Null ist.
@endnode

@remark ********************************************************
@remark * Diese Seite wird bei DrÅcken der Help-Taste gezeigt. *
@remark ********************************************************

@node %PEACEBUG Hilfeseite
@toc Inhaltsverzeichnis
@next Inhaltsverzeichnis
@prev Inhaltsverzeichnis
     Dieser Hypertext beschreibt die Funktionen und die Bedienung von
     PEACEBUG, einem Low Level Debugger fÅr alle Atari Computer.

     Dieses Dokument ist so geschrieben, dass Sie es auf zweierlei Arten
     lesen kînnen, je nachdem welche Art Ihnen eher zusagt:
     1. Als Hypertext, d.h. Sie verzweigen Åber die Links auf die Sie
        interessierenden Seiten.
     2. Als normales Manual, d.h. Sie lesen Seite fÅr Seite.

     NÑhere Informationen finden Sie Åber das Inhaltsverzeichnis.
@endnode

@remark ***************************
@remark * Hier folgen alle pnodes *
@remark ***************************

@pnode ST-GUIDE
ST-GUIDE ist Fairware und
wurde von Holger Weets ge-
schrieben. Vielen Dank und
GrÅsse aus der Schweiz nach
Oldenburg.
@endnode

@pnode %VEKTOR
Dies ist die berÅchtige Routine, die zu-
stÑndig ist fÅr das ein-, aus-, um- und
vorhÑngen der 48 Exceptionroutinen, die
PEACEBUG zur VerfÅgung stellt. Sie wird
bei jedem Einsprung und vor dem Aufrufen
einer Funktion Åber Return bzw. Åber
eine Funktionstaste ausgefÅhrt.
@endnode

@pnode %VERSION
Versionsnummer des Debuggers.
Ist als Asciistring codiert,
also z.B. "0104" fÅr V1.04.
@endnode

@pnode %TSR
TSR = @{B}T@{b}erminate and @{B}S@{b}tay @{B}R@{b}esident.
TSR's sind Programme, die sich  beenden,
aber resident bleiben, wie z.B. Spooler,
Mausbeschleuniger und last but not least
Debugger.
@endnode
