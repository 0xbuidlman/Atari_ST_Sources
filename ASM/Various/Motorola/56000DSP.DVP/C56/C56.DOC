c56:    

    Dave Dunfield's Micro C compiler (mc121a.zip) modified by Steve
Moshier to generate DSP56000 code.


1. c56 features

    Register variables may be declared; these reference the index
    registers r2 - r5.  They should ordinarily be used as pointers.

    Registers are allocated in the sequence r2, r3, ... as
    encountered in the source code. Registers may be globally
    declared.  Locally declared registers are allocated in sequence,
    then decallocated on returning from the function.

    Stack variables and subroutine arguments work, but are not
    usually as fast as if global symbols are used.  Subroutine
    results are returned in the DSP56K "a" accumulator.  If any stack
    code is actually emitted, r6 is used as the stack pointer.

    A data type "fractional" has been added.  It replaces "char" and
    uses the multiply instruction appropriately.  Multiplication of
    "int" types is also implemented but takes longer. "char" is still
    recognized but is treated as "fractional."  All of char, int,
    unsigned, and fractional are the same size, one 24-bit location.

    The hardware do loop instruction is generated by the special
    statement hwloop(n){ } where n, an expression, is the loop count,
    and the code in curly brackets will be executed n times.  Both
    "break" and "continue" work in this context, and hwloops may be
    nested to the hardware stack limit.  A (sometimes spurious) nop
    instruction is generated as the last loop statement, to catch
    jump targets that might land on the end of the loop.

    Command line switch -s in c56 will pass C source through to the
    output as comments.

    Command line switch -l in c56 will defeat numerical evaluation of
    logical expressions.  This saves two instruction cycles per
    compare operation but means that the result of the comparison
    cannot be treated as a number equal to 1 or 0.

2.c56 problems

    Integer constants are limited to 16 bits due to the compiler
    arithmetic.  Type char is left unimplemented; it may produce 8086
    garbage if string variables or character constants are declared.
    Type char and type fractional are equivalent, as far as the
    compiler is concerned.

    All variables are put in X memory space.

    Nested multiple register indirections of the form  *( *p ), where
    p is a register pointer, sometimes do not work.  However, *( *p +
    n ), *( *p + **q ) and similar expressions *do* work.

    There is no DSP pipeline optimization except for a few simple
    combinations that have been incorporated into the peephole optimizer.


3. mc problems

    The original compiler code expects (c << 8), where c is a char,
    to produce a 16 bit result.

    It does not understand #include "filename" or #include <filename>
    but only #include filename (i.e. with no punctuation).

    Complicated expressions such as y = *a * *b + *c * *d + *e * *f
    sometimes do not work.  The compiler front end produces incorrect
    variable stacking.  At least part of the problem was traced to a
    confusion about register declarations.

    The peephole optimizer has various troubles with storing and
    recognizing wildcard patterns.

    The above problems have been addressed in the c56 version, in
    which "filename" and <filename> both refer to the current
    default directory.

    The compiler has been compiled sucessfully in MSDOS with
    Microsoft C.  It compiled on a Unix system but did not work.
    Portability problems have not been addressed.

4. c56 files

        c56.mak     MSDOS Microsoft makefile

        cc56.bat    To run the compiler and optimizer in MSDOS,
                    enter "cc56 filename" without the .c

        c56.c       front end
        c56cg.c     code generator  
        c56io.c     file i/o
        o56.c       peephole optimizer

    Note, cc56.bat invokes Microsoft's C preprocessor -- but then
    #asm, #endasm don't work.
