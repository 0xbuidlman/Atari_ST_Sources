*OPT_MAXI_VITESSE

	ifd OPT_MAXI_VITESSE
	output d:\assemble\sources.v45\unitrans\qunitran.acx
	else
	output d:\assemble\sources.v45\unitrans\unitrans.acx
	endc

OPT_GWVA_DEBUG_ERROR			; [option][root] generates an illegal when something goes wrong (for debugging purposes)
OPT_GWVA_DEBUG_PRINT_COMMENTS		; [option][root] print comments/warnings when assembling source

*OPT_GWVA_DEBUG_SEARCH_EXEC		; [option][root] is needed to do any log alert_box/logger
*OPT_GWVA_DEBUG_SEARCH_EXEC_IN_ALERT_BOX	; [option][root][LIB_HEXA][LIB_DECI][OPT_GWVA_DEBUG_SEARCH_EXEC] prints an alert box at each method distribution
*OPT_GWVA_DEBUG_SEARCH_EXEC_IN_LOGGER	; [option][root][LIB_HEXA][LIB_DECI][OPT_GWVA_DEBUG_SEARCH_EXEC] prints in log window each method distribution
*LIB_HEXA				; [none]
*LIB_DECI				; [none]

*GWVA_DEBUG_MSG_MAX_SIZE = 256		; [var] defines the debug message max length (generated by SEARCH_EXEC)
*GWVA_DEBUG_MAX_MSG_DEBUG_PENDING = 64	; [var] how many debug messages can be sent in a row


OPT_FULL_PATHNAMES
*MDL_RELOCATE_RSC

*OPT_DEBUG_IN_ACCESSORY_MODE
*OPT_DEBUG


	lea objet_application,a1

	include unitrans.def
	include visual45.s
	include unitrans.hs
	include unitrans.obj

	comment HEAD=7
	section TEXT

;---------------------------------------------------------------------------
	; Exemple de programme Visual Assembleur 4.5
	; Propri‚t‚ : marche aussi bien en accessoire qu'en programme

	; Programme de conversion de formats texte
	; V 1.0 28/02/1997
	; 26/1/98 : complŠte la table pour ISO-8801
;---------------------------------------------------------------------------

	; Les objets radio-boutons doivent ˆtre tri‚s verticalement !!!

DONT_KNOW=$FF
NB_ENTREES_TABLE=11
NB_FORMATS=4		; unix / atari / html / pc

my_inits_created:
	ifnd OPT_MAXI_VITESSE
	move #MAIN_FORM,d0
	move #TXT_WARNING_LIMI,d1
	bsr GWVA_RSC_RETURN_PTR_ON_TEXT
	bset #HIDETREE,ob_flags+1(a0)
	endc	; ifnd OPT_MAXI_VITESSE

	moveq #GWVA_PRGRET_CONSUMED,d6
	rts

my_inits_opened:
	tst GWVA_ROOT_IS_ACC_PRG
	bne.s acc_open

	moveq #GWVA_PRGRET_CONSUMED,d6
	rts

acc_open:	lea objet_fenetre_main,a0
	bsr GWVA_WIND_CREATE_OPEN_ONE_WIND

	cmp.w #GWVA_NO_ERROR_GENERIC,d7
	bne.s app_term

	moveq #GWVA_PRGRET_CONSUMED,d6
	rts

bouton_load_and_convert_clique:

	lea texte_load,a0		; 35 chars max.
	lea mask_everything,a1		; 18 caracteres max
	lea 0,a2
	bsr GWVA_FILE_SELECTOR
	tst d0
	ble .annule

	move.l a2,a0
	bra.s open_object

.annule:	moveq #GWVA_PRGRET_CONSUMED,d6
	rts

bouton_close_clique:
	lea objet_fenetre_main,a0	; ne sert … rien pour l'APP
	bsr GWVA_WIND_DELETE_ONE_WIND	; mais c'est pas grave

event_window_main_closed:
app_term:
acc_close:

	bsr GWVA_ROOT_KILL_APPLICATION
	moveq #GWVA_PRGRET_CONSUMED,d6
	rts

		*************************************

open_object:		; ici : a0 pointeur sur un pathname !

	moveq #MX_PREFTTRAM,d0
	bsr GWVA_FILE_LOAD_IN_MEM
	tst.l d0
	ble .erreur_pas_assez_memoire_pour_charger

	; le programme ...

	save.l d0/a0

	lea texte_save,a0		; 35 chars max.
	lea mask_everything,a1		; 18 caracteres max
	lea 0,a2
	bsr GWVA_FILE_SELECTOR
	tst d0
	ble .annule_save

	ifd OPT_MAXI_VITESSE
	move.l a2,pointeur_nom_fichier
	move.l #buffer_write,pointeur_buffer_write
	else
	FILE_OPEN write,(a2),d7
	tst d7
	bmi .erreur_open_file_for_writing
	endc

	graf_mouse #BUSY_BEE

	load.l d0/a0

	move.l a0,a1		; a0 = debut fichier
	add.l d0,a1			; a1 = fin fichier

	move.l a0,a4		: a4 = ptr dans m‚moire

.pas_rendu_a_la_fin_fichier:

	lea table_comparaisons,a2	; ptr ptr string src
	move struct_radio_src+GWVA_FRADIO_OBJ_SELECTION,d0
	sub #RDIO_SRC_UNIX,d0
	mulu #4,d0
	add.l d0,a2			; a2 = ptr sur ptr 1Šre chaine cmp

	lea table_comparaisons,a3	; ptr ptr string dest
	move struct_radio_dest+GWVA_FRADIO_OBJ_SELECTION,d0
	sub #RDIO_DEST_UNIX,d0
	mulu #4,d0
	add.l d0,a3			; a3 = ptr sur ptr 2Šme chaine cmp

	clr d1			; compteur du NB comparaisons
.scan_all_entries:

	move.l (a2),a5		; a5 = ptr chaine cmp
	move.l 4(a2),d2
	sub.l (a2),d2		; d2 = long chaine cmp
	move.l (a3),a6		; a6 = ptr chaine to replace if cmp OK
	move.l 4(a3),d3
	sub.l (a3),d3		; d3 = long chaine replace

	move.l a4,d4
	move d2,d6
	; ne touche aucun registre sauf d2/a4/a5
	bsr compare_a4_to_a5_length_d2_replace_by_a6_length_d3_and_write
	move.l d4,a4

	tst d0
	beq.s .char_found_and_written

	lea NB_FORMATS*4(a2),a2
	lea NB_FORMATS*4(a3),a3

	addq #1,d1
	cmp #NB_ENTREES_TABLE,d1
	blt.s .scan_all_entries

	ifd OPT_MAXI_VITESSE
	move.b (a4),([pointeur_buffer_write.l])
	addq.l #1,pointeur_buffer_write
	else
	save.l a0/a1/a4
	FWRITE a4,#1,d7	; d7 conserv‚
	load.l a0/a1/a4

	cmp.l #1,d0
	bne.s .erreur_write_file

	endc

	moveq #1,d6		; ruse

.char_found_and_written:
	lea 0(a4,d6.w),a4
	cmp.l a1,a4

	blt .pas_rendu_a_la_fin_fichier

.fin_parse_fichier:
.erreur_write_file:
	MFREE a0

	ifd OPT_MAXI_VITESSE
	FILE_OPEN write,([pointeur_nom_fichier.l]),d7
	tst d7
	bmi .erreur_open_file_for_writing
	move.l pointeur_buffer_write,d0
	sub.l #buffer_write,d0
	FWRITE #buffer_write,d0,d7
	FCLOSE d7
	else
	FCLOSE d7
	endc

	graf_mouse #ARROW

	moveq #GWVA_PRGRET_CONSUMED,d6
	rts

.annule_save:
.erreur_open_file_for_writing:
	load.l d0/a0
	MFREE a0
	moveq #GWVA_PRGRET_CONSUMED,d6
	rts

.erreur_pas_assez_memoire_pour_charger:
	moveq #GWVA_PRGRET_CONSUMED,d6
	rts

		*************************************

compare_a4_to_a5_length_d2_replace_by_a6_length_d3_and_write:
	; ne touche aucun registre sauf d2/a4/a5
	; retour dans d0

	tst d2
	beq.s .compare_negatif

.boucle:	cmp.b (a4)+,(a5)+
	bne.s .compare_negatif

	subq #1,d2
	bne.s .boucle

.compare_positif:

	ifd OPT_MAXI_VITESSE

	move.l a6,a4
	move.l pointeur_buffer_write,a5
.copy_buff:	subq #1,d3
	bmi.s .fin_recopie
	move.b (a4)+,(a5)+
	bra.s .copy_buff
.fin_recopie:
	move.l a5,pointeur_buffer_write

	else

	save.l d1-d6/a0-a6
	FWRITE a6,d3,d7
	load.l d1-d6/a0-a6

	endc

	clr d0
	rts

.compare_negatif:
	moveq #-1,d0
	rts

		*************************************

	section DATA

texte_load:		dc.b 'Choose file to convert : ',0
texte_save:		dc.b 'Choose file to write to : ',0
mask_everything:	dc.b '*.*',0

 even

table_comparaisons:
	dc.l char_01_unix,char_01_atari,char_01_html,char_01_pc	
	dc.l char_02_unix,char_02_atari,char_02_html,char_02_pc	
	dc.l char_03_unix,char_03_atari,char_03_html,char_03_pc	
	dc.l char_04_unix,char_04_atari,char_04_html,char_04_pc	
	dc.l char_05_unix,char_05_atari,char_05_html,char_05_pc	
	dc.l char_06_unix,char_06_atari,char_06_html,char_06_pc	
	dc.l char_07_unix,char_07_atari,char_07_html,char_07_pc	
	dc.l char_08_unix,char_08_atari,char_08_html,char_08_pc	
	dc.l char_09_unix,char_09_atari,char_09_html,char_09_pc	
	dc.l char_10_unix,char_10_atari,char_10_html,char_10_pc	
	dc.l char_11_unix,char_11_atari,char_11_html,char_11_pc	
	dc.l fin_table

char_01_unix:	dc.b $0a
char_01_atari:	dc.b $0d,$0a
char_01_html:	dc.b $0a
char_01_pc:		dc.b $0d,$0a

char_02_unix:	dc.b 'é'
char_02_atari:	dc.b '‚'
char_02_html:	dc.b '&eacute;'
char_02_pc:		dc.b 'é'

char_03_unix:	dc.b 'è'
char_03_atari:	dc.b 'Š'
char_03_html:	dc.b '&egrave;'
char_03_pc:		dc.b 'è'

char_04_unix:	dc.b 'ê'
char_04_atari:	dc.b 'ˆ'
char_04_html:	dc.b '&ecirc;'
char_04_pc:		dc.b 'ê'

char_05_unix:	dc.b 'à'
char_05_atari:	dc.b '…'
char_05_html:	dc.b '&agrave;'
char_05_pc:		dc.b 'à'

char_06_unix:	dc.b 'â'
char_06_atari:	dc.b 'ƒ'
char_06_html:	dc.b '&acirc;'
char_06_pc:		dc.b 'â'

char_07_unix:	dc.b 'ù'
char_07_atari:	dc.b '—'
char_07_html:	dc.b '&ugrave;'
char_07_pc:		dc.b 'ù'

char_08_unix:	dc.b 'û'
char_08_atari:	dc.b '–'
char_08_html:	dc.b '&ucirc;'
char_08_pc:		dc.b 'û'

char_09_unix:	dc.b 'î'
char_09_atari:	dc.b 'Œ'
char_09_html:	dc.b '&icirc;'
char_09_pc:		dc.b 'î'

char_10_unix:	dc.b 'ç'
char_10_atari:	dc.b '‡'
char_10_html:	dc.b '&ccedil;'
char_10_pc:		dc.b 'ç'

char_11_unix:	dc.b 'ô'
char_11_atari:	dc.b '“'
char_11_html:	dc.b '&ocirc;'
char_11_pc:		dc.b 'ô'

fin_table:

*char__unix:	dc.b DONT_KNOW
*char__atari:	dc.b 
*char__html:	dc.b 
*char__pc:		dc.b DONT_KNOW

*char_01_unix:	dc.b '&'
*char_01_atari:	dc.b '&'
*char_01_html:	dc.b '&amp;'
*char_01_pc:	dc.b '&'

	section BSS

	ifd OPT_MAXI_VITESSE
pointeur_nom_fichier:	ds.l 4
pointeur_buffer_write:	ds.l 1
buffer_write:	ds.b 200000
	endc
 END
