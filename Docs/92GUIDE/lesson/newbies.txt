****************************************************************************
                            68k ASM for newbies                            
****************************************************************************

I ) PRESENTATION
 I.1 ) generalities
 I.2 ) binary 
 I.3 ) hexadecimal
 I.4 ) the calculator

II ) First instructions: move/arithmetics
 II.1 ) move
 II.2 ) arithmetics
 II.3 ) flag register
 II.4 ) integers vs reals
 II.5 ) miscealeanous

III ) Other instructions
 III.1 ) Shifts
 III.2 ) logical operations

IV ) The stack / the compiler / first program
 IV.1 ) the stack
 IV.2 ) the assembler
 IV.3 ) 1st program: hello world ! 

V ) Branches
 V.1 ) labels
 V.2 ) comparisons, status register... 
 V.3 ) conditionnal Branch...
 V.4 ) conditionnal DEBranch
 V.5 ) non conditionnal Branch.

VI )  Structured programming in ASM
 VI.1 )  pseudo code
 VI.2 )  The program 

VII ) Debugging
** VII.1 ) Raven
 VII.2 ) Db92


I ) PRESENTATION

 I.1 ) generalities

 First, as assembly is a langage extremly similar to the structure of the
machine, there are a few things i have to explain now...
The 92' s alphabet is limited to "0" and "1" which correspond to material
states: " electrons not passing" and " electrons flowing through the
arteries of the calc".A letter in this alphabet is called a BIT. 4 bits are
a NIBBLE, 8 bits form a BYTE , 16 bits a WORD and 32bits a DOUBLE WORD or
LONGWORD.
 These 4 structures are the structures with which you will be working ( it
happens to be the ones with which the processor of the 92 is working ).
the "lower byte" of a word is the right 8 bits of the word ( the right byte )
the "higher byte" of a word is the left 8 bits of the word.. 
Same for longwords: lower word and upper word...

 Please: never forget : whatever the numbers you will be using, these numbers
are just a representation of a serie of bits stored in the memory of the 92
(under the form of micro interrupters swithed on or off ).
 So: the computer is working with binary data ( these little bits got 2
states: "bi"  of bin ). But data isn' t enough: to build a program, you
need data and instructions.
 Instructions will be simply coded using binary data: to each instruction we
write ( move.w xxx for exemple ), corresponds an instruction which the
processor can understand ( 00011010101... ). An instruction coded in this
manner is called an "opcode": it is generally noted in hexadecimal code ( see
I.3 )... It is the job of the Assembler ( you needn' t care about it ) to
translate our instructions into their binary equivalent and it is the job of
the disassembler to invert the process.

ex: 4AFA ( in hexadecimal) = 0100101011111010 ( in binary )
= illegal ( for the programmer ) 

 Here, a problem arises which you guys have surely seen: there is no way
for the calculator to do a difference between data and instructions, and
more generaly, between 2 form of data. YOU have to know the difference
between  data and instructions as a programmer. If you tell the processor
to execute something, it will do it. And if you made him execute some data
instead of some real code, he will never know... He will probably end with
an "illegal interruption", recognizing an opcode which doesn' exist. ( see
\system.txt I.3 )

 I.2 ) binary 

 If you have allready programmed a litlle, you know that all programs are
nothing but a traduction of an algorythm, a pseudo code. And an algorythm
( if detailled enough ) deals with nothing but numbers. What i want to say is
that all your data is nothing but numbers and you will be dealing with
numbers in assembly: a boolean variable for exeample is a bit. A one or zero
 So: how do we use numbers: all we got is 0 and 1 ? ? Take it easy: Can
you remember when you learned to count ? Then, that' s it.
Well, basicaly, numbers are representing objects: 10 is a representation
of  " I I I I I I I I I I ".

 The difference between these two representation is that one is that of a high
level mathematic: it uses a "base" to count.
We use to count in base 10 while the calc counts in base 2.
 Here is a simple way to understand how to pass from one base to another.

 ex: what is the diffrence between 27, 270, 2700. They are multiplied
by 10 which is the number of letters we are using ( for numbers ) : they can
be decomposed in :27=2*10+7, 270=2*100+7*10+0, 2700=2*1000+7*100+0*10+0.

 let' s use the same principle with 2 letters: we' ll try to decompose a
number into its 2 powers:
ex:           1=1*2^0                                        :    1
              2= 1*2^1+0*2^0                                 :   10 
              3= 1*2^1 +1*2^0                                :   11
              8= 1*2^3 +0                                    : 1000
              9= 1*2^3+0+0+1*2^0                             : 1001

 I will not go deeper in the study of these conversion problems: one should
try to get a good program to do these conversions himself... Knowing how it
is working is quite enough.
 To those of you who are reading this and saying: he thinks we are dumb!! All
he did is a base change... Yeah but i think that even if you got a calc which
does these conversions between decimal and binary much faster than you will
ever do these ( my casio does this quite well... ) , you should try to work
in binary, with these numbers, as they are at the heart of the machine.
 However, please, do not spend too much time on this: there are many other
more interesting things to learn and whatever happens, if you program a lot
in assembly, you will learn it little by little.

 That way, on a byte ( 8 bits ), it is possible to represent 2^8-1 numbers.
where $FF = %11111111 = 256 and $0 = %00000000 = 0.
 This method (base change) allows you to represent positive integers.
Negative integers cannot be represented that way.
 There are many ways to represent positive and negative number. However, only
three methods survived the history of computer science.
 1) the complement to two ( see II.2 for why and how ) for integers
 2) BCD integers ( this will be included in later releases )
 3) floating point coded binary. uses BCD, mantisa, and exponent...
    ( later perhaps )

 Now that you know what is inside the calc : you understand the headaches of
the first programmers who had to program in binary: it is awfull...
So, to represent the content of memory, hexadecimal is widely used.
 
 I.3 ) hexadecimal

 Hexadecimal is just a representation of the state  of the
memory. You will now have 16 letters: 0-9 and A-F : this has been chosen
because it gets much easier to represent a word with this notation: to a
group of 4 bits, you associate a "letter" as 4 bits allow 2^4=16 states.
thus, you see well in the definition of hexadecimal how it is simple...
 
 ex: 1100 1010 1000 1101 is CA8D ( i think ... :) )

 This is just another base change ! 

 I.4 ) the calculator
 
Your calc is made of 2 parts:
      *** The memory: where the data is stored under a binary form. "Data"
          means the instructions with their parameters which are to be
          executed by the processor. This mem is the RAM ( 128 kb on most
          92 ) and the ROM ( 1 Mb on most 92 ) 


      *** The processor, the heart of the calc: 2 parts

       a) a small part of memory in the processor where parameters for the
       near to come instructions are stored: the registers...
       b) the processor itself, where instructions are executed...

 The registers are some small micro switches which can be set to anything we
want: we use to store the data we want to process in these regs. You may put
there numbers to add or adresses to data ... ANYTHING !
These registers have been created because accessing to the memory is slow:
if the data is very near to where it is to be processed , the speed is
greatly increased. Registers are very usefull because they allow a very
flexible programming...
There are five sorts of regs:

 a) dataregisters: numbered from 0 to 7 ( there are 8 ) : D0/D7  : 32 bits
 b) adressregisters: A0/A6  : 32 bits
These are for you: you may store in these registers all data you wish.
you may store in these registers 32 bit data

 c) A7 : stack register ( it is physicaly similar to A0/A6 but it is used in
         a totaly different manner. see III )  :32 bits

 d) Status register:  16 bits
composed of 2 bytes: the lower byte, the flag register is widely used: its
bits are set depending on the result of some operations executed by the
processor.
The flag register is: 0 0 0 X N Z V C
The five flags to the right are described in the arithmetics section.
The upper byte or the system byte is a group of bits used by the system:
you can use them too but it requires to know what you are doing. The use
of these bits and of exceptions is described in the "system.txt" file.

 e) program counter: 24 bits 
The program counter is a register in which the adress in memory to the next
instuction to be executed is stored : you cannot modify its content !

-----------------------------------------------------------------------------

II ) First instructions: move/arithmetics

 II.1 ) move

 One of the most important action you need to do when programming is handling
data. I mean that you need to know how to move data to or from memory.
The corresponding instruction is: "Move" ( as "mov" for the x86 processor
family ) 

ex: "move     D2,D4" will move ( copy ) data from D2 to D4.

 More generaly, in all the instructions you 'll use, the first parameter is
the source and the second the destination.
Then, you need to precise the data form you will use : BYTE, WORD or
LONGWORD: you can move the lower byte of D2, its lower WORD or its whole
content. Here is how to do this: 

move.B   D2,D4     : byte
move.W   D2,D4     : word
move.L   D2,D4     : longword

 this syntax is used for all instructions too. ( the .x extension where
x=b,w,l is an extension valid for all instructions ) Important: when
programming, never forget to precise the lenght of the data you use: this
is CAPITAL !
 Even when it is trivial, you should precise the lenght... ( i did not always
did this myself but i am no example and i have spend days debugging such
errors... ) 

 Move may be used to put certain values in some places: you wish to put
"1270" ( in decimal ) in the D4 register. Just type : move.w   #1270,D4
the "#" stands for immediate value: you will thus store the number 1270
( in decimal ) or "10011110110" (in binary ) in the D4 register .

if the number you got is hex, just type: move.w  #$4F6,D4
"$" stands for hexadecimal.
if the number you got in bin, just type: move.w  #%00000001,D4
"%" stands for binary.
Note: that notation, "nothing,$,%" will now be used in all the file,
even in the text.
 
 Still, if you want to move data from a certain place in the memory ( not
the processor's one ): you know the adress of the data you need: $4F6.
type : move.w    ($4F6),D4
the processor will take the word stored at the adress 4F6 and copy it to D4.

 Note: when going through other programmers code, you will notice some use:
move.w   $4F6,D4 : they do not write parentheses. Parentheses are not needed
there but i suggest you to use them nonetheless: they will help you to
differentiate #$4f6 and ($4f6) which are two completely different datas.
One is a pointer and the other one is just data.

 Similarly, if you have stored in an adress register the adress of
the data you want, you may type: "move.l  (A0),D1"
the parentheses ( necessary there ) mean that it is indirect adressing: the
data we will copy to D1 is the data which A0 points to.
 Lastly, "move.w  32(A0),D1" will copy to D1.w the data stored at adress
A0+#32. The addition is done in some internal register of the processor and
does not affect the A0 register.

Here it is ! You have seen the principals operations you can do with move. 
However, before going on, i think you should try to take a look a jimmy
mardel' s guide: he describes all ways of using the move command: all ways
of adressing memory. This may not seem very exciting but it is usefull to
know what you can do with all instructions before trying to program.
( see \doc\68kguide.txt )

 II.2 ) arithmetics

 Another important thing to do on data is arithmetics.
 I will present here simple arithmetics: addition, substractions and negative
numbers.
let' s imagine you want to calculate 100+25
you 'd do: move.b  #100,D0  (the byte is used as 100 can be stored in 8 bits)
           move.b  #25,D1
           add.b   D0,D1

this piece of code will do: D0+D1->D1
you' ll have 125 in D1 at the end of this code. But of course in binary.
now, for 100 - 25 , 

move.b    #100,D0
move.b    #25,D1
sub.b     D1,D0

in which case, you do: D0 - D1 ->D0
let ' s imagine we had done : 

move.b    #100,D0
move.b    #25,D1
sub.b      D0,D1

then, there would be - 75 in D0, a negative number ! 
Here arises the problem of recognizing negative numbers. A simple convention
is to use the bit the most to the left to state the sign: if 0, positive,
if 1, negative. This allows you to code -127 by %11111111 and +127 by
%01111111. 
let' s imagine it was that simple:

Note: all operations will be made on a byte from now but it is exactly
the same on a word or on a longword 

we wish to add +4 and -1. we should get +3
        4       %00000100
    +  -1       %10000001
     ____________________
       +3       %10000101= - 5     

this doesn' t work. So, we use a slightly different way to represent negative
numbers: the complement to two. 

we have +4 : %00000100
we want -4 : we take the complement to one ( we invert all bits of the number)
and we add 1. 

               11   -------------> these are the carry bits
we get:   %11111011
       +  %00000001
         __________
          %11111100 = (-4)  : do not forget carry bits ! 

in our exemple   (+4) + (-1)= (+3)

         111111 ----------> these are the carry bits
  (+4)   %00000100
+ (-1)   %11111111
  _________________
  (+3)   %00000011

 It works that way. Some may have noticed the importance of the lenght
of the data used. I have chosen to add numbers on one byte: the result
is thus valid only on one byte. Because at the end of this exemple, we
get %00000011 with one carry bit ( ie: the one the most to the left ).
the result is +3 if we had decided we were working with signed numbers
and is %0000000100000011 = 259 on one word if we had decided to work with
unsigned integers.

 In the processor, everything happens the same way: it calculates your
addition on the data specified and stores the carry bit elsewhere. ( it
stores it in the carry bit of the status register : see II.3 ). If working
with unsigned integers, you should check the carry bit. Otherwise, your
program is likely not to work. Once more, the same law rules: a register
is what YOU want it to be. DO NOT expect the calc to know it for you. The
processor has no way to know that $FF=%11111111 is 256 or -1.

 There, you may see the use of the "ext" opcode. ( if you have gone through
jimmy mardel' s guide ) 
Let' s imagine we have got an array in which all entries are bytes and in
which numbers may be as well positive as negative...
the first number stored is -1 : $FF=%11111111 ( it is a byte ! )
now, we want to add this to a number which is stored in D0 but this number
is a word...
if we did:
clr.w    D1             ; clear the D1 register's lower word
move.b   (A0),D1        
add.w    D1,D0

this would be completely false: we would not add -1 to D0 but +255 to D0.
( yes: if the D1 reg was cleared, then we have: $00FF in the
lower word of D1. Thus, if we add D1 and D0, we add 255=$00FF to D0
we need to add -1 on a word to D0: -1 is $FFFF: ext.w will transform a
negative number on a byte to a negative number on a word.
now, the right piece of code is:

clr.w    D1
move.b   (A0),D1
ext.w    D1         ; transforms $00FF to $FFFF
add.w    D1,D0

 Basicaly, what the "ext" opcode has done is copying the last bit of the
lower byte through the upper byte of D1.

 Now that you know how to do additions, substractions... What about
multiplications and divisions ?
The corresponding instructions are :  mulu ( unsigned ) , muls ( signed ) ,
divu ( unsigned ) and divs ( signed ) . If working with signed numbers, then
use muls and divs. 
"muls.x  D2,D4"  will multiply the lower x of D2 and D4, and store the 32 bit
result in D4.
"divs.x D2,D4" will calculate D4/D2 ( D4 is 32 bits and D2 is 16 bits )
and store the quotient in the lower word of D4 and the rest in the upper
word of D4.

 II.3 ) flag register

 the flag register is: 0 0 0 X N Z V C

 C is the carry flag.
The carry generated by a mathematic operation ( addition, substraction,
multiplication... ) is stored there. See II.3 to understand its use.
 V is the overflow flag.
It is set if an arythmetic operation resulted in an overflow.
ex: if there was a carry in an addition
 Z is the zero flag.
It is set if the result of an arithmetic operation is zero.
 N is the negative flag.
It is set if the highest bit of the result of the last arithmetic operation
is set: in fact, if set, it means that the result was negative if you were
working with negative numbers.
 X is a copy of C.
It isn' t affected by all arithmetic operations.

 II.4 ) integers vs reals

 You have been working till then with integers. What about reals ?
The 68000 processor has no build in instructions to handle floating point
arithmetics ( ie: reals )! To simulate these float numbers, there are 2
solutions: write software routines which will handle the float calculus
or use integers ( fixed numbers ). 
 Writing routines which handle floating point numbers is rather complex
and the code generated is quite slow. The solution is to use fixed point
arithmetics. ( mode "fix" on the calc )
 If we are in mode "fix2", Pi=3.1416..... is represented by 3.14. The float
number is truncated after the second digit.In fact, the number stored in
memory is 314. All numbers are multiplied by 100. When it is time to display
them, it takes into account the mode used and adds a coma.
 The main problem with this method is that it has high calculus errors with
a low accuracy. Less than 10^-2...
 Here, because we work in base ten, the idea was to multiplicate by 10^2.
In assembly, the idea is the same but we multiply numbers by 2^10 for example.
As 2^10=1024 ~ 1000 . That way you get more or less a 10^-3 precision and
calculus are much simpler with 2 powers. ( see \lesson\lesson_1.txt  )

 II.5 ) miscealeanous

 The move instruction has some limitations:

   1) when you move one word or one byte into a 32 bits reg, the uper word
or the upper byte is not affected.
Some programmers use the ext instruction to clear the upper word or byte:
"ext.l D1" will clear the upper word if D1 is lower than +32768=$8000...
Because it will copy the highest bit of the D1 lower word through D1
upper word and if D1 is lower than $8000, the highest bit is cleared.
ext.w D1 will , in the same manner clear the upper byte of the lower word of
D1.
   2) when move is used to send or get something from mem, you cannot access
to odd adresses when moving words or longwords. It would result in an
"adress error".
   3) Never forget the parentheses when necessary

 Adresses are often given in hex: it is more convenient. Their unit is the
byte. ex: 128 kb are in fact 2^17 = 131072 bytes = $20000

-----------------------------------------------------------------------------

III ) Other instructions

 III.1 ) Shifts

 When shifting a number in base ten, you multiply or divide it by 10.
That' s the same idea in ASM: in base 2, shifting a number of one bit to the
left is just like multiplying it by 2^1, 2 bits, 2^2=4...
then if we have %00001000 and we shift it to the left of one, we get
%00010000 which is 16*2=32. It work just the same for dividing:
we would get %00000100 which is 16/2=8...

 The two instruction which do this are: lsl ( logical shift left ) and lsr
(logical shift right ). 
 However, that last exemple hid a great problem: what if we had had negative
numbers ? from %11111111 = -1 shifted to the right of one, we have
%01111111 = +127 instead of -2...

 This can be done using : asl ( arithmetic shift left ) and asr ( arithmetic
shift right ) which do the same than lsr but on signed numbers. Asr
simply copy the bit the most to the left in the hole made by the shift. I
believe that asl is exactly the same instruction than lsl...

Note: a possible use of shifts is to optimize some code as it is a very fast
      instruction.
      ( see \lesson\lesson_1.txt )

 III.2 ) logical operations

 This section will first present definitions for the standard logical
operations, then some of their possible use.

  III.2.1 ) Definitions

 The or, and, eor and not instruction will perform the corresponding logical
operation on each bit, one after the other.
 Here are the logic tables of the bit logical operations.

 NOT: it will realize a logic no on the bit:
   NOT 1 = 0
   NOT 0 = 1 

 OR :
    0 OR 0 = 0
    0 OR 1 = 1
    1 OR 0 = 1
    1 OR 1 = 1

 AND:
    0 AND 0 = 0
    0 AND 1 = 0
    1 AND 0 = 0
    1 AND 1 = 1

 EOR: the Exclusive OR
    0 EOR 0 = 0
    1 EOR 0 = 1
    0 EOR 1 = 1
    1 EOR 1 = 0

  III.2.2 ) Using AND

 The best way to understand how these instructions can be used is to look
what their result will be on a few examples. Please, note that understanding
this section needs a little habit of binary numbers and their traduction to 
decimal.

    76543210 ---------> bit number
    01010101
AND 01111000
-------------
    01010000

 a) Masks
 The obvious result of this operation is to clear some bits. Here, the bits
0,1,2,3,7 were cleared and the others were kept as they were sooner.
%01111000 is called a mask: it allows you to isolate some bits in a byte so
that it is possible to test them. separately without using bset.

 b) Arithmetics
 Another use of AND is to calculate the rest or the quotient of a division by
a two power. Here is an example with a division by 8=2^3.
The equation: ( x and %00000111 ) + ( x and %11111000 ) = x is true.
what you have is: %00000xxx + %xxxxx000 = %xxxxxxxx
Then, xxxxx000 = 000xxxxx * 8 . In fact, the first equation can be rewritten
in: r + q * 8 =x
These are the definition of q=quotient and r=rest.

  III.2.3 ) Using OR

    76543210 ---------> bit number
    01010101
AND 01110000
-------------
    01110101

 The result is to set bits 4,5,6, while leaving all other bits untouched.
This is another way to use masks: there, you can set one or more than one
bit at a time without bothering about changing other bits.

  III.2.4 ) Using EOR

 This logic operation is used to invert only certain bits in a byte. Another
way to use masks.

    76543210 ---------> bit number
    01010101
AND 01110000
-------------
    00100101

 Here, bits 4,5,6 were inverted and all the other bits were not touched...
Note that EOR is used on the x86 processor familly to clear registers as
x EOR x is allways 0 .

-----------------------------------------------------------------------------

IV ) The stack / the compiler / first program

 IV.1 ) the stack

    IV.1.1  Description


 The stack is a 16 kb area of memory stored at $120 or $400. ( you don' t
need to know where exactly ). You have access to this memory by the stack
pointer A7 : the adress to the stack is stored in A7.

The stack is mainly used to: 
     1) save variables before working with them 
     2) transmit parameters to a subroutine
 
 Storing params in the registers is usually much more easy and much faster
( that is the way of most of the libraries i know ) .
Why using the stack in this way ? Because we ( the users of fargo )
are using routines implemented in the tios: these routines use the stack to
store parameters. ( ex: tios::DrawStrXY ) . 
 It is often usefull to use the stack to save all registers and restore
them after: this is something most libs do . Refer to \doc\68kguide.txt to
know how to do: check the "movem" instruction .

Now , you know what the stack is used for: how can you use it ?

    IV.1.2  Pushing Data to the Stack

 The stack is used to store temporary variables. The 92 tios routines use
a LIFO stack ( last in, first out ) in reverse order. Here is why.

Let' s say that A7, the stack pointer, is $4000 , D0 is $0000FFFF and you
execute the instructions:

move.w   D0,-(A7)
move.l   D0,-(A7)
sub.l    #$2,A7
move.w   D0,(A7)
Here is what they will do: 

     Adress            Stack

                ----------------------
$4000           |      $xxxx         | ---> A7=$4000 before the instruction  
                ----------------------
$3FFE=$4000-$2  |      $FFFF         | ---> A7=$3FFE after the 1st inst
                ----------------------
$3FFC           |      $0000         |
                ----------------------
$3FFA           |      $FFFF         | ---> A7=$3FFA after the 2nd inst
                ----------------------
$3FF8           |      $FFFF         | ---> A7=$3FF8 after the 4th inst
                ----------------------
$3FF6           |                    |
                ----------------------
$3FF4           |                    |
                ----------------------

What these inst have done is: 
              1) look at the data size ( x=w or l )
              2) sub the data size to A7
              3) copy the data to the mem pointed to by A7

Note: you can see that the minus in the move instruction is used just to
update A7 before moving the data.
 This operation, saving variables in the stack and more generally sending
data to the stack is called pushing data.

    IV.1.3 Poping data from the stack

To get back the data we last saved, we could do:

move.w   D0,(A7)+
move.l   D0,(A7)
add.l    #$4,A7
move.w   D0,(A7)+

     Adress            Stack

                ----------------------
$4000           |      $xxxx         | ---> A7=$4000 after the 4th inst  
                ----------------------
$3FFE=$4000-$2  |      $FFFF         | ---> A7=$3FFE after the 3rd inst
                ----------------------
$3FFC           |      $0000         |
                ----------------------
$3FFA           |      $FFFF         | ---> A7=$3FFA after the 1st inst
                ----------------------
$3FF8           |      $FFFF         | ---> A7=$3FF8 before the 1st inst
                ----------------------
$3FF6           |                    |
                ----------------------
$3FF4           |                    |
                ----------------------

 The use of the plus and the add are equivalent and self explanatory.

    IV.1.4  Notes

 If you have perfectly understood the previous explanation, then you must
wonder why the stack is in reverse order: why not begin at adress $3000 and
store data in the "right" order:

move.w   D0,(A7)+
move.l   D0,(A7)+
move.w   D0,(A7)+


     Adress            Stack

                ----------------------
$3000           |      $xxxx         | ---> A7=$3000 before the instruction  
                ----------------------
$3002           |      $FFFF         | ---> A7=$3002 after the 1st inst
                ----------------------
$3004           |      $0000         |
                ----------------------
$3006           |      $FFFF         | ---> A7=$3006 after the 2nd inst
                ----------------------
$3008           |      $FFFF         | ---> A7=$3008 after the 4th inst
                ----------------------
$300A           |                    |
                ----------------------
$300C           |                    |
                ----------------------

 Well: it doesn' t work that way because the ti 92 rom uses the stack in the
reverse order and the processor itself uses it that way  (see the bsr and jsr
instructions) That' s all. If YOU want to use it in the "right" order, then
you will probably lock the calc as vital data is stored there when your
program is launched and you will just crunch the data allready stored while
saving your own data.
 Note that when poping data from the stack, you do not erase the data you
saved there: you just update the stack pointer. Later, this data is erased
when newer data is saved.
 Last but not least: you may have noticed i have not pushed or poped byte
data. This is because if you did so, you would update the stack pointer to
an odd adress, resulting with your next use of the stack in an adress error.
This is because you cannot move data to odd adresses ( une adresse impaire
in french )


 IV.2 ) the assembler

 You may have some ideas now as to how program things in asm. Now, to run a
program written in assembly, you need:
 1) type that program in a txt file renamed to .asm
 2) Dos users should get into the dir they have typed that program and type
at the dos prompt: "fargo file_name" where file_name is the name of the file
where you wrote your program without the asm extension. ( this is explained
in fargo doc )

 Now, you should have a file named: file_name.92p which needs to be send to
the calc after fargo is installed.

 In fact, when you ran the command: "fargo xxx":
 1) an assembler named a68k written by someone called W. Gibbs and modified by
fargo author reads your file: it takes all the opcodes and convert them to
their hexadecimal equivalent
 2) Then, the file thus generated is modified to match fargo format and .92p
format. ( see \system.txt section III.3 for more on the assembler/linker )

 To write a file which a68k can read, you need to follow a very precise
syntax:

-----------------------------------------------------------------------------
                           begening of the file
-----------------------------------------------------------------------------
      include "library_1_file_name.h"
      include "library_2_file_name.h"
      include "library_3_file_name.h"
      xdef    _main
      xdef    _comment

_main:

; there, your code




_comment:
  dc.b "program_name",0

 end

-----------------------------------------------------------------------------
                               End of the file
-----------------------------------------------------------------------------

You should take care of the spaces i put. However, looking at fargo.txt
included in fargo doc is not a bad idea.... It is clearly explained and if
you still have doubts, then look at the examples with fargo...
Look at \doc\direct.txt which contains the directives which can be used with
fargo supported by the a68k assembler.


 IV.3 ) 1st program: hello world ! 

 We want now to display something on the screen.
-----------------------------------------------------------------------------
                           begening of the file
-----------------------------------------------------------------------------

 include "flib.h"
 include "tios.h"
 xdef    _main
 xdef    _comment


_main:
    
    jsr      flib::clr_scr          ; clear the screen 
    move.w   #4,-(A7)               ; move the first param to the stack
    lea      string(pc),A0          ; move adress of _string to the stack
    move.l   A0,-(A7)
    move.w   #0,-(A7)               ; push position
    move.w   #0,-(A7)               ; push position
    jsr      tios::DrawStrXY        ; call subroutine
    add.l    #10,(A7)               ; restore the stack pointer
    jsr      flib::idle_loop        ; subroutine which waits till key pressed
    rts

string:
  dc.b "This string is displayed",0

_comment:
  dc.b "Hello, World",0

 end       

-----------------------------------------------------------------------------
                               End of the file
-----------------------------------------------------------------------------

 Now: let' s see what we did: lea ? What is this ? 
"lea  string,D0" :  moves the relative adress of string to D0 ( the relative
adress is the number of bytes you need to add to the absolute adress of the
instruction "lea" to get the adress of string )

Instead, we wrote: "lea   string(pc),D0"
 This added to the PC ( see I.4.e )( the absolute adress of the "lea" inst at
that instant) to the relative adress of string and stores the result in D0
(it could be Ax) Thus, you get the absolute adress of "string" stored in D0.
Then that adress is pushed to the stack. We could have written:
"pea    string(pc)" ( push effective adress ).

 Lastly, after having displayed our string, we restore the stack: instead of
erasing the data in the stack, we restore the stack pointer to its initial
value: we add the sum of the size of the data we pushed to the stack pointer
(10=2+4+2+2). Or, more simply, it could have been:  "lea  10(A7),A7"
( this adds 10 to A7 )

ok: now, save this file with the extension : "asm" and run
"fargo <name of the file without the asm extension> ".
you get your <name of the file>.92p file: send it to the calc, lauch it...

-----------------------------------------------------------------------------

V ) Branches

 V.1 ) labels
   
 In an ASM prog , you may define labels: if you have done some programming on
a casio calc or on some old basic, there was the goto function... 
"goto  <label>" meant that when executing the goto statement, the computer
had to go to the label pointed to by goto. ( it could be combined with an if
statement ) 
There exists the same in ASM.

to define a label, you write: 

name_of_label:

that' s all ! the ":" is important: it is him which helps the compiler to
recognize the label...
 
 V.2 ) comparisons, status register... 

 To compare 2 operands, you execute a cmp opcode... 

cmp  D0,D1

 This does: D1 - D0 and affects the bits of the flag register depending on
the result of this substraction ( see II.2) .
Note:
 1) the result of D1 - D0 is not stored in memory or anywhere: it is virtual...
( in fact, it is executed into some internal reg of the processor )
 2) The result of a standard arithmetic operation usualy affects the flag reg
in the same way: you may thus remove some cmp from your programs... 

 V.3 ) conditionnal Branch...

 The opcode is: Bxx name_of_label_to branch_to
where xx is one the 14 extensions available ( check \doc\68kguide.txt: it is
explained in the inst section ).
ex: Bcc, Bhi... 
 The following piece of code will:

cmp    B , A
bxx    name_of_label_to_branch_to

then bxx will branch to the label if:

*  when working with unsigned integers: 
 
A >  B            Bhi ( branch if higher )
A >= B            Bcc ( branch if carry clear )
A <= B            Bls ( branch if lower or same )
A <  B            Bcs ( branch if carry set ) 
A =  B            beq ( branch if equal ) 
A <> B            bne ( branch if non equal ) 

*  with signed integers

A >  B            bgt ( branch if greater )
A >= B            bge ( branch if greater or equal )
A <= B            ble ( branch if lower or equal )
A <  B            blt ( branch if lower )
A =  B            beq ( branch if equal )
A <> B            bne ( branch if non equal )


Note:
 1) In fact, in each different branch, the processor just checks some
different flags in the flags register, depending on the branch executed.
ex: beq will just test the Z flag and branch if it is set because if the
Z flag is set, then the last arithmetic operation resulted in a zero.
for more on what bits are tested, check jimmy guide.
 2) When the assembler reads the asm file to be traduced in hexadecimal,
it reads the branch opcode and calculates the relative adress to the label
from the branch opcode. In fact, when the processor executes a branch opcode
it just adds that relative adress to the adress of the instruction which
is beeing processed ( the adress of the instruction in process is stored in
the PC: program counter cf:I.4.e).
 3) there exist other branches : bvc, bpl: check \doc\68kguide.txt to know
about them.


 V.4 ) conditionnal DEBranch

They are coded just the same: not very difficult: check \doc\68kguide.txt

 V.5 ) non conditionnal Branch.

There are 3 non conditionnal branches.

   V.4.1 ) Bra

      Basicaly, "bra name_of_label to branch_to" will work just the same as
     previous branches. It just doesn' t test flags: it ALLWAYS branch.
     Not much to say, really.

   V.4.2 ) Bsr, Jsr

      These two instructions are used to ALLways branch to a SUBROUTINE.
     A subroutine is something from which you will get back when executed.
     After the subroutine is executed ( when an RTS opcode will be found ),
     the programm will continue to execute just after the BSR or JSR opcode.

     a ) How to use them.
       You should use BSR only for your own subroutines: the ones you wrote
      and which are included in your program while JSR is used to call a
      subroutine from the libraries. ( a list of the library calls available
      is included in each library in the file lib_name.h )
      "jsr lib_name::sub_routine_name"  will simply call the subroutine,
      most probably destroy some registers, and go on with the program
      execution after JSR when it find the rts opcode which mark the end of
      the subroutine ( you do not have to bother about that rts ) .
      "bsr subroutine_label" will do the same.
      The subroutine should be written that way:

subroutine_label:
  .
  .  ; there, your code
  .
  .
  rts

     b ) How they work.
       When the processor reads the BSR or JSR opcode, it saves in the
      stack the adress written in the PC ( I.4.e and IV.3 ), and the
      content of the flag register. When the processor reads the rts opcode
      at the end of the subroutine, it restores the PC with the value stored
      in the stack ( you may have changed it... It is quite fun to do so .. )
      There exists another instruction too: RTR. When this instruction is
      used instead of RTS, the flag register is restored too.

-----------------------------------------------------------------------------

VI )  Structured programming in ASM

 More than any other langage, ASM is extremly complex: listings get longer
and longer, most of the time unreaddable, no one but you can understand the
program. It becomes very quickly impossible .
There are some solutions... 

 VI.1 )  pseudo code

 Before writing anything in ASM, you MUST know what you will do.. 
I remember my programming some things in pascal or basic some time ago... I
began to write things on the screen without even knowing how i would do what
i had in mind. If this was possible  for very simple progs, it is no more
possible for an ASM prog ( because of its complexity and lenght ) 
 So: you need fist to write a pseudo code: it is a text ( preferably in your
own language at the begening ) which describes the general structure of the
program... 
for exemple, if you are writing a doom like engine..
( my case some time ago..)

for ray from 0 to 150

launch ray. 

calculate dist to the first object. 

render the slight portion of picture based on the distance to the first
object encountered.

end_launch

easy, not ? 
 This is the first version: slowly by slowly, you try to go deeper, you
explain with more detail what will be done in the "launch ray " section...

 While writing the pseudo code, you build a " table descriptor": there, you
keep track of each variable, its use, its type, the different values it will
take, the range of its values, its initialisation ( when, how ).
 At last, you got a doc which can be understood by anyone... ( taking
time of course )  

 VI.2 )  The program 

 On this basic structure, you can write your program.... 
It is very important that you keep in mind that structures as
"if then else endif" are very easy to code...
for exemple: 

if_1:
   cmp D0,D1
   bcc   else_1
then_1:
; your code
   bra end_if_1
else_1:

end_if_1:


or the "while, do, end_while" structure: 

while_1:
   cmp   D0,D1
   bcc   end_while_1
do_1:
; your code

end_while_1

or the "iter, end_iter" statement:

iter_1:
; your code
exit_if_1:
   cmp  D0,D1
   bcc  exit
   bra  iter_1
end_iter_1

 VI.3 ) hints

 Generally, using a modular approach is time saving: first, write some
subroutines, test them, make them work :) and write finally the main routine
which calls these subroutines. Subroutines should be written not to be fast
or small but to be easilly understood and easy to update should you ever need
it.
 Optimization is not a good idea till you haven' t made the program running.
You cannot know before finishing it if it will be fast enough. Thus, thinking
optimization before finishing the program will often end in you not beeing
able to read your own code anymore...

-----------------------------------------------------------------------------

VII ) Debugging

 Well: you have written now your first program, perhaps have you tried to
write another one... If so, wellcome to the great world of asm debugging...
There, you will spend more than 60 percent of your time while programming
in asm ! :) !
Hopefully, there are a few tools available to minimize that wasted time...

 VII.1 ) Raven
-----------------------------------
Note: raven is not yet available for fargo II
and will probably not for quite some time:
its author is allmost entirely rewriting it
and is overworked now..
Thus, this section is temporarily non relevant
-----------------------------------

 If you plan to use Raven, i suggest you to copy the fargo.bat and
a68k.bat files present in the folder you decompressed the tutorial into
in the bin folder of the fargo folder. These files will replace the
fargo 0.2.6 ones: they will allow the compiler to create the file:
name_of_your_file.txt. 
 There, you will find your code and at the begening of each line, the
hexadecimal coding of your work: these hex numbers are the exact copy
of what you would find if you scanned the memory of your 92 where your
program is stored.

 This debugger is an exception handler: it stays some sort of "resident" in
the memory and redirect all calls to exception routines and error traps.
(see system.txt on exception vectors )                                                                         
 RAVEN will allow you to look at the content of memory, of registers when an
error occurs then to exit from the program. It will recover from most errors.
As a user, you may even "break" the program by hitting the "on" key and to
get back to the program by "enter".
 When you are in the raven screen, you can see the content of a part of the
memory the PC points to: these are the codes of the near to come instructions.
You may compare these to the hex codes in the list.txt file: thus, you will
be able to know exactly where the program has been broken...
 Similarly, you can add user breakpoints: you can add "illegal" in your code,
just like any other istruction: it will provoque an "illegal instruction"
when executing the program and will allow you to sneak in the memory...
but this is not very efficient as you cannot allow the program to go on after
this.
 You may add this code at the place you want the breakpoint to be:

   move.b  d0,-(a7)
   clr.b   d0
breakpoint:
   tst.b   d0
   beq     breakpoint
   move.b  (a7)+,d0
  

 This piece of code will create an endless loop as it will test the lower
byte of D0 ( cleared ) if it equal to 0 and will test it till it is not zero.
if you are using raven, just hit the on key when this loop is launched, then
modify the content of D0 ( write anything in the lower byte of D0 ) and go in
trace mode ( trace mode is when you hit "t" : each instruction is executed
after "t" is hit and the program gets back to the debugger ) : after a few
instructions, you will be back to the program, you will be able to see all
registers and to trace the program...

 VII.2 ) Db92

Note: 
1) This section was written by guillaume Pothier , db92 author.
2) If you don't understand the label named "showship", you can read
   \lesson\lesson_3.txt and/or "sprite.asm" 
   while the waitkey routine may be understood by reading \lesson\lesson_2.txt
3) You will notice that in this program, subroutines are separated from the
   body of the program: it helps you to read the file and spot errors.


 Let's see how to use db92 with a simple example program. It is supposed
to blank the screen, draw a sprite, wait a key and exit.
 This tutorial does not fully describe all the features of db92. See
db92.doc for more detailed informations.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        include tios.h
        include your_file.sdb
; your_file is the name of your asm file...
        xdef    _main
        xdef    _comment



_main:
        ;Clear Screen
        move.l  #tios::main_lcd,a0

        move.w  #30*128/4-1,d3
       ClrScr_Loop:
        clr.l   (a0)+
        dbf     d3,ClrScr_Loop

        move.w  #120,VX
        bsr     ShowShip
        move.b  #10,VX          ;error
        bsr     ShowShip
        bsr     WaitKey
	
        rts

_comment        dc.b    "db92 tutorial.",0

Ship    dc.b    $81,$DB,$FF,$FF,$7E,$3C,$66



ShowShip:
        move.l  #tios::main_lcd+(30*115),a0
        lea     Ship(pc),a2
	move.w  VX(pc),d3
        and.w   #$FF,d3
	move.b  d3,d4
	and.b   #$F,d4
	add.b   #8,d4
	lsr.b   #3,d3
	and.w   #$FFFE,d3
	add.w   d3,a0
        move.w  #6,d3
       SS_Loop:
	clr.l   d5
        move.w  (a2)+,d5                ;error
	ror.l   d4,d5
	move.l  (a0),d7
	and.l   d5,d7
	seq     d1
	eor.l   d5,(a0)
	add.l   #30,a0
        dbf     d3,SS_Loop
	rts

VX      dc.w    120

WaitKey:
        move.l  #tios::kb_vars+$16,a0
       WK_Loop:
	tst.w   6(a0)
        bne     WK_Loop         ;error
	clr.w   6(a0)
        move.l  (a7)+,a0
	rts



  end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




 When you run this program, you obtain an adress error and the calculator
freezes. Now, load db92 and debug this program (see the db92.doc to learn
how to load the target program. I don't write it here as the method will
be likely to change).
    
 The program's disassembled code appears in the 'Code' window. You can
see that it is not very similar to the source code : there are no labels,
no comments and so on...
 Now, press the 'r' key. db92 starts to run the program. A short time
later, the 'Adress error' screen is displayed. db92 has handled the error
and is waiting for you to press a key.
 Once you are back in the normal screen, PC points to 'ror.l d4,d5'. This
is the instruction following the faulty instruction.
NOTE : For 'Bus Error' and 'Adress error' exceptions, PC always points
       after the faulty instruction.
 Press the 'Up' key. You see 'move.w (a2)+,d5', and if you look at a2 in
the 'Registers' window, you will see that it has a odd value.

 The problem is that you usually don't know where is this instruction in
your program. You have several solutions to find it :
  - the program is small enough, and you can locate it by looking the
    instructions before and after.
  - You run the program step by step from the beginning, using the F7 (Trace),
    F8(Step) and F4(Run To) keys. Basically, the technique is to Step (F8) the
    program until you find the instruction that caused the error. If it is not
    a bsr or jsr or trap instruction, you have located the error. Else, you
    reload the program and you execute it up to the location of the branch
    instruction which caused the error (you may use F4 or the breakpoints).
    Then, you Trace (F7) to go inside the branch, and you Step again...
    The problem of this method is that it is really annoying and time consu-
    ming.
  - Use the symbolic debugging : you can have the labels and variables names
    instead of their adresses in the 'Code' window. The simplest way to enable
    the symbolic debugging is to use 'autosymb.exe', a program that scans your
    source file to find symbolic informations.
    All you have to do is to put this line just above the _main label :
        include tut.sdb   ;assuming you source file is 'tut.asm'
    Then, execute 'autosymb tut.asm', or include autosymb in the batch you
    use to build your Fargo program, and compile the program.
       NOTE : You can choose not to use autofarg but to directly use the
       symbolic macros that are in 'symb.inc'. This is tougher, but it can be
       useful for big projects. See 'db92.doc' to learn how to do that.
    

  Let's use the symbolic debugging to locate the adress error. Reload the
program once you have compiled it with the symbolic informations. Press 'r'
to run the program. After the Adress error occured, PC points to the same
'ror.l d4,d5' instruction, but if you look a few lines below, you see
'dbf d3,:SS_Loop'. And if you go up two lines, you see the label ':SS_Loop'.
So now, you have located the faulty instruction.
  What is the problem ? a2 points to an odd adress while you try to read a
word. a2 points to the 'Ship' data, which is at an odd adress. Actually, the
'move.w' should be replaced by a 'move.b', as the sprite is only 8 pixels
wide. Recompile the program with this correction.

  If you run the program again, there is no more error, but the program
exits immediately, without waiting for a key to be pressed. As the problem
seems to come from the 'WaitKey' routine, it would be a good idea to debug
only this routine. So, go to the 'Labels' window (use F6 to change the
active window), select the 'WaitKey' label and press 'Enter'. The selected
instruction in the 'Code' window is the first instruction of 'WaitKey'.
 Press F4 to execute the program until this line is reached. At this point,
if you single step the program, you will notice that the error comes from
the 'bne' instruction, which should be replaced by a 'beq'.

  Modify the program, compile it, run it again. Well, the programs waits
for a key, but there is nothing on the screen. You have to single step the
program to find out what happens (use the F4 key to go directly after the
ClearScreen loop if you dont want to press F8 over 1000 times...)
 Now, step the first call to ShowShip and press F5 to see the result on the
screen. The ship is correctly drawn in the middle bottom of the screen. If
you step over the second call to ShowShip and press F5 again, the ship has
disappeared. What happened ?
  Terminate the program, either by pressing F2 or by pressing 'r' to execute
it until the end (the latter method is usually better if your program has no
severe error, especially if your program allocates memory : if you force-
fully terminate it using F2, the memory is not freed). Then, run it up to
the instruction after the first call to ShowShip.
  Now, in the 'Variables' window, look at the 'VX' symbol. It has the value
0x0078. Step the 'move.b #$0A,_VX' and look at VX : it is now 0x0A78
instead of 0x000A. As the ShowShip routine takes into account only the 8
lower bits of VX, the ship will be redrawn at the same position, and as it
is drawn using a EOR, it will erased.
 Replace the 'move.b  #10,VX' by a 'move.w', and all will work properly.


*****************************************************************************
                                  Newbies
*****************************************************************************

