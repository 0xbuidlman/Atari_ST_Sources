------------============ File storage on the TI92 (v4) ============-----------

Contents:
=========

0) Preface
----------

1) The structure of file and folder tables
------------------------------------------
1.1     Introduction
1.2     format of file/folder tables

2) The structure of various file types
--------------------------------------
2.1     Basic format of a file
2.2     Identifying file types
2.3     Tokenisation
2.4     Hiding data in files
2.5     Format of an internal string
2.6     Format of a string
2.7     Format of a picture
2.8     Format or a text file
2.9     Format of a data file
2.A     Format of a GDB file
2.B     Format of functions(/programs)
2.B3    Example of function(/program) format
2.B4    Example function
2.C     Format of expressions
2.C1    Floating point number
2.C2    Binary integer
2.C3    Binary fraction
2.D     Examples of tokenised types
2.E     Token listings
2.E1    System tokens
2.E2    Function tokens
2.E3    Program tokens

3) Parameter Passing
--------------------
3.1     Passing parameters to functions/programs
3.2     Returning values from functions

4) TI system variable addresses
-------------------------------

5) USEFUL ROUTINES - how to create files/folders in Fargo
---------------------------------------------------------

==============================================================================
0) Preface
==============================================================================
This document was intended to be used as a reference, firstly for myself, not
a tutorial. Therefore it may not be presented in a manner which is simplest to
understand. I have, however, tried to make it as clear as possible. If you
have any suggestions please email me.

Before reading this document I would recommend reading all of the Fargo
documentation, especially HANDLES.TXT which is the basis for all file storage
on the 92. The notation used in this document should be fairly similar to
that used in the Fargo documentation.

Some of this information might seem a bit dated...I haven't got round to doing
any Fargo II programming recently, so the information is quite old. Also,
the format of this file may make it difficult to understand, but looking over
some of the files yourself should clarify any problems.

Note: all symbols will be represented by their names enclosed in the "_" pair
      (excluding the "'s)

==============================================================================
1) The structure of file and folder tables
==============================================================================
1.1 - Introduction
------------------
On the TI92 there is a block of memory (handle) allocated for a folder table,
this table lists all of the folders and the handles for their file tables.
Every file table lists the files and the handles for the file. These tables
all use the same format, shown below.

folder table - handle $B
main folder - handle $C (main folder is an entry in the folder table)

you should know that you can find the starting address of the handle in d0.w
by:
	tios::DEREF     d0,a0

Access to these tables is now provided by a set of ROM calls, therefore the
structure does not need to be known, however, it is listed for reference.

The following addresses are displacements from the beginning of the
handle/file table or of the structure (file listing)

1.2 - format of file/folder tables
----------------------------------
00.W : maximum number of files/folders before handle has to be resized
02.W : number of files/folders in table (N)
04   : (0C)[N] listing in the format below (alphabetical order)
     +00   : file/folder name (lowercase) terminating in 0s until $08
     +08.W : file/folder flags
           . 3  : locked
           . 4  : hidden
           . 7  : folder
           . 14 : parameter (in function/program)
     +0A.W : handle of file/file table

Note: These tables only change in size when more room is required to store the
      entries, for speed the table is only resized at intervals of 10 entries.
      This is marked by the first word in the table, the corresponding size
      change is $78 bytes.

The type of the file is governed by the format of the file itself and is
separate from the file table.

==============================================================================
2) The structure of various file types
==============================================================================
2.1 - basic format of a FILE (addresses from start of handle)
-------------------------------------------------------------
$00.W : length of file in bytes (from $02 to after last byte)
$02   : file contents
Note: Last byte of file=(($00.W)+1).B

from now on the start address of files is considered to be the start of the
file + 2 and all addresses are relative to this point.

The "identifying" (last) byte of the file is shown in the "[]" pair as in the
convention used is not part of the structure, but it is left there just for
reference.

When referring to a file structure (STRUCT) it is without the identifying byte
and word for the size of the file. FILE {file type} means that the entire
structure should be used. When just referring to the file type the
identifying byte will be included.

OFFSET will be a word offset in little endian form, i.e LLHH in memory.

2.2 - identifying file types
----------------------------
        end   type
$??????????   EXPR  expression (i.e if none of others)
$????????2D   STR   string
$????????D9   LIST  list (note: D9={ )
$??????D9D9   MAT   matrix (list of lists, note: D9D9...={{..},{..},...}=[..])
$19E4E5..DC   PRGM  program (Prgm,END_TAG,...parameters of program,flags)
$????????DC   FUNC  function (Doesn't have to start with Func unlike programs)
$????????DD   DATA  data
$????????DE   GDB   GDB
$????????DF   PIC   picture
$????????E0   TEXT  text
$????????E1   FIG   figure
$????????E2   MAC   macro

2.3 - tokenisation
------------------
When functions/programs in the Function Editor are run from the home
screen, they are tokenised, before the statements are actually interpreted.
This involves each line of the code being coded into special ID's called
tokens, or quanta. This makes the program quicker to execute. This
tokenisation, however, is not only restricted to programs, the whole file
structure is based on them, expressions for example, this is also reduces
the space needed to store expressions.

2.4 - hiding data in files
--------------------------
Tokenised files are read from the end to the start, then end of the token is
governed by when the first token is ended (i.e when all the parameters are in
place) any data at the start of the file (in memory) is therefore ignored when
the file is read. The way in which they are tokenised allows the type to be
determined in the way described (2.2)

2.5 - format of internal string ($00) (non printing-string)
-------------------------------------
$00.B : #0
$01.B : characters

[$??.B : #0]

2.6 - format of a string ($2D) (printing string)
------------------------------
$00.B : internal string (i.e 0,chars,0)

[$??.B : #$2D]

2.7 - format of a picture ($DF)
-------------------------------
$00.W : height of picture
$02.W : width of picture
$04   : picture data, ceiling(width/8) bytes for each row of pixels

[$??.B : #$DF]

2.8 - format of a text file ($E0)
---------------------------------
00.W : offset of cursor in text
02   : lines of text (marked with ':')
     +00.B : identifier to start line with,
           : $20 : None
           : $0C : Page Break
           : $43 : Command
           : $50 : PrintObj
     +01.B : text line
     +??.B : $0D for enter usually, $00 for last line

[??.B : #$E0]


2.9 - format of a data file ($DD)
----------------------------------
00.B : number of rows
01.B : number of columns (Cols)
02   : [Cols] Column item listings
     +00.B : Column number
     +01   : FILE LIST rows
??   : [Cols]  Function used for column calculation for each column
     +00.B : Column number
     +01   : FILE FUNC colfunc
??   : [Cols] Column names
     +00.B : Column number
     +01   : FILE STRING starting with $E9 (i.e size.w,$E9,0,chars,0,$2D)

[??.B : #$DD]


2.A - format of a GDB
---------------------
Stored here are copies of many of the system variables (4).
If "?" proceeds a name, the name is unknown, if it preceeds it the value of
it is unknown.

00.B : 01
01.B : Mode|Angle
     : 01 : Radians
     : 02 : Degrees
02.B : 01
03.B : Mode|Graph
     : 01 : Func
     : 02 : Parametric
     : 03 : Polar
     : 04 : Sequence
     : 05 : 3D
04   : float xmin
0E   : float xmax
18   : float xscl  : mode not 3D
     : float xgrid : mode 3D
22   : float ymin
2C   : float ymax
36   : float yscl  : mode not 3D
     : float ygrid : mode 3D
40   : float _DELTA_x (|xmax-xmin|/238)
4A   : float _DELTA_y (|ymax-ymin|/102)
56   : if mode=Func {
     +00   : float xres
     } elseif mode=Parametric {
     +00   : float tmin
     +0A   : float tmax
     +14   : float tstep
     } elseif mode=Polar {
     +00   : float _THETA_min
     +0A   : float _THETA_max
     +14   : float _THETA_step
     } elseif mode=Sequence {
     +00   : float nmin
     +0A   : float nmax
     +14   : float plotstrt
     +1E   : float plotstep
     } elseif mode=3D {
     +00   : float zmin
     +0A   : float zmax
     +14   : float zscl
     +1E   : float eye_THETA__degree_
     +28   : float eye_PHI__degree_
     +32   : float scale1?=232*sin(45)/(|zmax-zmin|*sin(mod(
                                 eye_THETA__degree_,90)+45))
     +3C   : float scale2?=(96/|zmax-zmin|)*?f(eye_THETA__degree_,
                                 eye_PHI__degree_)
     }
??.W : Graph Formats flags
     . 0 : Coordinates: POLAR
     . 1 : Leading Cursor: ON
     . 2 : Labels: ON
     . 4 : Axes: OFF
     . 5 : Grid: ON
     . 6 : Graph Order: SIMUL
     . 7 : Coordinates: OFF
     . 8 : Style: WIRE FRAME
     . 15 : Graph Order: Greyed (mode Sequence)
??.B : $FF : mode Sequence
     : $00 : mode not Sequence
??.B : $00
??.B : number of functions to plot (N)
??   : [N] Functions to plot
     +00.B : Function number
     +01.B : FILE FUNC function
??   : if 3D {
     +00.B : 00
     } else {
     +00.W : Table Setup flags (TblSet)
           .6 : Independent: ASK
           .7 : Graph <-> Table: ON 
     +02   : float tblStart
     +1C   : float _DELTA_tbl
     +16   : FILE LIST tblInput
     }

[??.B : #$DE]

------------------------------------------------------------------------------
Reverse Memory Layout now assumed, due to the way tokenisation is done...

2.B - format of Functions(/Programs) ($DC)
------------------------------------------
[$00.B : #$DC]

01.B : flags *
     . 0-2 : Style : 0 : Line
                   : 1 : Dot
                   : 2 : Thick
                   : 3 : Animate
                   : 4 : Path
                   : 5 : Above
                   : 6 : Below
                   : 7 : Square
     . 3 : Tokenised (if 0)
     . 4 : tokenised outside home screen?
     . 6 : Plot On/Off (on=1) *
02.W : #0 (occasionly different)
04   : tokenised parameters terminating in END_TAG ($E5)
??   : If created in "Program editor" {
     +00.W : Type tokens i.e. #$E419 for Prgm, #$E417 for Func
     +02   : if untokenised { 
           +00.W : OFFSET of cursor in editor
           +02.B : #0
           +03   : program text (normal order)
           } else {
           +00   :[??] statements making up tokenised func/prog
                 +00   : statement
                 +??.B : #$E7 : next statement on same line
                       : #$E8 : next statement on new line
                       : #$E9 : final statment
                 +??.B : #0   : if not at end
           }
     } else {
     +00   : [??] statements making up tokenised function
           +00   : statement
           +??.B : #$E7 : if not at end
                 : #$E9 : final statment
           +??.B : #0   : if not at end
     }

[* For the plotting functions (e.g. y1(x)) the properties in the "Y= Editor"
are set actually in the flags of the function.]

Any function/program will have the same format if created in the "Program
Editor", however, functions can be created elsewhere, and will not have tokens
Func:...:Endfunc. To allow identification of programs the Prgm token is always
present even in the tokenised form.

2.B3 - Example of function(/program) format (postive memory)
-------------------------------------------
"Program Editor":
Untokenised Function size "(....):Func:...:EndFunc" 00 ofst 17E4 E5...0000??DC
Tokenised Function   size E9 0FE4 00E8 ... 00E8 17E4 E5....0000??DC
Untokenised Program  size "(....):Prgm:...:EndPrgm" 00 ofst 19E4 E5...0000??DC
Tokenised Program    size E9 12E4 00E8 ... 00E8 19E4 E5....0000??DC

Home Screen:
Tokenised Function   0008 E9 ... E5...0000??DC

??=flags

2.B4 - Example function
-----------------------
Whenever detokenising takes place, any standard TI function will be shown as:
function(par1,par2,...)
For +,-,*,/ etc. then it will be shown as follows
function[par1,par2,...]
to avoid confusion in simplification, at least that's the idea ;)

Here is a nice 3D graph (listed in Positive memory layout)
0026 E9 02011F 08 93 02011F 09 93 8B 04011F 91 44  02011F 08 93 02011F 09 93..
size [  2      x  ^  2      y  ^  +  4      /  cos 2      x  ^  2      y  ^  
..8B 24 8B 91 E5 09 08 0000 40 DC
  +  pi +  /  (  y  x  )       ]

/[+[pi,+[^[y,2],^[x,2]]],cos(/[4,+[^[y,2],^[x,2]]])]
/[+[pi,+[y^2,x^2]],cos(/[4,+[y^2,x^2]])]
/[+[pi,x^2+y^2],cos(/[4,x^2+y^2])]
/[x^2+y^2+pi,cos((x^2+y^2)/4)]
function(x,y)=cos((x^2+y^2)/4)/(x^2+y^2+pi)

2.C - format of expressions
---------------------------
expressions can consist of single or multiple tokens, these tokens can be of
different file types (e.g strings), but the way in which the tokens are
combined allows the last byte to indicate the type properly.

Numerical values are identified by the tokens $1F-$23 the meanings of the
tokens are as follows:
$1F     Positive integer (Binary)
$20     Negative integer (Binary)
$21     Positive fraction (Binary)
$22     Negative fraction (Binary)
$23     Floating point number  (can be +ve or -ve)

2.C1 - Floating point number (long double)
------------------------------------------
*Positive Memory Layout*
$00.W : <7.......|........>     Sign bit (0 if +ve, 1 if -ve)
      : <.6543210|76543210>     Biased exponent ($4000) (i.e. exp=n-$4000)
$02   : ($08) Mantissa (packed BCD ?.???????????????, ?=4 bits=1 digit)

[$0A.B : #$23]

 +--+--------+-----------------------------------------------------+
 | S|Exponent|                      Mantissa                       |
 +--+--------+-----------------------------------------------------+
79 78       63                                                     0

2.C2 - Binary integer
---------------------
[$00.B : $1F if +ve, $20 if -ve]

$01.B   number of bytes used to store integer (n)
$02     n bytes of integer (little endian form in memory, i.e LLHH +ve mem)
The encoding for the number 0 is just 1F00 as no bytes are needed to store it.

2.C3 - Binary fraction
----------------------
[$00.B : $21 if +ve, $23 if -ve]

$01     Binary integer structure for numerator
$??     Binary integer structure for denominator

2.D - Examples of tokenised types
---------------------------------
These examples are listed backwards, i.e. decreasing memory.
expression ends when span of first token ends, i.e all parameters have been
taken account of or closed with END_TAG ($E5)

C4         932593081F0102 08 1F0101 1F0102 E5  
integrate( e^(x^2)        x  1      2      )
token1     p1             p2 p3     p4     END

BA   518B1F010108 08 1F00 0B E5
sum( sqrt(1+x)    x  0    a  )

a+b+a-b+(a+b)*(a-b)->a

80 0B 8B 8F 8D 0C 0B 8B 0C 0B 8D 0C 8B 0B 8B 0C 0B 
-> a  +  *  -  b  a  +  b  a  -  b  +  a  +  b  a

->a+*-ba+ba-b+a+ba
->[a,+[*[-[b,a],+[b,a]],-[b,+[a,+[b,a]]]]]
->[a,+[*[a-b,a+b],-[b,+[a,a+b]]]]
->[a,+[(a+b)*(a-b),-[b,a+b+a]]]
->[a,+[(a+b)*(a-b),a+b+a-b]]
->[a,a+b+a-b+(a+b)*(a-b)]
a+b+a-b+(a+b)*(a-b)->a

(matrix type [list of rows])

D9 D9 1F0101 1F0102 E5 D9 1F0103 1F0104 E5 E5 
{  {  1      2      }  {  3      4      }  }
{{12}{34}}
{{1,2},{3,4}}
[1 2] 
[3 4]

------------------------------------------------------------------------------
2.E - token listings
--------------------
The parameters for the functions are not generally specified except for a few
Tokens, which are used, but not necessarily documented. The parameters will be
shown as listed in the CATALOG dialog, except in certain cases where the
parameters surround the OPeration. The pair "{}" show what other information
is left for the OPeration as if it were a function call, e.g.
EndFor {DISPLACEMENT} although formally has no parameters the relative offset
of the For statement proceeds the EndFor token. Comments are also shown in
parenthesis.

Symbols used:
_char_	char describing the symbol
/_		angle symbol
->		store (/to)
|>		convert (type)

A note on subtypes:
As well as the variable types there are a couple of other types listed in the
CATALOG dialog:
DMSNUMBER	An angle in Degrees, Minutes, & Seconds.
VEC		A vector of any type:
		Rectangular	X,Y[,Z]
		Polar		R,THETA
		Cylind	R,THETA,Z
		Spherical	R,THETA,PHI

****No Parameters (variables/constants/values)****
00	STRUCT internal string
01	q (Not used - $1B is used normally)
02	r
03	s
04	t
05	u
06	v
07	w
08	x
09	y
0A	z
0B	a
0C	b
0D	c
0E	d
0F	e
10	f
11	g
12	h
13	i
14	j
15	k
16	l
17	m
18	n
19	o
1A	p
1B	q
1C	*system token
1D	@xxx {BYTE xxx}
1E	@nxxx {BYTE xxx}
1F	STRUCT positive integer
20	STRUCT negative integer
21	STRUCT positive fraction
22	STRUCT negative fraction
23	STRUCT BCD float
24	_pi_
25	_exp_
26	_imaginary_
27	-_infinity_
28	_infinity_

2A	undef (UNDEFINED_TAG)
2B	false
2C	true
2D	TYPE/STRUCT string

****1 Parameter (Fuctions)****
2F	acosh(EXPR)
30	asinh(EXPR)
31	atanh(EXPR)

35	cosh(EXPR)
36	sinh(EXPR)
37	tanh(EXPR)

3B	acos(EXPR)
3C	asin(EXPR)
3D	atan(EXPR)

44	cos(EXPR)
45	sin(EXPR)
46	tan(EXPR)

4B	abs(EXPR)
4C	angle(EXPR)
4D	ceiling(EXPR)
4E	floor(EXPR)
4F	int(EXPR)
50	sign(EXPR)
51	_sqrt_(EXPR)
52	_exp_^(EXPR)
53	ln(EXPR)
54	log(EXPR)
55	fPart(EXPR)
56	iPart(EXPR)
57	conj(EXPR)
58	imag(EXPR)
59	real(EXPR)
5A	approx(EXPR)
5B	tExpand(EXPR)
5C	tCollect(EXPR)
5D	getDenom(EXPR)
5E	getNum(EXPR)

60	cumSum(LIST)
61	det(MAT)
62	colNorm(MAT)
63	rowNorm(MAT)
64	norm(MAT)
65	mean(LIST)
66	median(LIST)
67	product(LIST)
68	stdDev(LIST)
69	sum(LIST)
6A	variance(LIST)
6B	unitV(VEC)
6C	dim(MAT)
6D	mat->list(MAT)
6E	newList(NUMELEMENTS)
6F	rref(MAT)
70	ref(MAT)
71	identity(INT)
72	diag(MAT)
73	colDim(MAT)
74	rowDim(MAT)
75	_transpose_(MAT)
76	EXPR ! {EXPR}
77	EXPR % {EXPR}
78	EXPR _radians_ {EXPR}
79	not(EXPR)
7A	_negative_ EXPR {EXPR}
7B	STRUCT VEC:Polar {MAT} ([[R,/__THETA]])
7C	STRUCT VEC:VecCylind {MAT} ([[R,/__THETA,Z]])
7D	STRUCT VEC:VecSphere {MAT} ([[R,/__THETA,/__PHI]])

*****2 parameters (Functions)*****
7F	combine (not used)
80	EXPR->VAR {VAR,EXPR}
81	EXPR|CONDITION {EXPR,CONDITION}
82	EXPR1 xor EXPR2 {EXPR1,EXPR2}
83	EXPR1 or EXPR2 {EXPR1,EXPR2}
84	EXPR1 and EXPR2 {EXPR1,EXPR2}
85	EXPR1 < EXPR2 {EXPR1,EXPR2}
86	EXPR1 <= EXPR2 {EXPR1,EXPR2}
87	EXPR1 = EXPR2 {EXPR1,EXPR2}
88	EXPR1 >= EXPR2 {EXPR1,EXPR2}
89	EXPR1 > EXPR2 {EXPR1,EXPR2}
8A	EXPR1 /= EXPR2 {EXPR1,EXPR2}
8B	EXPR1 + EXPR2 {EXPR2,EXPR1}
8C	EXPR1 .+ EXPR2 {EXPR2,EXPR1}
8D	EXPR1 - EXPR2 {EXPR2,EXPR1}
8E	EXPR1 .- EXPR2 {EXPR2,EXPR1}
8F	EXPR1 * EXPR2 {EXPR2,EXPR1}
90	EXPR1 .* EXPR2 {EXPR2,EXPR1}
91	EXPR1 / EXPR2 {EXPR2,EXPR1}
92	EXPR1 ./ EXPR2 {EXPR2,EXPR1}
93	EXPR1 ^ EXPR2 {EXPR1,EXPR2}
94	EXPR1 .^ EXPR2 {EXPR1,EXPR2}

96	solve(EQUATION,VAR)
97	cSolve(EQUATION,VAR)
98	nSolve(EQUATION,VAR)
99	zeros(EXPR,VAR)
9A	cZeros(EXPR,VAR)
9B	fMin(EXPR,VAR)
9C	fMax(EXPR,VAR)

9E	polyEval(LIST,EXPR)
9F	randPoly(VAR,ORDER)
A0	crossP(VEC1,VEC2)
A1	dotP(VEC1,VEC2)
A2	gcd(EXPR1,EXPR2)
A3	lcm(EXPR1,EXPR2)
A4	mod(EXPR1,EXPR2)
A5	intDiv(EXPR1,EXPR2)
A6	remain(EXPR1,EXPR2)
A7	nCr(EXPR1,EXPR2)
A8	nPr(EXPR1,EXPR2)
A9	P->Rx(REXPR,_THETA_EXPR)
AA	P->Ry(REXPR,_THETA_EXPR)
AB	R->P_THETA_(XEXPR,YEXPR)
AC	R->Pr(XEXPR,YEXPR)
AD	augment(MAT1,MAT2)
AE	newMat(NUMROWS,NUMCOLUMNS)
AF	randMat(NUMROWS,NUMCOLUMNS)
B0	simult(MAT,VEC)

B2	exp->list(EXPR,VAR)
B3	randNorm(MEAN,SD)
****3 Parameters****
B4	mRow(EXPR,MAT,INDEX)
B5	rowAdd(MAT,RINDEX1,RINDEX2)
B6	rowSwap(MAT,RINDEX1,RINDEX2)
****4 Parameters****
B7	arcLen(EXPR,VAR,START,END)
B8	nInt(EXPR,VAR,LOW,UP)
B9	_PI(product)_(EXPR,VAR,LOW,HIGH)
BA	_SIGMA_(EXPR,VAR,LOW,HIGH)
BB	mRowAdd(EXPR,MAT,INDEX1,INDEX2)
****Variable No. Parameters (Functions)****
BC	ans([INT])
BD	entry([INT])
BE	exact(EXPR[,TOL])

C0	comDenom(EXPR[,VAR])
C1	expand(EXPR[,VAR])
C2	factor(EXPR[,VAR])
C3	cFactor(EXPR[,VAR])
C4	_integrate_(EXPR,VAR[,LOW,UP])
C5	_differentiate_(EXPR,VAR[,ORDER])
C6	avgRC(EXPR,VAR[,H])
C7	nDeriv(EXPR,VAR[,H])
C8	taylor(EXPR,VAR,ORDER[,POINT])
C9	limit(EXPR,VAR,POINT[,DIRECTION])
CA	propFrac(EXPR[,VAR][,TOL])
CB	when(CONDITION,TRUE[,FALSE][,UNDEF])
CC	round(EXPR[,DIGITS])
CD	STRUCT DMSNUMBER {EXPR DD[,[EXPR MM][,EXPR SS]]}
CE	left(STRING[,NUM])
CF	right(STRING[,NUM])
D0	mid(STRING,START[,COUNT])
D1	shift(LIST[,INT])
D2	seq(EXPR,VAR,LOW,HIGH[,STEP])
D3	list->mat(LIST[,ELEMENTS PER ROW])
D4	subMat(MAT[,ROW1][,COL1][,ROW2][,COL2])
D5	matrix thing??
D6	rand([INT])
****Misc Items****
D7	min(EXPR1,EXPR2)
D8	max(EXPR1,EXPR2)
D9	TYPE/STRUCT list(/matrix) (LIST_TAG={) (this type of matrix uses lists of rows)
DA	execute function/program (only from within a program)
DB	TYPE/STRUCT matrix (Data Editor Type?) (MATRIX_TAG)
DC	TYPE/STRUCT program/function
DD	TYPE/STRUCT data
DE	TYPE/STRUCT GDB
DF	TYPE/STRUCT picture
E0	TYPE/STRUCT text
E1	TYPE/STRUCT figure
E2	TYPE/STRUCT macro
E3	*fn token (returns a value)
E4	*tibasic token (doesn't return a value)
E5	) or } (END_TAG)
E6	(C) (comment)
E7	: between tokens on same line
E8	: marks end of line in tibasic
E9	end of tibasic program

undefined values are stored as null starting/terminating strings

these are values which form the expressions, expressions can terminate in any
of the values and therefore they do not clash with any of the types described
in this file
		     
------------------------------------------------------------------------------
2.E1 - system tokens ($1C)
--------------------------
01	x_bar_
02	y_bar_
03	_SIGMA_x
04	_SIGMA_x_^2_
05	_SIGMA_y
06	_SIGMA_y_^2_
07	_SIGMA_xy
08	Sx
09	Sy
0A	_sigma_x
0B	_sigma_y
0C	nStat
0D	minX
0E	minY
0F	q1
10	medStat
11	q3
12	maxX
13	maxY
14	corr
15	R_^2_
16	medx1
17	medx2
18	medx3
19	medy1
1A	medy2
1B	medy3
1C	xc
1D	yc
1E	zc
1F	tc
20	rc
21	_THETA_c
22	nc
23	xfact
24	yfact
25	zfact
26	xmin
27	xmax
28	xscl
29	ymin
2A	ymax
2B	yscl
2C	_DELTA_x
2D	_DELTA_y
2E	xres
2F	xgrid
30	ygrid
31	zmin
32	zmax
33	zscl
34	eye_THETA_
35	eye_PHI_
36	_THETA_min
37	_THETA_max
38	_THETA_step
39	tmin
3A	tmax
3B	tstep
3C	nmin
3D	nmax
3E	plotStrt
3F	plotStep
40	zxmin
41	zxmax
42	zxscl
43	zymin
44	zymax
45	zyscl
46	zxres
47	z_THETA_min
48	z_THETA_max
49	z_THETA_step
4A	ztmin
4B	ztmax
4C	ztstep
4D	zxgrid
4E	zygrid
4F	zzmin
50	zzmax
51	zzscl
52	zeye_THETA_
53	zeye_PHI_
54	znmin
55	znmax
56	zpltstep
57	zpltstrt
58	seed1
59	seed2
5A	ok
5B	errornum
5C	sysMath
5D	sysData

5F	regCoef
60	tblInput
61	tblStart
62	_DELTA_tbl

------------------------------------------------------------------------------
2.E2 - function tokens ($E3)
----------------------------
01	# STRING-EXPR (indirection) {STRING-EXPR}
02	getKey()
03	getFold()
04	switch([INT])

06	ord(STRING)
07	expr(STRING)
08	char(INT)
09	string(EXPR)
0A	getType(VAR)
0B	getMode(STRING)
0C	setFold(VAR)
0D	ptTest(X,Y)
0E	pxlTest(ROW,COLUMN)
0F	setGraph(STRING,STRING)
10	setTable(STRING,STRING)
11	setMode(STRING,STRING)
12	format(EXPR[,STRING])
13	inString(SEARCH-STRING,SUBSTRING[,START])
14	STRING1 & STRING2 (append) {STRING2,STRING1}
15	DMSNUMBER |>DD {DMSNUMBER}
16	EXPR |>DMS {EXPR}
17	VEC |>Rect {VEC}
18	VEC |>Polar {VEC}
19	VEC |>Cylind {VEC}
1A	VEC |>Sphere {VEC}

B1	part? (not used)

------------------------------------------------------------------------------
2.E3 - program tokens ($E4)
---------------------------
****No Parameters****
01      ClrDraw
02      ClrGraph
03      ClrHome
04      ClrIO
05      ClrTable
06      Custom
07      Cycle
08      Dialog
09      DispG
0A      DispTbl
0B      Else (If...Endif)
0C      EndCustm
0D      EndDlog
0E      EndFor {DISPLACEMENT}
0F      EndFunc
10      EndIf
11      EndLoop {DISPLACEMENT}
12      EndPrgm
13      EndTBar
14      EndTry {DISPLACEMENT}
15      EndWhile {DISPLACEMENT}
16      Exit
17      Func
18      Loop
19      Prgm
1A      ShowStat
1B      Stop
1C      Then
1D      Toolbar
1E      Trace
1F      Try
20      ZoomBox
21      ZoomData
22      ZoomDec
23      ZoomFit
24      ZoomIn
25      ZoomInt
26      ZoomOut
27      ZoomPrev
28      ZoomRcl
29      ZoomSqr
2A      ZoomStd
2B      ZoomSto
2C      ZoomTrig
****One Parameter****
2D      DrawFunc EXPR
2E      DrawInv EXPR
2F      Goto LABEL {EXPR}
30      Lbl LABEL {EXPR}
31      Get VAR
32      Send LIST
33      GetCalc VAR
34      SendCalc VAR
35      NewFold FOLDERNAME
36      PrintObj VAR
37      RclGDB VAR
38      StoGDB VAR
39      ElseIf CONDITION
3A      If CONDITION
3B      If CONDITION Then {CONDITION}
3C      RandSeed EXPR
3D      While CONDITION
****Two Parameters****
3E      LineTan EXPR,POINT
3F      CopyVar VAR1,VAR2
40      Rename OLDVARNAME,NEWVARNAME
41      Style EXPR,STRING
42      Fill EXPR,VAR
43      Request STRING,VAR
44      PopUp ITEMLIST,VAR
45      PtChg X,Y
46      PtOff X,Y
47      PtOn X,Y
48      PxlChg ROW,COLUMN
49      PxlOff ROW,COLUMN
4A      PxlOn ROW,COLUMN
****Three Parameters****
4B      MoveVar VAR,OLD FOLDER,NEW FOLDER
4C      DropDown TITLE-STRING,{STRING1,...},VAR (note: {...} means list here)
4D      Output ROW,COLUMN,EXPR
4E      PtText STRING,X,Y
4F      PxlText STRING,ROW,COLUMN
50      DrawSlp X,Y,SLOPE
****Variable Number of Parameters****
51      Pause [EXPR]
52      Return [EXR]
53      Input [STRING,][VAR]
54      PlotsOff [1][,2] ... [,9]
55      PlotsOn [1][,2] ... [,9]
56      Title STRING[,LABEL]
57      Item STRING[,LABEL]
58      InputStr [STRING,]VAR
59      LineHorz Y[,DRAWMODE]
5A      LineVert X[,DRAWMODE]
5B      PxlHorz ROW[,DRAWMODE]
5C      PxlVert COLUMN[,DRAWMODE]
5D      AndPic PICVAR[,PXLROW,PXLCOL]
5E      RclPic PICVAR[,PXLROW,PXLCOL]
5F      RplcPic PICVAR[,PXLROW,PXLCOL]
60      XorPic PICVAR[,PXLROW,PXLCOL]
61      DrawPol EXPR[,_THETA_MIN][,_THETA_MAX][,_THETA_STEP]
62      Text STRING
63      OneVar L1[,L2][,L3][,L4]
64      StoPic VAR[,PXLROW,PXLCOL][,WIDTH,HEIGHT]
65      Graph EXPR1[,EXPR2][,VAR1][,VAR2]
66      Table EXPR1[,EXPR2][,VAR1]
67      NewPic MAT,PICVAR[,MAXROW][,MAXCOL]
68      DrawParm EXPR,EXPR[,TMIN,][,TMAX][,TSTEP]
69      CyclePic PICNAME-STRING,N[,WAIT],[CYCLES],[DIRECTION]
6A      CubicReg L1,L2[,[L3][,L4,L5]]
6B      ExpReg L1,L2[,[L3][,L4,L5]]
6C      LinReg L1,L2[,[L3][,L4,L5]]
6D      LnReg L1,L2[,[L3][,L4,L5]]
6E      MedMed L1,L2[,[L3][,L4,L5]]
6F      PowerReg L1,L2[,[L3][,L4,L5]]
70      QuadReg L1,L2[,[L3][,L4,L5]]
71      QuartReg L1,L2[,[L3][,L4,L5]]
72      TwoVar L1,L2[,[L3][,L4,L5]]
73      Shade EXPR1,EXPR2,[XLOW],[XHIGH],[PAT],[PATRES]
74      For VAR,LOW,HIGH[,STEP]
75      Circle X,Y,R[,DRAWMODE]
76      PxlCrcl ROW,COL,R[,DRAWMODE]
77      NewPlot N,TYPE,XLIST[,YLIST][,FRQ][,CAT][,INC][,MARK][,BUCKET]
78      Line XSTART,YSTART,XEND,YEND[,DRAWMODE]
79      PxlLine ROWSTART,COLSTART,ROWEND,COLEND[,DRAWMODE]
7A      Disp [EXPR,...]
7B      FnOff [1][,2] ... [,99]
7C      FnOn [1][,2] ... [,99]
7D      Local VAR1,...
7E      DelFold VAR1,...
7F      DelVar VAR1,...
80      Lock VAR1,...
81      Prompt VAR1,...
82      SortA LIST1,...
83      SortD LIST1,...
84      UnLock VAR1,...
85      NewData DATAVAR,LIST1,...
86      Define VAR(ARG1,...)=EXPR
****Misc Items****
87      Else (Try...Endtry) CONDITION
88      ClrErr 
89      PassErr

* {displacement} is the OFFSET (word), in the form LLHH (+ve memory), for the
the beginning of the statement from this word, note this is positive.

==============================================================================
3) Parameter Passing
==============================================================================
3.1 - Passing Parameters to Functions/Programs
----------------------------------------------
As shown above (2.B), each function/program has its parameters listed at the
end of the file. It is simple to intercept the parameters passed to a
function/program through Fargo)

Each function/program is given a temporary folder when it is run, in the form
0xxx (0001-0255), which is removed when the function/program is finished. This
folder serves two purposes:
1) Storing Local Variables in the function/program
2) Stores a copy of the Parameters passed to the program
The parameters are given the names defined in the header of the file, and the
local variables those used in the local definition. These types can be
distinguished from the file flags (see 1.2)

Note the handle of the temporary folder for the current program is given by
the value in RAM named DefTempHandle, and accessible as tios::DefTempHandle

These variables, in the table, are as you would expect, tokenised expressions,
so if they are to be used, it is for specific cases (i.e. positive integers 
- $1F), otherwise ROM routines should be used.

3.2 - Returning values from Functions
-------------------------------------
For functions (only) a single tokenised expression can be passed back.
Functions return the expression on the EStack.
Basically, handle $E contains the EStack, it is used for various calculations
in the ROM and in it's workings. By pushing the tokenised expression to this
EStack using many of the ROM calls available (i.e push_expression, or byte by
byte using push_quantum) and setting a status byte, the expression is returned
from the function. This status byte can be found at tios::main_lcd+$126E using
Fargo II. To return a value, this byte should be set to 2. I am not too sure
what the different values for this byte represent yet.

For any more details of this look at TESTFUNC.ASM in the Fargo release.
Note: in order to pass parameters to a Fargo function/program the TIBasic
tokens need to be modified to allow a parameter. These tokens can be defined
using the block (section):
[bss]
	section _tibasic
	[tibasic function/program (tokenised)]
_tibasic

For the format of functions/programs and token listings refer to the above
documentation.

==============================================================================
14) TI system variable addresses
==============================================================================
All addresses are in hexadecimal and relative to the lcd memory.

Variables available in all modes:

tblInput*       (tios::Heap+4*$11)      (i.e handle $11)

seed1           113E
seed2           1448

ok              197C
errornum        1986 

xc              1F78
yc              1F82
zc              1F8C
tc              1F96
rc              1FA0
_THETA_c        1FAA
nc              1FB4

tblStart        2004
_DELTA_tbl      200E

zxmin           208A
zxmax           2094
zxscl           209E
zymin           20A8
zymax           20B2
zyscl           20BC
zxres           20C6
ztmin           20D0
ztmax           20DA
ztstep          20E4
z_THETA_min     20EE
z_THETA_max     20F8
z_THETA_step    2102
znmin           210C
znmax           2116
zpltstrt        2120
zpltstep        212A
zzmin           2134
zzmax           213E
zzscl           2148
zeye_THETA_     2152
zeye_PHI_       215C
zxgrid          2166
zygrid          2170

xfact           245C
yfact           2466
zfact           2470
sysMath         247A

Variables available in particular modes:
Function:
xres            1B18

Parametric:
tmin            1BCC
tmax            1BDC
tstep           1BE0

Polar:
_THETA_min      1CA8
_THETA_max      1CB2
_THETA_step     1CBC

3D:
zmin            1E74
zmax            1E7E
zscl            1E88
eye_THETA_      1E92
eye_PHI_        1E9C

None (internal - (2.A)):
scale1?         1EA6
scale2?         1EB0

Variables available in all modes, independently of each other: 
                Func Parm Pol  Seq  3D
xmin            1AC8 1B7C 1C58 1D34 1E24
xmax            1AD2 1B86 1C62 1D3E 1E2E
xscl/xgrid      1ADC 1B90 1C6C 1D48 1E38
ymin            1AE6 1B9A 1C76 1D52 1E42
ymax            1AF0 1BA4 1C80 1D5C 1E4C
yscl/ygrid      1AFA 1BAE 1C8A 1D66 1E56
_DELTA_x        1B04 1BB8 1C94 1D70 1E60
_DELTA_y        1B0E 1BC2 1C9E 1D7A 1E6A

Note: xscl & yscl are used in 2 dimensions, xgrid & grid in 3.

* Type governed by file type (should be expression - $D9)
  Otherwise 10 byte BCD float structure

==============================================================================
5) USEFUL ROUTINES
==============================================================================
These routines, are merely examples of how to deal with the VAT on the TI92,
they will probably not serve much purpose as by resizing the file and folder
tables, the memory is rearranged, causing the program to move. (currently)
------------------------------------------------------------------------------

;-----------------------------------------;
; create_folder(CHAR *folder, WORD flags) ;
;-----------------------------------------;
; returns:  d0=handle of folder           ;
;           d0=1  folder already exists   ;
;           d0=2  not enough memory       ;
; destroys: d0-d3/a0-a3                   ;
;-----------------------------------------;
create_folder:
	move.l  #(12*10+4),-(a7)
	jsr     tios::HeapAlloc * Create Folder *
	lea     4(a7),a7

	tst.w   d0
	beq     \nomem
	move.w  d0,d4

	move.w  d0,-(a7)
*             /-----stack frame size ((return address)+link [if any])
*             | /---amount already pushed in current routine
*             | | /-displacement from last pushed item before being called
	move.w  4+2+4(a7),-(a7) ;flags
	or.w    #$0080,(a7)     ;make sure it is folder
	move.w  #$B,-(a7)
	move.l  4+6+0(a7),-(a7) ;folder
	bsr     add_sym_table   * Add folder entry *
	lea     $A(a7),a7

	tst     d0
	bne     \error
	move.w  d4,d0

	tios::DEREF     d4,a0   * Set max. and no. of files in folder *
	move.w  #$A,(a0)+
	clr.w   (a0)
\error:
	rts             
\nomem:
	moveq   #2,d0
	rts

;---------------------------------------------------------------;
; create_file(CHAR *name, HANDLE folder, WORD size, WORD flags) ;
;---------------------------------------------------------------;
; returns:  d0=handle of file                                   ;
;           d0=1  file already exists                           ;
;           d0=2  not enough memory                             ;
; destroys: d0-d4/a0-a3                                         ;
;---------------------------------------------------------------;
create_file:
	move.w  4+0+6(a7),-(a7) ;size
	clr.w   -(a7)
	jsr     tios::HeapAlloc * Create File *
	lea     4(a7),a7
	tst.w   d0
	beq     \nomem
	move.w  d0,d4

	move.w  d0,-(a7)        ;handle
	move.w  4+2+8(a7),-(a7) ;flags
	move.w  4+4+4(a7),-(a7) ;folder
	move.l  4+6+0(a7),-(a7) ;name
	bsr     add_sym_table   * Add file to folder table *
	lea     10(a7),a7

	tst     d0
	bne     \error

	move.w  d4,d0
	tios::DEREF     d4,a0   * Set the size of the variable *
	move.w  4+0+6(a7),(a0)
\error:
	rts             
\nomem:
	moveq   #2,d0
	rts

;--------------------------------------------------------------------;
; add_sym_table(CHAR *entry, HANDLE table, WORD flags, HANDLE entry) ;
;--------------------------------------------------------------------;
; returns:  d0=0  no error                                           ;
;           d0=1  file already exists                                ;
;           d0=2  not enough memory                                  ;
; destroys: d0-d3/a0-a3                                              ;
;--------------------------------------------------------------------;
add_sym_table:
	move.w  4+0+4(a7),-(a7) ;tablehnd
	move.l  4+2+0(a7),-(a7) ;entry
	bsr     find_sym_table  * Get Position to add entry *
	lea     6(a7),a7
	
	tst.w   d0
	bne     exists
	move.w  d1,d3
	neg.w   d3

	move.w  4+0+4(a7),d0    ;tablehnd
	move.w  d0,d1
	tios::DEREF     d1,a0   ;a0=address of table

	move.w  (a0),d1
	move.w  2(a0),d2
	cmp.w   d1,d2
	bne     skip_resize     ;need to resize table?

	add.w   #10,d1
	move.w  d1,(a0)
	muls    #12,d1
	addq    #6,d1

	movem.l d1/a0,-(a7)     * Resize the table to add entry *
	move.l  d1,-(a7)
	move.w  d0,-(a7)        ;tablehnd
	jsr     tios::HeapRealloc
	lea     6(a7),a7
	movem.l (a7)+,d1/a0

	tst.w   d0
	beq     nomem
skip_resize:
	tios::DEREF     d0,a0   ;not required

	add.w   #1,2(a0)        ;set number of entries
	move.w  2(a0),d0
	add.w   d0,d3           ;d3=number of entries from end
	muls    #12,d0          ;don't know what high word is
	lea     4(a0,d0.w),a0

	subq    #1,d3
	tst.w   d3
	beq.s   insert
copyloop:                       
	move.l  -(a0),12(a0)    * Make room for extra entry in table *
	move.l  -(a0),12(a0)
	move.l  -(a0),12(a0)
	dbra.s   d3,copyloop
insert:
	move.l  4+0+6(a7),8(a0) ;flags,handle
	clr.l   (a0)            ;clear the space for new entry
	clr.l   4(a0)

	move.l  4+0+0(a7),a1    ;entry

	moveq   #7,d0

copyfile:                       
	move.b  (a1)+,(a0)+     * Copy the entry into position *
	dbeq.s  d0,copyfile     ;d0.w=-1
	clr.l   d0
	rts
exists:
	moveq   #1,d0
	rts
nomem:
	moveq   #2,d0
	rts

;----------------------------------------------------------------------;
; find_sym_table(CHAR *name, HANDLE table)                             ;
;----------------------------------------------------------------------;
; returns:  d0=0 , d1=no. files from start of file table to place file ;
;   else    d0=handle of the file , d1=flags                           ;
; destroys: d0-d1/a0-a3                                                ;
; notes:                                                               ;
;  sorts through the file table {table}, entry by entry, and finds     ;
;  where {name} should be positioned if the file already exists then   ;
;  the handle and flags of that file is returned so it can be used as  ;
;  an extended core[find_var].                                         ;
;----------------------------------------------------------------------;
find_sym_table:
	move.l  4+0+0(a7),a1
	move.w  4+0+4(a7),d0
	tios::DEREF     d0,a0
	move.w  2(a0),d0
	subq    #1,d0
	move.w  d0,d1
	mulu    #12,d0
	lea     4(a0,d0.w),a0   ;a0 points to start of last entry
next_file:
	lea     (a0),a2
	lea     (a1),a3
	moveq   #7,d0
char_loop:
	cmp.b   (a2)+,(a3)+
	bne.s   file_change?
	tst.b   -1(a2)
	dbeq.s  d0,char_loop
	move.w  8(a0),d1        * Name already exists *
	move.w  10(a0),d0
	rts
file_change?:
	lea     -12(a0),a0
	dbgt.s  d1,next_file
	clr.l   d0              * Found position of name *
	addq    #1,d1
	rts

;----------------------------------------------------------------------;
; find_sym_table_binary(CHAR *name, HANDLE table)                      ;
;----------------------------------------------------------------------;
; returns:  d0=no. files from start of file table to place file        ;
;   else    d0=no. files from start of file table where {name} is      ;
; destroys: d0-d2/a0-a3                                                ;
; notes:                                                               ;
;  sorts through the file table {table}, binary sort, and finds where  ;
;  {name} should be positioned if the file already exists then the     ;
;  handle and flags of that file is returned so it can be used as an   ;
;  extended core[find_var]. UNTESTED!!!!!!                             ;
;----------------------------------------------------------------------;
binmove	MACRO
	lsr.w   #1,d1
	\1.w    d1,d0
	tst.w   d1
	dbeq.s  next_file
	rts
	ENDM

find_sym_table:
	move.l  4+0+0(a7),a1    a1 points to name to add
	move.w  4+0+4(a7),d0
	tios::DEREF     d0,a0
	move.w  2(a0),d1        d1 = number of files (index to jump)
	lea     4(a0),a0        a0 points to first file name in table
	clr.w   d0              d0 = current file index = 0

move_down:
	binmove add
move?:
	bgt.s   move_down
	binmove sub
next_file:
	move.w  d0,d2
	mulu    #12,d2
	lea     0(a0,d2.w),a2
	lea     (a1),a3
	moveq   #7,d2
char_loop:
	cmp.b   (a2)+,(a3)+
	bne.s   move?
	tst.b   -1(a2)
	dbeq.s  d2,char_loop
	rts
	

==============================================================================
Acknowledgements
----------------
David Ellsworth - Firstly for Fargo, and for all of the help that he has given
                  me since.
Mathieu Lacage  - Suggestions to this document & corrections :)
==============================================================================

I would appreciate if anyone has any suggestions or revisions as to this
document, I am not sure whether it is currently very informative and would
like it to be. Also feel free to email me with any questions on this file
or any other TI92 related question.

Gareth <Gareth-James@usa.net>

-----------------================== EOF ==================-------------------

