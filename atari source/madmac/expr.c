/*
 *  Expression analyzer
 *
 *	expr(tk, a_value, a_attr, a_esym)
 *	evexpr(tk, a_value, a_attr, a_esym)
 *
 */
#include "as.h"
#include "expr.h"		/* generated by `mkexpr' */
#include "sect.h"

extern VALUE pcloc;		/* value of PC at beginning of line */
extern char *comma_error;
extern VALUE dos_time();
extern VALUE dos_date();
char missym_error[] = "missing symbol";


/*
 *  Tunable definitions
 */
#define STKSIZE		64	/* size of expression stacks */
#define	EVSTACKSIZE	64	/* expression evaluator stack size */


/*
 * token classes
 * in order of precedence
 */
#define END	0		/* end/beginning of input */
#define ID	1		/* symbol or constant */
#define OPAR	2		/* ( */
#define CPAR	3		/* ) */
#define	SUNARY	4		/* special unary (^^defined, etc.) */
#define UNARY	5		/* unary class: ! ~ - */
#define MULT	6		/* multiplicative class: * / % */
#define ADD	7		/* additive class: + - */
#define SHIFT	8		/* shift class: << >> */
#define REL	9		/* relational class: <= >= < > <> = != */
#define AND	10		/* bitwise and: & */
#define XOR	11		/* bitwise xor: ^ */
#define OR	12		/* bitwise or: | */


extern char *seg_error;
extern int cursect;		/* current section (TDB) */
extern int curenv;		/* current local symbol enviroment level */
extern TOKEN *tok;		/* -> list of tokens from input */
static char tokcl[128];		/* (generated) table of token classes */
static VALUE evstk[EVSTACKSIZE]; /* evaluator value stack */
static WORD evattr[EVSTACKSIZE]; /* evaluator attribute stack */

char *str_error = "missing symbol or string";


/*
 *  token-class initialization list
 */
char itokcl[] = {
	0,				/* END */
	CONST, SYMBOL, 0,		/* ID */
	'(','[','{', 0,		/* OPAR */
	')',']','}', 0,		/* CPAR */
	CR_DEFINED, CR_REFERENCED,	/* SUNARY (special unary) */
	CR_STREQ, CR_MACDEF,
	CR_DATE, CR_TIME, 0,
	'!', '~', UNMINUS, 0,		/* UNARY */
	'*', '/', '%', 0,		/* MULT */
	'+', '-', 0,			/* ADD */
	SHL, SHR, 0,			/* SHIFT */
	LE, GE, '<', '>', NE, '=', 0, /* REL */
	'&', 0,			/* AND */
	'^', 0,			/* XOR */
	'|', 0,			/* OR */
	1				/* (the end) */
};


/*
 *  Initialize expression analyzer
 *
 */
iexpr()
{
	register int i;
	register char *p;

	/*
	 * initialize token-class table
	 */
	for (i = 0; i < 128; ++i)	/* mark all entries END */
		tokcl[i] = END;

	for (i = 0, p = itokcl; *p != 1; ++p)
		if (*p == 0)
			++i;
		else tokcl[*p] = i;
}




/*
 *  Convert expression to postfix
 *
 */
static TOKEN *tk;		/* deposit tokens here */
SYM *lookup();
SYM *newsym();
static VALUE str_value();	/* return numeric value of a string */


/*
 *  Recursive-descent expression analyzer
 *  (with some simple speed hacks)
 *
 */
expr(otk, a_value, a_attr, a_esym)
register TOKEN *otk;	/* -> buffer to place postfix expression */
VALUE *a_value;		/* -> value return */
WORD *a_attr;		/* -> value attribute return */
SYM **a_esym;		/* ->-> involved external symbol */
{
	register SYM *sy;
	register char *p;
	register int j;

	tk = otk;
	/*
	 *  Optimize for single constant or single symbol.
	 *
	 */
	if ((*tok == CONST || *tok == SYMBOL) &&
		  tokcl[tok[2]] < UNARY)
	{
		if (*tok == CONST)
		{
			*tk++ = CONST;
			*tk++ = *a_value = tok[1];
			*a_attr = ABS | DEFINED;
			if (a_esym != NULL)
				*a_esym = NULL;
		}
		else
		{
			p = (char *)tok[1];
			j = 0;
			if (*p == '.')
				j = curenv;
			sy = lookup(p, LABEL, j);

			if (sy == NULL)
				sy = newsym(p, LABEL, j);
			sy->sattr |= REFERENCED;

			*tk++ = SYMBOL;
			*tk++ = (TOKEN)sy;

			if (sy->sattr & DEFINED)
				*a_value = sy->svalue;
			else *a_value = 0;

			*a_attr = sy->sattr & ~GLOBAL;

			if ((sy->sattr & (GLOBAL|DEFINED)) == GLOBAL &&
				  a_esym != NULL)
				*a_esym = sy;
		}
		tok += 2;
		*tk++ = ENDEXPR;
		return OK;
	}

	if (expr0() != OK)
		return ERROR;
	*tk++ = ENDEXPR;
	return evexpr(otk, a_value, a_attr, a_esym);
}


/*
 *  Binary operators
 *  (all the same precedence)
 */
expr0()
{
	register TOKEN t;

	if (expr1() != OK)
		return ERROR;
	while (tokcl[*tok] >= MULT)
	{
		t = *tok++;
		if (expr1() != OK)
			return ERROR;
		*tk++ = t;
	}
	return OK;
}


/*
 *  Unary operators
 *  (detect unary '-')
 */
expr1()
{
	register int class;
	register TOKEN t;
	SYM *sy;
	char *p, *p2;
	WORD w;
	int j;

	class = tokcl[*tok];

	if (*tok == '-' ||
		  class == UNARY)
	{
		t = *tok++;
		if (expr2() != OK)
			return ERROR;
		if (t == '-')
			t = UNMINUS;
		*tk++ = t;
	}
	else if (class == SUNARY)
		switch ((int)*tok++) {
			case CR_TIME:
				*tk++ = CONST;
				*tk++ = dos_time();
				break;

			case CR_DATE:
				*tk++ = CONST;
				*tk++ = dos_date();
				break;

			case CR_MACDEF:		/* ^^macdef <macro-name> */
				if (*tok++ != SYMBOL) return error(missym_error);
				p = (char *)*tok++;
				if (lookup(p, MACRO, 0) == NULL) w = 0;
				else w = 1;

				*tk++ = CONST;
				*tk++ = (TOKEN)w;
				break;

			case CR_DEFINED:
				w = DEFINED;
				goto getsym;

			case CR_REFERENCED:
				w = REFERENCED;

getsym:
				if (*tok++ != SYMBOL) return error(missym_error);
				p = (char *)*tok++;
				j = 0;
				if (*p == '.') j = curenv;
				if ((sy = lookup(p, LABEL, j)) != NULL && (sy->sattr & w)) w = 1;
				else w = 0;

				*tk++ = CONST;
				*tk++ = (TOKEN)w;
				break;

			case CR_STREQ:
				if (*tok != SYMBOL && *tok != STRING) return error(str_error);
				p = (char *)tok[1];
				tok +=2;

				if (*tok++ != ',') return error(comma_error);

				if (*tok != SYMBOL && *tok != STRING) return error(str_error);
				p2 = (char *)tok[1];
				tok += 2;

				w = !strcmp(p, p2);
				*tk++ = CONST;
				*tk++ = (TOKEN)w;
				break;
		}
	else return expr2();

	return OK;
}


/*
 *  Terminals (CONSTs) and parenthesis grouping
 */
expr2()
{
	register char *p;
	register SYM *sy;
	register int j;

	switch ((int)*tok++)
	{
		case CONST:
			*tk++ = CONST;
			*tk++ = *tok++;
			break;

		case SYMBOL:
			p = (char *)*tok++;
			j = 0;
			if (*p == '.')
				j = curenv;

			sy = lookup(p, LABEL, j);
			if (sy == NULL)
				sy = newsym(p, LABEL, j);

			*tk++ = SYMBOL;
			*tk++ = (TOKEN)sy;
			break;

		case STRING:
			*tk++ = CONST;
			*tk++ = str_value(*tok++);
			break;

		case '(':
			if (expr0() != OK)
				return ERROR;
			if (*tok++ != ')')
				return error("missing close parenthesis ')'");
			break;

		case '[':
			if (expr0() != OK)
				return ERROR;
			if (*tok++ != ']')
				return error("missing close parenthesis ']'");
			break;

		case '$':
			*tk++ = ACONST;		/* attributed const */
			*tk++ = sloc;		/* current location */
			*tk++ = cursect | DEFINED; /* store attribs */
			break;

		case '*':
			*tk++ = ACONST;		/* attributed const */
			*tk++ = pcloc;		/* location at start of line */
			*tk++ = cursect | DEFINED; /* store attribs */
			break;

		default:
			return error("bad expression");
	}
	return OK;
}


/*
 *  Evaluate expression.
 *
 *  If the expression involves only ONE external symbol, the
 *  expression is UNDEFINED, but it's value includes everything
 *  but the symbol value, and `a_esym' is set to the external
 *  symbol.
 *
 */
evexpr(tk, a_value, a_attr, a_esym)
TOKEN *tk;			/* tokenized expression */
VALUE *a_value;		/* ==> expression result */
WORD *a_attr;		/* ==> expression attrib */
SYM **a_esym;		/* ==> -> external symbol (or NULL) */
{
	register WORD *sattr;
	register VALUE *sval;
	register WORD attr;
	register SYM *sy;
	SYM *esym;

	sval = evstk;			/* (empty) initial stack */
	sattr = evattr;
	esym = NULL;			/* no external symbol involved */

	while (*tk != ENDEXPR)
		switch ((int)*tk++)
		{
			case SYMBOL:
				sy = (SYM *)*tk++;
				sy->sattr |= REFERENCED; /* set "referenced" bit */

				if (!(sy->sattr & DEFINED))
				{
					if (!(sy->sattr & GLOBAL))
					{			/* reference to undefined symbol */
						*a_attr = 0;
						*a_value = 0;
						return OK;
					}
					if (esym != NULL)	/* check for multiple externals */
						return error(seg_error);
					esym = sy;
				}

				if (sy->sattr & DEFINED)
					*++sval = sy->svalue;	/* push symbol's value */
				else *++sval = 0;	/* 0 for undefined symbols */

				*++sattr = sy->sattr & ~GLOBAL;	/* push attribs */
				break;

			case CONST:
				*++sval = *tk++;	/* push value */
				*++sattr = ABS|DEFINED;	/* push simple attribs */
				break;

			case ACONST:
				*++sval = *tk++;	/* push value */
				*++sattr = *tk++;	/* push attribs */
				break;

				/*
				 *  Binary "+" and "-" matrix:
				 *
				 *		ABS	 Sect	  Other
				 *	     ----------------------------
				 *   ABS     |	ABS   |  Sect  |  Other |
				 *   Sect    |	Sect  |  [1]   |  Error |
				 *   Other   |	Other |  Error |  [1]   |
				 *	     ----------------------------
				 *
				 *   [1] + : Error
				 *       - : ABS
				 *
				 */
			case '+':
				--sval;			/* pop value */
				--sattr;		/* pop attrib */
				*sval += sval[1];	/* compute value */

				if (!(*sattr & (TEXT|DATA|BSS)))
					*sattr = sattr[1];
				else if (sattr[1] & (TEXT|DATA|BSS))
					return error(seg_error);
				break;

			case '-':
				--sval;			/* pop value */
				--sattr;		/* pop attrib */
				*sval -= sval[1];	/* compute value */

				attr = *sattr & (TEXT|DATA|BSS);
				if (!attr)
					*sattr = sattr[1];
				else if (sattr[1] & (TEXT|DATA|BSS))
					if (!(attr & sattr[1]))
						return error(seg_error);
					else *sattr &= ~(TEXT|DATA|BSS);
				break;


				/*
				 *  Unary operators only work on ABS items
				 */
			case UNMINUS:
				if (*sattr & (TEXT|DATA|BSS))
					error(seg_error);
				*sval = -*sval;
				*sattr = ABS|DEFINED;	/* expr becomes absolute */
				break;

			case '!':
				if (*sattr & (TEXT|DATA|BSS))
					error(seg_error);
				*sval = !*sval;
				*sattr = ABS|DEFINED;	/* expr becomes absolute */
				break;

			case '~':
				if (*sattr & (TEXT|DATA|BSS))
					error(seg_error);
				*sval = ~*sval;
				*sattr = ABS|DEFINED;	/* expr becomes absolute */
				break;


				/*
				 *  Comparison operators must have two values that
				 *  are in the same segment, but that's the only requirement.
				 */
			case LE:
				--sattr;
				--sval;
				if ((*sattr & TDB) != (sattr[1] & TDB)) error(seg_error);
				*sattr = ABS|DEFINED;
				*sval = *sval <= sval[1];
				break;

			case GE:
				--sattr;
				--sval;
				if ((*sattr & TDB) != (sattr[1] & TDB)) error(seg_error);
				*sattr = ABS|DEFINED;
				*sval = *sval >= sval[1];
				break;

			case '>':
				--sattr;
				--sval;
				if ((*sattr & TDB) != (sattr[1] & TDB)) error(seg_error);
				*sattr = ABS|DEFINED;
				*sval = *sval > sval[1];
				break;

			case '<':
				--sattr;
				--sval;
				if ((*sattr & TDB) != (sattr[1] & TDB)) error(seg_error);
				*sattr = ABS|DEFINED;
				*sval = *sval < sval[1];
				break;

			case NE:
				--sattr;
				--sval;
				if ((*sattr & TDB) != (sattr[1] & TDB)) error(seg_error);
				*sattr = ABS|DEFINED;
				*sval = *sval != sval[1];
				break;

			case '=':
				--sattr;
				--sval;
				if ((*sattr & TDB) != (sattr[1] & TDB)) error(seg_error);
				*sattr = ABS|DEFINED;
				*sval = *sval == sval[1];
				break;


				/*
				 *  All other binary operators must have two ABS items
				 *  to work with.  They all produce an ABS value.
				 */
			default:
				if ((*sattr & (TEXT|DATA|BSS)) ||
					  (*--sattr & (TEXT|DATA|BSS)))
					error(seg_error);

				*sattr = ABS|DEFINED;	/* expr becomes absolute */
				switch ((int)tk[-1])
				{
					case '*':
						--sval;
						*sval *= sval[1];
						break;

					case '/':
						--sval;
						if (sval[1] == 0)
							return error("divide by zero");
						*sval /= sval[1];
						break;

					case '%':
						--sval;
						if (sval[1] == 0)
							return error("mod (%) by zero");
						*sval %= sval[1];
						break;


					case SHL:
						--sval;
						*sval <<= sval[1];
						break;

					case SHR:
						--sval;
						*sval >>= sval[1];
						break;

					case '&':
						--sval;
						*sval &= sval[1];
						break;

					case '^':
						--sval;
						*sval ^= sval[1];
						break;

					case '|':
						--sval;
						*sval |= sval[1];
						break;

					default:
						interror(5);	/* bad operator in expression stream */
						/*NOTREACHED*/
				}
		}

	if (esym != NULL)
		*sattr &= ~DEFINED;
	if (a_esym != NULL)
		*a_esym = esym;

	*a_attr = *sattr;		/* copy value + attrib */
	*a_value = *sval;

	return OK;
}


static VALUE str_value(p)
register char *p;
{
	register VALUE v;

	for (v = 0; *p; ++p)
		v = (v << 8) | (*p & 0xff);
	return v;
}
