106,111d105
< /*	Check control key for nodisk system at main 8/13/91	D.Mui	*/
< /*	Exit graphic mode before closing work station 12/20/91		*/
< /*	Change at gsx_malloc for saving 25 columns of screen 7/7/92 Mui	*/
< /*	Add 3D stuff				7/7/92		D.Mui	*/
< /*	Add code to do sparrow res change	7/17/92		D.Mui	*/
< /*	Add new variables			8/1/92		D.Mui	*/
112a107
> 
129,131d123
< #include <osbind.h>
< #include <vdidefs.h>
< #include <mode.h>
142c134,191
< EXTERN BYTE	*save_2();
---
> typedef struct wsstr
> {
> 	WORD		ws_xres;
> 	WORD		ws_yres;
> 	WORD		ws_noscale;
> 	WORD		ws_wpixel;
> 	WORD		ws_hpixel;
> 	WORD		ws_ncheights;
> 	WORD		ws_nlntypes;
> 	WORD		ws_nlnwidths;
> 	WORD		ws_nmktypes;
> 	WORD		ws_nmksizes;
> 	WORD		ws_nfaces;
> 	WORD		ws_npatts;
> 	WORD		ws_nhatchs;
> 	WORD		ws_ncolors;
> 	WORD		ws_ngdps;
> 	WORD		ws_supgdps[10];
> 	WORD		ws_attgdps[10];
> 	WORD		ws_color;
> 	WORD		ws_rotate;
> 	WORD		ws_fill;
> 	WORD		ws_cell;
> 	WORD		ws_npals;
> 	WORD		ws_nloc;
> 	WORD		ws_nval;
> 	WORD		ws_nchoice;
> 	WORD		ws_nstring;
> 	WORD		ws_type;
> 	WORD		ws_pts0;
> 	WORD		ws_chminh;
> 	WORD		ws_pts2;
> 	WORD		ws_chmaxh;
> 	WORD		ws_lnminw;
> 	WORD		ws_pts5;
> 	WORD		ws_lnmaxw;
> 	WORD		ws_pts7;
> 	WORD		ws_pts8;
> 	WORD		ws_mkminw;
> 	WORD		ws_pts10;
> 	WORD		ws_mkmaxw;
> } WS;
> 
> 
> typedef struct fdbstr
> {
> 	LONG		fd_addr;
> 	WORD		fd_w;
> 	WORD		fd_h;
> 	WORD		fd_wdwidth;
> 	WORD		fd_stand;
> 	WORD		fd_nplanes;
> 	WORD		fd_r1;
> 	WORD		fd_r2;
> 	WORD		fd_r3;
> } FDB;
> 
> 
163,164d211
< 
< EXTERN	WORD	gl_hbox;
190d236
< EXTERN UWORD	d_rezword;
206d251
< EXTERN WORD	intout[];
233c278
< GLOBAL LONG	gl_vdo;
---
> 
247,248c292
< GLOBAL WORD	ctldown;	/* ctrl key down ?	*/
< /* 8/1/92 */
---
> 
341,344c385,386
< /*	Set the resolution	*/
< 
< 	VOID	
< setres()
---
> adjgcol(color)
> unsigned int color;
346c388,389
< 	int	mode;
---
>     OBJECT  *obj;
>     int	    i;
348,357c391,392
< 	if ( ( gl_vdo & 0x30000L ) == 0x30000L )
< 	{
< 	  if ( !( d_rezword & 80 ) )
< 	  {
< 	    mode = mon_type();
< 	    intin[0] = 5;
< 	    gl_ws.ws_xres = d_rezword;
< 	  }
< 	}
< }
---
>     if (gl_ws.ws_ncolors > LWHITE)
> 	return;
358a394,398
>     rs_gaddr(ad_sysglo, R_TREE, SELECTOR, &obj);
>     obj[FCLSBOX].ob_spec = (obj[FCLSBOX].ob_spec & 0xfffffff0) | color;
>     obj[FUPAROW].ob_spec = (obj[FUPAROW].ob_spec & 0xfffffff0) | color;
>     obj[FDNAROW].ob_spec = (obj[FDNAROW].ob_spec & 0xfffffff0) | color;
>     obj[FSVELEV].ob_spec = (obj[FSVELEV].ob_spec & 0xfffffff0) | color;
359a400,402
>     for (i = DRIVEA; i <= DRIVEP; i++)
> 	obj[i].ob_spec = (obj[i].ob_spec & 0xfffffff0) | color;
> }
370a414
> 
476d519
< 	/* New stuff 8/13/91	*/
478,480d520
< 	ctldown = Getshift( -1 ) & 0x0004 ? TRUE : FALSE;
< 
< 
483,484c523,525
< 	if ( !ctldown )
< 	  ldaccs();				/* load in accessories	*/
---
> 	ldaccs();				/* load in accessories	*/
> 
> /*	sh_start();*/				/* turn on the shell	*/
505c546
< 	/* 8/1/92	*/
---
> 
520a562
> 
522a565,567
> /* July 14 1992 - ml.  fix up GEM resource colors */
> 	adjgcol(WHITE);
> 
529a575
> /*
534c580
< /*	  gsx_trans(bi.bi_pdata, bi.bi_wb, bi.bi_pdata, bi.bi_wb, bi.bi_hl);	*/
---
> 	  gsx_trans(bi.bi_pdata, bi.bi_wb, bi.bi_pdata, bi.bi_wb, bi.bi_hl);
535a582
> */
568,572c615
< 	mn_init();
< 		
< 	ini_fsel();
< 
< 				/* startup gem libs	*/
---
> 						/* startup gem libs	*/
638,639d680
< 	mn_new();
< 
650a692,693
> 						/* close workstation	*/
> 	gsx_wsclose();
654,655d696
< 						/* close workstation	*/
< 	gsx_wsclose();
701,705d741
< 	gl_vdo = 0x0L;
< 				/* _VDO */		/* 7/17/92 */
< 	getcookie( 0x5F56444FL, &gl_vdo );
< 
< 	
713,715d748
< 	if ( ctldown )
< 	  goto p_1;
< 
748c781
< p_1:
---
> 
769a803,804
> 		temp += 5;		/* skip other envr stuff	*/
> 		scan_2(temp, &res);	/* don't get the return code	*/
772,773c807,808
< 		  scan_2( temp+11, &cache );	/* fixed 6/26/90 Mui	*/
< 						/* fixed 7/17/92	*/
---
> 		  scan_2( temp+6, &cache );/* fixed 6/26/90	Mui	*/
> 		
781,802c816,818
< 					/* if sparrow mode 7/17/92	*/
< 		if ( ( gl_vdo & 0xFFFF0000L ) == 0x00030000L )	
< 		{			/* not an extended mode 	*/	
< 		  if ( gl_reschange )	/* 7/21/92 */
< 		  {
< 		    temp = save_2( temp+14, d_rezword >> 8 ); 	
< 		    save_2( temp, d_rezword );	
< 		  }
< 		  else
< 		  {	
< 		    if ( *(temp+14) != 0xD )
< 		    {
< 		      temp += 14;
< 		      temp = scan_2( temp, &res );
< 		      d_rezword = res << 8;
< 		      temp = scan_2( temp, &res ); 	
< 		      d_rezword |= res;  	
< 		    }
< 		    else
< 		      break;
< 		  }
< 		}
---
> 
> 		if (gl_reschange)	/* if we've been here before	*/
> 		  save_2( temp, (res & 0xF0 )|( gl_restype ));
805,815c821,824
< 		  temp += 5;		/* skip other envr stuff	*/
< 		  scan_2(temp, &res);	/* don't get the return code	*/
< 		  if ( gl_reschange )	/* if we've been here before	*/
< 		    save_2( temp, (res & 0xF0 )|( gl_restype ));
< 		  else
< 		  {	
< 		    res &= 0xF;
< 		    gl_reschange = FALSE;
< 		    if ( !app_reschange( res ) )
< 		      change = FALSE;	/* NO no res change		*/
< 		  } 
---
> 		  res &= 0xF;
> 		  gl_reschange = FALSE;
> 		  if ( !app_reschange( res ) )
> 		    change = FALSE;	/* NO no res change		*/
829a839
> 
832c842
< 	WORD
---
> 	VOID
842c852,868
< 	gl_tmp.fd_addr = dos_alloc( gl_mlen ); 
---
> 
> 	if ( !( gl_tmp.fd_addr = dos_alloc( gl_mlen ) ) )
> 	  return;
> }
> 
> 
> #if 0
> /*     save 1/2 of the screen memory	*/
> 
> 	WORD
> gsx_malloc()
> {
> 	gsx_fix( &gl_tmp, 0x0L, 0x0L );
> 
> 	gl_mlen = (LONG)(( gl_ws.ws_yres + 1 ) * ( gl_ws.ws_xres + 1 ) );
> 	gl_mlen = ( gl_mlen * gl_nplanes ) / 16; 
> 	gl_tmp.fd_addr = dos_alloc( gl_mlen );
843a870,872
> #endif
> 
> 
Return code 2
