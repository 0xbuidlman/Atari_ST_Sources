Date:		5/21/93
Updated:	6/15/93
Author:		Hans-Martin Krober


			ATARI TOS 5.01 Release Notes

Softloaded Resources
--------------------

It is now possible to load the TOS resource files. At boot time, TOS looks
for the following files in the MULTITOS direoctory of the boot drive:
	GEM.RSC		- AES resource file
	DESKTOP.RSC	- Desktop's resource file
	KEYBD.TBL	- XBIOS Keyboard table

The reosurce files are ordinary GEM resource files but with version number 
checking. The first byte in the resource header of the resource file
contains the version number.

The format of the KEYBD.TBL file is:

	[ unshifted keyboard table (128 Bytes)     ]
	[ shifted keyboard table (128 Bytes)       ]
	[ caps lock keyboard table (128 Bytes)     ]
	{ alternate unshifted keyboard table **    }
	{ alternate shifted keyboard table **      }
	{ alternate caps lock keyboard table **    }
 
 	**: An alternate keyboard table is a list of two bytes pairs.
 	    The list is NUL terminated.
 
  	Use an assembler (madmac), aln and fixrom to create the tables. You
 	can get the data for the tables from bios.s.
  
 	This works only a 100% on machines with the AKP code (since 5/92)
 	in the bios. Older versions have the alternate key handling hard
 	coded while the bios with AKP uses tables for the alternate key
 	handling.

Example: The German keyboard table:

;
;	Keyboard Table for ATARI ST/TT/FALCON030
;	Keyboard: German
;	02/12/92 (from bios.s)
;	Used for loadable keyboard tables
;
;	Makefile lines:
;	--------------
;	keybd.tbl: kbtblgrm.s
;	mac kbtblgrm.s
;	aln -o keybdgrm.tbl -a 0 x x kbtblgrm.o
;	fixrom keybdgrm.tbl
;
;
;	NOTE:	Alternate keyboard table will only work on machines with
;		_AKP cookie set. This was introduced in 05/92.

	.even
	.data

	dc.w	$2771				; magic word for keybd table

	dc.b	$00,$1b,'1','2','3','4','5','6' ; unshifted
	dc.b	'7','8','9','0',$9e,$27,$08,$09
	dc.b	'q','w','e','r','t','z','u','i'
	dc.b	'o','p',$81,'+',$0D,$00,'a','s'
	dc.b	'd','f','g','h','j','k','l',$94
	dc.b	$84,'#',$00,'~','y','x','c','v'
	dc.b	'b','n','m',',','.','-',$00,$00
	dc.b	$00,$20,$00,$00,$00,$00,$00,$00

	dc.b	$00,$00,$00,$00,$00,$00,$00,$00 
	dc.b	$00,$00,'-',$00,$00,$00,'+',$00
	dc.b	$00,$00,$00,$7f,$00,$00,$00,$00
	dc.b	$00,$00,$00,$00,$00,$00,$00,$00
	dc.b	'<',$00,$00,'(',')','/','*','7'
	dc.b	'8','9','4','5','6','1','2','3'
	dc.b	'0','.',$0D,$00,$00,$00,$00,$00
	dc.b	$00,$00,$00,$00,$00,$00,$00,$00

grmshif:
	dc.b	$00,$1b,'!','"',$dd,'$','%','&'	; shifted
	dc.b	'/','(',')','=','?','`',$08,$09
	dc.b	'Q','W','E','R','T','Z','U','I'
	dc.b	'O','P',$9a,'*',$0D,$00,'A','S'
	dc.b	'D','F','G','H','J','K','L',$99
	dc.b	$8e,'^',$00,'|','Y','X','C','V'
	dc.b	'B','N','M',';',':','_',$00,$00
	dc.b	$00,$20,$00,$00,$00,$00,$00,$00

	dc.b	$00,$00,$00,$00,$00,$00,$00,$37
	dc.b	$38,$00,'-',$34,$00,$36,'+',$00
	dc.b	$32,$00,$30,$7f,$00,$00,$00,$00
	dc.b	$00,$00,$00,$00,$00,$00,$00,$00
	dc.b	'>',$00,$00,'(',')','/','*','7'
	dc.b	'8','9','4','5','6','1','2','3'
	dc.b	'0','.',$0D,$00,$00,$00,$00,$00
	dc.b	$00,$00,$00,$00,$00,$00,$00,$00

grmcl:
	dc.b	$00,$1b,'1','2','3','4','5','6' ; caps lock
	dc.b	'7','8','9','0',$9e,$27,$08,$09
	dc.b	'Q','W','E','R','T','Z','U','I'
	dc.b	'O','P',$9a,'+',$0D,$00,'A','S'
	dc.b	'D','F','G','H','J','K','L',$99
	dc.b	$8e,'#',$00,'~','Y','X','C','V'
	dc.b	'B','N','M',',','.','-',$00,$00
	dc.b	$00,$20,$00,$00,$00,$00,$00,$00

	dc.b	$00,$00,$00,$00,$00,$00,$00,$00
	dc.b	$00,$00,'-',$00,$00,$00,'+',$00
	dc.b	$00,$00,$00,$7f,$00,$00,$00,$00
	dc.b	$00,$00,$00,$00,$00,$00,$00,$00
	dc.b	'<',$00,$00,'(',')','/','*','7'
	dc.b	'8','9','4','5','6','1','2','3'
	dc.b	'0','.',$0D,$00,$00,$00,$00,$00
	dc.b	$00,$00,$00,$00,$00,$00,$00,$00

	; alternate keyboard tables

grmatran:
	dc.b	$1a,'@',  $27,'[',  $28,']',  0	; alternate unshifted
grmashif:
	dc.b	$1a,$5c,  $27,'{',  $28,'}',  0	; 5c is '\', alt shift
grmacl:
	dc.b	$1a,'@',  $27,'[',  $28,']',  0 ; alt caps lock




Bug Fix: Menu Bar Problem
-------------------------
 
The system does not hang anymore when you move the mouse cursor into the Desk
menu while launching a new application.


Bug Fix: objc_edit
------------------

A FBOXTEXT object or BOXTEXT object with outlined flag set and right or left
aligned text will now always draw the cursor properly. Right aligned text
works correctly now.


Bug Fix: menu_bar
-----------------

MultiTOS makes sure now that after a menu_bar(tree, 0) the menu stays disabled
even after an application was swapped out and in.


Bug Fix: Popup Menus
--------------------

Popup menus don't get blocked anymore when mouse enters the menu bar while a
popup menu is displayed.


Bug Fix: Selected Icons
-----------------------

After launching an application under MultiTOS the icon now gets deselected.


Desktop: Scrolling while selecting icons
----------------------------------------

When the user selects icons or text lines in desktop windows using the rubber
band and the rubber band exceeds the window's work area, the window will
start to scroll. 


Window Iconifying
----------------------------------------

How to use the AES Window Iconify Feature
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1.) The SMALLER Gadget

    To create a window which can be iconified the application has to specify 
the SMALLER gadget in the window "kind" parameter of a wind_create() call.

Example:
    wind_create(NAME|SIZER|MOVER|CLOSER|FULLER|SMALLER, x, y, w, h);

Binding:
#define SMALLER	0x1000

    
2.) New Messages

    There are two new messages for the iconify feature: WM_ICONIFY and
WM_UNICONIFY. When the user clicks on the SMALLER gadget of a window, the
AES will send a WM_ICONIFY message to the application. The application
should then iconify its window. Double clicking on the work area of an
iconified window will cause the AES to send a WM_UNICONIFY message to
the application. The application should respond to that message by bringing
the window back to its original state.

When the user holds down the CONTROL key while selecting the SMALLER
gadget of a window, the AES will send a WM_ALLICONIFY message. The
application should then close all its windows and open a new, iconified
windows. This iconified window represents all of the application's
windows. The application has to keep trakc itself that all its
windows are closed and the "All Iconified" window is open. A double
click on the work area of this iconified window will cause the AES
to send a WM_UNICONIFY message. The application should then reopen
its windows and close the "All Iconified" window. 

WM_ICONIFY:
	msgbuff[0] = WM_ICONIFY 
	msgbuff[3] = window handle
	msgbuff[4] = x coordinate of icon window
	msgbuff[5] = y coordinate of icon window
	msgbuff[6] = width of icon window
	msgbuff[7] = height of icon window

WM_UNICONIFY:
	msgbuff[0] = WM_UNICONIFY
	msgbuff[3] = window handle
	msgbuff[4] = x coordinate of orignal window
	msgbuff[5] = y coordinate of orignal window
	msgbuff[6] = width of orignal window
	msgbuff[7] = height of orignal window

WM_ALLICONIFY:
	msgbuff[0] = WM_ALLICONIFY 
	msgbuff[3] = window handle
	msgbuff[4] = x coordinate of icon window
	msgbuff[5] = y coordinate of icon window
	msgbuff[6] = width of icon window
	msgbuff[7] = height of icon window

Binding:
#define WM_ICONIFY	34
#define WM_UNICONIFY	35
#define WM_ALLICONIFY	36


3.) New wind_set() Calls

There are three new calls to wind_set():

	WORD wind_set(handle, WF_ICONIFY, x, y, w, h)
	WORD handle;
	WORD x, y, w, h;
	
This call will iconify a window to the given width and height and place it
at the given coordinates. All window gadgets but the move and title bar will
be removed by this call. The font in the title bar will be set to SMALL
(6 point). A WM_REDRAW message will be send to the application to redraw the
work area of the iconified window. It is recommended to draw an icon inside
the work area. The standard size of an iconified window is 72 by 72.

The AES will now look for double clicks inside the work area to send a
WM_UNICONIFY message to the application.

If an application closes an iconified window and then opens it again, it
will still be in the iconified state. Before closing a window an application
should check if the window is iconified and if so, bring it back to its
original state before closing it.


	WORD wind_set(handle, WF_UNICONIFY, x, y, w, h)
	WORD handle;
	WORD x, y, w, h;
	
This call will uniconify a window to the given width and height and place it
at the given coordinates, meaning the window will go back to its original
state. All of the window's gadgets will again be added by this call. The font
in the title bar will be reset to IBM. A WM_REDRAW message will be send to
the application to redraw its work area.


	WORD wind_set(handle, WF_UNICONIFYXYWH, x, y, w, h)
	WORD handle;
	WORD x, y, w, h;

This call will set the coordinates and size which will be send to a window
when it gets the WM_UNICONIFY message. Normally the AES sends the coordinates
and size of the window which it had before it got iconified. This call is
needed if a window is opened in iconified state.

Binding:
#define WF_ICONIFY		26
#define WF_UNICONIFY		27
#define WF_UNICONIFYXYWH	28


4.) New wind_get() Calls

There are two new calls to wind_get():

	WORD wind_get(handle, WF_ICONIFY, iconified, icn_w, icn_h, dummy)
	WORD handle;
	WORD *iconified, *icn_w, *icn_h, *dummy;

This call will return the state of a window. A value of TRUE states that the
window is iconified.

	iconified == TRUE	--> window is iconified
	iconified == FALSE	--> window is not iconified

It also returns the width and height the AES sends to windows when they get
iconified.


	WORD wind_get(handle, WF_UNICONIFY, x, y, w, h)
	WORD handle;
	WORD *x, *y, *w, *h;

This call will return the x and y coordinates as well as the width and
height of an iconified window's orignal coordinates and size. That are
the coordinates and size of the window before it was iconified.


5.) Example Code

	.
	WINDOW	*win;
	.
	.
	win->handle = wind_create(NAME|SIZER|MOVER|CLOSER|FULLER|SMALLER,
			full.g_x, full.g_y, full.g_w, full.g_h);
	.
	.

	event = evnt_multi( MU_MESAG|MU_BUTTON|MU_KEYBD, 2, 1, 1,
			      0, 0, 0, 0, 0,
			      0, 0, 0, 0, 0,
			      (LONG) msgbuff,	/* message buffer	*/
			      0, 0,		/* timer counter	*/
			      &mx, &my, &button, &kstat, &kreturn, &clicks
			  );
	.
	.
	if (event & MU_MESAG) {
		switch (msgbuff[0]) {
			.
			.
		case WM_ICONIFY:
		    if ((win = get_win(msgbuff[3])) == NULL)
		    	break;
		    form_dial(FMD_SHRINK,
			msgbuff[4], msgbuff[5], msgbuff[6], msgbuff[7],
			win->work.g_x, win->work.g_y,
			win->work.g_w, win->work.g_h);
				
		    wind_set(msgbuff[3], WF_ICONIFY,
		    	msgbuff[4], msgbuff[5], msgbuff[6], msgbuff[7]);

		    wind_get(msgbuff[3], WF_WORKXYWH,
		    	&win->work.g_x, &win->work.g_y,
			&win->work.g_w, &win->work.g_h);
		    break;
		    
		case WM_UNICONIFY:
		    if ((win = get_win(msgbuff[3])) == NULL)
		    	break;
		    form_dial(FMD_GROW,
		    	win->work.g_x, win->work.g_y,
			win->work.g_w, win->work.g_h,
			msgbuff[4], msgbuff[5], msgbuff[6], msgbuff[7]);
				
		    wind_set(msgbuff[3], WF_UNICONIFY,
		    	msgbuff[4], msgbuff[5], msgbuff[6], msgbuff[7]);

		    wind_get(msgbuff[3], WF_WORKXYWH,
		    	&win->work.g_x, &win->work.g_y,
			&win->work.g_w, &win->work.g_h);
		    break;

		case WM_REDRAW:
		    if ((win = get_win(msgbuff[3])) == NULL)
		    	break;
		    wind_get(msgbuff[3], WF_ICONIFY, &iconified,
		    	&dummy, &dummy &dummy);
		    if (iconified)
		    	redraw_iconWindow(win, msgbuff[4], msgbuff[5],
		    	    msgbuff[6], msgbuff[7]);
		    else
			redraw_normalWindow(win, msgbuff[4], msgbuff[5],
		    	    msgbuff[6], msgbuff[7]);
		    break;	    		
		.
		.
		.
	


Replacing the System Font
-------------------------

By using the AE_FONTID and AE_PNTSIZE variables in the GEM.CNF file, the
user can now replace the system font and or change its size. 
NOTE: The replacement font has to be a Speedo GDOS font.

Sample GEM.CNF lines:

AE_FONTID=5		# use Speedo GDOS font with Font ID 5
AE_PNTSIZE=18		# Use a point size 18
 
or:

AE_PNTSIZE=24		# change the size of the system font to 24 points


Changing the font the desktop uses in its windows
-------------------------------------------------

Using the "Set Color & Style..." dialog box the user is able to change the
font as well as the size of the font which the GEM desktop uses in its
windows.


TEDINFO objects supporting Speedo GDOS fonts
--------------------------------------------

It is possible now to specify not only IBM and SMALL as the font used by a
TEDINFO object. The available options for te_font are:

#define GDOS_PROP       0	/* Speedo GDOS font			    */
#define GDOS_MONO       1	/* Speedo GDOS font, force monospace output */ 
#define GDOS_BITM       2	/* GDOS bit map font			    */
#define IBM             3 	/* System font 				    */
#define SMALL           5 	/* Small system font		  	    */

Also, the TEDINFO structure has changed. The old structure looked like this:

TEDINFO
{
        LONG            te_ptext;       /* ptr to text (must be 1st)    */
        LONG            te_ptmplt;      /* ptr to template              */
        LONG            te_pvalid;      /* ptr to validation chrs.      */
        WORD            te_font;        /* font                         */
        WORD            te_resrvd1;     /* reserved			*/
        WORD            te_just;        /* justification- left, right...*/
        WORD            te_color;       /* color information word       */
        WORD            te_resrvd2;     /* reserved			*/
        WORD            te_thickness;   /* border thickness             */
        WORD            te_txtlen;      /* length of text string        */
        WORD            te_tmplen;      /* length of template string    */
};

The reserved fields are used now and the strucure has changed to:

TEDINFO
{
        LONG            te_ptext;       /* ptr to text (must be 1st)    */
        LONG            te_ptmplt;      /* ptr to template              */
        LONG            te_pvalid;      /* ptr to validation chrs.      */
        WORD            te_font;        /* font                         */
        WORD            te_fontid;      /* GDOS font id			*/
        WORD            te_just;        /* justification- left, right...*/
        WORD            te_color;       /* color information word       */
        WORD            te_fontsize;    /* GDOS font size in points	*/
        WORD            te_thickness;   /* border thickness             */
        WORD            te_txtlen;      /* length of text string        */
        WORD            te_tmplen;      /* length of template string    */
};

If the te_font field contains GDOS_PROP, GDOS_MONO, GDOS_BITM the application
specifies in te_fontid which GDOS font the AES uses to draw this TEDINFO
field. The AES sets the font size to the number of points according to the
te_fontsize field.

GDOS_MONO will force the output of a Speedo GDOS font to be monospaced. 

All the above works fine with editable text fields (FTEXT objects), too. 
Also, you are able to specify now SMALL as the font (te_font field) in 
FTEXT objects. In previous versions of GEM that would lead to strange 
results.


-->> NOTE: ATARI SPEEDO GDOS VERSION 4.11 (!!!) IS REQUIRED.


Sample Code:

	.
	.
	init_vdi();
	init_aes();
	.
	.
	rsrc_gaddr(R_TREE, BOX, &tree);

	ted = (TEDINFO*) tree[TEXT1].ob_spec;
	ted->te_font = GDOS_PROP;  /* use Speedo GDOS font */
	ted->te_just = TE_LEFT;	   /* left justified 	   */	
 	ted->te_fontid = 5;	   /* use font with ID 5   */
	ted->te_fontsize = 18;	   /* 18 points 	   */

	ted = (TEDINFO*) tree[FTEXT1].ob_spec;
	ted->te_font = GDOS_MONO;  /* use Speedo GDOS font, force monospaced */
	ted->te_just = TE_RIGHT;   /* right justified 	   */	
 	ted->te_fontid = 6;	   /* use font with ID 5   */
	ted->te_fontsize = 8;	   /* 8 points 	   	   */

	ted = (TEDINFO*) tree[FBOXTEXT2].ob_spec;
	ted->te_font = GDOS_MONO;  /* use Speedo GDOS font, force monospaced */
	ted->te_just = TE_CNTR;    /* centered	 	   */	
 	ted->te_fontid = 5;	   /* use font with ID 5   */
	ted->te_fontsize = 10;	   /* 10 points 	   */

	form_dial(FMD_START, ...);
	objc_draw(tree, ...);

	form_do(tree, FTEXT1);
	.
	.
