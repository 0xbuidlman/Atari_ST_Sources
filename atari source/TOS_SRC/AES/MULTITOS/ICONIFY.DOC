
How to use the AES Window Iconify Feature
=========================================

1.) The SMALLER Gadget

    To create a window which can be iconified the application has to specify 
the SMALLER gadget in the window "kind" parameter of a wind_create() call.

Example:
    wind_create(NAME|SIZER|MOVER|CLOSER|FULLER|SMALLER, x, y, w, h);

    
2.) New Messages

    There are two new messages for the iconify feature: WM_ICONIFY and
WM_UNICONIFY. When the user clicks on the SMALLER gadget of a window, the
AES will send a WM_ICONIFY message to the application. The application
should then iconify its window. Double clicking on the work area of an
iconified window will cause the AES to send a WM_UNICONIFY message to
the application. The application should respond to that message by bringing
the window back to its original state.

WM_ICONIFY:
	msgbuff[0] = WM_ICONIFY (26)
	msgbuff[3] = window handle
	msgbuff[4] = x coordinate of icon window
	msgbuff[5] = y coordinate of icon window
	msgbuff[6] = width of icon window
	msgbuff[7] = height of icon window

WM_UNICONIFY:
	msgbuff[0] = WM_UNICONIFY (27)
	msgbuff[3] = window handle
	msgbuff[4] = x coordinate of orignal window
	msgbuff[5] = y coordinate of orignal window
	msgbuff[6] = width of orignal window
	msgbuff[7] = height of orignal window
	

3.) New wind_set() Calls

There are two new calls to wind_set():

	WORD wind_set(handle, WF_ICONIFY, x, y, w, h)
	WORD handle;
	WORD x, y, w, h;
	
This call will iconify a window to the given width and height and place it
at the given coordinates. All window gadgets but the move and title bar will
be removed by this call. The font in the title bar will be set to SMALL
(6 point). A WM_REDRAW message will be send to the application to redraw the
work area of the iconified window. It is recommended to draw an icon inside
the work area. The standard size of an iconified window is 72 by 72.

The AES will now look for double clicks inside the work area to send a
WM_UNICONIFY message to the application.

If an application closes an iconified window and then opens it again, it
will still be in the iconified state. Before closing a window an application
should check if the window is iconified and if so, bring it back to its
original state before closing it.


	WORD wind_set(handle, WF_UNICONIFY, x, y, w, h)
	WORD handle;
	WORD x, y, w, h;
	
This call will uniconify a window to the given width and height and place it
at the given coordinates, meaning the window will go back to its original
state. All of the window's gadgets will again be added by this call. The font
in the title bar will be reset to IBM. A WM_REDRAW message will be send to
the application to redraw its work area.


4.) New wind_get() Calls

There are two new calls to wind_get():

	WORD wind_get(handle, WF_ICONIFY, iconified, dummy, dummy, dummy)
	WORD handle;
	WORD *iconified, *dummy;

This call will return the state of a window. A value of TRUE states that the
window is iconified.

	iconified == TRUE	--> window is iconified
	iconified == FALSE	--> window is not iconified


	WORD wind_get(handle, WF_UNICONIFY, x, y, w, h)
	WORD handle;
	WORD *x, *y, *w, *h;

This call will return the x and y coordinates as well as the width and
height of an iconified window's orignal coordinates and size. That are
the coordinates and size of the window before it was iconified.


5.) Example Code

	.
	WINDOW	*win;
	.
	.
	win->handle = wind_create(NAME|SIZER|MOVER|CLOSER|FULLER|SMALLER,
			full.g_x, full.g_y, full.g_w, full.g_h);
	.
	.

	event = evnt_multi( MU_MESAG|MU_BUTTON|MU_KEYBD, 2, 1, 1,
			      0, 0, 0, 0, 0,
			      0, 0, 0, 0, 0,
			      (LONG) msgbuff,	/* message buffer	*/
			      0, 0,		/* timer counter	*/
			      &mx, &my, &button, &kstat, &kreturn, &clicks
			  );
	.
	.
	if (event & MU_MESAG) {
		switch (msgbuff[0]) {
			.
			.
		case WM_ICONIFY:
		    if ((win = get_win(msgbuff[3])) == NULL)
		    	break;
		    form_dial(FMD_SHRINK,
			msgbuff[4], msgbuff[5], msgbuff[6], msgbuff[7],
			win->work.g_x, win->work.g_y,
			win->work.g_w, win->work.g_h);
				
		    wind_set(msgbuff[3], WF_ICONIFY,
		    	msgbuff[4], msgbuff[5], msgbuff[6], msgbuff[7]);

		    wind_get(msgbuff[3], WF_WORKXYWH,
		    	&win->work.g_x, &win->work.g_y,
			&win->work.g_w, &win->work.g_h);
		    break;
		    
		case WM_UNICONIFY:
		    if ((win = get_win(msgbuff[3])) == NULL)
		    	break;
		    form_dial(FMD_GROW,
		    	win->work.g_x, win->work.g_y,
			win->work.g_w, win->work.g_h,
			msgbuff[4], msgbuff[5], msgbuff[6], msgbuff[7]);
				
		    wind_set(msgbuff[3], WF_UNICONIFY,
		    	msgbuff[4], msgbuff[5], msgbuff[6], msgbuff[7]);

		    wind_get(msgbuff[3], WF_WORKXYWH,
		    	&win->work.g_x, &win->work.g_y,
			&win->work.g_w, &win->work.g_h);
		    break;

		case WM_REDRAW:
		    if ((win = get_win(msgbuff[3])) == NULL)
		    	break;
		    wind_get(msgbuff[3], WF_ICONIFY, &iconified,
		    	&dummy, &dummy &dummy);
		    if (iconified)
		    	redraw_iconWindow(win, msgbuff[4], msgbuff[5],
		    	    msgbuff[6], msgbuff[7]);
		    else
			redraw_normalWindow(win, msgbuff[4], msgbuff[5],
		    	    msgbuff[6], msgbuff[7]);
		    break;	    		
		.
		.
		.
	
