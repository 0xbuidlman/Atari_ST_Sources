head	1.10;
access;
symbols;
locks
	ersmith:1.10;
comment	@ * @;


1.10
date	93.06.15.22.53.36;	author ersmith;	state Exp;
branches;
next	1.9;

1.9
date	93.06.14.23.48.02;	author ersmith;	state Exp;
branches;
next	1.8;

1.8
date	93.06.09.23.47.00;	author ersmith;	state Exp;
branches;
next	1.7;

1.7
date	93.05.12.01.40.22;	author ersmith;	state Exp;
branches;
next	1.6;

1.6
date	93.04.27.23.00.14;	author ersmith;	state Exp;
branches;
next	1.5;

1.5
date	93.04.14.22.19.54;	author ersmith;	state Exp;
branches;
next	1.4;

1.4
date	93.03.12.19.51.12;	author ersmith;	state Exp;
branches;
next	1.3;

1.3
date	93.03.10.20.12.42;	author ersmith;	state Exp;
branches;
next	1.2;

1.2
date	93.03.08.20.07.02;	author ersmith;	state Exp;
branches;
next	1.1;

1.1
date	93.02.24.23.52.46;	author ersmith;	state Exp;
branches;
next	1.0;

1.0
date	93.02.03.21.26.46;	author ersmith;	state Exp;
branches;
next	;


desc
@Desktop "show file" functions
@


1.10
log
@Minor resource editing, elclean ups, etc.
@
text
@/*	DESKSHOW.C		5/3/88			Allan Pratt
 *
 *	
 * show.c: desktop "show file" code.
 *
 * showfile(fname,mode)
 * char *fname;		filename of file to show
 * int mode;		TRUE for printer, FALSE for screen.
 *
 * For screen mode, call this function after the screen is clear and the 
 * cursor is enabled.  When this function returns, the screen needs to
 * be cleared again and the cursor disabled.
 *
 * This code uses BIOS I/O exclusively to avoid ^C handling.
 * It does its own ^S/^Q and ^C handling.
 *
 * ^S/^C get checked every 16 characters or each --more--, whichever comes
 * first.  ^C causes return to the desktop, ^S waits for ^Q (continue) or
 * ^C (quit). 
 *
 * Note that hitting space in the middle of a page makes the "more" come
 * 24 lines from now, rather than having the same effect as waiting
 * for the more and then hitting space.
 *
 * d and D and ^D cause the "more" to come 1/2 page from now; Return
 * makes it come one line from now.
 *
 * q, Q, and ^C cause the output to stop immediately.
 *
 * Line wrap is not modified: if it was no-wrap to begin with, that's
 * what you get.
 *
 * For printer mode, the keyboard gets checked every MAXCHAR characters.
 * q, Q, ^C, and Undo all cause printing to abort.
 * Printer mode, of course, does its own tab expansion.  It only
 * understands TAB, BS, and CR as control characters.  Others will
 * mess up the tab expansion (which means you shouldn't use the desktop
 * print function with wierder files than that).
 */

/*	Return error code back to the caller, form feed after print 
					8/15/89		D.Mui		*/

/*	take out rsrc_gaddr( R_STRING ...	8/30/89	D.Mui		*/

/************************************************************************/
/*	New Desktop for Atari ST/TT Computer				*/
/*	Atari Corp							*/
/*	Copyright 1989,1990 	All Rights Reserved			*/
/************************************************************************/

#include "portab.h"
#include "obdefs.h"
#include "deskdefi.h"
#include "deskwin.h"
#include "deskusa.h"
#include "osbind.h"
#include "extern.h"
#include "pdesk.h"
#include "pmisc.h"


/* trap() is GEMDOS trap #1; trap13() is (obviously) trap 13. */

extern long trap(), trap13();

#define BUFSIZ 4096	/* Malloc this much as a disk buffer */

/* #define MAXLINE 24	*/	/* line interval for --more-- */
#define MAXCHAR 16	/* character interval for checking keyboard */

/* ASCII equates */

#define CTLC 3
#define CTLD 4
#define BS 8
#define TAB 9
#define NL 10
#define CR 13
#define CTLQ 17
#define CTLS 19
#define SPACE 32

	WORD
showfile(fname,mode)
	BYTE *fname;
	WORD mode;
{
    WORD linecount,serial,status;
    register WORD charcount;
    register WORD handle;
    BYTE *buf;
    register BYTE *ptr;
    register LONG len;
    register WORD i;
    LONG c;
    WORD ch;
    LONG  alert; 

    linecount = charcount = 0;
    handle = -1;
    status = TRUE;
	
    if (!(buf = malloc( (LONG)BUFSIZ))) 
    {		
	status = FALSE;
	
#ifdef SILLY_ERROR_HANDLING
	if ( mode )	/* printer mode	no memory */
	{
#endif
	  do1_alert( FCNOMEM );
	  goto allout;
#ifdef SILLY_ERROR_HANDLING
	}
	else		/* alpha mode	*/
	{
	  alert = (LONG) get_fstring( NOMEM );
 	  bconws( (BYTE *)alert );
	  bconws( (BYTE *)Nextline );
	}
	goto allfin;
#endif
    }

    if ((handle = (WORD) Fopen(fname,0)) < 0) 
    {
	status = FALSE;

#ifdef SILLY_ERROR_HANDLING
	if ( mode )	/* printer mode	no file */
	{
#endif
	  form_error( 2 );
	  goto allout;
#ifdef SILLY_ERROR_HANDLING
	}
	else		/* aplha mode	*/
	{
	  alert = get_fstring( CANTOPEN );
 	  bconws( (BYTE *)alert );	/* Can not open	*/
	  bconws( fname );	/* filename	*/
	  bconws( Nextline );
	}
	goto allfin;
#endif
    }

    /* PRINTER MODE CODE */
    if (mode) {
				/* find out where to send */
				/* serial or parallel	  */

	serial = ( trap14( 0x21, 0xFFFF ) & 0x10 ) ? TRUE : FALSE;

	charcount = 0;

	while ((len = Fread(handle,(LONG)BUFSIZ,buf)) > 0) {
	    for (ptr = buf,i=0; i<len; i++,ptr++) {
		switch(*ptr) {
		    case CR:
			charcount = 0;
			break;
		    case BS:
			charcount--;
			break;
		    default:
			/* advance for printing chars only */
			if (*ptr >= (UWORD)SPACE) charcount++;
		}
doa2:		if ( !Bconout( serial,*ptr ) )/* device not present ?	*/
		{				/* retry ?		*/
		   if ( do_alert( 2, NOOUTPUT ) == 1 )
		     goto doa2;
		   else				/* cancel */
		   {
		     status = FALSE;
		     goto alldone;
		   }
		}		     	 		   
dontprint:
		if (++linecount >= MAXCHAR) {
		    linecount = 0;
		    if (Bconstat(2)) {
			ch = (WORD)(c = Bconin(2));
			if (ch == CTLC || ch == 'q' || ch == 'Q' ||
			    (c & 0x00ff0000L) == 0x00610000) goto alldone;
		    }
		}
	    }
	}
	goto alldone;
    }

    /* SCREEN MODE CODE */
    while ((len = Fread(handle,(LONG)BUFSIZ,buf)) > 0) {
	for (ptr = buf, i = 0; i<len; i++, ptr++) {
	    Bconout(2,*ptr);
	    charcount++;
	    if (*ptr == NL) {
		charcount=0;
		linecount++;
		if (linecount >= d_nrows) 
		{
		    alert = (LONG) get_fstring( MORE );
		    bconws( "\r" );
		    bconws( (BYTE *)alert );
		    if (doui(1,&linecount)) 
		      goto alldone;
		    bconws("\r\033K\r");
		}
	    }
	    else if (charcount >= MAXCHAR) {
		if (doui(0,&linecount)) goto alldone;
	    }
	}
    }

    if ( len < 0 )
    {
	alert = (LONG)get_fstring( READERRO );/* was READERRO, changed for LC */
	bconws( Nextline );
	bconws( (BYTE *)alert );
    }
    else
    {
	 alert = (LONG) get_fstring( ENDFILE );
	 bconws( Nextline );
	 bconws( (BYTE *)alert );
    }

allfin:
    doui( 1, &linecount );

alldone:
    if ( handle >= 0 )
    {
      if ( ( mode ) && ( status ) )
	Bconout( serial, 0x0C );
      Fclose(handle);
    }

allout:
    if ( buf )		/* if there is memory allocated	*/
      free( buf );	/* free it			*/

    return( status );
}


/* This routine uses the global GEM variable gl_button to get the button
 * state, and it shouldn't.  But it can't call graf_mkstate, because
 * that causes a dispatch, which causes the AES to buffer keystrokes.
 */
EXTERN WORD gl_button;		/* changed 3/6/91	*/

LONG uikey()
{
#if 0
    /* DISABLED MOUSE BUTTON HANDLING FOR DISPLAYING FILES IN THIS FASION - CJG */
    if( gl_button & 1 ) return SPACE;    /* left mouse button = next page    */
    if( gl_button & 2 ) return CTLC;     /* right mouse button quits         */
#endif
    if( Bconstat(2) ) return Bconin(2); /* if there's a key, return it      */
    return 0;                           /* otherwise, return nullo          */
}

/*
 * doui: get user I/O.  Mode is 0 for polling, ~0 for blocking (at --more--).
 *
 * Returns 1 if user wants to stop, or modifies *plinecount for next
 * screenful.
 */

	WORD
doui(mode,plinecount)
	WORD mode;
	WORD *plinecount;
{
    LONG c;
    WORD stop = 0;

    while( (c = uikey()) || mode || stop ) {
	switch ((WORD)(c) & 0xff) {
	    /* ^D and d and D step 1/2 screen ahead */
	    case CTLD:
	    case 'd':
	    case 'D':
		*plinecount = d_nrows/2;
		return 0;

	    /* space steps another screenful */
	    case SPACE:
		*plinecount = 0;
		return 0;

	    /* Return steps another line */
	    case CR:
		/* do one line & say --more-- again */
		*plinecount = d_nrows-1;
		return 0;

	    /* ^S, ^Q pause/restart */
	    case CTLS:
		stop = 1;
		break;

	    case CTLQ:
		stop = 0;
		break;

	    /* ^C, q, and Q quit */
	    case CTLC:
	    case 'Q':
	    case 'q':
		return 1;

	    /* check here for non-ASCII keys */
	    default:
		/* UNDO quits */
		if ((c & 0x00ff0000) == 0x00610000) 
		    return 1;

		/* other keys don't do anything */
		break;
	}
    }
    return 0;
}


VOID bconws(s)
register BYTE *s;
{
    while (*s) Bconout(2,*s++);
}
@


1.9
log
@Merged in Hans-Martin and Cary's changes
@
text
@@


1.8
log
@Another check in to save work.
@
text
@@


1.7
log
@Added iconification,color icons in alerts,etc.
@
text
@@


1.6
log
@Merged Cary's and Hans-Martin's changes
@
text
@a0 48
/*
*************************************************************************
*			Revision Control System
* =======================================================================
*  $Revision: 1.4 $	$Source: f:\multitos/RCS/deskshow.c,v $
* =======================================================================
*  $Author: ersmith $	$Date: 1993/03/12 19:51:12 $	$Locker: ersmith $
* =======================================================================
*  $Log: deskshow.c,v $
*
*		03/24/93	cjg
* Removed usage of gl_button in the show file code - uikey()
* 
*
* Revision 1.4  1993/03/12  19:51:12  ersmith
* Merged HMK's loadable resource stuff
*
* Revision 1.3  1993/03/10  20:12:42  ersmith
* Lattice port
*
* Revision 1.1  1993/02/24  23:52:46  ersmith
* 1 meg floppy MultiTOS
*
* Revision 1.0  1993/02/03  21:26:46  ersmith
* MultiTOS version 1.0
*
* Revision 2.3  89/07/29  20:23:22  kbad
* Removed error messages requiring keyboard input at the start of showfile.
* Also added uikey() to allow mouse buttons to function like keys during
* showfile.
* 
* Revision 2.2  89/04/26  18:11:42  mui
* aes30
* 
* Revision 2.1  89/02/22  05:22:36  kbad
* *** TOS 1.4  FINAL RELEASE VERSION ***
* 
* Revision 1.3  88/07/01  16:21:10  mui
* Check port for printing
*
* Revision 1.2  88/07/01  15:48:12  mui
* Take out tab expansion, fix fm_show
* 
* Revision 1.1  88/06/02  12:29:59  lozben
* Initial revision
* 
*************************************************************************
*/
@


1.5
log
@Incorporated more single/multitasking changes.
@
text
@d10 11
a20 6
 * Revision 1.4  1993/03/12  19:51:12  ersmith
 * Merged HMK's loadable resource stuff
 *
 * Revision 1.3  1993/03/10  20:12:42  ersmith
 * Lattice port
 *
d307 2
d311 1
@


1.4
log
@Merged HMK's loadable resource stuff
@
text
@d5 1
a5 1
*  $Revision: 1.3 $	$Source: f:\multitos/RCS/deskshow.c,v $
d7 1
a7 1
*  $Author: ersmith $	$Date: 1993/03/10 20:12:42 $	$Locker: ersmith $
d10 3
@


1.3
log
@Lattice port
@
text
@d5 1
a5 1
*  $Revision: 1.1 $	$Source: f:\multitos/RCS/deskshow.c,v $
d7 1
a7 1
*  $Author: ersmith $	$Date: 1993/02/24 23:52:46 $	$Locker: ersmith $
d9 4
a12 1
*  $Log:	deskshow.c,v $
@


1.2
log
@REAL MultiTOS 1.01
@
text
@d9 7
a15 4
*  $Log: deskshow.c,v $
 * Revision 1.1  1993/02/24  23:52:46  ersmith
 * 1 meg floppy MultiTOS
 *
d89 10
a98 12
#include <portab.h>
#include <deskobde.h>
#include <deskdefi.h>
#include <deskwin.h>
#include <deskusa.h>
#include <gemdefs.h>
#include <osbind.h>
#include <extern.h>

extern	char	*get_fstring();
extern	char	*malloc();
extern	VOID	free();
a103 10
#define Fopen(f,m) trap(0x3d,f,m)
#define Fread(handle,count,buf) trap(0x3f,handle,(long)count,buf)
#define Fclose(handle) trap(0x3e,handle)
#define Mxalloc(size,a) gemdos(0x44,(long)size,a)
#define Mfree(size) trap(0x49,(long)size)

#define Bconstat(d) trap13(1,d)
#define Bconin(d) trap13(2,d)
#define Bconout(d,c) trap13(3,d,c)

d121 1
d123 2
a124 2
char *fname;
int mode;
d126 10
a135 10
    int linecount,serial,status;
    register int charcount;
    register int handle;
    char *buf;
    register char *ptr;
    register long len;
    register int i;
    long c;
    int ch;
    long  alert; 
d141 1
a141 1
    if (!(buf = malloc( (long)BUFSIZ))) 
d155 3
a157 3
	  alert = get_fstring( NOMEM );
 	  bconws( alert );
	  bconws( Nextline );
d163 1
a163 1
    if ((handle = Fopen(fname,0)) < 0) 
d178 1
a178 1
 	  bconws( alert );	/* Can not open	*/
d195 1
a195 1
	while ((len = Fread(handle,(long)BUFSIZ,buf)) > 0) {
d206 1
a206 1
			if (*ptr >= (unsigned)SPACE) charcount++;
d222 1
a222 1
			ch = (int)(c = Bconin(2));
d233 1
a233 1
    while ((len = Fread(handle,(long)BUFSIZ,buf)) > 0) {
d242 1
a242 1
		    alert = get_fstring( MORE );
d244 1
a244 1
		    bconws( alert );
d258 1
a258 1
	alert = get_fstring( READERROR );
d260 1
a260 1
	bconws( alert );
d264 1
a264 1
	 alert = get_fstring( ENDFILE );
d266 1
a266 1
	 bconws( alert );
d292 1
a292 1
extern gl_button;		/* changed 3/6/91	*/
d294 1
a294 2
long
uikey()
d309 1
a309 1
int 
d311 2
a312 2
int mode;
int *plinecount;
d314 2
a315 2
    long c;
    int stop = 0;
d318 1
a318 1
	switch ((int)(c) & 0xff) {
d365 3
a367 2
bconws(s)
register char *s;
@


1.1
log
@1 meg floppy MultiTOS
@
text
@d5 1
a5 1
*  $Revision: 2.3 $	$Source: /u2/MRS/osrevisions/aes/deskshow.c,v $
d7 1
a7 1
*  $Author: kbad $	$Date: 89/07/29 20:23:22 $	$Locker: kbad $
d9 4
a12 1
*  $Log:	deskshow.c,v $
@


1.0
log
@MultiTOS version 1.0
@
text
@d94 1
d287 1
a287 1
      Mfree( buf );	/* free it			*/
@
