head	1.10;
access;
symbols;
locks
	ersmith:1.10;
comment	@ * @;


1.10
date	93.06.15.22.53.36;	author ersmith;	state Exp;
branches;
next	1.9;

1.9
date	93.06.14.23.48.02;	author ersmith;	state Exp;
branches;
next	1.8;

1.8
date	93.06.09.23.47.00;	author ersmith;	state Exp;
branches;
next	1.7;

1.7
date	93.05.12.01.40.22;	author ersmith;	state Exp;
branches;
next	1.6;

1.6
date	93.04.27.23.00.14;	author ersmith;	state Exp;
branches;
next	1.5;

1.5
date	93.04.14.22.19.54;	author ersmith;	state Exp;
branches;
next	1.4;

1.4
date	93.03.12.19.51.12;	author ersmith;	state Exp;
branches;
next	1.3;

1.3
date	93.03.10.20.12.42;	author ersmith;	state Exp;
branches;
next	1.2;

1.2
date	93.03.08.20.07.02;	author ersmith;	state Exp;
branches;
next	1.1;

1.1
date	93.02.24.23.52.46;	author ersmith;	state Exp;
branches;
next	1.0;

1.0
date	93.02.03.21.26.46;	author ersmith;	state Exp;
branches;
next	;


desc
@Desktop memory configuration code (?)
@


1.10
log
@Minor resource editing, elclean ups, etc.
@
text
@/*	DESKMEM.C		7/18/89 - 10/4/89	D.Mui		*/
/*	Converted to Lattice C 5.51	02/18/93	C.Gee		*/


/************************************************************************/
/*	New Desktop for Atari ST/TT Computer				*/
/*	Atari Corp							*/
/*	Copyright 1989,1990 	All Rights Reserved			*/
/************************************************************************/

#include "portab.h"
#include "obdefs.h"
#include "deskdefi.h"
#include "osbind.h"
#include "deskwin.h"
#include "extern.h"
#include "deskusa.h"
#include "pdesk.h"
#include "pmisc.h"


BYTE	*lp_start;
BYTE	*lp_mid;
BYTE	*lp_end;

#define LMSIZE	0x1000L	

UWORD	apsize;

/*	Init the application buffer	*/

	WORD
apbuf_init( VOID )
{
	REG UWORD	i;
	REG APP		*app,*app1;
	    APP		*appsave;
	
	apsize += APP_NODE;
	
	if ( ! ( app = ( APP *)malloc( (LONG)( sizeof( APP ) * apsize ) ) ) )
	  return( FALSE );

	for ( i = 0; i < apsize; i++ )/* set up linked array	*/
	  app[i].a_next = ( BYTE *)&app[i+1];

/*	app[i-1].a_next = (APP*)0;	*/
	app[i-1].a_next = ( BYTE *)0;

	if ( applist )		/* we already has an app buffer	*/		
	{			/* then copy the old stuff	*/
	  app1 = app;
	  while( applist )
	  {			/* save the link list	*/
	    appsave = ( APP *)app1->a_next;
	    *app1 = *applist;
	    app1->a_next = ( BYTE *)appsave;
	    applist = ( APP *)applist->a_next;
	    if ( !applist )
	    {				/* new free app starts at	*/
	      appfree = ( APP *)app1->a_next;
	      app1->a_next = ( BYTE *)0;
	    }
	    else
	      app1 = ( APP *)app1->a_next;	
	  }
	
	  applist = app;		/* new using list		*/
	}
	else
	  appfree = app;

	if ( appnode )
	  free( appnode );

	appnode = app;			/* new app buffer		*/

	return( TRUE );
}


/*	Initalize some memory buffer	*/

	WORD
mem_init( VOID )
{
	/* Allocate write string buffer	*/

	if ( !( lp_mid = lp_start = malloc( LMSIZE ) ) ) /* 2 k memory	*/	
	{
m_1:	  do1_alert( FCNOMEM );	
	  return( FALSE );
	}

	lp_end = lp_mid + LMSIZE;

	if ( !apbuf_init() )
	{
	  free( lp_start );	/* free the write buffer	*/
	  goto m_1;
	}
	
	return( TRUE );
}




/*	Fill the path into buffer	*/

	BYTE	
*lp_fill( path, buf )
	BYTE	*path;
	BYTE	**buf;
{
	REG BYTE	*ptr;
	BYTE	*ptr1;

	if ( !lp_start )		/* No memory	*/
	  goto lp_1;
	  
	ptr1 = ptr = lp_mid;

	do
	{
	  if ( ptr >= lp_end )		/* end of buffer */
	  {
lp_1:	    *buf = (BYTE*)0;
	    return( path );
	  }

	  if ( *path == '@@' )
	  {
	    path++;
	    *ptr++ = 0;
	    break;
	  }

	  *ptr++ = *path;

	}while( *path++ );

	lp_mid = ptr;
	*buf = ptr1;
	return( path ); 
}


/*	Do the garbage collection of the buffer		*/

	WORD
lp_collect( VOID )
{
	REG WORD	i;
	BYTE	*addr;
	REG OBJECT	*obj;
	REG APP		*app;

	addr = malloc( LMSIZE );	/* 2 k memory	*/	
	if ( !addr )
	{
	  do1_alert( MCFAIL );
	  return( FALSE );
	}

	obj = background;

	lp_mid = addr;
	
	lp_end = lp_mid + LMSIZE;
	
	for ( i = 1; i <= obj[0].ob_tail; i++ )
	{
 	  if ( !(obj[i].ob_flags & HIDETREE) ) 
	  {
	    if ( backid[i].i_path )
	      lp_fill( backid[i].i_path, &backid[i].i_path );
	  }
	}

	app = applist;
	
	while( app )
	{
	  lp_fill( app->a_name, &app->a_name );
	  app = ( APP *)app->a_next;
	}

	free( lp_start );
	lp_start = addr;	
	return( TRUE );
}
@


1.9
log
@Merged in Hans-Martin and Cary's changes
@
text
@@


1.8
log
@Another check in to save work.
@
text
@@


1.7
log
@Added iconification,color icons in alerts,etc.
@
text
@@


1.6
log
@Merged Cary's and Hans-Martin's changes
@
text
@@


1.5
log
@Incorporated more single/multitasking changes.
@
text
@@


1.4
log
@Merged HMK's loadable resource stuff
@
text
@@


1.3
log
@Lattice port
@
text
@@


1.2
log
@REAL MultiTOS 1.01
@
text
@d2 1
d4 1
d11 9
a19 7
#include <portab.h>
#include <deskobde.h>
#include <deskdefi.h>
#include <osbind.h>
#include <deskwin.h>
#include <extern.h>
#include <deskusa.h>
a20 2
EXTERN	BYTE	*malloc();
EXTERN	VOID	free();
d33 1
a33 1
apbuf_init()
d41 1
a41 1
	if ( ! ( app = malloc( (LONG)( sizeof( APP ) * apsize ) ) ) )
d45 1
a45 1
	  app[i].a_next = &app[i+1];
d47 2
a48 1
	app[i-1].a_next = (APP*)0;	
d55 1
a55 1
	    appsave = app1->a_next;
d57 2
a58 2
	    app1->a_next = appsave;
	    applist = applist->a_next;
d61 2
a62 2
	      appfree = app1->a_next;
	      app1->a_next = (APP*)0;
d65 1
a65 1
	      app1 = app1->a_next;	
d85 1
a85 1
mem_init( )
d113 1
a113 1
	REG BYTE	*path;
d134 1
a135 1
	    path++;
d152 1
a152 1
lp_collect( )
d186 1
a186 1
	  app = app->a_next;
@


1.1
log
@1 meg floppy MultiTOS
@
text
@@


1.0
log
@MultiTOS version 1.0
@
text
@d18 1
d71 1
a71 1
	  Mfree( appnode );
d96 1
a96 1
	  Mfree( lp_start );	/* free the write buffer	*/
d186 1
a186 1
	Mfree( lp_start );
@
