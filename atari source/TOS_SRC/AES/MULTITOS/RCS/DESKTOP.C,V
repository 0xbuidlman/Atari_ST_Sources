head	1.10;
access;
symbols;
locks
	ersmith:1.10;
comment	@ * @;


1.10
date	93.06.15.22.53.36;	author ersmith;	state Exp;
branches;
next	1.9;

1.9
date	93.06.14.23.48.02;	author ersmith;	state Exp;
branches;
next	1.8;

1.8
date	93.06.09.23.47.00;	author ersmith;	state Exp;
branches;
next	1.7;

1.7
date	93.05.12.15.50.18;	author ersmith;	state Exp;
branches;
next	1.6;

1.6
date	93.04.27.23.00.14;	author ersmith;	state Exp;
branches;
next	1.5;

1.5
date	93.04.14.22.19.54;	author ersmith;	state Exp;
branches;
next	1.4;

1.4
date	93.03.12.19.51.12;	author ersmith;	state Exp;
branches;
next	1.3;

1.3
date	93.03.10.20.12.42;	author ersmith;	state Exp;
branches;
next	1.2;

1.2
date	93.03.08.20.07.02;	author ersmith;	state Exp;
branches;
next	1.1;

1.1
date	93.02.24.23.52.46;	author ersmith;	state Exp;
branches;
next	1.0;

1.0
date	93.02.03.21.26.46;	author ersmith;	state Exp;
branches;
next	;


desc
@Desktop initialization code
@


1.10
log
@Minor resource editing, elclean ups, etc.
@
text
@/*	DESKTOP.C		3/15/89 - 7/26/89	Derek Mui	*/
/*	Take out vdi_handle	6/28/89					*/
/*	Read in icn file	9/23/89			D.Mui		*/
/*	New adj_menu to adjust menu	6/27/90		D.Mui		*/
/*	Take the wind_update in deskmain	8/9/90	D.Mui		*/
/*	Add m_cpu to check CPU	9/19/90			D.Mui		*/
/*	Fix the cache menu so that it checks the cache when menu is down*/
/*					10/24/90	D.Mui		*/
/*	Moved the wind_set in the main to just before menu_bar. It is 	*/
/*	to fix the acc problem			12/4/90	D.Mui		*/
/*	Change appl_init to ap_init and appl_exit to ap_exit 4/3/91	*/
/*	Add wm_update before bringing up the menu bar 4/18/91 Mui	*/
/*	Install desktop critical error handler	4/22/91	D.Mui		*/
/*	Rename deskmain to desktop		5/1/91	D.Mui		*/
/*	Check control key for nodisk system at re_icon 8/13/91	D.Mui	*/
/*	Change all the iconblk to ciconblk	7/11/92	D.Mui		*/
/*      Load rsc file from disk			2/10/92 H.Krober        */
/*	Start the separation of desktop and aes 3/18/93 C.Gee		*/
/*	Implement flags for PRG vs SYS version  4/14/93 C.Gee		*/
/*	Speedo GDOS font support in windows	5/25/83 H.Krober	*/ 

/************************************************************************/
/*	New Desktop for Atari ST/TT Computer				*/
/*	Atari Corp							*/
/*	Copyright 1989,1990 	All Rights Reserved			*/
/************************************************************************/

#include "portab.h"
#include "machine.h"
#include "obdefs.h"
#include "deskdefi.h"
#include "deskwin.h"
#include "osbind.h"
#include "extern.h"
#include "mintbind.h"	
#include "signal.h"
#include "vdomode.h"
#include "deskusa.h"
#include "pdesk.h"
#include "pmisc.h"
#include "pboth.h"
#include "softload.h"
/*
 *	Set the SOFTLOAD flag to implement softloaded desktop resources.
 *	The desktop will then try to read its resource file from
 *	[A|C]:\MULTITOS\DESKTOP.RSC. If the load failes because the file
 *	is not present, a file selector box will ask the user to find
 * 	the resource file for the system. If this dialog box is exited
 *	using the 'Cancel' button, the resource will be copied from ROM.
 *
 *	NOTE: You have to define SOFTLOAD in deskrom.c, too, because there
 *	      are the actual functions.
 *
 *	See the Defines in SOFTLOAD.H
 */

/*
 *	Turn on resource file version number checking by setting the
 *	DESKRSVER to 1. Use "rscvers versnr DESKTOP.RSC"
 *	to create a DESKTOP.RSC with a version number in the first byte of the
 *	resource header. This is to prevent user from using the wrong
 *	resource file.
 *	See the Defines in SOFTLOAD.H
 */

/*
 *	Set the DESKPRG flag to compile this file for a
 *	replacement Desktop. Clear it for making GEM.SYS
 *      DESKPRG must also be set/cleared in
 *	      DESKSTAR.S, DESKVARI.C, DESKROM.C, DOSBIND.C
 *	See the Define in softload.h
 */

typedef struct cblk
{
	LONG		cb_pcontrol;
	WORD		*cb_pglobal;
	LONG		cb_pintin;
	LONG		cb_pintout;
	LONG		cb_padrin;
	LONG		cb_padrout;		
}CBLK;


EXTERN	UWORD	d_rezword;
#ifdef OBSOLETE_CODE
EXTERN	WORD	icn_whandle;
#endif
EXTERN	BYTE	*lp_mid;
EXTERN	BYTE	*lp_start;
EXTERN	WORD	d_exit;
EXTERN	BYTE	*q_addr;
EXTERN	UWORD	apsize;
EXTERN	OBJECT	*deskptr;		/* desktop resource	*/ /* this shouldn't be extern anymore, since the rsc is loaded from here now */
EXTERN	LONG	gl_vdo;
EXTERN	CBLK	c;
EXTERN	WORD	ctldown;
EXTERN	WORD	st_lang;

GLOBAL	WORD	d_multi;		/* flag for multitasking mode (MiNT) */
GLOBAL  LONG	mintvers;		/* MiNT version number */
GLOBAL	WORD	v_handle;
GLOBAL	WORD	desk_id;
GLOBAL	WORD	m_st;		/* machine type flag	*/	
GLOBAL	WORD	m_cpu;		/* cpu type		*/
GLOBAL	WORD	numicon;	/* the number of icon in the resource	*/	
GLOBAL	BYTE	*iconmem;	/* icon data memory address	*/
GLOBAL	BYTE	restable[6];	/* resolution table	*/
				/* Low , Medium, High, TT Medium, TT High, TT Low */
GLOBAL	WORD	d_maxcolor;
GLOBAL	USERBLK	chxcache;
GLOBAL	WORD	pglobal[15];
CICONBLK	*ciconaddr;
GLOBAL	WORD	d_spd;
GLOBAL	WORD	d_numfonts;
GLOBAL	FNTLST	*d_fontlst;
GLOBAL	UWORD	st_time;	/* time code		*/
GLOBAL	UWORD	st_date;
GLOBAL	UWORD	st_dchar;
GLOBAL	WORD	st_keybd;

GLOBAL	OBJECT	*fontmn;	/* font popup menu in	*/ 
				/* "Set Color & Style"	*/
				/* dialog box		*/
EXTERN	WORD	win_font;	/* window font 		*/
EXTERN	WORD	win_fsize;	/* window font szie 	*/


MLOCAL	BYTE	TIMETABLE[] =	/* was: BYTE *TIMETABLE[], changed for LC */
{/* Eurotime, Eurodate and seperator */
	0,0,'/',	/* USA	*/
	1,1,'.',	/* GERMANY	*/
	1,1,'/',	/* FRENCH	*/
	0,0,'/',	/* USA	*/
	1,1,'/',	/* SPAIN	*/
	1,1,'/',	/* ITALY	*/
	1,2,'-'		/* SWEDEN,NORWAY,FINLAND*/
};
	
#if DESKPRG
GLOBAL	WORD	gl_debug = 0;	/* Debug level for soft loaded desktop only */
GLOBAL	WORD	gl_port  = 1;	/* port for debug messages */

VOID	Ndebug( WORD level, LONG number );
VOID	Debug( WORD level, BYTE *str );
#endif

#if SOFTLOAD
MLOCAL BYTE	DESKRSC[40]; /* = "C:\\MULTITOS\\DESKTOP.RSC"; */

/*
 *	->> These message have to get internationalized!
 */

BYTE	*RSCVMSG =	"[1][Desktop resource in MULTITOS|\
directory has incorrect version|number. Resource was not|loaded from disk.]\
[ OK ]";

GLOBAL WORD	romdesk;
#endif


/*	Check if we're running MINT or not */
	WORD
desk_cMiNT( VOID )
{
	return( d_multi = getcookie( 0x4D694E54L, &mintvers ) );
}



MLOCAL WORD tosvers;

/* get the TOS version number; this *must* be executed in supervisor mode */

MLOCAL VOID gettosvers()
{
	LONG *sysbase;

	sysbase = *((LONG **)(0x4f2L));	/* get the RAM OS header */
	sysbase = (LONG *)sysbase[2];	/* get the real one */

	tosvers = (WORD)(sysbase[0] & 0x0000ffffL);
}


/*	Catch desktop terminate signal */

	VOID
desk_term()
{
	d_exit = L_EXIT;
	return;			/* DOES THIS BELONG HERE ??? (hmk 2/16/93) */
#if 0
	/* IS THIS STUFF NEEDED? IF SO< WHERE?   */
	Debug1( "Desktop catches terminate signal\r\n" );

	ciconaddr = (CICONBLK*) 0;
	if ( iconmem )
	{
	  LBCOPY( (BYTE *)temp, (BYTE *)c.cb_pglobal, 30 );
	  *((LONG*)(&c.cb_pglobal[7])) = iconmem;
	  rsrc_free(); 	
	  iconmem = (BYTE*) 0;
	  LBCOPY( c.cb_pglobal, temp, 30 );	
	}
	iconaddr = (OBJECT*) 0;
	iconmem = (BYTE*) 0;
	inf_path[0] = 0;		
	Pterm(1);
#endif
}


	WORD
ch_xcache()
{
	ch_cache( FALSE );
	return( 0 );
}


/*	Read in icn file	*/

	WORD
re_icon( )
{
	REG WORD	ret;
	WORD		temp[15];
	LONG		*ptr;
	BYTE		buf2[18];	
	BYTE		*iaddr;

	ret = FALSE;

	if ( !ctldown )			/* no control key down */
	{
	  LBCOPY( (BYTE *)temp,(BYTE *)c.cb_pglobal, 30 );
	  strcpy( cicndata, buf2 );	/* Try color icon file	*/
	  buf2[0] = ( isdrive() & 0x4 ) ? 'C' : 'A';
 
	  if ( !rsrc_load( buf2 ) )
	  {
	    strcpy( icndata, buf2 );	/* Try old icon file	*/
	    buf2[0] = ( isdrive() & 0x4 ) ? 'C' : 'A';
	    if ( !rsrc_load( buf2 ) )	
	      goto i_1;
	  }

	  ptr = (LONG*) &c.cb_pglobal[7]; /* get the new rsc address	*/
	  iaddr = (BYTE *) *ptr;
		
	  if ( iconmem )		/* free up memory	*/
	  {				/* use rs_free to free memory	*/
	    *ptr = (LONG) iconmem;	/* because it may have color icons */	
	    rsrc_free();
	  }

	  iconmem = iaddr;		
	  iconaddr = get_tree( 0 );	
	  numicon = iconaddr[0].ob_tail;
	  iconaddr++;			/* get the icon address	*/
	  ret = TRUE;
i_1:					/* restore the pglobal	*/
	  LBCOPY( (BYTE *)c.cb_pglobal,(BYTE *)temp, 30 );
	}

	return( ret );
}

	WORD
d_load_fonts()			/* load GDOS fonts */
{
	REG WORD	i;
	REG FNTLST	*fontsp;

	if (d_spd)		/* Is Speedo GDOS there? */
		d_numfonts = d_v_load_fonts();
	else
		d_numfonts = 1; /* only system font available */
	Debug1("NEWDESK: Fonts loaded\r\n");
	if ((d_fontlst = malloc(d_numfonts * sizeof(FNTLST))) == NULL) {
		do1_alert( FCNOMEM );
		return( FALSE );
	}
	/*
	 *	Get font names
	 */
	for (i = 1, fontsp = d_fontlst; i <= d_numfonts; i++, fontsp++) {
		fontsp->fnt_id = d_v_font_name(i, &fontsp->fnt_name[2], &fontsp->fnt_type);
		fontsp->fnt_name[0] = ' ';	/* build strings so we can also */
		fontsp->fnt_name[1] = ' ';	/* use them in the popup menu 	*/
		fontsp->fnt_name[34] = ' ';
		fontsp->fnt_name[35] = '\0';
		Debug1( fontsp->fnt_name);
	}
	win_font = 0;	/* system font */	
	win_fsize = 10; /* 10 points */

	return( TRUE );
}

/*
 *	Objects for the font popup menu
 */
OBJECT  fntmnb1 = { -1, -1, -1, G_BOX, NONE, SHADOWED, 0xFF1100L, 2, 0, 35, 0 };
OBJECT	fntmnb2 = { -1, -1, -1, G_STRING, NONE, NORMAL, 0L, 0,  1, 35, 1 };

	WORD	
build_fontmenu()	/* build font popup menu for "Set Color & Style" dialog" */
{
	REG WORD	i;
	REG FNTLST	*fontsp;	
	OBJECT		*tree;
	TEDINFO		*ted;

	/*	First, soemthing else...
	 *	Hack Speedo font into the "Desktop Info"
	 *	dialog box.
	 */
	if (d_numfonts > 1) {
		rsrc_gaddr(R_TREE, ADDINFO, &tree); /* Desktop Info... */
		ted = (TEDINFO *) tree[GEMMSG].ob_spec;
		ted->te_font = GDOS_PROP;
		ted->te_fontid = 3;	/* Swiss */
		ted->te_fontsize = -1;	/* Take size of system font */
	}

	/*
	 *	Now the popup menu stuff...
	 */
	if ((fontmn = ( OBJECT *)malloc( (LONG)( ( d_numfonts + 1 ) * sizeof(OBJECT) ))) == NULL) {
		do1_alert( FCNOMEM );
		return FALSE;
	}
	LBCOPY((BYTE*) fontmn, (BYTE*) &fntmnb1, sizeof(OBJECT));	/* outside box	*/
	rsrc_obfix(fontmn, 0);

	fontsp = d_fontlst;
	for (i = 1; i <= d_numfonts; i++, fontsp++) {
		LBCOPY((BYTE *)&fontmn[i], (BYTE *) &fntmnb2, sizeof(OBJECT));
		rsrc_obfix(fontmn, i);
		objc_add(fontmn, 0, i); 
		fontmn[i].ob_spec = (LONG) fontsp->fnt_name;
		fontmn[i].ob_y = (i - 1) * gl_hchar;
		fontmn[i].ob_width = fontmn[0].ob_width;
		fontmn[0].ob_height += gl_hchar;
	}
	return TRUE;
}

/*	Initalize the icon and allocate backid memory	*/

	WORD
ini_icon()
{
	REG WORD	i;
	REG OBJECT	*obj;
	REG IDTYPE	*itype;
	    CICONBLK	*icblk;

	backid = (IDTYPE *) malloc( (LONG)( sizeof( IDTYPE ) * 
		( maxicon + 1 ) ) );

	if ( !backid )
	{
	  do1_alert( FCNOMEM );	/* ++ERS 12/16/92 */
	  return( FALSE );
	}
	
	obj = background;
	
	for ( i = 1; i <= maxicon; i++ )
	{
	  itype = &backid[i];
	  obj[i].ob_type = G_CICON;	/* 7/11/92 */
	  obj[i].ob_flags = HIDETREE;
	  obj[i].ob_state = NORMAL;
	  obj[i].ob_width = dicon.g_w;
	  obj[i].ob_height = dicon.g_h;
	  icblk = (CICONBLK*)(iconaddr[0].ob_spec);
	  itype->i_cicon = *icblk;
	  itype->i_cicon.monoblk.ib_ptext = (LONG) &itype->i_name[0]; 	
	  obj[i].ob_spec = (LONG) &itype->i_cicon;
	  itype->i_path = (BYTE*)0;
	}

	return( TRUE );
}

/*	Shift the menu	*/

	VOID
adj_menu( which )
	WORD	which;
{
	OBJECT	*obj;
	WORD	w,x,y;

	obj = menu_addr;		/* shift the menu	*/
	objc_offset( menu_addr, which, &x, &y );
	
	w = obj[which].ob_width + x;
	if ( w >= ( full.g_w + full.g_x ) )
	{
	  x = w - ( full.g_w + full.g_x ) + gl_wchar;
	  obj[which].ob_x -= x;	
	}			
}


/*	Initalize the desktop resource		*/

	WORD
ini_rsc()
{
	REG OBJECT	*obj;
	GRECT	pt;
	ICONBLK		*iblk;
	WORD		w,i;
	CICONBLK	*icblk;
	BYTE		*verstring;
	TEDINFO		*ted;

#if SOFTLOAD
	if (romdesk) {				/* if loading rsc from */
						/* disk failed and we  */
						/* have to use the rom */
						/* version, then we've */
						/* to do an rsrc_rcfix */ 
		Debug1( "Rsrc_rcfix\r\n" );
		rsrc_rcfix( (LONG)deskptr );
	}
#else
	Debug1( "Rsrc_rcfix\r\n" );
	rsrc_rcfix( (LONG)deskptr );
#endif
	Debug1( "Get tree\r\n" );					
	menu_addr = get_tree( ADMENU );	/* get the menu address		*/
	adj_menu( IDSKITEM - 1 );
	adj_menu( ICONITEM - 1 );			

	if ( !iconaddr )		/* if icon has read in 	*/
	{				/* then read it again	*/
	  if ( !re_icon() )
	  {
	    iconaddr = get_tree( ADICON );
	    numicon = iconaddr[0].ob_tail;
	    iconaddr++;
	  }
	}
	background = get_tree( BACKGROU ); /* was BACKROUND, changed for LC */
	maxicon = background[0].ob_tail;/* max background icon		*/
/* 	Allocate memory for color icons 
 * 	These should go away if we have a RCS that can handle color icon 
 */

	if ( !ciconaddr )	/* 7/10/92 */
	{
	  if ( ciconaddr = (CICONBLK*) malloc( (LONG)( sizeof(CICONBLK) * 
	  maxicon ) ) )
	  {		
	    for ( i = 0; i < maxicon; i++ )
	    {
	      background[i+1].ob_spec = (LONG) &ciconaddr[i];
	      background[i+1].ob_type = (UWORD) G_CICON;
	    }
	  }
	  else
	  {
 	    Cconws( "Color icon failed \r\n" );
	    return(FALSE);
	  }
	}
	rc_copy( (WORD *)&full, (WORD *)&background[0].ob_x );

	/* Precalculate the disk icon's pline values	*/

	if ( iconaddr[0].ob_type == G_CICON )
	{
	  icblk = (CICONBLK*)iconaddr[0].ob_spec;
	  iblk = &icblk->monoblk; 
	}
	else
	  iblk = (ICONBLK*)(iconaddr[0].ob_spec);

	rc_copy( &iblk->ib_xicon,(WORD *) &pt );	/* get the icon's xywh	*/

	d_xywh[0] = pt.g_x;			/* disk icon outline	*/
	d_xywh[3] = d_xywh[1] = pt.g_y;
	d_xywh[4] = d_xywh[2] = d_xywh[0] + pt.g_w; 
	d_xywh[5] = d_xywh[3] + pt.g_h;
	
	rc_copy( &iblk->ib_xtext,(WORD *)&pt );
	d_xywh[8] = d_xywh[6] = pt.g_x + pt.g_w;
	d_xywh[13] = d_xywh[7] = pt.g_y;
	d_xywh[11] = d_xywh[9] = d_xywh[7] + pt.g_h;
	d_xywh[12] = d_xywh[10] = pt.g_x;
	d_xywh[16] = d_xywh[14] = d_xywh[0];
	d_xywh[15] = d_xywh[5];
	d_xywh[17] = d_xywh[1];
				
	dicon.g_x = 0;			/* precalculate text icon's x,y,w,h */
	dicon.g_y = 0;
	dicon.g_w = iblk->ib_wtext;
	dicon.g_h = iblk->ib_hicon + iblk->ib_htext;

	rc_copy( (WORD *)&dicon, (WORD *)&r_dicon );
	r_dicon.g_w += 5;
	r_dicon.g_h += 7;
	r_dicon.g_w += ( full.g_w % r_dicon.g_w ) / ( full.g_w / r_dicon.g_w );
	r_dicon.g_h += ( full.g_h % r_dicon.g_h ) / ( full.g_h / r_dicon.g_h );
				
	w = gl_wchar * 14;		/* text outline	*/

	obj = get_tree( TEXTLINE ); /* was TEXTLINES, changed for LC */
	f_xywh[9] = f_xywh[8] = f_xywh[6] = f_xywh[3] = f_xywh[1] = f_xywh[0] = 0;
	f_xywh[2] = w;
	f_xywh[4] = w;
	f_xywh[5] = obj[TSTYLE].ob_height;
	f_xywh[7] = obj[TSTYLE].ob_height;

/* set up the "Desktop Info..." dialog to show multi/single tasking,
 * and also the right TOS version number
 */
	obj = get_tree(ADDINFO);
	ted = (TEDINFO *)obj[VERTEXT].ob_spec;
	verstring = (BYTE *)ted->te_ptext;
	trap14(0x26, gettosvers);	/* Supexec(gettosvers) */

/* if MiNT is not present, don't show the MiNT copyright box */
/* also, if the TOS version is < 5.00, then show "MultiTOS" instead
 * of "TOS"
 */
	if (!d_multi) {
		obj[MINTCBOX].ob_flags |= HIDETREE;
	} else if (tosvers < 0x0500) {
		tosvers = mintvers;
		verstring = get_string(MTOSVERS);
		ted->te_ptext = verstring;
	}
/* put the version number into the right place in the string */
/* ASSUMPTION: major TOS version is < 10 */
	while (*verstring && *verstring != '#')
		verstring++;
	if (*verstring) {
		*verstring++ = '0' + tosvers/256;
		tosvers &= 0xff;
		*verstring++ = '.';
		*verstring++ = '0' + (tosvers/16);
		*verstring++ = '0' + (tosvers % 16);
	}
	Debug1( "Ini_rsc done\r\n" );	
	return( TRUE );
}

#if SOFTLOAD
/*
 *	chrscver()
 *	Check version number or rsc file
 *	Returns:  1, proper version
 *		  0, wrong version
 *		 -1, unable to open
 */
WORD
chkrscver(fname, vers)		/* check version number of rsc file */
BYTE	*fname;			/* file name */
BYTE	vers;			/* version number it should have */ 
{
	WORD	fd;
	BYTE	rvers;
	BYTE	cvers;
	WORD	rhdr;
	WORD	ret = 0;

	if ( ( fd = dos_open(fname, 0) ) >= 0 )
	{
	  if ( dos_read( fd, 2, (LONG)&rhdr) > 0 )
	  {
	     /*
 	      *	Check the version number in the 1st byte of the rsc header.
	      * The format is: %1xxxxxxx
 	      *                 |  |
	      *                 |  +- version number
	      *                 +---- always one
	      */
	     rvers = (BYTE) (rhdr >> 8);	/* just the first byte */
	     cvers = (BYTE) (vers | 0x80);	/* set version nr. */
	     if (rvers == cvers) {
			ret = 1;
	     }
	   }
	   dos_close(fd);
	} else {
		ret = -1;
	}
	return ret;
}


VOID deskrsc()			/* load the desk rsc from disk */
{
	
	WORD	load = 0;
#if DESKRSVER
	WORD	verflg;
#endif
	UWORD	*rscaddr;

	strcpy("C:\\MULTITOS\\DESKTOP.RSC", DESKRSC);
	DESKRSC[0] = ( isdrive() & 0x4 ) ? 'C' : 'A';

	/*
 	 * Before loading the resource file, check its version
	 * so that we are using the proper one.
  	 *
	 *	Returns:  1, proper version
	 *		  0, wrong version
	 *		 -1, unable to open
	 */
#if DESKRSVER
	if ((verflg = chkrscver(DESKRSC, DSKRSVER)) == 1) {
		load = rsrc_load(DESKRSC);	
	} else if (verflg == 0) {
		form_alert(1, RSCVMSG);
	}
#endif
	if (!load)
	{
		rsc_read();		/* cjg 03/30/93 */
		deskptr = NULL;
		rom_ram(1, (LONG)deskptr);		/* use ROM desktop rsc */
		romdesk = TRUE;
	}
	else
	{
		rsrc_gaddr(0, 0, (LONG *)&rscaddr);
		romdesk = FALSE;
		deskptr = (OBJECT *) rscaddr;
	}
}
#endif



MLOCAL	BYTE	DESK_MAGIC[] = "4c4c444D";
MLOCAL	BYTE	SH_MAGIC[] = "SH_MAGIC=";

/*	Process 2 - Desktop 	*/

#if DESKPRG
	VOID
main( VOID )

#else
	VOID
deskmain()
#endif
{
	REG WORD	i;
	WORD		ret,doitonce,code;
	WORD		*ptr;	
	BYTE		temp[30];
	LONG		value;
	LONG		*pvalue;
	WORD		temp1, temp2;

#if !DESKPRG
	WORD		x;
#endif

	catchsignal( SIGTERM );	/* Redirect all the Signals	*/
				/* Catch only the terminate signal */	
	Psignal( SIGTERM, desk_term );

	initkballoc();		/* initialize the lmalloc() functions */

	if ( !inf_path[0] )	/* Not set up yet		*/	
	  m_infpath( inf_path );

	desk_id = appl_init( );	/* initalize the application	*/

				/* Let AES knows that we will handle AP_TERM 	*/
	shel_write( 9, 0x1, 0,(LONG)Nostr,(LONG)Nostr );
	
#if DESKPRG
	ret = graf_handle( &gl_wchar, &gl_hchar, &gl_wbox, &gl_hbox );
#else
	ret = graf_handle( &x, &x, &x, &x );
#endif
	v_handle = ret;

	desk_vopnvwk( &v_handle, Getrez()+2, &ptr );
	
	if ( !v_handle )
	{
/* we can't really translate this string because the resource file
 * isn't open yet. Bummer! ++ERS 12/16/92
 */
	  form_alert( 1, "[1][ Desktop failed to open | work station ][ BYE ]" );
	  goto m_6;
	}

#if DESKPRG
	gl_ncols = ( ptr[0] + 1 )/ gl_wchar;	/* get # of columns */
	gl_nrows = ( ptr[1] + 1 )/ gl_hchar;	/* get # of rows    */
#endif

	doitonce = TRUE;
#ifdef OBSOLETE_CODE
	icn_whandle = -1;
#endif
	d_exit = L_NOEXIT;

	ciconaddr = (CICONBLK*)0;	/* 7/10/92 */
	ctldown = trap13( 0x0b, -1 ) & 0x0004 ? TRUE : FALSE;	/* 07/19/93 */

	Debug1( "Desktop checks cookie\r\n" );
	
	desk_cMiNT();	/* check to see if we are multitasking */	

#if DESKPRG
	gl_vdo = 0x0L;
				/* _VDO */		/* 7/19/93 */
	getcookie( 0x5F56444FL, &gl_vdo );
#endif

	if ( getcookie( 0x5F414B50L, &value ) )	/* get _AKP cookie */
	{
	  st_keybd = (WORD) (value & 0x00FFL);
	  code = (WORD)(( value >> 8 ) & 0x00FF); 
					/* get the keyboard preferences */
	}
	else
	  st_keybd = code = 0;

	if ( ( st_keybd > 8 ) || ( st_keybd < 0 ) )
	  st_keybd = 0;

	if ( ( code > 6 ) || ( code < 0 ) || ( code == 3 ) )
	  code = 0;

	code = code * 3;
					/* set the default IDT stuff */
	st_time  = (UWORD) TIMETABLE[code++];
	st_date  = (UWORD) TIMETABLE[code++];
	st_dchar = (UWORD) TIMETABLE[code];

	/* The _IDT format is as follow				*/
	/* HIGH WORD  |	         LOW WORD			*/
	/* 31 - 16    | 15-12      11-8     	  7-0 bit 	*/
	/* Reserved   |	st_time    st_date  	  st_char	*/
	/*  		0 12 hour  0  MM-DD-YY   		*/
	/*		1 24 hour  1  DD-MM-YY			*/	
	/*			   2  YY-MM-DD			*/
	/*			   3  YY-DD-MM			*/
		
	if ( getcookie( 0x5F494454L, &value ) )	/* get _IDT cookie */
	{
	  st_date = (UWORD)((value >> 8) & 0xFL); /* get the date preferences */
	  st_time = (UWORD)(( value >> 12 ) & 0xFL);
	  if ( !( st_dchar = (UWORD)(value & 0xffL )) )
	    st_dchar = '/';
	}
top:
	
#if SOFTLOAD
	deskrsc();		/* read desktop resource */
#else
	Debug1( "Desktop does rom ram\r\n" );
	Ndebug1( deskptr );
	rsc_read();			/* cjg 03/19/93 */
	rom_ram( 1, (LONG)deskptr );	/* read in desktop resource	*/
#endif

#if !DESKPRG			/* Do this only with the ROM version */
	Debug1( "Desktop does deskerr\r\n" );

	deskerr();
#endif
	ret = TRUE;		/* assume everything is OK	*/

	if ( getcookie( 0x46534d43L, (LONG *)&pvalue ) ) /* FSMC */
	{
	  if ( (*pvalue++ == 0x5F535044L) && 
	  (((WORD)(*pvalue >> 16)) == 0x0411)) /* _SPD */
	  	d_spd = 1;    /* at least Version 4.11 */
	} 

	if (!d_load_fonts()) 	/* Load Speedo GDOS fonts	*/
		goto m_2;			

	appnode = (APP*)0;	/* No app buffer yet		*/
	applist = (APP*)0;	/* No app list yet		*/
	apsize = 0;		/* Initalize app size		*/
	autofile[0] = 0;

	desk_mice( HOURGLASS );	/* busy bee pointer		*/	
				/* get the full window size	*/

	wind_get( 0, WF_WORKXYWH, &full.g_x, &full.g_y, &full.g_w, &full.g_h );

	Debug1( "Desktop does ini_rsc\r\n" );

	ini_rsc();		/* init the resource		*/

	Debug1( "Ini_icon\r\n" );
	if ( !ini_icon() )	/* hide all the desktop icons	*/
	  goto m_2;

	Debug1( "Mem_init\r\n" );
	if ( !mem_init() )	/* init the app path buffer	*/
	{
m_2:

#if !DESKPRG			/* Do this only with the ROM Version */
	  desknoerr();	  
#endif
	  goto m_1;		/* and desk app buffer		*/
	}

	/* initalize all the windows before reading in inf file	*/

	Debug1( "Ini_window\r\n" );
	ini_windows( );	 

	d_maxcolor = ptr[13];		/* vdi max number of color	*/

	if ( doitonce )			/* do it once only	*/
	  adjobjects();			/* adjust object positions      */
		
	Debug1( "Read inf file\r\n" );
	read_inf();			/* Let see what the user want	*/

	Debug1( "Q_inf\r\n" );
	q_inf();			/* make a copy of inf file	*/
#if !DESKPRG
/* CJG 03/19/93	temporarily disabled... */
	desknoerr();
#endif
					/* Get the real res mode for FALCON	*/
	if ( ( gl_vdo & HIGHWORD ) == FALCON ) 
	  d_rezword = setmode(-1);
	else
	  pref_save = res_type(Getrez()+2);

					/* change the menu bar		*/
	do_view( ( s_view == S_ICON ) ? ICONITEM : TEXTITEM );

	switch( s_sort )
	{
	  case S_NAME:
	    i = NAMEITEM;
	    break;
	  case S_DATE:
	    i = DATEITEM;
	    break;
	  case S_SIZE:
	    i = SIZEITEM;
	    break;
	  case S_TYPE:
	    i = TYPEITEM;
	    break;
	  case S_NO:
	    i = NOSORT;
	}

	Debug1( "Wind_set\r\n" );
	temp1 = (WORD)((LONG) background >> 16L);
	temp2 = (WORD)((LONG)background & 0x0000FFFFL);
	wind_set( 0, WF_NEWDESK, temp1, temp2, 0, 0 );

	Debug1( "Do_view\r\n" );
	do_view( i );			/* fix up the menu bar	*/

	ch_machine( );			/* check the machine	*/
					/* set up the right menu text */
					/* do it here!!!!!!	*/	
	strcpy( get_fstring( ( m_cpu == 30 ) ? CACHETXT : BLTTXT ),
		(BYTE *) menu_addr[BITBLT].ob_spec );

	menu_addr[SUPERITE].ob_type = G_USERDEF; /* was SUPERITEM, changed LC */
	chxcache.ub_code = (LONG) ch_xcache;
	menu_addr[SUPERITE].ob_spec = (LONG) &chxcache; 
		/*  +----------------> was SUPERITEM, changed for LC */

	Debug1( "Ch_cache\r\n" );
	ch_cache( TRUE );		/* set the cache	*/

					/* check desktop file	*/	
	put_keys();			/* set up the key menu	*/

	if (!build_fontmenu()) 		/* Build the font popup menu */
		goto m_1;		/* for "Set Color & Style"   */
					/* dialog box 		     */

	Debug1( "Put menu bar\r\n" );

	if ( d_exit != L_WAKEUP )
	{
	  menu_bar( menu_addr, TRUE );	/* show the menu	*/
	  do_redraw( 0, &full, 0 );	/* draw the background	*/
	}



#if !DESKPRG
	Debug1( "Menu_register\r\n" );
 	menu_register( desk_id, get_fstring(DESKNAME) );
#endif

	Debug1( "Open def\r\n" );
	open_def();			/* open default windows	*/
	desk_mice( ARROW );

	if ( doitonce )
	{
	  if ( autofile[0] )
	    shel_write( 1, ( autofile[1] == '1' ) ? 1 : 0, 0,
		(LONG)&autofile[3],(LONG)Nostr );
	}

	doitonce = FALSE;

	Debug1( "Actions\r\n" );
	
	d_exit = L_NOEXIT;

	actions();			/* handle the events	*/

	wind_update( 1 );		/* Block out any more events	*/
	desk_mice( HOURGLASS );		

	free_windows( );		/* free up all windows	*/	

	wind_set( 0, WF_NEWDESK, 0, 0, 0, 0 );
	
	free( lp_start );		/* free string buffer	*/

	free( appnode );		/* free app buffer	*/
	
	free( backid );

	free( q_addr );			/* update inf file on disk	*/

	wind_update( 0 );		/* release window	*/

					/* Loop again		*/
	if ( ( d_exit == L_READINF ) || ( d_exit == L_WAKEUP ) )
	  goto top;

	Debug7( "Desktop frees mn_bar\r\n" );

	menu_bar( 0x0L, FALSE );
m_1:
	if ( ciconaddr )	/* start everything over again	*/	
	{
	  free( ciconaddr );
	  ciconaddr = (CICONBLK *) 0;
	}

	iconaddr = (OBJECT*) 0;

	if ( iconmem )
	{
	  LBCOPY( (BYTE *)temp,(BYTE *) c.cb_pglobal, 30 );
	  *((LONG*)(&c.cb_pglobal[7])) = (LONG) iconmem;
	  rsrc_free(); 	
	  iconmem = (BYTE*) 0;
	  LBCOPY((BYTE *)c.cb_pglobal,(BYTE *)temp, 30 );	
	}

	inf_path[0] = 0;
	d_v_unload_fonts();
	d_v_clsvwk( );
m_6:
	appl_exit();
	Pterm( 1 );
}


/*	Check the machine type and set res table	*/

	VOID
ch_machine()
{
	LONG	value;

	m_st = TRUE;		
			/* _VDO	*/
	if ( getcookie( 0x5F56444FL, &value ) )
	{			/* 7/16/92 */
	  if ( ( ( value >> 16L ) & 0x0000FFFFL ) >= 0x02 )	/* TT	*/
	    m_st = FALSE;
	}
			/* _CPU	*/
	getcookie( 0x5F435055L, &value );
	m_cpu =  (WORD) value;

	/* the restable is set according to gl_restype value	*/

	bfill( 6, 0, restable );	/* zero the table	*/

	if ( !m_st )			/* TT machine	*/
	{
	  if ( pref_save == 5 )		/* TT High	*/
	    restable[4] = 1;
	  else
	  {
	    bfill( 4, 1, restable );	/* LOW MEDIUM HIGH	*/
	    restable[5] = 1;		/* TT-LOW MEDIUM	*/
	  }
	}	
	else
	{
	  if ( pref_save == 3 )		/* ST HIGH		*/
	    restable[2] = 1;
	  else
	  {
	    restable[0] = 1;
	    restable[1] = 1;	
	  }		
	}
}


#pragma inline asm1() { "4e7a"; "0002"; }

#pragma inline asm2() { "4e7b"; "7002"; }

#pragma inline asm3() { "4e7a"; "7002"; }

#pragma inline asm4() { "2007"; }

	LONG
inq_cache( data )
	REG LONG	data;
{
	BYTE	*old;
	WORD	super;

	super = (WORD) Super( 0x1L );
	
	if ( !super )
	  old = (BYTE *) Super( 0x0L );
		asm1();
	  /*asm( ".dc.w $4e7a,$0002" );*/ /* movec.l cacr,d0		*/

	  if ( data != -1 )
		asm2();
	    /*asm( ".dc.w $4e7b,$7002" );*/ /* movec.l d7,cacr		*/
	  asm3();
	  /*asm( ".dc.w $4e7a,$7002" );*/ /* movec.l cacr,d7		*/

	if ( !super )
	  Super( old );

	asm4();
	/*asm( ".dc.w $2007" );*/

}



/*	Turn on the cache or bitblt 	*/

	VOID
ch_cache( set )
	WORD	set;
{
	WORD	value;
	LONG	data;
	WORD	temp;

	menu_addr[BITBLT].ob_state &= ~DISABLED;

	if ( m_cpu == 30 )
	{
	  if ( set )
	    data = ( s_cache ) ? CACHE_ON : CACHE_OFF;
	  else
	    data = 0xFFFFFFFFL;

	  if ( inq_cache( data ) == XCA_ON )
	    s_cache = TRUE;
	  else
	    s_cache = FALSE;

	  value = s_cache;

	}
	else
	{				/* turn the blt on	*/
					/* blt is there		*/
ch_1:	  if ( ( temp = (WORD)trap14( 64, -1 ) ) & 0x2 )	
	  {
	    if ( set )
	    {
	      trap14( 64, ( cbit_save ) ? 1 : 0  );
	      set = FALSE;
	      goto ch_1;	/* check status again	*/
	    }
	    else
	      cbit_save = ( temp & 0x1 ) ? TRUE : FALSE; 	
	      		
	    value = cbit_save;

	  }
	  else
	  {
	    value = FALSE;
	    menu_addr[BITBLT].ob_state |= DISABLED;
	  }
	}

	if ( value )
	  menu_addr[BITBLT].ob_state |= CHECKED;
	else 
	  menu_addr[BITBLT].ob_state &= ~CHECKED;
}


	
/* Adjust Object Positions */

	VOID
adjobjects()
{
    REG OBJECT 	*obj;
    WORD	x,y,w,h,dx,dy;	    
	
    obj = get_tree( ADINSDIS );
    objc_gclip( obj, IUP, &dx, &dy, &x, &y, &w, &h );
    obj[ IDOWN ].ob_y = h + obj[IUP].ob_y;   
    obj[ IDRIVE ].ob_y += 2;
    obj[ ITRASH ].ob_y += 2;
    obj[ IPRINTER ].ob_y += 2;

    obj = get_tree( INWICON );
    objc_gclip( obj, WUP, &dx, &dy, &x, &y, &w, &h );
    obj[ WDOWN ].ob_y = h + obj[ WUP ].ob_y;
    obj[ WFOLDER ].ob_height = gl_hchar;
    obj[ WNONE ].ob_height = gl_hchar;
    obj[ WOK ].ob_height = gl_hchar;
    obj[ WREMOVE ].ob_height = gl_hchar;
    obj[ WSKIP ].ob_height = gl_hchar;
    obj[ WQUIT ].ob_height = gl_hchar;    

    obj = get_tree( MNSYSTEM );
    objc_gclip( obj, MFUP, &dx, &dy, &x, &y, &w, &h );
    obj[ MFDOWN ].ob_y = h + obj[ MFUP ].ob_y;
    objc_gclip( obj, MKUPS, &dx, &dy, &x, &y, &w, &h );    
    obj[ MKDOWNS ].ob_y = h + obj[ MKUPS ].ob_y;
    obj[ MFBASE ].ob_height += 2;

    obj = get_tree( ADFILEIN );
    obj[ FIOK ].ob_y   += 2;
    obj[ FISKIP ].ob_y += 2;
    obj[ FICNCL ].ob_y += 2;
    obj[ FIRONLY ].ob_y -= 1;
    obj[ FIRWRITE ].ob_y -= 1;
}


#if DESKPRG

	VOID
Ndebug( level, number )
	WORD	level;
	LONG	number;
{
	BYTE	buffer[14];

	lbintohex( number, buffer );
	Debug( level, buffer );
	Debug( level, "\r\n" );	
}

/*	Debug routine	*/

	VOID
Debug( level, str )
	WORD	level;
	BYTE	*str;
{
	if ( gl_debug >= level )
	{
#if 1
	  while( *str )
	    trap13( 3, gl_port, *str++ );
#else
	  trap(9, str);
#endif
	}
}
#endif

@


1.9
log
@Merged in Hans-Martin and Cary's changes
@
text
@d86 1
d88 1
d306 2
a307 2
OBJECT  fntmn_b1 = { -1, -1, -1, G_BOX, NONE, SHADOWED, 0xFF1100L, 2, 0, 35, 0 };
OBJECT	fntmn_b2 = { -1, -1, -1, G_STRING, NONE, NORMAL, 0L, 0,  1, 35, 1 };
d336 1
a336 1
	LBCOPY((BYTE*) fontmn, (BYTE*) &fntmn_b1, sizeof(OBJECT));	/* outside box	*/
d341 1
a341 1
		LBCOPY((BYTE *)&fontmn[i], (BYTE *) &fntmn_b2, sizeof(OBJECT));
d710 1
d712 1
d785 3
a787 2
	  if ( *pvalue == 0x5F535044L ) /* _SPD */
	  	d_spd = 1;
@


1.8
log
@Another check in to save work.
@
text
@d20 1
a21 1

d112 3
d120 7
d269 80
d663 1
d779 9
d888 4
d969 2
a970 1
	v_clsvwk( );
d1192 1
@


1.7
log
@Check in to save work
@
text
@d137 1
a137 2
MLOCAL BYTE	*DESKRSC = "C:\\MULTITOS\\DESKTOP.RSC";
MLOCAL BYTE	*FDESKRSC = "DESKTOP.RSC";
d458 2
a459 2
		*verstring++ = '0' + (tosvers/10);
		*verstring++ = '0' + (tosvers % 10);
d518 2
a519 1
	*DESKRSC = ( isdrive() & 0x4 ) ? 'C' : 'A';
@


1.6
log
@Merged Cary's and Hans-Martin's changes
@
text
@d71 1
a71 1
 *	See the Defines in the makegem/makedesk files.
d99 1
a151 3



d156 2
a157 1
	LONG	value;
d159 3
a161 2
	return( d_multi = getcookie( 0x4D694E54L, &value ) );
}
d163 1
d165 3
d169 2
d172 2
d331 2
d431 31
d514 1
d516 1
@


1.5
log
@Incorporated more single/multitasking changes.
@
text
@d18 2
d21 1
d42 1
a42 1

d51 1
a51 1
 *	NOTE: You have to define SOFTLOAD in gemrom.c, too, because there
d53 2
d56 1
a56 1
#define SOFTLOAD 1
d58 2
a59 1
 *	Version number of the DESKTOP.RSC file. Use "rscvers versnr DESKTOP.RSC"
d63 1
d65 7
a71 8
#define DSKRSVER 1
/* 
 * 	Set the ONERSC flag to indicate that the system just has the
 *	U.S. desktop resource in ROMs. If the system cannot load the
 *	DESKTOP.RSC from disk, it will pop up a warning, saying that
 *	the U.S. version from ROM will be used.
 *
 *	-> This message has to get internationalized!
a73 2
/* #define  ONERSC		1 */	

d125 5
a129 1
};	
d131 5
a135 1
#ifdef SOFTLOAD
d147 2
a148 3
BYTE	*RSCNMSG =	"[1][Desktop resource not found in|MULTITOS \
directory. Use file|selector to specify it or|click on Cancel in file|\
selector to use ROM version.][ OK ]";
a149 1
BYTE	*RSCSMSG = 	"Find DESKTOP.RSC file.";
a150 2
BYTE	*RSCFMSG =	"[1][Loading the specified resource|file failed. \
Click on Cancel|in the file selector to use|U.S. ROM resource.][ OK ]";
a151 2
BYTE	*RSCRMSG =	"[1][No DESKTOP.RSC file loaded.|Using U.S. version \
from ROM.][ OK ]";
a152 2
GLOBAL WORD	romdesk;
#endif
d154 1
d164 4
d176 1
a267 3
#if 0
	  form_alert( 1, "[1][ Desktop failed to allocate | icon memory ][ OK ]" );
#else
a268 1
#endif
d324 1
a324 1
#ifdef SOFTLOAD
a336 1
		
a338 1
			
a350 1

a351 1
					
a352 1

a363 2
/*	      ciconaddr[i].monoblk = *((ICONBLK*)background[i+1].ob_spec);	*/
/*              ciconaddr[i].mainlist = (CICON*)0;	*/
a373 1

a420 1

d425 1
a425 1
#ifdef SOFTLOAD
a474 6
#ifdef ONERSC
	WORD	loop = 1;
	WORD	button = 0;
	BYTE	path[256];
	BYTE	fname[16];
#endif
d486 1
a486 1

a491 29

#ifdef	ONERSC
	if (!load) {
				/* std. desk rsc not found */
		if (verflag == -1)	/* file not found */
			form_alert(1, RSCNMSG);
		do {
			
			strcpy( "C:\\*.RSC", path );
	    		path[0] = ( isdrive() & 0x04 ) ? 'C' : 'A';
	    		strcpy( FDESKRSC, fname );

			fsel_exinput(path, fname, &button, RSCSMSG);
			rep_path(fname, path);
 
			if (button) {
				if ((verflg = chkrscver(path, DSKRSVER))==0){
					form_alert(1, RSCVMSG);
					loop = 1;
				} else if ((load = rsrc_load(path)) == 0) {
					form_alert(1, RSCFMSG);
					loop = 1;
				} else 
					loop = 0;
			} else
				loop = 0;
		} while (loop);

	}
d493 3
a495 6
	if (!load) {
#ifdef	ONERSC
		if (st_lang != 0)	/* No U.S. machine */
			form_alert(1, RSCRMSG);
				/* this msg has to get internationalized */
#endif
d499 3
a501 1
	} else {
d509 2
d516 1
d518 4
d523 1
d526 1
a526 1
	WORD		ret,x,doitonce,code;
d532 2
a533 4
#if 0	/* NOT USED: */
	WORD		buffer[8];		
	OBJECT		*obj;
	LONG		*lptr;
a535 1

d550 3
d554 1
d568 5
d578 1
d581 2
d584 5
a588 1
	desk_cMiNT();	/* check to see if we are multitasking */
d629 1
a629 1
#ifdef SOFTLOAD
d634 1
d637 2
d642 1
a642 1

d666 5
a670 1
m_2:	  desknoerr();	  
a681 4
	{
#if 0
	  adjdcol( WHITE );		/* adjust dialogue box's color  */
#endif
a682 1
	}
d689 2
a690 1

d692 1
d753 3
d758 1
a969 43
#if 0
/* adjust object colors if it is invalid */

/* NOTE: This routine should no longer be necessary, but is
 * maintained "just to be sure"
 * ++ERS, 1/19/93
 */
	VOID
adjdcol(color)
	UWORD color;
{
    REG OBJECT  *obj;

    if ( d_maxcolor > LWHITE)
	return;

    obj = get_tree(ADFILEIN);
    obj[FILEFT].ob_spec = (obj[FILEFT].ob_spec & 0xfffffff0) | color;
    obj[FIRIGHT].ob_spec = (obj[FIRIGHT].ob_spec & 0xfffffff0) | color;

    obj = get_tree(ADINSDIS);
    obj[IUP].ob_spec = (obj[IUP].ob_spec & 0xfffffff0) | color;
    obj[IDOWN].ob_spec = (obj[IDOWN].ob_spec & 0xfffffff0) | color;

    obj = get_tree(ADFORMAT);
    obj[SRCDRA].ob_spec = (obj[SRCDRA].ob_spec & 0xfffffff0) | color;
    obj[SRCDRB].ob_spec = (obj[SRCDRB].ob_spec & 0xfffffff0) | color;
    obj[ADRIVE].ob_spec = (obj[ADRIVE].ob_spec & 0xfffffff0) | color;
    obj[BDRIVE].ob_spec = (obj[BDRIVE].ob_spec & 0xfffffff0) | color;

    obj = get_tree(INWICON);
    obj[WUP].ob_spec = (obj[WUP].ob_spec & 0xfffffff0) | color;
    obj[WDOWN].ob_spec = (obj[WDOWN].ob_spec & 0xfffffff0) | color;

    obj = get_tree(MNSYSTEM);
    obj[ MFLEFT ].ob_spec = ( obj[ MFLEFT ].ob_spec & 0xfffffff0L ) | color;
    obj[ MFRIGHT ].ob_spec = ( obj[ MFRIGHT ].ob_spec & 0xfffffff0L ) | color;
    obj[ MFUP ].ob_spec = ( obj[ MFUP ].ob_spec & 0xfffffff0L ) | color;
    obj[ MFDOWN ].ob_spec = ( obj[ MFDOWN ].ob_spec & 0xfffffff0L ) | color;
    obj[ MKUPS ].ob_spec = ( obj[ MKUPS ].ob_spec & 0xfffffff0L ) | color;
    obj[ MKDOWNS ].ob_spec = ( obj[ MKDOWNS ].ob_spec & 0xfffffff0L ) | color;
}
#endif
d1010 34
@


1.4
log
@Merged HMK's loadable resource stuff
@
text
@d94 1
d150 9
d569 1
d605 2
@


1.3
log
@Lattice port
@
text
@d51 1
a51 1
#undef SOFTLOAD
d58 1
a58 1
#undef DSKRSVER
d156 1
a159 1
#if 0
a167 1
#endif
d172 1
d939 1
a939 1
ch_1:	  if ( ( temp = trap14( 64, -1 ) ) & 0x2 )	
@


1.2
log
@REAL MultiTOS 1.01
@
text
@d17 1
d25 44
a68 12
#include <compiler.h>
#include <machine.h>
#include <deskobde.h>
#include <deskdefi.h>
#include <deskwin.h>
#include <gemdefs.h>
#include <osbind.h>
#include <extern.h>
#include <mintbind.h>	
#include <signal.h>
#include <vdomode.h>
#include <deskusa.h>
d72 6
a77 6
	long		cb_pcontrol;
	int		*cb_pglobal;
	long		cb_pintin;
	long		cb_pintout;
	long		cb_padrin;
	long		cb_padrout;		
a80 5
EXTERN	BYTE	*get_fstring();
EXTERN	BYTE	*malloc();
EXTERN	VOID	free();
EXTERN	OBJECT	*get_tree();

d88 1
a88 1
EXTERN	OBJECT	*deskptr;		/* desktop resource	*/
d92 1
d111 1
a111 1
MLOCAL	BYTE	*TIMETABLE[] =
d122 11
d134 15
d155 1
a155 1
	return;
d158 1
a158 1
	ciconaddr = (BYTE*)0;
d162 1
a162 1
	  LBCOPY( temp, c.cb_pglobal, 30 );
d170 1
a170 1
	iconmem = (OBJECT*) 0;
d189 1
a189 1
	REG WORD	i,ret;
d199 1
a199 1
	  LBCOPY( temp, c.cb_pglobal, 30 );
d211 2
a212 2
	  ptr = &c.cb_pglobal[7];	/* get the new rsc address	*/
	  iaddr = *ptr;
d216 1
a216 1
	    *ptr = iconmem;		/* because it may have color icons */	
d226 1
a226 1
	  LBCOPY( c.cb_pglobal, temp, 30 );
d243 2
a244 1
	backid = malloc( (LONG)( sizeof( IDTYPE ) * ( maxicon + 1 ) ) );
d264 2
a265 2
	  obj[i].ob_width = dicon.w;
	  obj[i].ob_height = dicon.h;
d268 2
a269 2
	  itype->i_cicon.monoblk.ib_ptext = &itype->i_name[0]; 	
	  obj[i].ob_spec = &itype->i_cicon;
d289 1
a289 1
	if ( w >= ( full.w + full.x ) )
d291 1
a291 1
	  x = w - ( full.w + full.x ) + gl_wchar;
d308 14
a321 2
	Debug1( "Rsrc_rcfix\r\n" );	
	rsrc_rcfix( deskptr );				
d338 1
a338 1
	background = get_tree( BACKGROUND );
d348 2
a349 1
	  if ( ciconaddr = malloc( (LONG)( sizeof(CICONBLK) * maxicon ) ) )
d355 2
a356 2
	      background[i+1].ob_spec = &ciconaddr[i];
	      backgroubd[i+1].ob_type = G_CICON;
d366 1
a366 1
	rc_copy( &full, &background[0].ob_x );
d378 1
a378 1
	rc_copy( &iblk->ib_xicon, &pt );	/* get the icon's xywh	*/
d380 10
a389 10
	d_xywh[0] = pt.x;			/* disk icon outline	*/
	d_xywh[3] = d_xywh[1] = pt.y;
	d_xywh[4] = d_xywh[2] = d_xywh[0] + pt.w; 
	d_xywh[5] = d_xywh[3] + pt.h;
	
	rc_copy( &iblk->ib_xtext, &pt );
	d_xywh[8] = d_xywh[6] = pt.x + pt.w;
	d_xywh[13] = d_xywh[7] = pt.y;
	d_xywh[11] = d_xywh[9] = d_xywh[7] + pt.h;
	d_xywh[12] = d_xywh[10] = pt.x;
d394 10
a403 10
	dicon.x = 0;			/* precalculate text icon's x,y,w,h */
	dicon.y = 0;
	dicon.w = iblk->ib_wtext;
	dicon.h = iblk->ib_hicon + iblk->ib_htext;

	rc_copy( &dicon, &r_dicon );
	r_dicon.w += 5;
	r_dicon.h += 7;
	r_dicon.w += ( full.w % r_dicon.w ) / ( full.w / r_dicon.w );
	r_dicon.h += ( full.h % r_dicon.h ) / ( full.h / r_dicon.h );
d407 1
a407 1
	obj = get_tree( TEXTLINES );
d418 58
d477 61
d543 1
a543 1
	WORD
d548 1
a548 3
	WORD		*ptr;
	WORD		buffer[8];
	OBJECT		*obj;
d551 5
d557 1
d571 1
a571 1
	shel_write( 9, 0x1, 0, Nostr, Nostr );
d591 1
a591 1
	ciconaddr = (BYTE*)0;	/* 7/10/92 */
d597 3
a599 2
	  st_keybd = value & 0x00FFL;
	  code = ( value >> 8 ) & 0x00FF;	/* get the keyboard preferences */
d612 3
a614 3
	st_time = TIMETABLE[code++];
	st_date = TIMETABLE[code++];
	st_dchar = TIMETABLE[code];
d627 3
a629 3
	  st_date = ( value >> 8 ) & 0xFL;	/* get the date preferences */
	  st_time = ( value >> 12 ) & 0xFL;
	  if ( !( st_dchar = value & 0xffL ) )
d633 4
d639 2
a640 2
	rom_ram( 1, deskptr );	/* read in desktop resource	*/

d647 2
a648 2
	appnode = (BYTE*)0;	/* No app buffer yet		*/
	applist = (BYTE*)0;	/* No app list yet		*/
d655 1
a655 1
	wind_get( 0, WF_WORKXYWH, &full.x, &full.y, &full.w, &full.h );
d722 3
a724 1
	wind_set( 0, WF_NEWDESK, background, 0, 0 );
d732 2
a733 1
	strcpy( get_fstring( ( m_cpu == 30 ) ? CACHETXT : BLTTXT ), menu_addr[BITBLT].ob_spec );
d735 4
a738 3
	menu_addr[SUPERITEM].ob_type = G_USERDEF;
	chxcache.ub_code = ch_xcache;
	menu_addr[SUPERITEM].ob_spec = &chxcache;
d755 1
a755 1
	menu_register( desk_id, get_fstring(DESKNAME) );
d764 2
a765 1
	    shel_write( 1, ( autofile[1] == '1' ) ? 1 : 0, 0, &autofile[3], Nostr );
d781 1
a781 1
	wind_set( 0, WF_NEWDESK, 0x0L, 0, 0 );
d804 1
a804 1
	  ciconaddr = (BYTE*)0;
d811 2
a812 2
	  LBCOPY( temp, c.cb_pglobal, 30 );
	  *((LONG*)(&c.cb_pglobal[7])) = iconmem;
d815 1
a815 1
	  LBCOPY( c.cb_pglobal, temp, 30 );	
d828 1
a828 1
	WORD
d837 1
a837 1
	  if ( ( ( value >> 16 ) & 0x0000FFFFL ) >= 0x02 )	/* TT	*/
d842 1
a842 1
	m_cpu = value;
d871 8
d884 1
a884 1
	int	super;
d886 1
a886 1
	super = Super( 0x1L );
d889 3
a891 3
	  old = Super( 0x0L );

	  asm( ".dc.w $4e7a,$0002" ); /* movec.l cacr,d0		*/
d894 4
a897 1
	    asm( ".dc.w $4e7b,$7002" ); /* movec.l d7,cacr		*/
a898 2
	  asm( ".dc.w $4e7a,$7002" ); /* movec.l cacr,d7		*/

d902 3
a904 1
	asm( ".dc.w $2007" );
@


1.1
log
@1 meg floppy MultiTOS
@
text
@d371 2
@


1.0
log
@MultiTOS version 1.0
@
text
@d50 1
d280 1
a280 1
	  if ( ciconaddr = Malloc( (LONG)( sizeof(CICONBLK) * maxicon ) ) )
d552 1
a552 1
	menu_register( desk_id, "  \016\017 DESKTOP" );
d579 1
a579 1
	Mfree( lp_start );		/* free string buffer	*/
d581 1
a581 1
	Mfree( appnode );		/* free app buffer	*/
d583 1
a583 1
	Mfree( backid );
d585 1
a585 1
	Mfree( q_addr );		/* update inf file on disk	*/
d599 1
a599 1
	  Mfree( ciconaddr );
@
