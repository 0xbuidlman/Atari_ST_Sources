head	1.10;
access;
symbols;
locks
	ersmith:1.10;
comment	@ * @;


1.10
date	93.06.15.22.53.36;	author ersmith;	state Exp;
branches;
next	1.9;

1.9
date	93.06.14.23.48.02;	author ersmith;	state Exp;
branches;
next	1.8;

1.8
date	93.06.09.23.47.00;	author ersmith;	state Exp;
branches;
next	1.7;

1.7
date	93.05.12.15.50.18;	author ersmith;	state Exp;
branches;
next	1.6;

1.6
date	93.04.27.23.00.14;	author ersmith;	state Exp;
branches;
next	1.5;

1.5
date	93.04.14.22.19.54;	author ersmith;	state Exp;
branches;
next	1.4;

1.4
date	93.03.12.19.51.12;	author ersmith;	state Exp;
branches;
next	1.3;

1.3
date	93.03.10.20.12.42;	author ersmith;	state Exp;
branches;
next	1.2;

1.2
date	93.03.08.20.07.02;	author ersmith;	state Exp;
branches;
next	1.1;

1.1
date	93.02.24.23.52.46;	author ersmith;	state Exp;
branches;
next	1.0;

1.0
date	93.02.03.21.26.46;	author ersmith;	state Exp;
branches;
next	;


desc
@OS bindings
@


1.10
log
@Minor resource editing, elclean ups, etc.
@
text
@/*	DOSBIND.C		8/31/90					*/
/*	.title	'GEMDOS Bindings for AES/Desktop'			*/
/*	Bug fixed 2/5/87						*/
/*	Added global definition	11/30/87	D.Mui			*/
/*	Add do_cdir		1/28/88		D.Mui			*/
/*	Use MAC to assemble	6/29/90		D.Mui			*/
/*	Restore into C language	from 3.01	8/31/90	D.Mui		*/
/*	Convert to Lattice C 5.51		2/17/93	C.Gee		*/
/*	Force the use of prototypes		2/25/93 C.Gee		*/

/*
 *	Set the DESKPRG flag to compile this file for a
 *	replacement Desktop. Clear it for making GEM.SYS
 *
 *	See the Defines in SOFTLOAD.H
 */


#include "pgem.h"
#include "pmisc.h"
#include "gemdos.h"
#include "machine.h"
#include "softload.h"

EXTERN	LONG	trap();

GLOBAL	WORD	DOS_AX;

#if DESKPRG
EXTERN	WORD	d_multi;
#else
EXTERN	WORD	gl_multi;
#endif

/*  I know what this does, but I don't
*  know why it's supposed to do it.
*/
	WORD
isdrive( VOID )
{
	return( dos_sdrv( dos_gdrv() ) );
}


	LONG
dos_pexec( mode, name, tail, envr )
	WORD	mode;
	BYTE	*name,*tail,*envr;
{
	return( trap( X_EXEC,mode,name,tail,envr ) );
}
	

	WORD				/* 8/31/90	*/
pgmld( pname, ldaddr, tail, envrn )
  	BYTE	*pname,*tail,*envrn;
  	LONG	**ldaddr;
{
  	LONG	length;
  	LONG	*temp;
  
	if ( *ldaddr = ( LONG *)trap( X_EXEC, 3, pname, tail, envrn ) )
	{
  	  temp = *ldaddr;		/* code+data+bss lengths */
#if DESKPRG
	  if (d_multi)
#else
	  if (gl_multi)
#endif
  	    length = temp[3] + temp[5] + temp[7] + 0x150;
	  else
	  {
	    length = temp[3] + temp[5] + temp[7] + 0x1100;	/* gives 4K of stack, +256 bytes for basepage */
	    temp[1] = temp[0] + length;		/* save top of TPA for user stack */
	  }
	  if ( !trap( X_MSHRINK, 0, *ldaddr, length ) )
  	    return( TRUE );
	}

	return(-1);
}


	WORD				/* 8/31/90	*/
dos_sfirst(pspec, attr)
  	LONG		pspec;
  	WORD		attr;
{
  	REG LONG		ret;

  	if ( !( ret = trap(X_SFIRST,pspec,attr) ) )
  	  return(TRUE);

  	if ( ret == ENMFIL || ret == EFILNF )
  	  DOS_AX = E_NOFILES;

 	return(FALSE);
}


	WORD			/* 8/31/90	*/
dos_snext( VOID )
{
  	REG LONG		ret;

  	if ( !( ret = trap(X_SNEXT) ) )
  	  return(TRUE);

  	if ( ret == ENMFIL || ret == EFILNF )
  	  DOS_AX = E_NOFILES;

  	return(FALSE);
}



	WORD
dos_open(pname, access)
  	BYTE		*pname;
  	WORD		access;
{
  	return( (WORD)trap( X_OPEN, pname, access ) );
}



	VOID
dos_rename( old, new )
	BYTE	*old,*new;
{
	trap( X_RENAME, 0, old, new );
}

	
	WORD
dos_read(handle, cnt, pbuffer)
  	WORD		handle;
  	UWORD		cnt;
  	LONG		pbuffer;
{
 	LONG		ret;

  	ret = trap(X_READ,handle,(ULONG)cnt,pbuffer);
  	return((UWORD)ret);
}


	UWORD
dos_write(handle, cnt, pbuffer)
  	WORD		handle;
  	LONG		cnt;
	BYTE		*pbuffer;
{
 	return( (UWORD)trap(X_WRITE,handle,cnt,pbuffer));
}



	LONG
dos_lseek(handle, smode, sofst)
  	WORD		handle;
  	WORD		smode;
  	LONG		sofst;
{
  	return( trap(X_LSEEK,sofst, handle, smode) );
}


	WORD
dos_gdir(drive, pdrvpath)
  	WORD		drive;
  	LONG		pdrvpath;
{
 	return( ( WORD )trap(X_GETDIR,pdrvpath,drive) );
}



	LONG
dos_xalloc(nbytes, type)
  	LONG		nbytes;
	WORD		type;
{
	LONG		ret;
#if DESKPRG
	if (!d_multi) {
#else
	if (!gl_multi) {
#endif
		type &= 0x03;
	}
	ret = trap( X_XMALLOC, nbytes, type );
	Debug1( "AES Dos_xalloc " );
	Ndebug1( nbytes );

	return( ret );
}


	WORD
dos_gdrv( VOID )
{
	return( ( WORD )trap(X_GETDRV) );
}


/*	Set dta buffer	*/

	WORD
dos_dta(ldta)
	LONG		ldta;
{
	return( ( WORD )trap(X_SETDTA,ldta));
}


	WORD
dos_close(handle)
	WORD		handle;
{
	return( ( WORD )trap(X_CLOSE,handle) );
}


	LONG			/* 9/4/90	*/
dos_chdir(pdrvpath)
	LONG		pdrvpath;
{
	return( trap( X_CHDIR, pdrvpath ) );
}


	WORD
dos_free(maddr)
	LONG		maddr;
{
	Debug7( "AES frees " );
	Ndebug7( maddr );
	return( ( WORD )trap(X_MFREE,maddr) );
}


	WORD
dos_sdrv(newdrv)
	WORD		newdrv;
{
	return( ( WORD )trap(X_SETDRV,newdrv) );
}


	WORD		/* 8/30/90	*/
do_cdir( drive, path )
	WORD	drive;
	BYTE	*path;
{
	trap( X_SETDRV, drive );
	return( ( WORD )trap( X_CHDIR, path ) );
}


	VOID
dos_term( code )
	WORD	code;
{
	trap( X_TERM, code );
}


/*	Set the current directory				*/
/*	The path should look like A:\ or A:\FOLDER for mode 1	*/
/*	The path should look like A:\FILENAME or 		*/
/*	A:\FOLDER\FILENAME for mode 0				*/


	VOID
dos_setdir( path, mode )
	REG BYTE	path[];
	WORD		mode;
{
	REG BYTE	*ptr;

	if ( path[0] == '\\' )		/* at the current root	*/
	{
	   dos_chdir( ( LONG )"\\" );
	   return;
	}

	if ( path[1] == ':' )		/* drive id	*/
	  dos_sdrv( (WORD)( toupper( path[0] ) - 'A') );
	else
	  return; 
	
	if ( mode )
	  dos_chdir( ( LONG )&path[2] );
	else
	{
	  ptr = r_slash( path );
	  if ( &path[2] == ptr )
	  {
	    Debug1( "Set to root\r\n" );		
	    dos_chdir( ( LONG )"\\" );
	  }
	  else
	  {
	    *ptr = 0;
	    dos_chdir( ( LONG )&path[2] );
	    *ptr = '\\';	
	  }
	}
}
@


1.9
log
@Merged in Hans-Martin and Cary's changes
@
text
@@


1.8
log
@Another check in to save work.
@
text
@@


1.7
log
@Check in to save work
@
text
@@


1.6
log
@Merged Cary's and Hans-Martin's changes
@
text
@d14 2
a15 3
 *      DESKPRG must also be set/cleared in
 *	      DESKSTAR.S, DESKVARI.C, DESKROM.C
 *	See the Defines in makedesk/makegem files.
d23 1
@


1.5
log
@Incorporated more single/multitasking changes.
@
text
@d10 10
d28 4
d33 1
d65 3
d69 1
d185 3
a187 1

d189 1
@


1.4
log
@Merged HMK's loadable resource stuff
@
text
@d18 1
a19 1

d30 1
a30 1
	WORD
d35 1
a35 1
	return( (WORD)trap( X_EXEC,mode,name,tail,envr ) );
d50 7
a56 1
  	  length = temp[3] + temp[5] + temp[7] + 0x150;
d167 3
d173 1
@


1.3
log
@Lattice port
@
text
@@


1.2
log
@REAL MultiTOS 1.01
@
text
@d8 6
a14 3
#include	<gemdos.h>
#include 	<machine.h>

a15 1
EXTERN	BYTE	*r_slash();
d19 1
d24 1
a24 1
isdrive()
d47 1
a47 1
	if ( *ldaddr = trap( X_EXEC, 3, pname, tail, envrn ) )
d77 1
a77 1
dos_snext()
a96 2
  	LONG		ret;
  
d149 1
a149 1
 	return( trap(X_GETDIR,pdrvpath,drive) );
d169 1
a169 1
dos_gdrv()
d171 1
a171 1
	return( trap(X_GETDRV) );
d177 1
a177 1
	VOID
d181 1
a181 1
	return(trap(X_SETDTA,ldta));
d189 1
a189 1
	return( trap(X_CLOSE,handle) );
a196 2
	LONG		ret;

d207 1
a207 1
	return( trap(X_MFREE,maddr) );
d215 1
a215 1
	return( trap(X_SETDRV,newdrv) );
d225 1
a225 1
	return( trap( X_CHDIR, path ) );
d252 1
a252 1
	   dos_chdir( "\\" );
d262 1
a262 1
	  dos_chdir( &path[2] );
d269 1
a269 1
	    dos_chdir( "\\" );
d274 1
a274 1
	    dos_chdir( &path[2] );
@


1.1
log
@1 meg floppy MultiTOS
@
text
@@


1.0
log
@MultiTOS version 1.0
@
text
@@
