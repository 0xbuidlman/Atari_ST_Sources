head	1.10;
access;
symbols;
locks
	ersmith:1.10;
comment	@ * @;


1.10
date	93.06.15.22.53.36;	author ersmith;	state Exp;
branches;
next	1.9;

1.9
date	93.06.14.23.48.02;	author ersmith;	state Exp;
branches;
next	1.8;

1.8
date	93.06.09.23.47.00;	author ersmith;	state Exp;
branches;
next	1.7;

1.7
date	93.05.12.01.40.22;	author ersmith;	state Exp;
branches;
next	1.6;

1.6
date	93.04.27.23.00.14;	author ersmith;	state Exp;
branches;
next	1.5;

1.5
date	93.04.14.22.19.54;	author ersmith;	state Exp;
branches;
next	1.4;

1.4
date	93.03.12.19.51.12;	author ersmith;	state Exp;
branches;
next	1.3;

1.3
date	93.03.10.20.12.42;	author ersmith;	state Exp;
branches;
next	1.2;

1.2
date	93.03.08.20.07.02;	author ersmith;	state Exp;
branches;
next	1.1;

1.1
date	93.02.24.23.52.46;	author ersmith;	state Exp;
branches;
next	1.0;

1.0
date	93.02.03.21.26.46;	author ersmith;	state Exp;
branches;
next	;


desc
@Misc. desktop functions
@


1.10
log
@Minor resource editing, elclean ups, etc.
@
text
@/*	DESKMISC.C		3/16/89	- 9/13/89	Derek Mui	*/
/*	Change chk_par		9/25/89			D.Mui		*/
/*	Fix at fill_string to take out control character	7/9/91	*/
/*	Convert to Lattice C 5.51	2/18/93		C.Gee		*/
/*	Change rep_path			6/02/93		H.M.Krober	*/	

/************************************************************************/
/*	New Desktop for Atari ST/TT Computer				*/
/*	Atari Corp							*/
/*	Copyright 1989,1990 	All Rights Reserved			*/
/************************************************************************/

#include "portab.h"
#include "obdefs.h"
#include "deskdefi.h"
/*#include "gemdefs.h"*/
#include "deskwin.h"
#include "deskusa.h"
#include "message.h"
#include "osbind.h"
#include "error.h"
#include "extern.h"
#include "pdesk.h"
#include "pmisc.h"


EXTERN	UWORD		st_dchar;
EXTERN	WORD		st_date;
EXTERN	WORD		st_time;
EXTERN	GRECT		full;
EXTERN	WORD		numicon;
EXTERN	WORD		x_type;
EXTERN	WINDOW		*x_win;
EXTERN	OBJECT		*menu_addr;


#if 0
/* this function already existed in deskmn.c */
/* XDeselect()
 * ====================================================================
 * Deselect an object and redraw - use the flag to redraw in case
 * the area to redraw needs to be bigger.( ie: SHADOWED )
 */
VOID
XDeselect( tree, obj )
OBJECT *tree;
WORD   obj;
{
       	GRECT trect;
	WORD	dummy;
       			
       if( tree[ obj ].ob_state & SELECTED )
       {
         tree[ obj ].ob_state &= ~SELECTED;
         trect = *(GRECT *)&tree[(obj)].ob_x;
	 objc_gclip( tree, obj, &dummy, &dummy, &trect.g_x, &trect.g_y, 
		   &trect.g_w, &trect.g_h );
         objc_draw((LONG)tree,obj,MAX_DEPTH,trect.g_x,trect.g_y,trect.g_w,trect.g_h );
       }
}
#endif /* 0 */

#if 0		/* see kballoc.c for implementation */
	BYTE
*malloc( size )
	LONG	size;
{
	return( Mxalloc( size, 3 ) );
}
#endif

	VOID
m_objdraw( obj, which, start, x, y, w, h )
	OBJECT	*obj;
	WORD	which,start,x,y,w,h;
{
	wind_update(1);
	objc_draw( (LONG)obj, which, start, x, y, w, h );
	wind_update(0);
}

	
	WORD
m_sfirst( path, att )
	BYTE	*path;
	WORD	att;
{
	WORD		ret;

	if ( *path == 'c' )
	  return( !c_sfirst( path ) );
	else
	{
	  desk_mice( HOURGLASS );
	  Fsetdta( &dtabuf );
	  ret = Fsfirst( path, att );
	  desk_mice( ARROW );
 	  return( ret );
	}
}


/*	Wait for redraw message	*/

	WORD
wait_msg( handle, obj )
	WORD	handle;
	OBJECT	*obj;
{
	WORD	msgbuff[8];

	msgbuff[0] = 0;

	while( appl_read( -1, 16, msgbuff ) )
	{
	  switch( msgbuff[0] )
	  {
	    case MN_SELECTED:
	      menu_tnormal( (LONG)menu_addr, msgbuff[3], 1 );
	      break;	

	    case WM_TOPPED:	/* don't allow other window to go on top */
				/* because it will deselect the objects	*/
	      if ( msgbuff[3] == handle )
	        wind_set( handle, WF_TOP, msgbuff[4], msgbuff[5], 
			  msgbuff[6], msgbuff[7] );
	 
	      break;

	    case WM_CLOSE:
	      if ( msgbuff[3] == handle )
		return( msgbuff[0] );

	      break;
		
	    case WM_REDRAW:
	      if ( msgbuff[3] == handle )
	      {
	        draw_loop( handle, obj, 0, MAX_DEPTH, msgbuff[4], msgbuff[5],
		           msgbuff[6], msgbuff[7] );	 
		break;
	      }
		
	    case WM_UNTOPPED:
	      hd_window( msgbuff );
	      break;
	      		
	    case WM_MOVED:	
	      if ( msgbuff[3] == handle )
	      {
	        wind_set( handle, WF_CURRXYWH, msgbuff[4], msgbuff[5], 
			  msgbuff[6], msgbuff[7] );
	        wind_get( handle, WF_WORKXYWH, &obj->ob_x, &obj->ob_y, &obj->ob_width,
			  &obj->ob_height );
	      }
	      else 	
	        hd_window( msgbuff );

	      break;

	    default:
	      break;	
	  }
	}

	return( msgbuff[0] );
}


/*	Check path length and allocate memory	*/

	WORD
c_path_alloc( path )
	BYTE	*path;
{
	WORD	level;

	level = ch_level( path );
	
	if ( level > d_level )
	{
/*	  form_alert( 1, Alloc );	*/
	  if ( !path_alloc( level ) )
	    return( FALSE );
	}

	return( TRUE );
}


/*	Hit the disk	*/

	WORD
hit_disk( drive )
	WORD	drive;
{
	BYTE	buffer[14];
	WORD	ret;

	strcpy( wildext, buffer );
	buffer[0] = drive;	    
	Fsetdta( &dtabuf );		/* set dta buffer	*/
	if ( ret = Fsfirst( buffer, 0x3F ) )
	{
	  if ( ret == EFILNF )		/* that's OK	*/
	    ret = FALSE;
	}

	return( ret ? FALSE : TRUE );
}


	OBJECT
*get_icon( item )
	WORD	item;
{
	if ( item >= numicon )
	  item = numicon - 1;
	
	return( &iconaddr[item] );
}


	OBJECT	
*get_tree( item )
	WORD	item;
{
	OBJECT	*obj;

	rsrc_gaddr( R_TREE, item, (LONG *)&obj );
	return( obj );
}


	BYTE	
*get_string( item )
	WORD	item;
{
	BYTE	*str;

	rsrc_gaddr( R_STRING, item, (LONG *)&str );
	return( str );
}


	BYTE	
*get_fstring( item )
	WORD	item;
{
	BYTE	**str;

	rsrc_gaddr( R_FRSTR, item, (LONG *)&str );
	return( *str );
}


	DIR
*get_dir ( win, item )
	WINDOW	*win;
	WORD	item;
{
	WORD	j;
	DIR	*dir;

	if (win->w_iconified)
		return &win->w_icndir;
	else {
		j = win->w_srtitem + item - 1;
		dir = ( DIR *)win->w_memory;
		return( &dir[j] );
	}
}


	VOID
up_1( win )
	WINDOW	*win;
{
	WORD	srtitem;
	
	if (win->w_iconified)
		srtitem = 0;
	else
		srtitem = win->w_srtitem;
	set_newview( srtitem, win );
	do_redraw( win->w_id, &full, 0 );
}

/*
	Update window because someone change 
	the d_state 	
*/

	VOID
up_2( win )
	WINDOW	*win;
{
	up_1( win );
	winfo( win );
}

	
/*	Put a file name into the win path buffer	*/
	
	BYTE
*put_name( win, name )
	WINDOW	*win;
	BYTE	*name;
{
	WORD	len;

	strcpy( win->w_path, win->w_buf );
	rep_path( name, win->w_buf );
	return( win->w_buf );
}



/*	Is the child inside the parent visible area?	*/
	
	WORD
in_parent( obj, child )
	OBJECT	*obj;
	WORD	child;
{
	return( inside( obj[child].ob_x + obj[0].ob_x, 
		        obj[child].ob_y + obj[0].ob_y,
		        (GRECT *)&obj[0].ob_x ) );	
}


	VOID
xinf_sset( obj, item, buf1 )
	OBJECT	*obj;
	WORD	item;
	BYTE	*buf1;
{
	BYTE	buf2[20];

	fmt_str( buf1, buf2 );
	inf_sset( (LONG)obj, item, buf2 );
}


	VOID
desk_mice( state )
	WORD	state;
{
	graf_mouse( state, 0L );
}


/*	Draw a single field of a dialog box	*/

	VOID
draw_fld( obj, which )
	REG OBJECT	*obj;
	WORD	which;
{
	GRECT	t;
	WORD	x,y;

	objc_gclip( obj, which, &x, &y, &t.g_x, &t.g_y, &t.g_w, &t.g_h );
	objc_draw( (LONG)obj, which, 0, t.g_x, t.g_y, t.g_w, t.g_h );
}


/*	Draw a single field of a dialog box inside a window	*/

	WORD
w_draw_fld( handle, obj, which )
	REG OBJECT	*obj;
	WORD	handle, which;
{
	GRECT	t;

	if ( handle == -1 )
	{
	  draw_fld( obj, which );
	  return( 0 );
	}	
	else
	{
	  rc_copy( &obj[which].ob_x, (WORD *)&t ); 
	  objc_offset( obj, which, &t.g_x, &t.g_y );
	  draw_loop( handle, obj, which, 0, t.g_x, t.g_y, t.g_w, t.g_h );
	  return( wait_msg( handle, obj ) );
	}
}


	WORD
getcookie( cookie, p_value )
	LONG	cookie;
	LONG	*p_value;
{
	LONG	*cookjar;
	BYTE	*old;
	WORD	status;

	status = FALSE;	

	old = ( BYTE *)Super( 0x0L );

	if ( cookjar = ( LONG *)( *(LONG*)(0x5a0)) )
	{
	  while( *cookjar )
	  {
	    if ( *cookjar == cookie )
	    {
	      *p_value = *( cookjar + 1 );
	      status = TRUE;
	      break;
	    }
	    else	
	      cookjar += 2;
	  }
	}

	Super( old );
	return( status );
}


/*	Format a value and fill the leading space	*/

	VOID
f_str( obj, item, value )
	OBJECT	*obj;
	WORD	item;
	LONG	value;
{
	BYTE	buffer[14];
	WORD	len1,len2;
	BYTE	*chrptr;

	lbintoas( value, buffer );	
	len1 = ((TEDINFO*)(obj[item].ob_spec))->te_txtlen;
	len1 -= 1;
	chrptr = ( BYTE *)((TEDINFO*)(obj[item].ob_spec))->te_ptext;
	bfill( len1, ' ', chrptr );
	len2 = strlen( buffer );
	strcpy( buffer, chrptr + (LONG)( len1 - len2 ) );
}


/*	Check the level of depth	*/

	WORD
ch_level( path )
	BYTE	*path;
{
	WORD	level;

	level = 0;

	while( *path )
	{
	  if ( *path++ == '\\' )
	    level++;
	}

	return( level );
}


/*	Draw a dialogue box, it may or may not inside a window */

	WORD
dr_dial_w( item, window, elements )
	WORD	item,window,elements;
{
	REG OBJECT	*addr;
	WORD		x,y,w,h,handle;

	handle = -1;
	addr = get_tree( item );
	form_center( addr, &x, &y, &w, &h );
	form_dial( FMD_START, 0, 0, 0, 0, x, y, w, h );
	if ( window )
	{
	  wind_update(1);
	  wind_calc( 0, elements, x, y, w, h, &x, &y, &w, &h );	
	  if ( ( handle = wind_create( elements, x, y, w, h ) ) != -1 )
	  {
	    wind_open( handle, x, y, w, h ); 
	    if ( wait_msg( handle, addr ) != WM_REDRAW )
	      draw_loop( handle, addr, 0, MAX_DEPTH, x, y, w, h );
	  }
	  wind_update(0);	
	}
	else
	  m_objdraw( addr, 0, 8, x, y, w, h );

	return( handle );
}




	VOID
do_finish( item )
	WORD	item;
{
	GRECT	pt;

	form_center( get_tree( item ), &pt.g_x, &pt.g_y, &pt.g_w, &pt.g_h );
	form_dial( FMD_FINISH, 0, 0, 0, 0, pt.g_x, pt.g_y, pt.g_w, pt.g_h );
	wait_msg( -1, (OBJECT *)0L );	
}


	WORD
xform_do( obj, which )
	OBJECT	*obj;
	WORD	which;
{
	WORD	ret;

	ret = form_do( obj, which ) & 0x7FFF;
	obj[ret].ob_state &= (~SELECTED);	/* was: ob_state = NORMAL; changed 5/20/93 HMK */
	return( ret );
}


/*	Form_do	and draw	*/

	WORD
fmdodraw( item, which )
	WORD	item, which;
{
	OBJECT	*obj;
	WORD	ret;

	wind_update( 1 );
	obj = get_tree( item );
	dr_dial_w( item, FALSE, 0 /* dummy */ );
	ret = xform_do( obj, which );
	do_finish( item );
	wind_update( 0 );
	return( ret );
}




/*	The path should look like A:\*.*	*/

	WORD
xcut_path( path, buffer, cut )
	REG BYTE	*path;
	BYTE	*buffer;
	WORD	cut;
{
	WORD	i;
	BYTE	*chrptr;

	buffer[0] = 0;

	i = ch_level( path );

	if ( i <= 1 )		/* only one level depth		*/
	  return( FALSE );	/* failed			*/

	path = r_slash( path );	/* reverse to next level	*/
	strcpy( path, buffer );
	path--;

	while( *path != '\\' )
	  path--;

	if ( cut )
	  strcpy( buffer, path );
	else
	{
	  chrptr = strscn( path + 1, buffer, '\\' );
	  *chrptr = 0;
	}

	return( TRUE );
}


/*	Cut one directory inside the path	*/
/*	The path should look like A:\*.*	*/

	WORD
cut_path( path )
	REG BYTE	*path;
{
	BYTE	buffer[14];

	return( xcut_path( path, buffer, TRUE ) );
}


/*	Concat a path			*/
/*	A:\aaa\*.*  -> A:\aaa\bbb\*.*	*/

	VOID
cat_path( name, path )
	BYTE	*name;
	REG BYTE	*path;
{
	BYTE	buffer[20];
	BYTE	*start;

	start = path;
	path = r_slash( path );
	strcpy( path, buffer );
	path++;
	rep_path( name, start );
	strcat( buffer, path );
}


/*	Replace path			*/
/*	A:\aaa\*.* -> A:\aaa\bbb	*/

	VOID
rep_path( name, path )
	BYTE	*name;
	BYTE	*path;
{
	path = r_slash( path );	
	if (name == NULL) {	/* +++ HMK 6/2/93 */
		*path = '\0';
		return;
	} else {
		path++;
		strcpy( name, path ); 
	}
}


/*	Perform an alert box message	*/

	WORD
do_alert( button, item )
	WORD	button, item;
{
	return( form_alert( button, get_string( item ) ) );
}


	WORD
do1_alert( item )
	WORD	item;
{
	return( do_alert( 1, item ));
}


	VOID
rc_center( rec1, rec2 )
	GRECT	*rec1;
	GRECT	*rec2;
{
	rec2->g_x = rec1->g_x + ( rec1->g_w / 2 );
	rec2->g_y = rec1->g_y + ( rec1->g_h / 2 );
}



	VOID
my_itoa(number, pnumstr)
	UWORD		number;
	REG BYTE		*pnumstr;
{
	REG WORD		ii;

	
	for (ii = 0; ii < 2; pnumstr[ii++] = '0');
	pnumstr[2] = NULL;
	merge_str( ( (number > 9)? pnumstr : pnumstr+1 ), "%W", &number);
} 

/*
*	Routine to format DOS style time.
*
*	15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
*	<     hh     > <    mm    > <   xx  >
*	hh = binary 0-23
*	mm = binary 0-59
*	xx = binary seconds \ 2 
*
*	put into this form 12:45 pm
*
*	IF(EUROTIME)THEN Military Time Format 
*/

	VOID
fmt_time(time, ptime)
	REG UWORD	time;
	REG BYTE	*ptime;
{
	REG WORD	pm, val;

	val = ((time & 0xf800) >> 11) & 0x001f;

	if ( st_time )
	  my_itoa( val, &ptime[0] );
	else
	{
	  if( val >= 12 ) 
	  {
	    if (val > 12)
		val -= 12;
	    pm = TRUE;
	  }
          else 
	  {
            if(val == 0)
		val = 12;
	    pm = FALSE;
	  }

	  my_itoa(val, &ptime[0]);
	}

	my_itoa( ((time & 0x07e0) >> 5) & 0x003f, &ptime[2]);

	if ( st_time )
	  strcpy("  ", &ptime[4]);
	else
	  strcpy( ((pm)? "pm" : "am" ), &ptime[4]);
}


/*
 *	Routine to format DOS style date.
 *	
 *	15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
 *	<     yy          > < mm  > <  dd   >
 *	yy = 0 - 99 (1980 - 2079)
 *	mm = 1 - 12
 *	dd = 1 - 31
 *
 *	IF(EURODATE)THEN Swap Day and Month thusly: dd/mm/yy
 *	IF(SWEDDATE)THEN Swap Day and Month thusly: yy/mm/dd
 */

	VOID
fmt_date(date, pdate)
	UWORD		date;
	REG BYTE		*pdate;
{
	switch( st_date )
	{
	  case 3:
	    my_itoa( (( 80 + ((date  >> 9) & 0x007f) ) % 100 ), &pdate[0]);
            my_itoa(date & 0x001f, &pdate[3]);
	    my_itoa( (date & 0x01e0) >> 5, &pdate[6]);
	    break;		
	  case 2:		/* swedish date */
	    my_itoa( (( 80 + ((date  >> 9) & 0x007f) ) % 100 ), &pdate[0]);
	    my_itoa( (date & 0x01e0) >> 5, &pdate[3]);
            my_itoa(date & 0x001f, &pdate[6]);
	    break;
	  case 1:		/* europane date */
	    my_itoa(date & 0x001f, &pdate[0]);
	    my_itoa( (date & 0x01e0) >> 5, &pdate[3]);
	    my_itoa( (( 80 + ((date  >> 9) & 0x007f) ) % 100 ), &pdate[6]);
	    break;
	  default:
	    my_itoa( (date & 0x01e0) >> 5, &pdate[0]); /* MM */
	    my_itoa(date & 0x001f, &pdate[3]);	       /* DD */	
	    my_itoa( (( 80 + ((date  >> 9) & 0x007f) ) % 100 ), &pdate[6]);
	}

	pdate[5] = pdate[2] = (BYTE)st_dchar;
}


/*	Build string		*/

	BYTE
*bldstring( dir, dst )
	DIR	*dir;
	REG BYTE	*dst;
{
	REG BYTE	*src;
	BYTE		buf[14];
	REG WORD	i;
	WORD		len;
	BYTE		*buffer;

	buffer = buf;

	if ( dir->d_att & READ )
	  *dst++ = 0x7F;
	else
	{
	  *dst++ = ( dir->d_att & SUBDIR ) ? 0x07 : ' ';
	}

	*dst++ = ' ';

	src = &dir->d_name[0];

	for( i = 0; i < 8; i++ )
	{
	  if ( ( *src ) && ( *src != '.' ) )
	    *dst++ = *src++;
	  else
	    break;
	}

	for ( ; i < 9; i++ )	/* fill with blanks	*/
	  *dst++ = ' ';

	if ( *src == '.' )
	  src++;

	for ( i = 0; i < 3; i++ )
	  *dst++ = ( *src ) ? *src++ : ' ';
	
	bfill( 11, ' ', dst++ );

	if ( dir->d_att & SUBDIR )
	{
	  buffer[0] = ' ';
	  buffer[1] = 0;
	}
	else
	  lbintoasc( dir->d_size, buffer );

	len = strlen( buffer );
	
	strcpy( buffer, dst + ( 10 - len ) );

	dst += 10;
	*dst++ = ' ';
	*dst++ = ' ';

	fmt_date( dir->d_date, buffer );
	dst = strcpy( buffer, dst ) - 1;
#if 0
	*dst++ = buffer[0];
	*dst++ = buffer[1];
	*dst++ = (BYTE)st_dchar;
/*	*dst++ = '-';	*/
	*dst++ = buffer[2];
	*dst++ = buffer[3];
	*dst++ = (BYTE)st_dchar;
/*	*dst++ = '-';	*/
	*dst++ = buffer[4];
	*dst++ = buffer[5];
#endif
	*dst++ = ' ';
	*dst++ = ' ';
 
	fmt_time( dir->d_time, buffer );
	*dst++ = buffer[0];
	*dst++ = buffer[1];
	*dst++ = ':';
	*dst++ = buffer[2];
	*dst++ = buffer[3];
	*dst++ = ' ';
	*dst++ = buffer[4];
	*dst++ = buffer[5];
	*dst++ = ' ';
	*dst++ = ' ';
	return( dst );
}

	BYTE
*g_name( file )
	BYTE	*file;
{	
	BYTE	*tail;

	tail = r_slash( file );
	if ( *tail == '\\' )
	  tail++;
	
	return( tail );
}


/*	save the extension of the path	*/
/*	A:\*.*				*/

	VOID
save_ext( path, buffer )
	BYTE	*path;
	BYTE	*buffer;
{
	strcpy( g_name( path ), buffer );
}
	
/*	save the middle dir just before the ext	*/
/*	A:\dir\*.*				*/

	VOID
save_mid( path, buffer )
	BYTE	*path;
	BYTE	*buffer;
{
	xcut_path( path, buffer, FALSE );
}


/*	Check for if the source is the parent of 	*/
/*	the destination					*/

	WORD
chk_par( srcptr, dstptr )
	REG BYTE	*srcptr;
	REG BYTE	*dstptr;
{
	if ( *srcptr != *dstptr )	/* Not the same device	*/
	  return ( TRUE );

	if ( !strcmp( srcptr, dstptr ) )
	{				/* not the same path	*/	
	  while( *srcptr )
	  {
	    if ( *srcptr != *dstptr )
	    {
	       if ( *srcptr == '*' )	/* source is the parent */
		 break;			/* return FALSE		*/
	       else
		 return( TRUE );
	    }
			
	    if ( !*dstptr )		/* destination is shorter */
	      return( TRUE );
		
	    srcptr++;
	    dstptr++;	
	  }/* while */
	}

	return( FALSE );
}


	WORD
fill_string( string, item )
	BYTE	*string;
	WORD	item;
{
	BYTE	*ptr,*ptr1;

	ptr1 = ptr = g_name( string );
	
	while( *ptr1 )
	{
	  if ( ( *ptr1 == '[' ) || ( *ptr1 == ']' ) || ( *ptr1 == '|' ) )
	    strcpy( ptr1+1, ptr1 );
	  else	
	    ptr1++;
	}

	merge_str( g_buffer, get_string( item ), (UWORD *)&ptr );
  	return( form_alert( 1, g_buffer ) );	
}


@


1.9
log
@Merged in Hans-Martin and Cary's changes
@
text
@@


1.8
log
@Another check in to save work.
@
text
@d5 1
a5 1
	
d258 1
a258 1
*get_dir( win, item )
d265 7
a271 3
	j = win->w_srtitem + item - 1;
	dir = ( DIR *)win->w_memory;
	return( &dir[j] );
d279 7
a285 1
	set_newview( win->w_srtitem, win );
d310 2
d521 1
a521 1
	obj[ret].ob_state = NORMAL;
d626 7
a632 2
	path++;
	strcpy( name, path ); 
@


1.7
log
@Added iconification,color icons in alerts,etc.
@
text
@@


1.6
log
@Merged Cary's and Hans-Martin's changes
@
text
@@


1.5
log
@Incorporated more single/multitasking changes.
@
text
@d37 2
a38 1

d61 1
a61 1

@


1.4
log
@Merged HMK's loadable resource stuff
@
text
@@


1.3
log
@Lattice port
@
text
@@


1.2
log
@REAL MultiTOS 1.01
@
text
@d4 1
d13 12
a24 16
#include <portab.h>
#include <deskobde.h>
#include <deskdefi.h>
#include <gemdefs.h>
#include <deskwin.h>
#include <deskusa.h>
#include <message.h>
#include <osbind.h>
#include <error.h>
#include <extern.h>

EXTERN	BYTE		*strcpy();
EXTERN	BYTE		*strscn();
EXTERN	WINDOW		*w_gfirst();
EXTERN	WINDOW		*w_gnext();
EXTERN	BYTE		*r_slash();
d26 1
d43 1
a43 1
WORD
d55 3
a57 3
	 objc_gclip( tree, obj, &dummy, &dummy, &trect.x, &trect.y, 
		   &trect.w, &trect.h );
         objc_draw( tree, obj, MAX_DEPTH, trect.x, trect.y, trect.w, trect.h );
d77 1
a77 1
	objc_draw( obj, which, start, x, y, w, h );
d118 1
a118 1
	      menu_tnormal( menu_addr, msgbuff[3], 1 );
d129 1
a129 1
	    case WM_CLOSED:
d229 1
a229 1
	rsrc_gaddr( R_TREE, item, &obj );
d240 1
a240 1
	rsrc_gaddr( R_STRING, item, &str );
d251 1
a251 1
	rsrc_gaddr( R_FRSTR, item, &str );
d265 1
a265 1
	dir = win->w_memory;
d315 1
a315 1
		        &obj[0].ob_x ) );	
d328 1
a328 1
	inf_sset( obj, item, buf2 );
d336 1
a336 1
	graf_mouse( state, (BYTE*)0 );
d350 2
a351 2
	objc_gclip( obj, which, &x, &y, &t.x, &t.y, &t.w, &t.h );
	objc_draw( obj, which, 0, t.x, t.y, t.w, t.h );
d371 3
a373 3
	  rc_copy( &obj[which].ob_x, &t ); 
	  objc_offset( obj, which, &t.x, &t.y );
	  draw_loop( handle, obj, which, 0, t.x, t.y, t.w, t.h );
d390 1
a390 1
	old = Super( 0x0L );
d392 1
a392 1
	if ( cookjar = *(LONG*)(0x5a0) )
d425 1
a425 1
	len1 = (TEDINFO*)(obj[item].ob_spec)->te_txtlen;
d427 1
a427 1
	chrptr = (TEDINFO*)(obj[item].ob_spec)->te_ptext;
d494 3
a496 3
	form_center( get_tree( item ), &pt.x, &pt.y, &pt.w, &pt.h );
	form_dial( FMD_FINISH, 0, 0, 0, 0, pt.x, pt.y, pt.w, pt.h );
	wait_msg( -1 );	
d524 1
a524 1
	dr_dial_w( item, FALSE );
d628 1
a628 1
	VOID
d632 1
a632 1
	do_alert( 1, item );
d641 2
a642 2
	rec2->x = rec1->x + ( rec1->w / 2 );
	rec2->y = rec1->y + ( rec1->h / 2 );
d767 1
a767 1
	WORD		t,len;
d938 1
a938 1
	merge_str( g_buffer, get_string( item ), &ptr );
@


1.1
log
@1 meg floppy MultiTOS
@
text
@@


1.0
log
@MultiTOS version 1.0
@
text
@d64 1
d71 1
a71 1

@
