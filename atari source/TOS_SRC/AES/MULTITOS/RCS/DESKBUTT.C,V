head	1.10;
access;
symbols;
locks
	ersmith:1.10;
comment	@ * @;


1.10
date	93.06.15.22.53.36;	author ersmith;	state Exp;
branches;
next	1.9;

1.9
date	93.06.14.23.48.02;	author ersmith;	state Exp;
branches;
next	1.8;

1.8
date	93.06.09.23.47.00;	author ersmith;	state Exp;
branches;
next	1.7;

1.7
date	93.05.12.01.40.22;	author ersmith;	state Exp;
branches;
next	1.6;

1.6
date	93.04.27.23.00.14;	author ersmith;	state Exp;
branches;
next	1.5;

1.5
date	93.04.14.22.19.54;	author ersmith;	state Exp;
branches;
next	1.4;

1.4
date	93.03.12.19.51.12;	author ersmith;	state Exp;
branches;
next	1.3;

1.3
date	93.03.10.20.12.42;	author ersmith;	state Exp;
branches;
next	1.2;

1.2
date	93.03.08.20.07.02;	author ersmith;	state Exp;
branches;
next	1.1;

1.1
date	93.02.24.23.52.46;	author ersmith;	state Exp;
branches;
next	1.0;

1.0
date	93.02.03.21.26.46;	author ersmith;	state Exp;
branches;
next	;


desc
@Desktop mouse stuff
@


1.10
log
@Minor resource editing, elclean ups, etc.
@
text
@/*	DESKBUTT.C		3/16/89 - 3/22/89	Derek Mui	*/
/*	Foption( win )		9/14/89			D.Mui		*/

/************************************************************************/
/*	New Desktop for Atari ST/TT Computer				*/
/*	Atari Corp							*/
/*	Copyright 1989,1990 	All Rights Reserved			*/
/************************************************************************/

#include "portab.h"
#include "machine.h"
#include "obdefs.h"
#include "deskdefi.h"
#include "deskwin.h"
#include "windlib.h"
#include "deskusa.h"
#include "osbind.h"
#include "extern.h"
#include "pdesk.h"
#include "pmisc.h"

EXTERN	WORD	d_multi;
EXTERN	WORD	desk_id;
EXTERN	WINDOW	*get_win();
EXTERN	WINDOW	*get_top();
EXTERN	DIR	*get_dir();
EXTERN	WINDOW	*x_win;

/*	Find an empty icon	*/

WORD
av_icon( VOID )
{
	REG WORD	i,k;
	REG OBJECT	*obj;
	WORD		x,y,col,row;
	WORD		xcol,xrow,found;

	obj = background;

	for ( i = 1; i <= maxicon; i++ )
	{
	  if ( obj[i].ob_flags & HIDETREE )
	  {
	    k = i;
	    col = full.g_w / r_dicon.g_w;
	    row = full.g_h / r_dicon.g_h;

	    for ( xrow = 0; xrow < row; xrow++ )
	    {
	      for ( xcol = 0; xcol < col; xcol++ )
	      {
	        found = FALSE;
	        app_posicon( xcol, xrow, &x, &y );

	        for ( i = 1; i <= maxicon; i++ )
	        {
	          if ( !( obj[i].ob_flags & HIDETREE ) )
	          {
		    if ( ( obj[i].ob_x == x ) && ( obj[i].ob_y == y ) )
		    {
		      found = TRUE;
		      break;
		    }
	          }
	        }

	        if ( !found )
	          goto av_1;
	      }
  	    } 
av_1:
	    backid[k].i_path = (BYTE*)0;
	    obj[k].ob_flags = NONE;
	    obj[k].ob_state = NORMAL;
	    obj[k].ob_x = x;
	    obj[k].ob_y = y;
	    return( k );
	  }
 	}

	return( -1 );
}


/*	Deselect all the disk and trash icons	*/

VOID
clr_dicons( VOID )
{
	GRECT		pt;
	REG OBJECT	*obj;
	WORD		i;

	obj = background;

	if ( build_rect( obj, &pt, d_xywh[6], d_xywh[9] ) )
	{
	  for ( i = 1; i <= obj[0].ob_tail; i++ )
	    obj[i].ob_state = NORMAL;	

	  do_redraw( 0, &pt, 0 );
	}	

}


/*	Handle the click event		*/

VOID
hd_button( WORD clicks, WORD kstate, WORD mx, WORD my )
{
	REG WORD	item;
	WORD		xitem,type,keypress,state;
	REG OBJECT	*obj;
	REG WINDOW	*win;
	WINDOW		*win1;

	wind_get( 0, WF_OWNER, &type, &xitem, &xitem, &xitem );

	if ( type != desk_id ) {
		Debug1("hd_button: no desktop window \r\n"); 
	  return;
	 }
				/* click on any objects	*/

	if ( ( kstate != K_RSHIFT ) && ( kstate != K_LSHIFT ) )
	  keypress = FALSE;
	else
	  keypress = TRUE;

	Debug1("hd_button: before i_find\r\n"); 
	if ( i_find( mx, my, &win1, &xitem, &type ) )
	{
	   Debug1("hd_button: item="); Ndebug1((LONG)xitem);
	   item = xitem;
	   win = win1;

	   if ( type == WINICON )	/* window objects	*/
	   {
#if 0	     /* NOW WE ALLOW USER TO DO STUFF WITH ICONIFIED WINDOWS 	*/
	     /* SO DO NOT RETURN 					*/
	     if (win->w_iconified)
	        return;
#endif
	     wind_update(1);
	     clr_dicons( );		/* clean up desktop icons */
	     
	     if ( ( x_win ) && ( x_win != win ) )
	       clr_xwin( x_win, TRUE );

	     wind_update(0);
	     if ( !item )		/* hit nothing		*/
	     {
	       if ( !keypress )		/* shift key down?	*/
		clr_xwin( win, FALSE );
		
	       r_box( win->w_id, win );
	       winfo( win );
	       return;
	     }
	     else			/* hit something	*/
	     {
	       if (win->w_iconified)	/* get the right object */
	       	  obj = win->w_icnobj;
	       else
	          obj = win->w_obj;	
	       state = obj[item].ob_state;  /* JTT - changed from ob_states */

	       if ( ( state & SELECTED ) && ( !keypress ) )
	  	  goto a_1;
 
	       if ( !keypress )
	       {
	         clr_xwin( win, FALSE );
	         state = SELECTED;
	       }
	       else
	         state ^= SELECTED;

	       obj[item].ob_state = state;
/*	       if (!win->w_iconified)*/
		       get_dir( win, item)->d_state = state;
	       do_redraw( win->w_id, &full, item );
	       winfo( win );
	     }
	  }
	  else				/* desktop icon selected 	*/
	  {
	    wind_update(1);
	    clr_allwin( );
	    wind_update(0);

	    if ( !item )		/* hit background		*/
	    {
	      if ( !keypress )		/* clean up all the disk icons	*/	
	        clr_dicons( );	
		
	      r_box( 0, (WINDOW*)0 );
	      return;
	    }
	    else
	    {
	      obj = background;
	      state = obj[item].ob_state;

	      if ( ( state & SELECTED ) && ( !keypress ) )
	         goto a_1;	
	    
	      if ( !keypress )
	      {
	        state = SELECTED;
	        clr_dicons();
	      }
	      else
	        state ^= SELECTED;

	      obj[item].ob_state = state; 
	      do_redraw( 0, &full, item );
	    }
	  }
a_1:
	  o_select();			/* update the search routine	*/
	  x_select();

	  if ( clicks == 2 ) {		/* double clicks	*/
	    open_item( item, type, win );
	    wind_update(1);
	    clr_allwin();	/* deselect icon */
	    wind_update(0);
	  } else				/* button still down	*/
 	    hd_down( item, type, win );

	}/* nothing is found	*/
}
@


1.9
log
@Merged in Hans-Martin and Cary's changes
@
text
@@


1.8
log
@Another check in to save work.
@
text
@d121 2
a122 1
	if ( type != desk_id )
d124 1
d132 1
d135 1
d141 2
d145 2
a146 1

d148 1
a148 1

d152 1
d164 4
a167 1
	       obj = win->w_obj;	
d182 2
a183 1
	       get_dir( win, item )->d_state = state;
d190 1
d192 1
d228 3
a230 2
	    /*if (!d_multi)*/	/* maybe not only in single tasking mode??? */
	    	clr_allwin();	/* deselect icon */
@


1.7
log
@Added iconification,color icons in alerts,etc.
@
text
@@


1.6
log
@Merged Cary's and Hans-Martin's changes
@
text
@d11 1
d137 3
a212 2
	    if (!d_multi)	/* maybe not only in single tasking mode??? */
	    	clr_allwin();
d214 2
@


1.5
log
@Incorporated more single/multitasking changes.
@
text
@@


1.4
log
@Merged HMK's loadable resource stuff
@
text
@d21 1
a21 1

d208 3
a210 1
	  if ( clicks == 2 )		/* double clicks	*/
d212 1
a212 1
	  else				/* button still down	*/
@


1.3
log
@Lattice port
@
text
@@


1.2
log
@REAL MultiTOS 1.01
@
text
@d10 10
a19 8
#include <portab.h>
#include <deskobde.h>
#include <deskdefi.h>
#include <deskwin.h>
#include <gemdefs.h>
#include <deskusa.h>
#include <osbind.h>
#include <extern.h>
d21 1
d30 2
a31 2
	WORD
av_icon( )
d45 2
a46 2
	    col = full.w / r_dicon.w;
	    row = full.h / r_dicon.h;
d87 2
a88 2
	VOID
clr_dicons( )
d109 2
a110 3
	VOID
hd_button( clicks, kstate, mx, my )
	WORD	clicks, kstate, mx, my;
d153 1
a153 1
	       state = obj[item].ob_states;
d166 1
a166 1
	       obj[item].ob_states = state;
d200 1
a200 1
	      obj[item].ob_states = state; 
@


1.1
log
@1 meg floppy MultiTOS
@
text
@@


1.0
log
@MultiTOS version 1.0
@
text
@@
