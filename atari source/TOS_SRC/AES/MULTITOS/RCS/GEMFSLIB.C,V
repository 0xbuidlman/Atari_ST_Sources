head	1.10;
access;
symbols;
locks
	ersmith:1.10;
comment	@ * @;


1.10
date	93.06.15.22.53.36;	author ersmith;	state Exp;
branches;
next	1.9;

1.9
date	93.06.14.23.48.02;	author ersmith;	state Exp;
branches;
next	1.8;

1.8
date	93.06.09.23.47.00;	author ersmith;	state Exp;
branches;
next	1.7;

1.7
date	93.05.12.15.50.18;	author ersmith;	state Exp;
branches;
next	1.6;

1.6
date	93.04.27.23.00.14;	author ersmith;	state Exp;
branches;
next	1.5;

1.5
date	93.04.14.22.19.54;	author ersmith;	state Exp;
branches;
next	1.4;

1.4
date	93.03.12.19.51.12;	author ersmith;	state Exp;
branches;
next	1.3;

1.3
date	93.03.10.20.12.42;	author ersmith;	state Exp;
branches;
next	1.2;

1.2
date	93.03.08.20.07.02;	author ersmith;	state Exp;
branches;
next	1.1;

1.1
date	93.02.24.23.52.46;	author ersmith;	state Exp;
branches;
next	1.0;

1.0
date	93.02.03.21.26.46;	author ersmith;	state Exp;
branches;
next	;


desc
@GEM file selector
@


1.10
log
@Minor resource editing, elclean ups, etc.
@
text
@/*  	NEWFSLIB.C	10/27/87 - 01/06/88	Derek Mui		*/
/*	Totally rewritten by Derek Mui					*/
/*	Change fs_input	1/21/88	- 1/22/88	D.Mui			*/
/*	Change at r_dir		1/28/88		D.Mui			*/
/*	Allocate all the memory first	2/10/88		D.Mui		*/
/*	Save the extension always and append to the new dir  2/12/88	*/
/*	Change at r_files		2/23/88	D.Mui			*/
/*	Save the default drive's directory	2/24/88	D.Mui		*/
/*	Save all the drive's default directory	2/29/88	D.Mui		*/
/*	Update 		3/1/88 - 3/2/88			D.Mui		*/
/*	Save and set new clipping rect	3/15/88		D.Mui		*/
/*	Change at fix_path		3/22/88		D.Mui		*/
/*	Optimize at fs_input		3/24/88		D.Mui		*/
/*	Fix at fs_input variable, fs_topptr 4/25/88	D.Mui		*/
/*	Change the unsigned to signed at r_sort 4/27/88 D.Mui		*/
/*	Change fs_input so that CATALOGGER will work	D.Mui		*/
/*	Change to make the underscore disappear	5/17/88	D.Mui		*/
/*	Fix the fs_input for doing cancel	9/5/90	D.Mui		*/
/*	Fix at r_file for checking the extension size 9/5/90	D.Mui	*/
/*	Change gsx_mfset to gr_mrestore			5/8/91	D.Mui	*/
/*	Fix the Ftitle 11 characters problem		6/11/91	D.Mui	*/
/*	Mininum height of slide bar is 1		1/6/92	D.Mui	*/
/*	Use Mxalloc instead of Malloc			3/30/92		*/
/*	Add ini_fsel to adjust drive boxes	7/15/92		D.Mui	*/
/* 	02/17/93	cjg	Converted to Lattice C 5.51		*/
/*	02/24/93	cjg	Force the use of prototypes		*/

/*	-----------------------------------------------------------
*	AES Version 4.0	MultiTOS version is written by Derek M. Mui
*	Copyright (C) 1992 
*	Atari (U.S.) Corp
*	All Rights Reserved
*	-----------------------------------------------------------
*/	

/*
*	-------------------------------------------------------------
*	GEM Application Environment Services		  Version 1.1
*	Serial No.  XXXX-0000-654321		  All Rights Reserved
*	Copyright (C) 1985			Digital Research Inc.
*	-------------------------------------------------------------
*/
#include "pgem.h"
#include "pmisc.h"

#include "machine.h"
#include "objaddr.h"
#include "gemdos.h"
#include "rslib.h"
#include "gemusa.h"
#include "windlib.h"
#include "osbind.h"
#include "mintbind.h"

#define LEN_FSNAME 16
#define NM_NAMES 9
#define DEVICES	16	/* sixteen devices	*/
#define LPATH	128



typedef	struct	fstruct
{
	BYTE	snames[LEN_FSNAME];
} FSTRUCT;


static VOID		r_sort( REG FSTRUCT *buffer, WORD count );


EXTERN  WORD	DOS_AX;
EXTERN	WS	gl_ws;
EXTERN	WORD	q_change;
EXTERN  GRECT	gl_rcenter;
EXTERN  LONG	ad_sysglo;
EXTERN	PD	*currpd;
EXTERN	WORD	gl_button;
EXTERN	WORD	gl_multi;
EXTERN	WORD	wtcolor[];
GLOBAL  GRECT	gl_rfs;

GLOBAL LONG	ad_fstree;
GLOBAL BYTE	*ad_fpath;
GLOBAL LONG	ad_title;
GLOBAL LONG	ad_select;

GLOBAL FSTRUCT	*ad_fsnames;

GLOBAL WORD	fs_first;		/* first enter the file selector */
GLOBAL UWORD	fs_topptr;
GLOBAL UWORD	fs_count;
GLOBAL LONG	fs_fnum;		/* max file allowed	*/

GLOBAL BYTE	*ad_fsdta;
GLOBAL BYTE     wildstr[] = "*.*";
GLOBAL BYTE	wslstr[] = "\\*.*";

MLOCAL BYTE	fsname[40];
MLOCAL BYTE	fcopy[40];
MLOCAL BYTE	*pathcopy;		/* path copy	*/
MLOCAL WORD	defdrv;

typedef struct pathstruct
{
	BYTE	pxname[128];
} PATHSTRUCT;

GLOBAL PATHSTRUCT *pxpath;	


/*
*	Routine to back off the end of a file string.
*/
	BYTE
*fs_back( pstr )
REG 	BYTE	*pstr;
{
REG	BYTE	*pend;
REG	WORD	i;

	i = strlen( pstr );		/* find the end of string	*/
	pend = pstr + i;
	
	while ( (*pend != '\\') &&
		(pend != pstr) )
	{
	  pend--;
	  if( (*pend == ':') && (pend == pstr+1) )
	    break;
	}
					/* if a : then insert	*/
					/*   a backslash for fsel dir line */
	if ( *pend == ':' )
	{
	  pend++;
	  LBCOPY( pend + 1, pend, i + 1 );
	  *pend = '\\'; 
	}
		
	return(pend);
}



/*
*	File Selector input routine that takes control of the mouse
*	and keyboard, searchs and sort the directory, draws the file 
*	selector, interacts with the user to determine a selection
*	or change of path, and returns to the application with
*	the selected path, filename, and exit button.
*	Add the label parameter
*/

	WORD
fs_input( pipath, pisel, pbutton, lstring )
	BYTE		*pipath;
	LONG		pisel;
	WORD		*pbutton;
	BYTE		*lstring;
{
REG	UWORD	i,j;
REG	LONG	tree;
	OBJECT	*obj;
	LONG	addr,mul,savedta,savepath;
	UWORD	botptr,value,count;
	WORD	label,last,ret;
	WORD	xoff,yoff,mx,my,bret;
	WORD	curdrv,savedrv,firstry;
	BYTE	dirbuffer[122];
	BYTE	scopy[16];	
	BYTE	chr;
	LONG	**lgptr;
	GRECT	clip;
	OBJECT	*xtree;
	WORD    newend, oldend;

#if UNLINKED
	state = currpd->p_state;
	if ( state == PS_NEW )			/* if start up sequence	*/
	  currpd->p_state = PS_CRITICAL;	/* then change state	*/
#endif
	wm_update( 3 );
	
/*
*	Start up the file selector by initializing the fs_tree
*/

	rs_gaddr(ad_sysglo, R_TREE, SELECTOR, &ad_fstree);
	ob_center(ad_fstree, &gl_rfs);

	gsx_mxmy( &mx, &my );		/* cjg 02/17/93 */

	firstry = TRUE;
	fs_first = TRUE;		/* first enter		*/	
	last = F1NAME;			/* last selected file	*/

	defdrv = (WORD)dos_gdrv();	/* get the default drive*/
	savedrv = defdrv;

	curdrv = defdrv + DRIVEA;
					/* save for default dr	*/ 
	pxpath = ( PATHSTRUCT *)dos_xalloc( (LONG)( ( WORD )LPATH * ( WORD )( DEVICES + 1 ) ),3 );

	if ( !pxpath )
	  goto bye2;
					/* allocate dta buffer	*/
	ad_fsdta = ( BYTE *)dos_xalloc( 0x00000100L, 3 );	

	if ( !ad_fsdta )		/* no buffer, bail out	*/
	  goto bye;

					/* get all the memory	*/
	mul = ( LONG )dos_xalloc( -1L, 3 );
					/* we shouldn't need more than 256K! */
	if (mul > 262144L)
	  mul = 262144L;		/* ++ERS 1/19/93 */

					/*	LEN_FSNAMES;	*/
	fs_fnum = mul / (LONG)LEN_FSNAME;	

	if ( ( !mul ) || ( fs_fnum < (LONG)NM_NAMES ) )
	{
	  dos_free( ( LONG )ad_fsdta );
bye:	  dos_free( ( LONG )pxpath );
bye2:	  fm_show( NOMEMORY, 0x0L, 1 );
	  wm_update( 2 );
/*	  currpd->p_state = state;	*/
	  return( FALSE );
	}
	else
	  ad_fsnames = ( FSTRUCT *)dos_xalloc( mul, 3 );  


	savepath = ( LONG )pxpath;		/* save the address	*/
	pathcopy = ( BYTE *)savepath;
	pxpath = ( PATHSTRUCT *)( savepath + (WORD)LPATH );	

	fm_dial( FMD_START, &gl_rcenter, &gl_rfs );

	xtree = obj = ( OBJECT *)ad_fstree;
	tree = ( LONG )ad_fstree;
	
	lgptr = ( LONG **)OB_SPEC( FDIRECTO );	/* change the buffer pointer */
	**lgptr = ( LONG )dirbuffer;


	fs_sset( tree, FLABEL, ( LONG )lstring, &addr, ( WORD *)&addr );
	fs_sset( tree, FDIRECTO, ( LONG)"", ( LONG *)&ad_fpath, ( WORD *)&addr ); 
	fs_sset( tree, FTITLE, ( LONG )"", &ad_title, ( WORD*)&addr );
	fs_sset( tree, FSELECTI, ( LONG )"", &ad_select, ( WORD *)&addr );

						/* get the current drive */
	count = isdrive();
	j = 1;
						/* start from A drive	*/
						/* set the button	*/
	for ( i = DRIVEA; i <= DRIVEP; i++ )	
	{
	  if ( count & j )			/* drive present	*/
	    obj[i].ob_state &= ~DISABLED;
	  else
	    obj[i].ob_state |= DISABLED;
	
	  obj[i].ob_state &= ~SELECTED;

/*	  LWSET( OB_STATE( i ), ( count & j ) ? NORMAL : DISABLED );	*/
	  j = j << 1;
	}


	label = F1NAME;				/* clean up the files 	*/

	for ( i = 0; i < NM_NAMES; i++ )	/* clean up fields	*/
	{
	  fs_sset( tree, label, ( LONG )" ", &addr, ( WORD *)&addr );
	  LWSET( OB_STATE( label++ ), NORMAL );
	}

						/* save the current dta	  */
	savedta = Fgetdta( );

	gsx_gclip( &clip );			/* get the clipping rect  */
						/* set the new one	  */
	gsx_sclip( &gl_rfs );
						/* reset the height	*/
	LWSET( OB_Y( FSVELEV ), 0 );	
	LWSET( OB_HEIGHT( FSVELEV ), LWGET( OB_HEIGHT( FSVSLID ) ) );

/* set element colors to the appropriate window part colors */
	((TEDINFO *)obj[FTITLE].ob_spec)->te_color = (UWORD)wtcolor[W_NAME];
	obj[FCLSBOX].ob_spec &= 0xFFFF0000L;
	obj[FCLSBOX].ob_spec |= (UWORD)wtcolor[W_CLOSER];
	obj[FDNAROW].ob_spec &= 0xFFFF0000L;
	obj[FDNAROW].ob_spec |= (UWORD)wtcolor[W_DNARROW];
	obj[FUPAROW].ob_spec &= 0xFFFF0000L;
	obj[FUPAROW].ob_spec |= (UWORD)wtcolor[W_UPARROW];
	obj[FSVSLID].ob_spec &= 0xFFFF0000L;
	obj[FSVSLID].ob_spec |= (UWORD)wtcolor[W_VSLIDE];
	obj[FSVELEV].ob_spec &= 0xFFFF0000L;
	obj[FSVELEV].ob_spec |= (UWORD)wtcolor[W_VELEV];

	gr_mouse( 258, 0x0L );
	gr_mouse( 0, 0x0L );


	ob_draw( tree, 0, MAX_DEPTH );		/* draw the box		*/

	fmt_str( ( BYTE *)pisel, scopy );		

	strcpy( pipath, ad_fpath );		/* make a copy		*/

	pathcopy[0] = defdrv + 'A';		/* Backup path		*/
	pathcopy[1] = ':';
	strcpy( wslstr, &pathcopy[2] );

	count = 0;
	fs_topptr = 0;
	botptr = 0;

	ret = FDIRECTO;			/* initial action	*/
	bret = 0;			/* cjg 02/17/93		*/

	do
	{
cg_1:
	  value = 1;				/* scroll factor	*/

	  switch ( ret )
	  {
	    case FSVSLID:
	      ob_offset( tree, FSVELEV, &xoff, &yoff );
	      value = NM_NAMES;
	      if ( my < yoff )
		goto up;
	      else if (my >= yoff + xtree[FSVELEV].ob_height)
	        goto down;
	      /* else fall through */

	    case FSVELEV:
	      if( !( xtree[ FSVELEV ].ob_state & SELECTED ))
		FXSelect( xtree, FSVELEV );
              gsx_sclip( &gl_rfs );

	      wm_update( 3 );
	      value = gr_slidebox( tree, FSVSLID, FSVELEV, TRUE );
	      wm_update( 2 );

	      if ( count > NM_NAMES )
	      {	
	        mul = ((LONG)( count - NM_NAMES )) * (LONG)(value);
	        if ( fs_topptr != ( mul / 1000 ) )
	        {
		  fs_topptr = ( UWORD )( mul / 1000 );
	          r_sfiles( fs_topptr, value );
	        }
	      }
	      
	      goto out;

down:	    case FDNAROW:			/* scroll down	*/
	      if ( fs_topptr >= botptr )
	      {
out:		FXWait();
		if (ret != FSVSLID);
	          FXDeselect( xtree, ret );
                gsx_sclip( &gl_rfs );
		break;
	      }

	      if ( (fs_topptr + value) <= botptr )
	        fs_topptr += value;
	      else
		fs_topptr = botptr;

	      goto sfiles;

up:	    case FUPAROW:			/* scroll up	*/
	      if ( !fs_topptr )
	      {
		goto out;
	      }
	      if ( (WORD)(fs_topptr - value) >= 0 )
	        fs_topptr -= value;
	      else
		fs_topptr = 0;

sfiles:	      
	      if( !( xtree[ ret ].ob_state & SELECTED ) && ret != FSVSLID )
		FXSelect( xtree, ret );

              gsx_sclip( &gl_rfs );

	      r_sfiles( fs_topptr, value );

	      if( gl_button )
		  goto cg_1;
	      
	      FXWait();
	      if (ret != FSVSLID)
	        FXDeselect( xtree, ret );
	      gsx_sclip( &gl_rfs );
	      break;

	    case FCLSBOX:			/* close box		*/
	      oldend = strlen( ad_fpath );	/* find # char in string*/
	      if( !( xtree[ FCLSBOX ].ob_state & SELECTED ))
		   FXSelect( xtree, FCLSBOX );
	      gsx_sclip( &gl_rfs );

	      *( fs_back( ad_fpath ) ) = 0;	/* back to last path	*/	
	      strcpy( ( BYTE *)ad_title, fs_back( ad_fpath ) + 1 );

						/* fall through		*/
	    case FDIRECTO:
rdir:
	      if ( !*ad_fpath )
		strcpy( pathcopy, ad_fpath );
 
	      strcpy( fs_back( ad_fpath ), &fcopy[0] );
						/* extension OK ?	*/
	      if ( ( fcopy[0] == '\\' ) && ( fcopy[1] ) )
		strcpy( fcopy, fsname );	/* yes			*/	

	      if ( fcopy[0] != '\\' )		/* any slash ?		*/
	      {
		fsname[0] = '\\';
		strcpy( fcopy, fsname + 1 );
	      }

	      if ( !fcopy[1] ) 			/* if no extension	*/
	      {
		strcpy( wslstr, &fsname[0] ); 
		strcat( wildstr, ad_fpath );
	      }

	      if ( r_dir( ad_fpath, scopy, &count ) )
	      {
		strcpy( ad_fpath, pathcopy );	/* copy current dir	*/
	        if ( count > NM_NAMES )		/* more than 9 items	*/
		  botptr = count - NM_NAMES;
	        else
	          botptr = 0;
	      }
	      else
	      {
rdir5:		strcpy( pathcopy, ad_fpath );
	        ob_draw( tree, FDIRECTO, MAX_DEPTH );
		if ( firstry )
		{
		  firstry = FALSE;
		  goto rdir;
		}
	      }
		
	      firstry = FALSE;

				/* reset the last one	*/
	      if ( curdrv <= DRIVEP ) 
	        ob_change( tree, curdrv, NORMAL, TRUE );

	      if ( *( ad_fpath + 1 ) == ':' )	/* if there a drive */
	        defdrv = (WORD)( *ad_fpath - 'A' );

	      curdrv = defdrv + DRIVEA;

	      if ( curdrv <= DRIVEP ) 
	        ob_change( tree, curdrv, SELECTED, TRUE );


	      /* CJG 08/11/92 */
	      if( ret == FCLSBOX )
	      {
	        newend = strlen( ad_fpath );	/* find # char in string*/

	        if( newend != oldend )	        /*  is dir changed ?	*/
	        {
	          if( !( xtree[ FCLSBOX ].ob_state & SELECTED ))
		     FXSelect( xtree, FCLSBOX );
	          gsx_sclip( &gl_rfs );
	        }
	        else
	        {				/* Hasn't changed, wait arnd*/
		  FXWait();
		  X_Deselect( xtree, FCLSBOX );
	          gsx_sclip( &gl_rfs );
		  break;
	        }

		if( !gl_button )
		{
		    FXWait();
		    X_Deselect( xtree, FCLSBOX );
		    gsx_sclip( &gl_rfs );
		}
	        else
		  goto cg_1;
	      }

	      break;

	    case DRIVEA:
	    case DRIVEB:
	    case DRIVEC:
	    case DRIVED:
	    case DRIVEE:
	    case DRIVEF:
	    case DRIVEG:
	    case DRIVEH:
	    case DRIVEI:
	    case DRIVEJ:
	    case DRIVEK:
	    case DRIVEL:
	    case DRIVEM:
	    case DRIVEN:
	    case DRIVEO:
	    case DRIVEP:
	      curdrv = ret;
	      i = ( ret - DRIVEA );		/* get the drive */
	      *ad_fpath = (BYTE)( i + 'A' );	/* stuff into the path */
	      *( ad_fpath + 1 ) = ':';
	      if ( !dos_gdir( i + 1, ( LONG )(ad_fpath + 2) ) )
	        goto fs1;
	      else
		goto rdir5;
		
	    case F1NAME:
	    case F2NAME:
	    case F3NAME:
	    case F4NAME:
	    case F5NAME:
            case F6NAME:
	    case F7NAME:
	    case F8NAME:
	    case F9NAME:
	      i = ret - F1NAME;
	      addr = ( LONG )&ad_fsnames[i + fs_topptr].snames[1];
	      chr = ad_fsnames[i + fs_topptr].snames[0];

						
	      if ( chr == 7 )  		/* is it a directory ?  */
	      {
		unfmt_str( ( BYTE *)addr, fs_back( ad_fpath ) + 1 );
fs1:
		strcat( &fsname[0], ad_fpath );
		goto rdir;
	      }
	      else  				/* must be a file	*/
	        if ( chr )
	        {				/* clean up the last selected */
		  ob_change( tree, last, NORMAL, TRUE );
		  strcpy( ( BYTE *)addr, ( BYTE *)LLGET( LLGET(OB_SPEC(FSELECTI)) ));
		  ob_change( tree, ret, SELECTED, TRUE );		  
		  ob_draw( tree, FSELECTI, MAX_DEPTH );
		  last = ret;
		  if ( bret & 0x8000 )		/* double click		*/ 
		  {
		    ob_change( tree, OK, SELECTED, TRUE );
		    goto fdone;			/* force to exit	*/
		  }
	        }

	      break;

	      default:
	        break;  
	  }					/* end of switch	*/

	  bret = fm_do( tree, FSELECTI );

	  gsx_mxmy( &mx, &my );

	  ret = bret & 0x7FFF;

	  if ( ret == CANCEL )
	    break;

	  if ( !strcmp( ad_fpath, pathcopy ) )/*  is dir changed ?	*/
	  {
	    ob_change( tree, ret, NORMAL, TRUE );
	    ret = FDIRECTO;			/* force a read again	*/
	  }
	  else {  
		 if ( ret == OK )
	           break;
	       }
	     	
	}while ( ret != CANCEL );

fdone:

	dos_sdrv( savedrv );
	dos_free( ( LONG )ad_fsdta );
	dos_free( ( LONG )ad_fsnames );
	dos_free( savepath );
	strcpy( ad_fpath, pipath );
	unfmt_str( ( BYTE *)ad_select, ( BYTE *)pisel );

	if ( ( *pbutton = inf_what( tree, OK, CANCEL ) ) == -1 )
	  *pbutton = NULL;

        ob_change( tree, ret, NORMAL, FALSE );
	fm_dial( FMD_FINISH, &gl_rcenter, &gl_rfs );
	dos_dta( savedta );
	gsx_sclip( &clip );
	
	wm_update( 2 );
/*	currpd->p_state = state;	*/
	gr_mouse( 259, 0x0L );
	return( TRUE );
}


/*	read in a directory	*/

	WORD	
r_dir( path, select, count )
	BYTE	*path;
	BYTE	*select;
REG	UWORD	*count;
{
	LONG	tree,addr;
REG	WORD	status;
	LONG	h,h1;
	BYTE	filename[16];


	gr_mouse( 2, 0x0L ); 

	if ( ! r_files( path, select, count, filename ) )
	{				/* if failed	*/
	  fm_error( 2 );
	  status = FALSE;
	  goto r_exit;
	}

	fs_count = *count;
	fs_draw( FDIRECTO, ( LONG )path, ( LONG )&addr, ( LONG )&addr ); 
	fs_draw( FTITLE, ( LONG )filename, ( LONG )&addr, ( LONG )&addr );
	fs_draw( FSELECTI, ( LONG )select, ( LONG )&ad_select, ( LONG )&addr ); 

	tree = ad_fstree;
	fs_topptr = 0;				/* reset top pointer	*/

	h = LWGET( OB_HEIGHT( FSVSLID ) );
	h += ADJ3DPIX << 1;
	if ( *count > NM_NAMES )
	{
	  h1 = *count;
	  h = ( h * (LONG)NM_NAMES ) / h1;
	}

	if ( !h )				/* min size */
	  h = 1;
	else
	{
	  if ( h > ( ADJ3DPIX << 1 ) )
	    h -= (LONG) (ADJ3DPIX << 1);	
	}
	LWSET( OB_Y(FSVELEV), 0 );		/* move it to the top	  */
	LWSET( OB_HEIGHT(FSVELEV), (UWORD)h );	/* height of the elevator */
	r_sfiles( 0, 0 );			/* show form the top	  */
	status = TRUE;
r_exit:
	gr_mouse( 260, 0x0L );
	return ( status );
}
	
/*	Read files into the buffer		           */
/*	The buffer size will always be NM_NAMES or more    */
/*	for easy coding and redraw the count will return   */
/*	the actual number of files		           */ 

	WORD
r_files( path, select, count, filename )
REG	BYTE	*path;/*5*/
	BYTE	*select;
	WORD	*count;
REG	BYTE	*filename;/*4*/
{
	REG	WORD	i;/*8*/
		LONG	j;/*2*/
	REG	LONG	k;/*4*/
		WORD	ret/*3*//*,len*/;
	REG	FSTRUCT	*fsnames;
	REG	WORD	drvid;/*4*/
		BYTE	*chrptr;

	fsnames = ad_fsnames;

	*filename = 0;		/* no file name		*/

				/* uppercase the drive path	*/
	if ( *( path + 1 ) == ':' )
	{
	  *path = toupper( *path );
	  drvid = (WORD)(*path - 'A');	
	}
	else
	  drvid = defdrv;

 				/* the drive present ? 	*/
	k = 1L;
	k = k << drvid; 
	j = Drvmap( );		/* get the drive map	*/

	if ( !( k & j ) )	/* drive not there	*/
	  return( FALSE );


	dos_sdrv( drvid );	/* set the default drive	*/
				/* take out the wild string stuff	*/

	chrptr = fs_back( path );	/* get the directory	*/
	if ( *chrptr == '\\' )		/* path exists, point at filename */
	  chrptr++;	  

	if ( strlen( chrptr ) > 12 )	/* 9/5/90		*/
	  chrptr[12] = 0;

	strcpy( chrptr, filename );	/* save the file name	*/
	strcpy( wildstr, chrptr );	/* this is the dir	*/
	dos_dta( ( LONG )ad_fsdta );					
					/* look for all sub dir	*/
	if ( ! ( ret = dos_sfirst( ( LONG )path, 0x37 ) ) )	
	{				/* error		*/
	  if ( DOS_AX != E_NOFILES )	/* it is not no files	*/
	  {				
	    strcpy( filename, chrptr );	/* then return		*/
	    return( FALSE );
	  }
	}

	if ( !fs_first )
	  *select = 0;			/* clean up selection filed */
	else
	  fs_first = FALSE;		/* don't clean up at this   */
					/* time			    */

	for ( i = 0; i < NM_NAMES; i++ )
	  strcpy( " ",  &fsnames[i].snames[0] );

	i = 0;
	  				/* look for directory	*/
	while ( ( ret ) && ( (UWORD)(i) < fs_fnum ) )	
	{
	  if( ad_fsdta[21] & (F_HIDDEN|F_SYSTEM) )
	    goto rfile2;

	  if( ad_fsdta[21] & F_SUBDIR ) /* if subdirectory	*/
	  {
	    if ( ad_fsdta[30] != '.' )
	      fsnames[i].snames[0] = 7;
	    else
	      goto rfile2; 
	  }
	  else
	  {
	    if ( wildcmp( filename, &ad_fsdta[30] ) )
	      fsnames[i].snames[0] = 0x20;
	    else
	      goto rfile2;
	  }

	  fmt_str( &ad_fsdta[30], &fsnames[i++].snames[1] );
rfile2:
	  ret = dos_snext();
	}

	if ( i )
	  r_sort( fsnames, i ); 

	strcpy( filename, chrptr );	/* restore file name	*/

	*count = (UWORD) i;

	return( TRUE );
}
		   
static VOID
r_sort( buffer, count )
REG	FSTRUCT	*buffer;
	WORD	count;
{ 
REG	WORD	i,j;
REG	WORD	gap;
	BYTE	tmp[LEN_FSNAME];
	BYTE	*first, *second;

	for( gap = count/2; gap > 0; gap = gap >> 1 )
	{
	  for( i = gap; i < count; i++ )
	  {
	    for ( j = i - gap; j >= 0; j -= gap )
	    {
#ifdef OUR_OPTIMIZER_WORKS
/* this is the way the code should be */
	      first = buffer[j].snames;
	      second = buffer[j+gap].snames;
#else
/* this is the way the Lattice optimizer needs it to be */
	      first = ((BYTE *)buffer) + j * LEN_FSNAME;
	      second = first + gap * LEN_FSNAME;
#endif
	      if ( strchk( first, second ) <= 0 )
	        break; 
	      LSTCPY( &tmp[0], first );
	      LSTCPY( first, second );
	      LSTCPY( second, &tmp[0] );
	    }
	  }
	}
}


/*	show files and update the scroll bar	*/

	VOID
r_sfiles( index, ratio )
	UWORD	index,ratio;
{	
REG	WORD	label,i;
REG	LONG	tree;
	LONG	addr,h,h1,h3;

	label = F1NAME;
	tree = ad_fstree;

	for ( i = index; i < ( index + NM_NAMES ); i++ )
	{
	  LWSET( OB_STATE(label),NORMAL );
	  fs_sset( ad_fstree, label, ( LONG )" ", &addr, ( WORD *)&addr ); 
	  fs_draw( label++, ( LONG )&ad_fsnames[i], ( LONG )&addr, ( LONG )&addr ); 
	}

	h = LWGET( OB_HEIGHT( FSVSLID ) );
	h += ADJ3DPIX << 1;

	h1 = LWGET( OB_HEIGHT( FSVELEV ) );
	h1 += ADJ3DPIX << 1;

	h3 = (LONG) index;

	if ( ratio == 1 || ratio == NM_NAMES )
	{
	  if ( fs_count > NM_NAMES )
	    h = ( (h - h1) * h3 ) / (LONG)(( fs_count - NM_NAMES ));
	  else
	    h = 0L;
	}
	else
	  h = ( (h - h1) * (LONG)ratio ) / 1000L;	  

	LWSET( OB_Y(FSVELEV), ( WORD )h );

	ob_draw( tree, FSVSLID, MAX_DEPTH );	/* erase the old slide bar */
}


/*	do the fs_sset and ob_draw	*/

	VOID
fs_draw( index, path, addr1, addr2 )
	WORD	index;
	LONG	path,addr1,addr2;
{
	fs_sset( ad_fstree, index, path, ( LONG *)addr1, ( WORD *)addr2 ); 
	ob_draw( ad_fstree, index, MAX_DEPTH );
}

/*	Adjust all the drive boxes	*/

	VOID
ini_fsel( VOID )
{
	WORD		x,y,i,j,w;
	REG OBJECT	*obj;
	OBJECT		*tree;

	rs_gaddr(ad_sysglo, R_TREE, SELECTOR, ( LONG *)&tree );
	obj = tree;

	y = x = 0;

	j = DRIVEA;
	for ( i = 0; i < 8; i++)
	{  
	   obj[j].ob_x = x;
	   obj[j++].ob_y = y;
	   obj[j].ob_x = obj[j].ob_width + (ADJ3DPIX << 1) + x + 1;
	   obj[j].ob_y = y;
	   y += obj[j].ob_height + (ADJ3DPIX << 1) + 1;
	   j++;
	} 	

	/* fix up the remaining of the file selector */

	obj[FUPAROW].ob_height -= 1;
	obj[FDNAROW].ob_height -= 1;
	ob_offset( ( LONG )tree, DRIVEA, &x, &y );
	y -= obj[FSDRIVE].ob_height + 2 + ADJ3DPIX;
	obj[FSDRIVE].ob_y = y;

	ob_offset( ( LONG )tree, FCLSBOX, &x, &y );

 	obj[FILEBOX].ob_x = x - ADJ3DPIX - 1; 
	obj[FTITLE].ob_x = x + obj[FCLSBOX].ob_width + (ADJ3DPIX << 1);
					 /* adjust FTITLE */	
	obj[FTITLE].ob_y = y;
	obj[FTITLE].ob_height = obj[FCLSBOX].ob_height;
	obj[FTITLE].ob_width -= (ADJ3DPIX << 1);

	y = y + obj[FCLSBOX].ob_height + ADJ3DPIX;
	obj[FILEBOX].ob_y = obj[SCRLBAR].ob_y = y;
	obj[FUPAROW].ob_y = ADJ3DPIX;
	y = obj[FUPAROW].ob_height + (ADJ3DPIX << 1);
	obj[FSVELEV].ob_height = obj[FSVSLID].ob_height;
	y += ADJ3DPIX;	
	obj[FSVSLID].ob_y = obj[FSVELEV].ob_y = y; 
	y += obj[FSVSLID].ob_height + (ADJ3DPIX << 1);
	obj[FDNAROW].ob_y = y;
	y += obj[FDNAROW].ob_height + ADJ3DPIX;
	obj[FILEBOX].ob_height = obj[SCRLBAR].ob_height = y;
	w = obj[FCLSBOX].ob_width + obj[FTITLE].ob_width + ( ADJ3DPIX << 2 );
	w -= obj[FUPAROW].ob_width;
	obj[FILEBOX].ob_width = w;
	obj[SCRLBAR].ob_x = obj[FILEBOX].ob_x + w;
	obj[SCRLBAR].ob_spec = 0;
	obj[FSVSLID].ob_flags |= (IS3DOBJ|IS3DACT);
	obj[FSVSLID].ob_state |= SELECTED;

	ob_offset( ( LONG )tree, FILEBOX, &x, &y );
	y = obj[FILEBOX].ob_height + y + 6 + ADJ3DPIX;
	obj[OK].ob_y = obj[CANCEL].ob_y = y;
	y += obj[OK].ob_height + ADJ3DPIX + 6;
	obj[0].ob_height = y;

/* colors will be set up at run time based on window colors */
}


	VOID
FXWait( VOID )
{
    do
    {
        if (gl_multi)
                Syield();
    }while( gl_button );
}

	VOID
FXSelect( tree, obj )
OBJECT *tree;
WORD   obj;
{
    GRECT 	rect;
    WORD	dummy;
	
    tree[ obj ].ob_state |= SELECTED;
    rect = *(GRECT *)&tree[(obj)].ob_x;
    ob_gclip( ( LONG )tree, obj, &dummy, &dummy, &rect.g_x, &rect.g_y,
	      &rect.g_w, &rect.g_h );
    gsx_sclip( &rect );
    ob_draw( ( LONG )tree, obj, MAX_DEPTH );		/* draw the box		*/
}


	VOID
FXDeselect( tree, obj )
OBJECT *tree;
WORD   obj;
{
    GRECT 	rect;
    WORD	dummy;
 	
    tree[ obj ].ob_state &= ~SELECTED;
    rect = *(GRECT *)&tree[(obj)].ob_x;
    ob_gclip( ( LONG )tree, obj, &dummy, &dummy, &rect.g_x, &rect.g_y,
	      &rect.g_w, &rect.g_h );
    gsx_sclip( &rect );
    ob_draw( ( LONG )tree, obj, MAX_DEPTH );		/* draw the box		*/
}

/* X_Deselect()
 * ====================================================================
 * Deselect an object and redraw - use the flag to redraw in case
 * the area to redraw needs to be bigger.( ie: SHADOWED )
 */
	VOID
X_Deselect( tree, obj )
OBJECT *tree;
WORD   obj;
{
       	GRECT trect;
	WORD	dummy;
       			
       if( tree[ obj ].ob_state & SELECTED )
       {
         tree[ obj ].ob_state &= ~SELECTED;
         trect = *(GRECT *)&tree[(obj)].ob_x;
	 ob_gclip( ( LONG )tree, obj, &dummy, &dummy, &trect.g_x, &trect.g_y, 
		   &trect.g_w, &trect.g_h );
    	 gsx_sclip( &trect );
         ob_draw( ( LONG )tree, obj, MAX_DEPTH );
       }
}
@


1.9
log
@Merged in Hans-Martin and Cary's changes
@
text
@@


1.8
log
@Another check in to save work.
@
text
@d53 1
a488 5
#if 0
                if (!gl_multi)
                        dsptch();
#endif

a612 1

a667 1

a778 1

d784 2
a785 1
REG	WORD	gap,i,j;
d787 1
d789 1
a789 1
	for( gap = count/2; gap > 0; gap /= 2 )
d795 10
a804 1
	      if ( strchk( buffer[j].snames, buffer[j+gap].snames ) <= 0 )
d806 3
a808 4

	      LSTCPY( tmp, buffer[j].snames );
	      LSTCPY( buffer[j].snames, buffer[j+gap].snames );
	      LSTCPY( buffer[j+gap].snames, tmp );
a814 1

a869 1

a877 1
	TEDINFO		*edspec;
d884 2
a885 1
	for ( i = 0, j = DRIVEA; i < 8; i++, j++ )
d892 1
a927 7
#if 0
	obj[FSVSLID].ob_flags &= ~(IS3DOBJ|IS3DACT);
	obj[FSVSLID].ob_width += ADJ3DPIX;
	obj[FSVELEV].ob_x += ADJ3DPIX;
	obj[FUPAROW].ob_x += ADJ3DPIX;
	obj[FDNAROW].ob_x += ADJ3DPIX;
#else
a929 1
#endif
d946 2
a947 4
#if 0
        if (!gl_multi)
                dsptch();
#endif
a949 1

@


1.7
log
@Check in to save work
@
text
@d51 2
a68 2
EXTERN  LONG	trap();
EXTERN	LONG	trap13();
a69 1

d78 1
d279 1
a279 1
	savedta = trap( 0x2F );
d288 13
d363 2
a364 1
	        FXDeselect( xtree, ret );
d387 1
a387 1
	      if( !( xtree[ ret ].ob_state & SELECTED ))
a393 5
#if 0
              if (!gl_multi)
                        dsptch();
#endif

d398 2
a399 1
	      FXDeselect( xtree, ret );
d710 1
a710 1
	j = trap13( 0xa );	/* get the drive map	*/
d921 2
a922 2
	w = obj[FCLSBOX].ob_width + obj[FTITLE].ob_width + ( ADJ3DPIX << 3 );
	w -= obj[FUPAROW].ob_width + ( ADJ3DPIX << 2 );
d925 11
d943 1
a943 24
/* if we don't have color, put a nice pattern in the title */
	if (gl_ws.ws_ncolors <= LWHITE)
	{
	  edspec = (TEDINFO *)obj[FTITLE].ob_spec;
/*	  edspec->te_color &= ( WORD )0xffffff00L;*/
	  edspec->te_color &= ( WORD )0xff00;
	  edspec->te_color |=0x41;
	}
#if 0
/* ++ERS 1/19/93: the colors are already set up correctly by objc_draw,
 * because we now say that "hollow, white, 3D objects" should get set
 * to the appropriate 3D colors
 */
        if (gl_ws.ws_ncolors > LWHITE)
	  return;

        obj[FCLSBOX].ob_spec = (obj[FCLSBOX].ob_spec & 0xfffffff0) | WHITE;
        obj[FUPAROW].ob_spec = (obj[FUPAROW].ob_spec & 0xfffffff0) | WHITE;
        obj[FDNAROW].ob_spec = (obj[FDNAROW].ob_spec & 0xfffffff0) | WHITE;
        obj[FSVELEV].ob_spec = (obj[FSVELEV].ob_spec & 0xfffffff0) | WHITE;

	for ( i = DRIVEA; i <= DRIVEP; i++ )
	   obj[i].ob_spec = (obj[i].ob_spec & 0xfffffff0) | WHITE;
#endif
a1015 1

@


1.6
log
@Merged Cary's and Hans-Martin's changes
@
text
@a0 71
/*
*************************************************************************
*			Revision Control System
* =======================================================================
*  $Revision: 1.4 $	$Source: f:\multitos/RCS/gemfslib.c,v $
* =======================================================================
*  $Author: ersmith $	$Date: 1993/03/12 19:51:12 $	$Locker: ersmith $
* =======================================================================
*  $Log: gemfslib.c,v $
 * Revision 1.4  1993/03/12  19:51:12  ersmith
 * Merged HMK's loadable resource stuff
 *
 * Revision 1.3  1993/03/10  20:12:42  ersmith
 * Lattice port
 *
* Revision 1.1  1993/02/24  23:52:46  ersmith
* 1 meg floppy MultiTOS
*
* Revision 1.0  1993/02/03  21:26:46  ersmith
* MultiTOS version 1.0
*
* Revision 2.2  89/04/26  18:23:06  mui
* TT
* 
* Revision 2.1  89/02/22  05:26:30  kbad
* *** TOS 1.4  FINAL RELEASE VERSION ***
* 
* Revision 1.14  88/11/02  12:00:29  mui
* Change fs_fnum from word to long
* 
* Revision 1.13  88/11/01  16:07:28  kbad
* fix hidden/system/readonly files (now they don't show)
* 
* Revision 1.12  88/11/01  11:21:04  kbad
* Reg opt @@ r_dir, r_files
* 
* Revision 1.11  88/10/24  10:31:33  mui
* click anywhere to reload the directory
* 
* Revision 1.10  88/10/17  13:37:39  kbad
* yanked fs_start to fix fs_input growing clip rect problem
* 
* Revision 1.9  88/09/09  17:11:25  kbad
* Fixed the colon cancer - fixed fs_back colon handling
* 
* Revision 1.8  88/08/17  20:35:35  mui
* change to handle more than 16 devices
* 
* Revision 1.7  88/07/29  01:30:12  kbad
* change r_files to fix filename copy
* 
* Revision 1.6  88/07/28  21:25:19  mui
* use GEMDOS to handle all path functions
* 
* Revision 1.5  88/07/08  11:51:38  mui
* don't read them in until it is needed
* 
* Revision 1.4  88/07/07 17:55:48  mui
* Get default directory from GEMDOS
*
* Revision 1.3  88/07/01 16:21:52  mui
* Change r_files to read in everything once
*
* Revision 1.2  88/07/01 15:49:12  mui
* Fix fs_input to handle drive: with no extension
*
* Revision 1.1  88/06/02  12:33:50  lozben
* Initial revision
* 
*************************************************************************
*/
@


1.5
log
@Incorporated more single/multitasking changes.
@
text
@@


1.4
log
@Merged HMK's loadable resource stuff
@
text
@d5 1
a5 1
*  $Revision: 1.3 $	$Source: f:\multitos/RCS/gemfslib.c,v $
d7 1
a7 1
*  $Author: ersmith $	$Date: 1993/03/10 20:12:42 $	$Locker: ersmith $
d10 3
d149 1
a149 1

d451 5
d549 5
d1025 4
@


1.3
log
@Lattice port
@
text
@d5 1
a5 1
*  $Revision: 1.1 $	$Source: f:\multitos/RCS/gemfslib.c,v $
d7 1
a7 1
*  $Author: ersmith $	$Date: 1993/02/24 23:52:46 $	$Locker: ersmith $
d9 4
a12 1
*  $Log:	gemfslib.c,v $
@


1.2
log
@REAL MultiTOS 1.01
@
text
@d9 7
a15 4
*  $Log: gemfslib.c,v $
 * Revision 1.1  1993/02/24  23:52:46  ersmith
 * 1 meg floppy MultiTOS
 *
d90 2
d108 2
d111 5
a115 9
#include <compiler.h>
#include <machine.h>
#include <pdstruct.h>
#include <obdefs.h>
#include <objaddr.h>
#include <gemdos.h>
#include <rslib.h>
#include <gemlib.h>
#include <gemusa.h>
d122 2
d129 3
a131 3
EXTERN	BYTE	toupper();			
EXTERN	BYTE	*dos_xalloc();
EXTERN  WORD	DOS_AX;
d135 2
a234 1
	BYTE	*chrptr;	
d255 2
d266 1
a266 2
	pxpath = dos_xalloc( (LONG)( ( WORD )LPATH * ( WORD )( DEVICES + 1 ) ), 
			     3 );
d271 1
a271 1
	ad_fsdta = dos_xalloc( 0x00000100L, 3 );	
d277 1
a277 1
	mul = dos_xalloc( -1L, 3 );
d287 2
a288 2
	  dos_free( ad_fsdta );
bye:	  dos_free( pxpath );
d295 1
a295 1
	  ad_fsnames = dos_xalloc( mul, 3 );  
d298 3
a300 3
	savepath = pxpath;		/* save the address	*/
	pathcopy = savepath;
	pxpath = savepath + (WORD)LPATH;	
d304 2
a305 1
	xtree = obj = tree = ad_fstree;
d307 2
a308 2
	lgptr = OB_SPEC( FDIRECTORY );	/* change the buffer pointer */
	**lgptr = dirbuffer;
d311 4
a314 4
	fs_sset( tree, FLABEL, lstring, &addr, &addr );
	fs_sset( tree, FDIRECTORY, "", &ad_fpath, &addr ); 
	fs_sset( tree, FTITLE, "", &ad_title, &addr );
	fs_sset( tree, FSELECTION, "", &ad_select, &addr );
d339 1
a339 1
	  fs_sset( tree, label, " ", &addr, &addr );
d359 1
a359 1
	fmt_str( pisel, scopy );		
d371 2
a372 1
	ret = FDIRECTORY;			/* initial action	*/
d404 1
a404 1
		  fs_topptr = mul / 1000;
d460 1
a460 1
	      strcpy( ad_title, fs_back( ad_fpath ) + 1 );
d463 1
a463 1
	    case FDIRECTORY:
d496 1
a496 1
	        ob_draw( tree, FDIRECTORY, MAX_DEPTH );
d570 1
a570 1
	      if ( !dos_gdir( i + 1, ad_fpath + 2 ) )
d585 1
a585 1
	      addr = &ad_fsnames[i + fs_topptr].snames[1];
d591 1
a591 1
		unfmt_str( addr, fs_back( ad_fpath ) + 1 );
d600 1
a600 1
		  strcpy( addr, LLGET( LLGET(OB_SPEC(FSELECTION)) ));
d602 1
a602 1
		  ob_draw( tree, FSELECTION, MAX_DEPTH );
d617 1
a617 1
	  bret = fm_do( tree, FSELECTION );
d629 1
a629 1
	    ret = FDIRECTORY;			/* force a read again	*/
d641 2
a642 2
	dos_free( ad_fsdta );
	dos_free( ad_fsnames );
d645 1
a645 1
	unfmt_str( ad_select, pisel );
d672 1
a672 1
REG	WORD	status,i;
d687 3
a689 3
	fs_draw( FDIRECTORY, path, &addr, &addr ); 
	fs_draw( FTITLE, filename, &addr, &addr );
	fs_draw( FSELECTION, select, &ad_select, &addr ); 
d699 1
a699 1
	  h = ( h * NM_NAMES ) / h1;
d707 1
a707 1
	    h -= (ADJ3DPIX << 1);	
a734 2
/*		LONG	temp,addr;*/
		BYTE	*chrptr;/*7*/
d737 1
a737 1
/*		BYTE	save;*/
d753 1
a753 1
	k = 1;
d773 1
a773 1
	dos_dta( ad_fsdta );					
d775 1
a775 1
	if ( ! ( ret = dos_sfirst( path, 0x37 ) ) )	
d825 1
a825 1
	*count = i;
d831 1
a831 1
	WORD
d833 1
a833 1
REG	FSTRUCT	(*buffer)[];
d836 1
a836 1
REG	WORD	gap,i,j,k;
d845 1
a845 1
	      if ( strchk( buffer[j], buffer[j+gap] ) <= 0 )
d848 3
a850 3
	      LSTCPY( tmp, buffer[j] );
	      LSTCPY( buffer[j], buffer[j+gap] );
	      LSTCPY( buffer[j+gap], tmp );
d874 2
a875 2
	  fs_sset( ad_fstree, label, " ", &addr, &addr ); 
	  fs_draw( label++, &ad_fsnames[i], &addr, &addr ); 
d884 1
a884 1
	h3 = index;
d891 1
a891 1
	    h = 0;
d894 1
a894 1
	  h = ( (h - h1) * ratio ) / 1000;	  
d896 1
a896 1
	LWSET( OB_Y(FSVELEV), h );
d909 1
a909 1
	fs_sset( ad_fstree, index, path, addr1, addr2 ); 
d917 1
a917 1
ini_fsel()
d919 1
a919 1
	WORD		x,y,i,j,w,h;
d924 1
a924 1
	rs_gaddr(ad_sysglo, R_TREE, SELECTOR, &tree );
d942 1
a942 1
	ob_offset( tree, DRIVEA, &x, &y );
d946 1
a946 1
	ob_offset( tree, FCLSBOX, &x, &y );
d971 1
a971 1
	ob_offset( tree, FILEBOX, &x, &y );
d981 2
a982 1
	  edspec->te_color &= 0xffffff00L;
d1004 2
a1005 2
	WORD
FXWait()
d1013 1
a1013 1
	WORD
d1023 1
a1023 1
    ob_gclip( tree, obj, &dummy, &dummy, &rect.g_x, &rect.g_y,
d1026 1
a1026 1
    ob_draw( tree, obj, MAX_DEPTH );		/* draw the box		*/
d1030 1
a1030 1
	WORD
d1040 1
a1040 1
    ob_gclip( tree, obj, &dummy, &dummy, &rect.g_x, &rect.g_y,
d1043 1
a1043 1
    ob_draw( tree, obj, MAX_DEPTH );		/* draw the box		*/
d1051 1
a1051 1
	WORD
d1063 1
a1063 1
	 ob_gclip( tree, obj, &dummy, &dummy, &trect.g_x, &trect.g_y, 
d1066 1
a1066 1
         ob_draw( tree, obj, MAX_DEPTH );
@


1.1
log
@1 meg floppy MultiTOS
@
text
@d5 1
a5 1
*  $Revision: 2.2 $	$Source: /u2/MRS/osrevisions/aes/gemfslib.c,v $
d7 1
a7 1
*  $Author: mui $	$Date: 89/04/26 18:23:06 $	$Locker: kbad $
d9 4
a12 1
*  $Log:	gemfslib.c,v $
@


1.0
log
@MultiTOS version 1.0
@
text
@@
