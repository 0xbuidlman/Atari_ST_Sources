head	1.10;
access;
symbols;
locks
	ersmith:1.10;
comment	@# @;


1.10
date	93.06.15.23.20.42;	author ersmith;	state Exp;
branches;
next	1.9;

1.9
date	93.06.14.23.48.02;	author ersmith;	state Exp;
branches;
next	1.8;

1.8
date	93.06.09.23.47.00;	author ersmith;	state Exp;
branches;
next	1.7;

1.7
date	93.05.12.15.50.18;	author ersmith;	state Exp;
branches;
next	1.6;

1.6
date	93.04.27.23.00.14;	author ersmith;	state Exp;
branches;
next	1.5;

1.5
date	93.04.14.22.19.54;	author ersmith;	state Exp;
branches;
next	1.4;

1.4
date	93.03.12.19.51.12;	author ersmith;	state Exp;
branches;
next	1.3;

1.3
date	93.03.10.20.12.42;	author ersmith;	state Exp;
branches;
next	1.2;

1.2
date	93.03.08.20.07.02;	author ersmith;	state Exp;
branches;
next	1.1;

1.1
date	93.02.24.23.52.46;	author ersmith;	state Exp;
branches;
next	1.0;

1.0
date	93.02.03.21.26.46;	author ersmith;	state Exp;
branches;
next	;


desc
@Interrupt handling stuff
@


1.10
log
@Minor fixups, resource file cleanup etc.
@
text
@*	Rename to INTERRUPT.S		9/5/90		D.Mui
*	RATRBP.S	11/06/84 - 03/27/85		Lowell Webster	
* 	Change at tikcod to check if the timer event is being recorded 
*	in the forkq			12/5/88		D.Mui
*	Use MAC to assemble	6/28/90			Derek Mui
* 	assemble with MAS 		900801 		kbad
*	Restore b_click into geminput.c	9/4/90		D.Mui
*	Restore b_delay into geminput.c	9/4/90		D.Mui

*	-----------------------------------------------------------
*	AES Version 4.0	MultiTOS version is written by Derek M. Mui
*	Copyright (C) 1992 
*	Atari (U.S.) Corp
*	All Rights Reserved
*	-----------------------------------------------------------
 
	.text

	.globl	_far_bchange
	.globl	_bchange
	.globl	_b_delay
	.globl	_far_mchange
	.globl	_mchange
	.globl  _drwaddr
	.globl	_forkq
	.globl	_justretf
	.globl	_tiksav
	.globl	_tikaddr
	.globl	_tchange
	.globl	_tikcod
	.globl	_NUM_TICK
	.globl	_CMP_TICK
	.globl	_gl_btrue
	.globl	_gl_bdelay
	.globl	_gl_bdesired
	.globl	_gl_bpend
	.globl	_bchange
	.globl	_gl_xrat
	.globl	_gl_yrat	
	.globl	_b_click

*****************************************************************
*	  called far with d0 = button state			*
*	  interrupts should be off and in supervisor mode	*	
*	  calls b_click in geminput.c				*
*****************************************************************

_far_bchange:
	move.l	a7,gstksave		; save stack, paranoid code
	lea.l	gstack,a7
	movem.l	d0-d2/a0-a2,-(sp)	; save regs that c will crunch
	move.w	d0,-(sp)		; pass button state, only if tick in gsx
	jsr	_b_click		; register this click event
	addq.l	#2,sp
	movem.l (sp)+,d0-d2/a0-a2
	movea.l	gstksave,a7
	rts

*****************************************************************
*	called far with interrupts off				*
*	d0 = xposition, d1 = yposition in absolute pixels	*
*****************************************************************

_far_mchange:
	move.l	a7, gstksave		; save stack
	lea.l 	gstack,a7
	movem.l d0-d2/a0-a2,-(sp)	; save regs that C will crunch

	move.w	d1,-(sp)		; delta y
	move.w	d1,_gl_yrat
	move.w	d0,-(sp)		; delta x
	move.w	d0,_gl_xrat
	move.l	#_mchange,-(sp)
	jsr	_forkq			; call forkq
	addq.l	#8,sp

	movem.l (sp)+,d0-d2/a0-a2
	move.l	gstksave,a7
	rts

*********************************************************
*	call gsx with absolute x and y to draw cursor	*
*********************************************************	

*_drawrat:
*	move.w	4(a7),d0		; xrat
*	move.w	6(a7),d1		; yrat
*	move.l	_drwaddr,-(sp)
*	rts

_justretf:
	rts

*********************************************************	
*	Timer interrupt code				*
*	called far with interrupts disabled		*
*	do not need to save registers			*
*********************************************************

_tikcod:
	move.l	a7, tstksave		; save stack
	lea.l 	tstack,a7
	addq.l	#1,TICKS		; bump up the absolute clock
	tst.l	_CMP_TICK		; are we timing now?
	beq	tpollmb			; nope, go away
	addq.l	#1,_NUM_TICK		; yes, we're timing
	subq.l	#1,_CMP_TICK
	bne	tpollmb
	move.l	_NUM_TICK,-(a7)		; we need to establish a forkq
	move.l	#_tchange,-(a7)		; that will pick us up	
	jsr	_forkq
	addq.l	#8,a7
	tst.w	d0			; event recorded ?
	bne	tpollmb			; Yes
	addq.l	#1,_CMP_TICK		; No, so reset the counter

tpollmb:
	move.w	#1,-(a7)		; count down for button delay	
	jsr	_b_delay
	addq.l	#2,a7
	move.l	tstksave,a7	; Interrupt processed, restore everything

*********************************************************	
* 	Chain to next guy who wants to get ticked!	*
*********************************************************

	move.l	_tiksav,-(a7)	; Go through some other vector.
	rts


	.bss
	.even

* addr in gsx in rat draw routine

;_gl_xrat:	.ds.w	1		; commented out by HMK 03/24/93 since they 
;_gl_yrat:	.ds.w	1		; redefined in gemsigna.c !!!

_drwaddr:	.ds.l	1		; initialized to _justretf
_tikaddr:	.ds.l	1		; initialized to _tikcod
gstksave:	.ds.l	1
tstksave:	.ds.l	1
_tiksav:	.ds.l	1		; addr in gsx driver of tick service
_NUM_TICK:	.ds.l	1
_CMP_TICK:	.ds.l	1
TICKS:		.ds.l	1		; absolute number of ticks NOT GLOBAL!
		.ds.l	23		; gsx stack for mouse
gstack:		.ds.l	1
		.ds.l	100		; tick stack
tstack:		.ds.l	1

	.end
@


1.9
log
@Merged in Hans-Martin and Cary's changes
@
text
@@


1.8
log
@Another check in to save work.
@
text
@@


1.7
log
@Check in to save work
@
text
@@


1.6
log
@Merged Cary's and Hans-Martin's changes
@
text
@@


1.5
log
@Incorporated more single/multitasking changes.
@
text
@@


1.4
log
@Merged HMK's loadable resource stuff
@
text
@d136 3
a138 2
_gl_xrat:	.ds.w	1
_gl_yrat:	.ds.w	1
@


1.3
log
@Lattice port
@
text
@@


1.2
log
@REAL MultiTOS 1.01
@
text
@@


1.1
log
@1 meg floppy MultiTOS
@
text
@@


1.0
log
@MultiTOS version 1.0
@
text
@@
