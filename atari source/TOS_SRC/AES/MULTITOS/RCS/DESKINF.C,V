head	1.10;
access;
symbols;
locks
	ersmith:1.10;
comment	@ * @;


1.10
date	93.06.15.22.53.36;	author ersmith;	state Exp;
branches;
next	1.9;

1.9
date	93.06.14.23.48.02;	author ersmith;	state Exp;
branches;
next	1.8;

1.8
date	93.06.09.23.47.00;	author ersmith;	state Exp;
branches;
next	1.7;

1.7
date	93.05.12.01.40.22;	author ersmith;	state Exp;
branches;
next	1.6;

1.6
date	93.04.27.23.00.14;	author ersmith;	state Exp;
branches;
next	1.5;

1.5
date	93.04.14.22.19.54;	author ersmith;	state Exp;
branches;
next	1.4;

1.4
date	93.03.12.19.51.12;	author ersmith;	state Exp;
branches;
next	1.3;

1.3
date	93.03.10.20.12.42;	author ersmith;	state Exp;
branches;
next	1.2;

1.2
date	93.03.08.20.07.02;	author ersmith;	state Exp;
branches;
next	1.1;

1.1
date	93.02.24.23.52.46;	author ersmith;	state Exp;
branches;
next	1.0;

1.0
date	93.02.03.21.26.46;	author ersmith;	state Exp;
branches;
next	;


desc
@NEWDESK.INF parsing code
@


1.10
log
@Minor resource editing, elclean ups, etc.
@
text
@/*	DESKINF.C		05/04/89 - 09/18/89	D.Mui		*/
/*	Read in different setting of color and pattern depends on the	*/
/*	color			6/28/90			D.Mui		*/
/*	Put in default values of color and pattern	7/2/90	D.Mui	*/
/*	Changed default color	7/20/90			D.Mui		*/
/*	Save_inf returns status and move the up_allwin 8/14/91	D.Mui	*/ 
/*	Change all the iconblk to ciconblk	7/11/92	D.Mui		*/
/*      Added another 0x00 to mkeys[] for VIDITEM obj  07/07/92 C.Gee   */
/*	The #E will save 10 fields instead of 4	7/17/92	D.Mui		*/ 
/*	Converted to Lattice C 5.51		2/18/93 C.Gee		*/
/*	Saving also window iconifying inform.	5/11/93 H.M.Krober	*/
/*	Save font used in text windows		5/26/93 H.M.Krober	*/

/************************************************************************/
/*	New Desktop for Atari ST/TT Computer				*/
/*	Atari Corp							*/
/*	Copyright 1989,1990 	All Rights Reserved			*/
/************************************************************************/

#include "portab.h"
#include "machine.h"
#include "obdefs.h"
#include "deskdefi.h"
#include "deskwin.h"
#include "deskusa.h"
#include "osbind.h"
#include "extern.h"
#include "pdesk.h"
#include "pmisc.h"
#include "pboth.h"

EXTERN	BYTE	mentable[];
EXTERN	APP	*applist;
EXTERN	WORD	q_change;
EXTERN	BYTE	*q_addr;
EXTERN	WORD	d_maxcolor;	/* max number of color	*/

EXTERN	WORD	win_font;
EXTERN	WORD	win_fsize;
EXTERN	WORD	d_numfonts;


UWORD	d_rezword;
WORD	font_save;
WORD	s_defdir;
WORD	s_fullpath;

#define SAVE_ATARI	128

/*	Default keystroke	*/

/* Added another 0x00 to the end for VIDITEM object - cjg 07/07/92 */
BYTE	mkeys[MAXMENU] = { 0x4F, 0x53, 0x4C, 0x00, 0x46, 0x42, 0x43, 0x57, 
			   0x45, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
			   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 
			   0x00, 0x00, 0x4D, 0x56, 0x50, 0x00, 0x00 };


/*	Make inf path	*/

	VOID
m_infpath( buffer )
	BYTE	*buffer;
{
	strcpy( infpath, buffer );	/* C:\NEWDESK.INF	*/
	buffer[0] = ( isdrive() & 0x04 ) ? 'C' : 'A';
}


/*	Reverse of hex_dig()	*/

	BYTE
uhex_dig(wd)
	REG WORD		wd;
{
	if ( (wd >= 0) && (wd <= 9) )
	  return(wd + '0');
	
	if ( (wd >= 0x0a) && (wd <= 0x0f) )
	  return(wd + 'A' - 0x0a);

	return(' ');
}
	

	BYTE
*escan_str(pcurr, ppstr)
	REG BYTE		*pcurr;
	REG BYTE		*ppstr;
{
	while( *pcurr == ' ' )
	  pcurr++;

	while( ( *pcurr != '@@' ) && ( *pcurr ) )
	  *ppstr++ = *pcurr++;

	*ppstr = 0;
	pcurr++;
	return( pcurr );
}


/*	Scan off and convert the next two hex digits and return with
	pcurr pointing one space past the end of the four hex digits
*/

	BYTE
*scan_2(pcurr, pwd)
	REG BYTE		*pcurr;
	REG UWORD		*pwd;
{
	REG UWORD		temp;
	
	temp = 0x0;
	temp |= hex_dig(*pcurr++) << 4;
	temp |= hex_dig(*pcurr++);
	if (temp == 0x00ff)
	  temp = NIL;
	*pwd = temp;
	pcurr++;
	return(	pcurr );
}


/*	Reverse of scan_2()	*/

	BYTE
*save_2(pcurr, wd)
	REG	BYTE		*pcurr;
	UWORD		wd;
{
	*pcurr++ = uhex_dig((wd >> 4) & 0x000f);
	*pcurr++ = uhex_dig(wd & 0x000f);
	*pcurr++ = ' ';
	return(	pcurr );
}

/*	Reverse of scan_str	*/

	BYTE
*save_str(pcurr, pstr)
	REG BYTE		*pcurr;
	REG BYTE		*pstr;
{
	while( (*pstr) && (pstr) )
	  *pcurr++ = *pstr++;
	*pcurr++ = '@@';
	*pcurr++ = ' ';
	return(pcurr);
}


/*	Scan the desktop icon	*/

	BYTE	
*inf_xdesk( pcurr )
	REG BYTE	*pcurr;
{
	REG WORD	ix;
	REG WORD	id;
	REG CICONBLK	*iblk;
	OBJECT		*obj;
	WORD		x,y,i,type;
	BYTE		buffer[14];
	WORD		temp;

	type = *pcurr++;

	switch( type )
	{
	  case 'C':		/* cartridge	*/
	    if ( !cart_init() )
	      return( pcurr );

	    ix = DISK;
	    break;	
	  case 'M':		/* No drive?	*/
	    if ( !( x = isdrive() ) )
	      return( pcurr );
		
	    if ( ( pcurr[13] == 'C' ) && !( x & 0x04 ) ) 
	      return( pcurr );

	    ix = DISK;		/* disk drive	*/
	    break;
	  case 'T':
	    ix = TRASHCAN;	/* trashcan	*/
	    break;
	  case 'X':				
	    ix = XFILE;		/* desktop file	*/
	    break;
	  case 'V':				
	    ix = XDIR;		/* desktop file	*/
	    break;
	  case 'O':				
	    ix = PRINTER;
	    break;
	  default:		/* illegal type	*/
	    return( pcurr );
	}

	if ( ( id = av_icon() ) == -1 )	/* allocate a desktop icon	*/
	  return( pcurr );

	backid[id].i_type = ix;

	obj = background;

	pcurr++;
	pcurr = scan_2( pcurr, &x );	/* icon x		*/
	pcurr = scan_2( pcurr, &y );	/* icon y		*/

	app_posicon( x, y, &obj[id].ob_x, &obj[id].ob_y );
					
	pcurr = scan_2( pcurr, &i );	/* get the icon id	*/
	backid[id].i_icon = i;

	iblk = (CICONBLK*)(background[id].ob_spec);
	cp_iblk( i, iblk );

	pcurr += 3;		
	temp = iblk->monoblk.ib_char & 0xFF00; /* preserve the upper byte */
	iblk->monoblk.ib_char = temp | (( *pcurr == ' ' ) ? 0 : *pcurr);
	pcurr += 2;		

					/* for extended file or folder */
	if ( ( type == 'X' ) || ( type == 'V' ) )
	{
  	  pcurr = lp_fill( pcurr, &backid[id].i_path );
	  pcurr = escan_str( pcurr, (BYTE *)iblk->monoblk.ib_ptext );
	  if ( ! *((BYTE*)(iblk->monoblk.ib_ptext) ) )
 	  {
	    if ( type == 'X' )
	      save_ext( backid[id].i_path, (BYTE *)iblk->monoblk.ib_ptext );
	    else
	      save_mid( backid[id].i_path, (BYTE *)iblk->monoblk.ib_ptext );
	  }	
	}
	else
	{
	  pcurr = escan_str( pcurr, (BYTE *)iblk->monoblk.ib_ptext );
	  pcurr = escan_str( pcurr, buffer );
	}

	return( pcurr );
}



/*	Parse a single line from the DESKTOP.APP file.	*/
/*	Just scan the application			*/

	BYTE
*inf_parse( pcurr )
	REG BYTE	*pcurr;
{
	REG APP		*app;
	REG WORD	type;
	LONG		limit;
	WORD		temp;
	
	pcurr -= 2;			/* important	*/

	switch( *pcurr++ )
	{
	  case 'A': 
	        type = ACCESSORY;
		break;
	  case 'Y':
		type = PTP;		/* prg takes parameter	*/
		break;	
	  case 'G':			/* GEM App File		*/
		type = PRG;
		break;
	  case 'F':			/* DOS File no parms	*/
		type = TOS;
		break;
	  case 'P':			/* DOS App needs parms	*/
		type = TTP;
		break;
	  case 'D':			/* folder subdir	*/
		type = FOLDER;
		break;
	  case 'N':			/* text file		*/
		type = TEXT;
		break;
	  case 'I':			/* icon 		*/
		type = ICONS;
		break;
	  default:
	    	return( pcurr );
	}

	if ( !(app = app_alloc() ) )	/* allocate a app 	*/
	   return( pcurr );	

	app->a_type = type;		/* prg takes parameter	*/

	pcurr++;
	pcurr = scan_2( pcurr, &app->a_icon );	/* get the icon number	*/
	pcurr = scan_2( pcurr, &app->a_dicon );	

	if ( *pcurr != ' ' )			/* default definiton	*/
	{
	  app->a_pref = hex_dig( *pcurr );

	  if ( *( pcurr + 1 ) != ' ' )		/* function key		*/
	  {
	    pcurr++;
	    scan_2( pcurr++, &app->a_key );		
	  }
	}

	pcurr += 2;

	pcurr = lp_fill( pcurr, &app->a_name );
	pcurr = escan_str( pcurr, app->a_doc );
	pcurr++;

 	limit = 0;
	if ( *pcurr != 0x0d )
	{
	  pcurr = escan_str( pcurr, app->a_argu );
	  pcurr++;
	  while ((*pcurr >= '0' && *pcurr <= '9') ||
	         (*pcurr >= 'A' && *pcurr <= 'F'))
	  {
	    limit = (limit << 4) + hex_dig(*pcurr);
	    pcurr++;
	  }
	}

	/********** Kludge **********/
	/* make the old inf works with the new one	*/
	if ( ( app->a_type == TOS ) && (app->a_name) && ( !app->a_name[0] ) )
	  app->a_type = TEXT;

	/***************************/

	app->a_limit = limit;
	return( pcurr );
}


/*
*	Initialize the application list by reading in the DESKTOP.APP
*	file, either from memory or from the disk if the shel_get
*	indicates no message is there.
*/

	VOID
inf_scan( buffer )
	BYTE	*buffer;
{
	REG WORD	i;
	REG WINDOW	*pws;
	REG BYTE	*pcurr;
	WORD		envr,j;
	BYTE		temp;
	BYTE		*ptr;
	
	i = 0;			/* for window index	*/
	pcurr = buffer;
	font_save = 0;
				/* put in default keystroke	*/
	for( j = 0; j < MAXMENU; j++ )
	  mentable[j] = mkeys[j];

	while ( *pcurr )		/* 0 is marked as end of buffer	*/
	{
	  if ( *pcurr++ == '#' )
	  {
	    temp = *pcurr;
	    pcurr += 2;
	    switch( temp )
	    {
	      case 'K':
					/* clean up keyboard table	*/
		for( j = 0; j < MAXMENU; j++ )
	  	  mentable[j] = 0;
					/* key board table	*/
					/* read in key equivalent */
	      	for ( j = 0; j < MAXMENU; j++ )
		{
		  if ( *pcurr == '@@' )
		    break;

		  pcurr = scan_2( pcurr, &envr );
		  mentable[j] = envr;
		}		
	
		break;
	
	      case 'Z':			/* auto boot file	*/
	    	pcurr = escan_str( pcurr, autofile );
	    	break;

	      case 'C':
	      case 'X':
	      case 'V':
	      case 'M':
	      case 'T':
	      case 'O':
		pcurr -= 2;
		pcurr = inf_xdesk( pcurr );
		break;

	      case 'W':				/* Window		*/
		if ( i >= MAXWIN ) 
		  break;

		if ( !winpd[i].w_free )
		  break;

		pws = &winpd[i++];		/* horizontal slide bar	*/
		pcurr = scan_2( pcurr, &pws->w_coli );
						/* vertical slide bar	*/
		pcurr = scan_2( pcurr, &pws->w_rowi );

						/* window's x position	*/
		pcurr = scan_2( pcurr, &pws->w_sizes.g_x );
		if ( pws->w_sizes.g_x >= gl_ncols )
		  pws->w_sizes.g_x = gl_ncols - 4;

		pws->w_sizes.g_x *= gl_wchar;

						/* window's y position	*/
		pcurr = scan_2( pcurr, &pws->w_sizes.g_y );
		if ( pws->w_sizes.g_y >= gl_nrows )
		  pws->w_sizes.g_y = gl_nrows - 1;
		
		pws->w_sizes.g_y *= gl_hchar;

						/* window's width	*/
		pcurr = scan_2( pcurr, &pws->w_sizes.g_w );
		if ( pws->w_sizes.g_w > gl_ncols )
		  pws->w_sizes.g_w /= 2;
		pws->w_sizes.g_w *= gl_wchar;
		if ( pws->w_sizes.g_w < ( 7 * gl_wbox ) )
		  pws->w_sizes.g_w = 7 * gl_wbox;
			
						/* window's height	*/
		pcurr = scan_2( pcurr, &pws->w_sizes.g_h );
		if ( pws->w_sizes.g_h >= gl_nrows )
		  pws->w_sizes.g_h /= 2;
		pws->w_sizes.g_h *= gl_hchar;
		if ( pws->w_sizes.g_h < ( 7 * gl_hbox ) )
		  pws->w_sizes.g_h = 7 * gl_hbox;

		do_xyfix( &pws->w_sizes );
	  	rc_copy( (WORD *)&pws->w_sizes, (WORD *)&pws->w_work );
		rc_copy((WORD *) &pws->w_sizes, (WORD *)&pws->w_normsizes);
						/* +++ HMK 5/11/93	     */
						/* window's iconified status */
		pcurr = scan_2( pcurr, &pws->w_iconified );

		if (pws->w_iconified & 0x01) {
						/* icon window's x position */
			pcurr = scan_2( pcurr, &pws->w_sizes.g_x );
			if ( pws->w_sizes.g_x >= gl_ncols )
				  pws->w_sizes.g_x = gl_ncols - 4;

			pws->w_sizes.g_x *= gl_wchar;

						/* icon window's y position */
			pcurr = scan_2( pcurr, &pws->w_sizes.g_y );
			if ( pws->w_sizes.g_y >= gl_nrows )
				  pws->w_sizes.g_y = gl_nrows - 1;
		
			pws->w_sizes.g_y *= gl_hchar;

						/* icon window's width	*/
			pcurr = scan_2( pcurr, &pws->w_sizes.g_w );
			
						/* icon window's height	*/
			pcurr = scan_2( pcurr, &pws->w_sizes.g_h );

		}

		ptr = scasb( pcurr, '@@' );
		*ptr = 0;		/* take out the @@ */	

		if ( !c_path_alloc( pcurr ) )
		{
		  i--;
		  goto i_12;
	        }

		*ptr = '@@';
		pcurr = escan_str( pcurr, pws->w_path );
i_12:		
		*ptr = '@@';
		break;

	      case 'Q':		/* Set window and desk color pattern	*/	
		for ( j = 0; j < 3; j++ )
		{
		  pcurr = scan_2( pcurr, &deskp[j] );
		  pcurr = scan_2( pcurr, &winp[j] );
		}
		  
		tt_color( TRUE );
		break;

	      case 'S':		/* set window font and font size */
		pcurr = scan_2(pcurr, &win_font);
		pcurr = scan_2(pcurr, &win_fsize);
		if (win_font > (d_numfonts - 1))
			win_font = 0;	/* sytem font */
		break;

	      case 'E':				/* environment string	*/
		pcurr = scan_2( pcurr, &envr );
		s_view = ( ( envr & 0x80 ) != 0 );
		s_sort = ( envr & 0x60 ) >> 5;
		cdele_save = ( ( envr & 0x10 ) != 0 );
		ccopy_save = ( ( envr & 0x08 ) != 0 );
		write_save = envr & 0x01;		
		pcurr = scan_2( pcurr, &envr );
		cbit_save = ( envr & 0x10 ) ? 1 : 0;
/*		pref_save = ( envr & 0x0F );*/	/* screen resoultion	*/

		/* This is the extended stuff	*/
			
		if ( *pcurr == 0x0d )		/* if it is the end */
		  break;			/* then skip	    */
	
		pcurr = scan_2( pcurr, &envr );
		font_save = ( envr & 0x0F ) ? 1 : 0;	
		
		pcurr = scan_2( pcurr, &envr );

		if ( envr & 0x01 )
		  s_sort = S_NO;

		s_cache = ( envr & 0x02 ) ? 1 : 0;
		s_stofit = ( envr & 0x04 ) ? 1 : 0;
		s_defdir = ( envr & 0x08 ) ? 1 : 0;
		s_fullpath = ( envr & 0x10 ) ? 1 : 0;
		break;

	      default:				/* must be the last one	*/
		pcurr = inf_parse( pcurr );
		break;

	    }/* switch	*/
	  }/* if	*/
	}/* while	*/
}


/*	
 *	Read in a desktop.inf file and parse the string
 */

	VOID
read_inf( VOID )
{
	REG LONG	size1;
	REG APP		*app;
	WORD		handle;
	UWORD		size;
	BYTE		buffer[20];
	BYTE		*afile;
	WORD		have_acc, have_gtp;

					/* Inquire the shell size */
	size = shel_get( (BYTE*)0, -1 );

	if ( !(afile = malloc( (LONG)(size+1) ) ) )
	{
	  Debug1( "Desktop read_inf no memory\r\n" );
	  return; 
	}
 					
	shel_get( afile, size );	/* Get the buffer	*/	

	if ( afile[0] != '#' )
	{
	  free( afile );		/* free old pointer	*/

	  if ( isdrive() )
	  {
	    m_infpath( buffer );	/* open newdesk.inf	*/
	    if ( ( handle = ( WORD )Fopen( buffer, 0 ) ) < 0 )
	    {				/* try desktop.inf	*/
	      strcpy( infdata, &buffer[3] );
	      if ( ( handle = ( WORD )Fopen( buffer, 0 ) ) < 0 )
	        goto re_1;
	    }

	    Fsetdta( &dtabuf );		/* set dta buffer	*/
	    Fsfirst( buffer, 0x31 );	/* search the file	*/
					/* get file size	*/
	    size1 = dtabuf.dirfile.d_size;
	    if ( !(afile = malloc( size1+1L )))
	    {
	      Debug1( "Desktop has no inf memory\r\n" );
	      return;	
	    }

	    Fread( handle, size, afile );
	    Fclose( handle );

	  }	/* No drive */
	  else
	  {
re_1:	    afile = malloc( (LONG)INFSIZE );
	    bfill( INFSIZE, 0, afile );
	    size1 = rom_ram( 3, (LONG)afile );
	  }
	}
	else
	  size1 = (LONG)size;

	afile[size1] = 0;

	shel_put( afile, (UWORD)(size1) );	/* copy to the aes buffer	*/

	/* init default desktop and window color and pattern values	*/

	deskp[0] = 0x41;	/* 4 = dithered, 1 = black */
	deskp[1] = 0x73;	/* 7 = solid, 3 = green */
	deskp[2] = 0x7D;	/* 7 = solid, D = light cyan */
	winp[0] = 0x70;
	winp[1] = 0x70;
	winp[2] = 0x70;

	tt_color( TRUE );		/* stuff color into system var	*/

	inf_scan( afile );		/* analyze the inf file		*/
	free( afile );

	app = applist;

	have_gtp = have_acc = 0;

	while( app )
	{
	  if ( app->a_type == PTP )
	  {
	    if ( strcmp( app->a_name, "*.GTP" ) )
	      have_gtp = 1;
	  }
	  else if ( app->a_type == ACCESSORY )
	  {
	    if ( strcmp( app->a_name,"*.ACC" ) )
	      have_acc = 1;
	  }
	  app = ( APP *)app->a_next;
	}

	if ( !have_gtp && (app = app_alloc( )) )
	{
	  app->a_type = PTP;
	  app->a_key = 0;
	  app->a_icon = 3;
	  app->a_dicon = 4;
	  app->a_limit = 0;
	  lp_fill( "*.GTP", &app->a_name ); 
	}

	if ( !have_acc && (app = app_alloc( )) )
	{
	  app->a_type = ACCESSORY;
	  app->a_key = 0;
	  app->a_icon = 3;
	  app->a_dicon = 4;
	  app->a_limit = 0;
	  lp_fill( "*.ACC", &app->a_name ); 
	}
}


/*
*	Convert a single hex ASCII digit to a number
*/

	WORD
hex_dig(achar)
	REG BYTE		achar;
{
	if ( (achar >= '0') && (achar <= '9') )
	  return(achar - '0');
	
	if ( (achar >= 'A') && (achar <= 'F') )
	  return(achar - 'A' + 10);

	return(0);
}
	

	BYTE
*save_win( win, pcurr )
	REG WINDOW	*win;
	REG BYTE	*pcurr;
{
	BYTE	*ptmp;

	*pcurr++ = '#';
	*pcurr++ = 'W';
	*pcurr++ = ' ';

	if (win->w_iconified) {				/* +++ 5/11/93 HMK */         
		pcurr = save_2( pcurr, win->w_coli );	/* horizontal slide bar  */
		pcurr = save_2( pcurr, win->w_rowi );
						/* window coords & size */
		pcurr = save_2( pcurr, win->w_normsizes.g_x / gl_wchar );
		pcurr = save_2( pcurr, win->w_normsizes.g_y / gl_hchar );
		pcurr = save_2( pcurr, win->w_normsizes.g_w / gl_wchar );
		pcurr = save_2( pcurr, win->w_normsizes.g_h / gl_hchar );
						/* window status (iconified) */
		pcurr = save_2( pcurr, win->w_iconified);
						/* icon window coords & size */
		pcurr = save_2( pcurr, win->w_sizes.g_x / gl_wchar );
		pcurr = save_2( pcurr, win->w_sizes.g_y / gl_hchar );
		pcurr = save_2( pcurr, win->w_sizes.g_w ); /* max w == 255!! */
		pcurr = save_2( pcurr, win->w_sizes.g_h ); /* max h == 255!! */
	} else {
		pcurr = save_2( pcurr, win->w_coli );	/* horizontal slide bar  */
		pcurr = save_2( pcurr, win->w_rowi );
		pcurr = save_2( pcurr, win->w_sizes.g_x / gl_wchar );
		pcurr = save_2( pcurr, win->w_sizes.g_y / gl_hchar );
		pcurr = save_2( pcurr, win->w_sizes.g_w / gl_wchar );
		pcurr = save_2( pcurr, win->w_sizes.g_h / gl_hchar );
		pcurr = save_2( pcurr, win->w_iconified); /* w_iconified == 0 !!! */
	}

	if ( (win->w_id != -1) || (win->w_saveid != -1) )
	{
	  ptmp = win->w_path;
	  while( *ptmp )
	    *pcurr++ = *ptmp++;
	}

	*pcurr++ = '@@';
	*pcurr++ = 0x0d;
	*pcurr++ = 0x0a;
	
	return( pcurr );
}


/*	Save a desktop.inf file		*/

	WORD
save_inf( todisk, path )
	WORD		todisk;
	BYTE		*path;
{
	REG APP		*start;	
	REG WINDOW	*win;
	REG BYTE	*pcurr;
	REG WORD	envr,i;
	WORD		j,w,len,h,handle;
	BYTE		*buf,*afile;
	APP		*app;
	OBJECT		*obj;
	LONG		size;
	BYTE		buf1[2];

	afile = (BYTE *)0L;
	if ( size = ( LONG )malloc( 0x5000L ) )	/* get 20K memory	*/
	{
	  buf = pcurr = ( BYTE *)size;
/*
	  if ( size < INFSIZE )
	    goto if_1;
	
	  buf = pcurr = malloc( size );
*/	  
	}
	else
	{
if_1:	  
	  do1_alert( FCNOMEM );
	  return( FALSE );
	}
	
	desk_mice( HOURGLASS );
	
	shel_get( buf, SAVE_ATARI ); 	/* get the control panel stuff	*/

	pcurr += SAVE_ATARI;

	if ( autofile[0] )
	{
	  *pcurr++ = '#';			
 	  *pcurr++ = 'Z';
	  *pcurr++ = ' ';
	  pcurr = save_str( pcurr, autofile );
	  *pcurr++ = 0x0d;
	  *pcurr++ = 0x0a;
	}
						/* save keyboard	*/
	*pcurr++ = '#';
	*pcurr++ = 'K';
	*pcurr++ = ' ';

	for ( i = 0; i < MAXMENU; i++ )
	  pcurr = save_2( pcurr, (UWORD)mentable[i] );

	*pcurr++ = '@@';
	*pcurr++ = 0x0d;
	*pcurr++ = 0x0a;

						/* save evironment	*/
	*pcurr++ = '#';
	*pcurr++ = 'E';
	*pcurr++ = ' ';
	envr = 0x0;
	envr |= write_save;
	envr |= s_view ? 0x80 : 0x00;
	envr |= ( s_sort << 5 ) & 0x60;
	envr |= cdele_save ? 0x10 : 0x00;
	envr |= ccopy_save ? 0x08 : 0x00;
	pcurr = save_2( pcurr, envr );

	envr = 0x0;			/* set resolution prefence	*/
	envr |= pref_save;
	envr |= ( cbit_save << 4 );	/* High order bit 		*/
	pcurr = save_2( pcurr, envr );

	pcurr = save_2( pcurr, font_save );

	envr = 0x0;
	if ( s_sort == S_NO )
	  envr |= 0x01;

	if ( s_cache )
	  envr |= 0x02;

	if ( s_stofit )
	  envr |= 0x04;

	if ( s_defdir )
	  envr |= 0x08;

	if ( s_fullpath )
	  envr |= 0x10;

	pcurr = save_2( pcurr, envr );	/* save the settings	*/

	/* 7/17/92	*/

	pcurr = save_2( pcurr, (d_rezword >> 8));
	pcurr = save_2( pcurr, (d_rezword & 0x00FF) );
	pcurr = save_2( pcurr, 0 );
	pcurr = save_2( pcurr, 0 );
	pcurr = save_2( pcurr, 0 );
	pcurr = save_2( pcurr, 0 );

	*pcurr++ = 0x0d;
	*pcurr++ = 0x0a;
	
	/* save the window and desk spec	*/

	*pcurr++ = '#';
	*pcurr++ = 'Q';
	*pcurr++ = ' ';

	tt_color( FALSE );

	for ( i = 0; i < 3; i++ )
	{
	  pcurr = save_2( pcurr, deskp[i] );/* save the desktop backgrounds */
	  pcurr = save_2( pcurr, winp[i] );
	}

	*pcurr++ = 0x0d;
	*pcurr++ = 0x0a;

	/* save window font & point size */

	*pcurr++ = '#';
	*pcurr++ = 'S';
	*pcurr++ = ' ';
	pcurr = save_2(pcurr, win_font);
	pcurr = save_2(pcurr, win_fsize);

	*pcurr++ = 0x0d;
	*pcurr++ = 0x0a;


	/********* save the opened window first	************/
	
	win = w_agfirst();
		
	i = -1;

	while( win )
	{
	  i++;
	  warray[i] = win;
	  win = w_agnext();
	}
					/* save windows		*/
	for ( j = i; j >= 0; j-- )
	  pcurr = save_win( warray[j], pcurr );

	/*******************************************************/

	win = winhead;
		
	while( win )
	{
	  if ( (win->w_id == -1) && (win->w_saveid == -1))
	    pcurr = save_win( win, pcurr );

	  win = ( WINDOW *)win->w_next;
	}


	start = applist;		/* search the last one	*/

	while( start )
	{
	  if ( !start->a_next )
	    break;

	  start = ( APP *)start->a_next;
	}

	app = start;

	while( app )
	{
	  *pcurr++ = '#';

	  switch( app->a_type )
	  {
	    case ACCESSORY:
		*pcurr++ = 'A';
		break;
	    case PTP:
		*pcurr++ = 'Y';
		break;
	    case TTP:
		*pcurr++ = 'P';
	 	break;
	    case PRG:
		*pcurr++ = 'G';
		break;
	    case TOS:
		*pcurr++ = 'F';
		break;
	    case FOLDER:
		*pcurr++ = 'D';
		break;
	    case TEXT:
		*pcurr++ = 'N';
		break;
	    case ICONS:
		*pcurr++ = 'I';
		break;
	  }

	  *pcurr++ = ' ';

	  pcurr = save_2(pcurr, app->a_icon);
	  pcurr = save_2(pcurr, app->a_dicon);

	  *pcurr++ = uhex_dig( app->a_pref );
	  pcurr = save_2( pcurr, app->a_key );

	  pcurr = save_str( pcurr, app->a_name );
	  pcurr = save_str( pcurr, app->a_doc );
	  pcurr = save_str( pcurr, app->a_argu );
	  if (app->a_limit)
	  {
	    ULONG limit = app->a_limit;
	    for (i = 0; i < 8; i++) {
	      *pcurr++ = uhex_dig((limit & 0xF0000000L) >> 28);
	      limit = limit << 4;
	    }
	  }
	  *pcurr++ = 0x0d;
	  *pcurr++ = 0x0a;

	  if ( app == applist )
	    break;

	  start = applist;

	  while( start )
	  {
	    if ( start->a_next == ( BYTE *)app )
	    {
	      app = start;
	      break;
	    }
	    start = ( APP *)start->a_next;
	  }
	}

	/* save the desktop disk drive	*/

	obj = background;

	w = r_dicon.g_w;
	h = r_dicon.g_h;

	for ( i = 1; i <= maxicon; i++ ) 
	{
	  if ( obj[i].ob_flags & HIDETREE )
	    continue;

	   *pcurr++ = '#';

	   switch( backid[i].i_type )
	   {
	     case PRINTER:
	       *pcurr++ = 'O';
	       break;		
	     case DISK:
	       if ( (BYTE)(backid[i].i_cicon.monoblk.ib_char & 0x00FF) == 'c' )
	         *pcurr++ = 'C';
	       else
	         *pcurr++ = 'M';
	       break;
	     case XFILE:		/* file on desktop	*/
	       *pcurr++ = 'X';
	       break;
	     case XDIR:			/* DIR on desktop	*/
	       *pcurr++ = 'V';
	       break;
	     case TRASHCAN:
	       *pcurr++ = 'T';
	       break;
	   }

	   *pcurr++ = ' ';
	   
	   /* save the position		*/

	   pcurr = save_2( pcurr, obj[i].ob_x / w );
	   pcurr = save_2( pcurr, obj[i].ob_y / h );
	   pcurr = save_2( pcurr, backid[i].i_icon );
	   pcurr = save_2( pcurr, 0xFFFF );
	   *pcurr = (BYTE)((CICONBLK*)(obj[i].ob_spec))->monoblk.ib_char;
	   if ( !*pcurr )
	     *pcurr = ' ';

	   pcurr++;

	   *pcurr++ = ' ';

	   if ( backid[i].i_path )
  	     pcurr = save_str( pcurr, backid[i].i_path );

	   pcurr = save_str( pcurr, (BYTE *)((CICONBLK*)(obj[i].ob_spec))->monoblk.ib_ptext );

	   if ( !backid[i].i_path )
  	     pcurr = save_str( pcurr, Nostr );

/*	   pcurr = save_str( pcurr, Nostr );	*/
	   *pcurr++ = 0x0d;
	   *pcurr++ = 0x0a;	
	}

	*pcurr = 0;		/* end of string mark */

	len = strlen( buf );

	afile = malloc( (LONG)((UWORD)len) );
	bfill( len, 0, afile );		/* clean up buffer	*/
	shel_put( buf, len );		/* copy to aes buffer	*/
	shel_get( afile, len );

	if ( todisk )
	{
/*	  m_infpath( infname );	*/	/* always write newdesk.inf	*/
if_3:					/* create a file, read & write	*/
	  handle = ( WORD )Fcreate( path, 0x0 );

	  if ( handle < 0 )
	  {
	    if ( fill_string( path, CNTCRTFL ) == 2  )
	      goto if_3;	/* repeat	*/
	    else
	      goto if_2;
	  }

	  size = Fwrite( handle, (LONG)((UWORD)len), afile );
	  Fclose( handle );
						/* check for full disk */
	  if ( size < (LONG)len )
	  {
	    buf1[0] = path[0];
	    buf1[1] = 0;
	    fill_string( buf1, STDISKFU );
	    Fdelete( path );
	  }	            

/*	  up_allwin( infname, FALSE ); 	*/ /* rebuild any window on the INF drive */
				
					/* update the buffer	*/
	  if ( strcmp( path, inf_path ) )
	  {
	    q_change = FALSE;
	    strcpy( afile, q_addr );
	  }

	}/* todisk */
	
if_2:
	free( buf );
	if (afile) free( afile );

	if ( todisk )
	  up_allwin( path, FALSE ); /* rebuild any window on the INF drive */

	desk_mice( ARROW );
	return( TRUE );
}


/*	Position the desktop icon	*/

	VOID
app_posicon( colx, coly, px, py )
	WORD		colx, coly;
	REG WORD	*px, *py;
{
	REG WORD	x, y, w, h;

	w = r_dicon.g_w;
	h = r_dicon.g_h;
	x = colx * w + full.g_x;
	y = coly * h + full.g_y;
	app_mtoi( x, y, px, py );
}


/*	Transform mouse position into icon position	*/

	VOID
app_mtoi( newx, newy, px, py )
	WORD		newx, newy;
	REG WORD	*px, *py;
{
	REG WORD	x, y, w, h;
	WORD		xm, ym;
	WORD		maxx,maxy;
	
	w = r_dicon.g_w;
	h = r_dicon.g_h;
				/* maximum x coordinate	*/
	maxx = ( full.g_w - dicon.g_w ) / w;

	x = newx / w;
	xm = newx % w;
	if ( xm > ( w / 2 ) )
	  x += 1;

	if ( x > maxx )
	  x = maxx;

	*px = x * w;		/* new x coordinate	*/

	if ( newy < full.g_y )
	  newy = full.g_y;

	maxy = ( full.g_h - dicon.g_h ) / h;

	newy -= full.g_y;

	y = newy / h;
	ym = newy % h;
	if ( ym > ( h / 2 ) )
	  y += 1;

	if ( y > maxy )
	  y = maxy;

	*py = y * h;
}


/*	Put or get color and pattern	*/

	VOID
tt_color( put )
	WORD	put;
{
	WORD	j;

	j = 2;		/* assume more than 4 colors	*/

	if ( d_maxcolor == 2 )
	  j = 0;

	if ( d_maxcolor == 4 )
	  j = 1;

	if ( put )
	{
	  windspec = (UWORD)winp[j];
	  if (background[0].ob_type != G_USERDEF)
	    background[0].ob_spec = (UWORD)deskp[j];
	}
	else
	{
	  if (background[0].ob_type != G_USERDEF)
	    deskp[j] = (UWORD)background[0].ob_spec;
	  winp[j] = (UWORD)windspec;
	}
}
@


1.9
log
@Merged in Hans-Martin and Cary's changes
@
text
@@


1.8
log
@Another check in to save work.
@
text
@d12 1
d38 5
d505 7
d726 1
a726 1
		pcurr = save_2( pcurr, win->w_iconified); /* == 0 */
d729 1
a729 1
	if ( win->w_id != -1 )
d873 12
d887 1
a887 1
	win = w_gfirst();
d895 1
a895 1
	  win = w_gnext();
d907 1
a907 1
	  if ( win->w_id == -1 )
@


1.7
log
@Added iconification,color icons in alerts,etc.
@
text
@d1174 2
a1175 1
	  background[0].ob_spec = (UWORD)deskp[j];
d1179 2
a1180 1
	  deskp[j] = (UWORD)background[0].ob_spec;
@


1.6
log
@Merged Cary's and Hans-Martin's changes
@
text
@d11 1
d253 2
d314 1
d316 1
d318 8
d333 2
d446 25
d472 1
a472 1
		pcurr = scan_2( pcurr, &envr );
d552 2
d623 2
d630 1
a630 1
	      return;
d632 5
a636 1

d640 1
a640 1
	if ( app = app_alloc( ) )
d646 1
d649 10
d691 24
a714 7
	pcurr = save_2( pcurr, win->w_coli );	/* horizontal slide bar  */
	pcurr = save_2( pcurr, win->w_rowi );
	pcurr = save_2( pcurr, win->w_sizes.g_x / gl_wchar );
	pcurr = save_2( pcurr, win->w_sizes.g_y / gl_hchar );
	pcurr = save_2( pcurr, win->w_sizes.g_w / gl_wchar );
	pcurr = save_2( pcurr, win->w_sizes.g_h / gl_hchar );
	pcurr = save_2( pcurr, 0 );
d944 8
@


1.5
log
@Incorporated more single/multitasking changes.
@
text
@d316 1
a316 1
	if ( ( app->a_type == TOS ) && ( !app->a_name[0] ) )
@


1.4
log
@Merged HMK's loadable resource stuff
@
text
@@


1.3
log
@Lattice port
@
text
@@


1.2
log
@REAL MultiTOS 1.01
@
text
@d10 1
d18 11
a28 22
#include <compiler.h>
#include <machine.h>
#include <deskobde.h>
#include <deskdefi.h>
#include <deskwin.h>
#include <gemdefs.h>
#include <deskusa.h>
#include <osbind.h>
#include <extern.h>

EXTERN	UWORD	rom_ram();
EXTERN	BYTE	*malloc();
EXTERN	VOID	free();
EXTERN  BYTE	*scasb();
EXTERN	BYTE	*r_slash();
EXTERN	BYTE	*lp_fill();
EXTERN	APP	*app_alloc();
EXTERN	WORD	isdrive();
EXTERN	WORD	cart_init();
EXTERN	BYTE	*strcpy();
EXTERN	WINDOW	*w_gfirst();
EXTERN	WINDOW	*w_gnext();
d158 1
d215 2
a216 1
	iblk->monoblk.ib_char[1] = ( *pcurr == ' ' ) ? 0 : *pcurr;
d223 1
a223 1
	  pcurr = escan_str( pcurr, iblk->monoblk.ib_ptext );
d227 1
a227 1
	      save_ext( backid[id].i_path, iblk->monoblk.ib_ptext );
d229 1
a229 1
	      save_mid( backid[id].i_path, iblk->monoblk.ib_ptext );
d234 1
a234 1
	  pcurr = escan_str( pcurr, iblk->monoblk.ib_ptext );
d334 1
a334 1
	REG WORD	i, tmp;
a336 2
	APP		*app;
	BYTE		*ptmp;
a337 1
	LONG		stmp;
d400 3
a402 3
		pcurr = scan_2( pcurr, &pws->w_sizes.x );
		if ( pws->w_sizes.x >= gl_ncols )
		  pws->w_sizes.x = gl_ncols - 4;
d404 1
a404 1
		pws->w_sizes.x *= gl_wchar;
d407 3
a409 3
		pcurr = scan_2( pcurr, &pws->w_sizes.y );
		if ( pws->w_sizes.y >= gl_nrows )
		  pws->w_sizes.y = gl_nrows - 1;
d411 1
a411 1
		pws->w_sizes.y *= gl_hchar;
d414 6
a419 6
		pcurr = scan_2( pcurr, &pws->w_sizes.w );
		if ( pws->w_sizes.w > gl_ncols )
		  pws->w_sizes.w /= 2;
		pws->w_sizes.w *= gl_wchar;
		if ( pws->w_sizes.w < ( 7 * gl_wbox ) )
		  pws->w_sizes.w = 7 * gl_wbox;
d422 6
a427 6
		pcurr = scan_2( pcurr, &pws->w_sizes.h );
		if ( pws->w_sizes.h >= gl_nrows )
		  pws->w_sizes.h /= 2;
		pws->w_sizes.h *= gl_hchar;
		if ( pws->w_sizes.h < ( 7 * gl_hbox ) )
		  pws->w_sizes.h = 7 * gl_hbox;
d430 1
a430 1
	  	rc_copy( &pws->w_sizes, &pws->w_work );
d504 1
a504 1
read_inf( )
d530 1
a530 1
	    if ( ( handle = Fopen( buffer, 0 ) ) < 0 )
d533 1
a533 1
	      if ( ( handle = Fopen( buffer, 0 ) ) < 0 )
d541 1
a541 1
	    if ( !(afile = malloc( size1+1 )))
d555 1
a555 1
	    size1 = rom_ram( 3, afile );
d559 1
a559 1
	  size1 = size;
d589 1
a589 1
	  app = app->a_next;
d634 4
a637 4
	pcurr = save_2( pcurr, win->w_sizes.x / gl_wchar );
	pcurr = save_2( pcurr, win->w_sizes.y / gl_hchar );
	pcurr = save_2( pcurr, win->w_sizes.w / gl_wchar );
	pcurr = save_2( pcurr, win->w_sizes.h / gl_hchar );
d673 2
a674 2
	afile = 0;
	if ( size = malloc( 0x5000L ) )	/* get 20K memory	*/
d676 1
a676 1
	  buf = pcurr = size;
d809 1
a809 1
	  win = win->w_next;
d820 1
a820 1
	  start = start->a_next;
d878 1
a878 1
	    if ( start->a_next == app )
d883 1
a883 1
	    start = start->a_next;
d891 2
a892 2
	w = r_dicon.w;
	h = r_dicon.h;
d907 1
a907 1
	       if ( backid[i].i_cicon.monoblk.ib_char[1] == 'c' )
d931 1
a931 1
	   *pcurr = (CICONBLK*)(obj[i].ob_spec)->monoblk.ib_char[1];
d942 1
a942 1
	   pcurr = save_str( pcurr, (CICONBLK*)(obj[i].ob_spec)->monoblk.ib_ptext );
d955 1
a955 1
	if (afile) free(afile);
d965 1
a965 1
	  handle = Fcreate( path, 0x0 );
d982 1
a982 1
	    fill_string( buf1, STDISKFULL );
d999 1
a999 1
	if (afile) free(afile);
d1018 4
a1021 4
	w = r_dicon.w;
	h = r_dicon.h;
	x = colx * w + full.x;
	y = coly * h + full.y;
d1037 2
a1038 2
	w = r_dicon.w;
	h = r_dicon.h;
d1040 1
a1040 1
	maxx = ( full.w - dicon.w ) / w;
d1052 2
a1053 2
	if ( newy < full.y )
	  newy = full.y;
d1055 1
a1055 1
	maxy = ( full.h - dicon.h ) / h;
d1057 1
a1057 1
	newy -= full.y;
@


1.1
log
@1 meg floppy MultiTOS
@
text
@@


1.0
log
@MultiTOS version 1.0
@
text
@d29 1
d536 1
a536 1
	  Mfree( afile );		/* free old pointer	*/
d588 1
a588 1
	Mfree( afile );
d684 1
d966 1
a966 1
	Mfree( afile );	
d1009 2
a1010 1
	Mfree( buf );
@
