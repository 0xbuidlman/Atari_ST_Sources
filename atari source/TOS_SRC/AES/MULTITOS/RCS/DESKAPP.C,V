head	1.10;
access;
symbols;
locks
	ersmith:1.10;
comment	@ * @;


1.10
date	93.06.15.22.53.36;	author ersmith;	state Exp;
branches;
next	1.9;

1.9
date	93.06.14.23.48.02;	author ersmith;	state Exp;
branches;
next	1.8;

1.8
date	93.06.09.23.47.00;	author ersmith;	state Exp;
branches;
next	1.7;

1.7
date	93.05.12.01.40.22;	author ersmith;	state Exp;
branches;
next	1.6;

1.6
date	93.04.27.23.00.14;	author ersmith;	state Exp;
branches;
next	1.5;

1.5
date	93.04.14.22.19.54;	author ersmith;	state Exp;
branches;
next	1.4;

1.4
date	93.03.12.19.51.12;	author ersmith;	state Exp;
branches;
next	1.3;

1.3
date	93.03.10.20.12.42;	author ersmith;	state Exp;
branches;
next	1.2;

1.2
date	93.03.08.20.07.02;	author ersmith;	state Exp;
branches;
next	1.1;

1.1
date	93.02.24.23.52.46;	author ersmith;	state Exp;
branches;
next	1.0;

1.0
date	93.02.03.21.26.46;	author ersmith;	state Exp;
branches;
next	;


desc
@Desktop application management
@


1.10
log
@Minor resource editing, elclean ups, etc.
@
text
@/*	DESKAPP.C		3/18/89 - 9/18/89	Derek Mui	*/

/************************************************************************/
/*	New Desktop for Atari ST/TT Computer				*/
/*	Atari Corp							*/
/*	Copyright 1989,1990 	All Rights Reserved			*/
/************************************************************************/

#include "portab.h"
#include "obdefs.h"
#include "deskdefi.h"
#include "deskwin.h"
/*#include "gemlib.h"*/
#include "deskusa.h"
#include "osbind.h"
#include "extern.h"
#include "pdesk.h"
#include "pmisc.h"

EXTERN	BYTE	*scasb();
EXTERN	WORD	font_save;
EXTERN	BYTE	*g_name();



/*	Find the application's icon type	*/

APP *
app_icon( REG BYTE *name, WORD type, WORD *icon )
/* looking for same type	*/
/* icon number			*/
{
	REG APP		*app;

	app = applist;
	*icon = 4;		/* default icon index		*/

	while( app )
	{
	  if ( type != -1 )	/* match the type 	*/
	  {
	    if ( app->a_type == type )
	    {
	       if ( wildcmp( app->a_doc, name ) )
	       {
	      	  *icon = app->a_dicon;
	          break;
	       }
	    }
	  }
	  else
	  {
	    if ( app->a_type != FOLDER )	/* skip this */
	    {
	      if ( x_wildcmp( app->a_name, name ) )
	      {
	      	*icon = app->a_icon;
	        break;
	      }

	      if ( ( app->a_type == ICONS ) || ( app->a_type == TEXT ) )
	      {
	        if ( x_wildcmp( app->a_doc, name ) )
		{
		  *icon = app->a_dicon;		  
	          break;
		}
	      }
	    }
	  }
	  app = (APP *)app->a_next;			/* JTT - (APP *) */
	}/* while     */

	return( app );
} 


/*	Free an application node	*/
VOID	
app_free( REG APP *app )
{
	REG APP	*list;

	if ( app == applist )
	  applist = (APP *)app->a_next;
	else
	{
	  list = applist;

	  while( list )
	  {
	    if ( (APP *)list->a_next == app )
	    {
	      list->a_next = app->a_next;	
	      break;
	    }
	
	    list = (APP *)list->a_next;
	  }
	}

	lp_collect();
	(APP *)app->a_next = appfree;
	appfree = app;
}


/*	Allocation an anode	*/

APP *
app_alloc( VOID )
{
	REG APP	*list;

again:
	list = (APP*)0;

	if ( appfree )
	{
	  list = appfree;
	  appfree = (APP *)appfree->a_next;
	  (APP *)list->a_next = applist;
	  applist = list;
	  list->a_doc[0] = 0;
	  list->a_argu[0] = 0;
	  list->a_key = 0;
	  list->a_pref = 0;
	  list->a_limit = 0;
	  list->a_name = Nostr;		/* Point to no string	*/
	}
	else
	{
	  if ( apbuf_init() )		/* allocate buffer	*/
	    goto again;
	} 

	return( list );
}



/*	Find the actual application type	*/

APP *
app_xtype( REG BYTE *name, WORD *install )
/* application installed	*/
{
	REG APP		*app;
	APP		*markapp;

	app = applist;
	markapp = (APP*) 0;
 
	while( app )
	{
	  if ( ( app->a_type != FOLDER ) && ( app->a_type != ICONS ) )
	  {
	    if ( x_wildcmp( app->a_name, name ) )
	    {
	      if ( markapp )
		goto x_p1;

	      *install = FALSE;
	      return( app );
	    }
	    
	    if ( !strcmp( app->a_doc, noext ) )
	    {
	      if ( x_wildcmp( app->a_doc, name ) )
	      {
	        *install = TRUE;
	        if ( app->a_name[0] )
		  return( app );
		
	        if ( !markapp )
		  markapp = app;
	      }
	    }
	  }
x_p1:
	  app = (APP *)app->a_next;

	}/* while     */

	return( markapp );
} 


WORD
x_wildcmp( BYTE *source, BYTE *dest )
{
	if ( *source )
	{
	  if ( *scasb( source, '*' ) )
	    return( wildcmp( source, g_name( dest ) ) );
	  else
	    return( strcmp( source, dest ) );	
	}
	return( FALSE );
}

WORD	ftab[] = { 0,   F1,  F2,  F3,  F4,  F5,  F6,  F7,  F8,  F9, F10,
		   F11, F12, F13, F14, F15, F16, F17, F18, F19, F20 };

/*	Find the key that matches the application	*/
	
APP *
app_key( WORD key )
{
	REG APP	*app;

	app = applist;
	
	while( app )
	{
	   if ( ftab[app->a_key] == key )
	      return( app );

	  app = (APP *)app->a_next;
	}

	return( (APP*)0 );
}	
@


1.9
log
@Merged in Hans-Martin and Cary's changes
@
text
@@


1.8
log
@Another check in to save work.
@
text
@@


1.7
log
@Added iconification,color icons in alerts,etc.
@
text
@@


1.6
log
@Merged Cary's and Hans-Martin's changes
@
text
@d128 1
@


1.5
log
@Incorporated more single/multitasking changes.
@
text
@@


1.4
log
@Merged HMK's loadable resource stuff
@
text
@@


1.3
log
@Lattice port
@
text
@@


1.2
log
@REAL MultiTOS 1.01
@
text
@d9 10
a18 8
#include <portab.h>
#include <deskobde.h>
#include <deskdefi.h>
#include <deskwin.h>
#include <gemdefs.h>
#include <deskusa.h>
#include <osbind.h>
#include <extern.h>
d28 4
a31 5
	APP
*app_icon( name, type, icon )
	REG BYTE	*name;
	WORD	type;		/* looking for same type	*/
	WORD	*icon;		/* icon number			*/
d71 1
a71 1
	  app = app->a_next;
d79 2
a80 4

	VOID	
app_free( app )
	REG APP	*app;
d85 1
a85 1
	  applist = app->a_next;
d92 1
a92 1
	    if ( list->a_next == app )
d98 1
a98 1
	    list = list->a_next;
d103 1
a103 1
	app->a_next = appfree;
d110 2
a111 2
	APP
*app_alloc()
d121 2
a122 2
	  appfree = appfree->a_next;
	  list->a_next = applist;
d143 3
a145 4
	APP
*app_xtype( name, install )
	REG BYTE	*name;
	WORD	*install;	/* application installed	*/
d180 1
a180 1
	  app = app->a_next;
d188 2
a189 4
	WORD
x_wildcmp( source, dest )
	BYTE	*source;
	BYTE	*dest;
d206 2
a207 3
	APP
*app_key( key )
	WORD	key;
d218 1
a218 1
	  app = app->a_next;
@


1.1
log
@1 meg floppy MultiTOS
@
text
@@


1.0
log
@MultiTOS version 1.0
@
text
@@
