
                                        acsi.s               Page 1       12:13:14 am 18-Feb-1993     Madmac 1.07  (Atari ST)


    1                                   ;+
    2                                   ; Edit History
    3                                   ;
    4                                   ; May-22-89	ml.	Started this with AHDI 3.00.
    5                                   ; Aug-21-89	ml.	Added format code.  It's seperated because it waits
    6                                   ;			forever for command completion.
    7                                   ; Sep-08-89	ml.	Added a 1 microsec delay (rstdelay()) after each 
    8                                   ;			access to the DMA chip which may reset the chip.
    9                                   ; Sep-13-89	ml.	If need to execute a command more than once to
   10                                   ;			get all bytes into RAM, use the original allocation
   11                                   ;			length for subsequent calls.
   12                                   ; Oct-06-89	ml.	Added start/stop unit code.  It's seperated because
   13                                   ;			it needs longer timeouts.
   14                                   ; Nov-08-89	ml.	Added a delay in _rcvacsi() when looping to do more
   15                                   ;			than one _sblkacsi().
   16                                   ; Nov-27-89	ml.	Added .even after declaring control.
   17                                   ; Dec-05-89	ml.	Flushing of D cache before reading status byte.
   18                                   ; Apr-09-90	ml.	Added a "read" from WDL to actually "set" the bit
   19                                   ;			for the new MMU chip.  It's a bug in the chip.  
   20                                   ;			Temporary only.
   21                                   ; Apr-20-90	ml.	Made the "read" added on Apr-09-90 conditional
   22                                   ;			assembly.  RDWDL flag defined in defs.h.
   23                                   ; Sep-24-91	ml.	Added the _slwacsi flag to indicate whether we
   24                                   ;			are talking to a slow ACSI device.  If so, extra
   25                                   ;			delay is necessary to wait for the device to
   26                                   ;			response.
   27                                   ; Oct-07-91	ml.	Instead of using "lsr" to check if transfer is
   28                                   ;			a multiple of 16 in _rcvacsi(), use "andi".
   29                                   ; Feb-13-92	ml.	Modified setacnt() so that if transfer length in
   30                                   ;			bytes is greater than 512 but not a multiple of 512, 
   31                                   ;			add 1 to the count in order to get all the data.
   32                                   ;-
   33                                   
   34                                   
   35                                   .include	"defs.h"
    1                                   ;+
    2                                   ; Conditional assembly
    3                                   ;-
    4           =00000001               DRIVER	equ	1			; 0: not compiling for AHDI.PRG
    5           =00000000               DEBUG	equ	0			; 0: don't include debugging code
    6           =00000000               RDWDL	equ	0			; 0: don't need extra read from WDL
    7                                   
    8           =00000006               SCSIID	equ	6			; our (host) SCSI ID
    9                                   
   10                                   
   11                                   ;+
   12                                   ; Restraints 
   13                                   ;-
   14           =0000000E               MAXLOG		equ	14		; max # of log units w/o drv A & B
   15           =00000008               MAXACSI		equ	8		; maximum number of ACSI devices
   16           =00000008               MAXSCSI		equ	8		; maximum number of SCSI devices
   17           =00000001               MAXIDE		equ	1		; maximum number of IDE devices
   18           =00000007               ACSIUNT		equ	7		; highest ACSI unit number
   19           =0000000F               SCSIUNT		equ	15		; highest SCSI unit number
   20           =00000010               IDEUNT		equ	16		; highest IDE unit number
   21           =000000FE               MAXACSECTS	equ	254		; max # of sectors/ACSI gulp


                                        defs.h               Page 2       12:13:14 am 18-Feb-1993     Madmac 1.07  (Atari ST)


   22           =00003FFF               MAXSPSECTS	equ	16383		; max # of sectors/Sparrow SCSI gulp
   23                                   					; Set from 16384 LT
   24           =0000FFFE               MAXSCSECTS	equ	65534		; max # of sectors/SCSI gulp
   25           =00000100               MAXIDESECTS	equ	256		; max # of sectors/IDE gulp
   26                                   
   27                                   
   28                                   ;+
   29                                   ; Machine type as defined in the _MCH cookie
   30                                   ;-
   31           =5F4D4348               _MCH	equ $5f4d4348		; _MCH
   32           =00000000               ST		equ	0
   33           =00010000               STE		equ	$00010000
   34           =00010008               STBOOK		equ	$00010008
   35           =00010010               MSTE		equ	$00010010
   36           =00020000               TT		equ	$00020000
   37           =00030000               SPARROW		equ	$00030000	; Changed to reflect ROMs LT
   38                                   
   39                                   ;+
   40                                   ; Offsets to ...
   41                                   ;-
   42           =000001BE               DOSPM		equ	$1be		; MSDOS boot sect's partition map
   43           =000001FE               DOSSIG		equ	$1fe		; MSDOS boot sect's signature
   44           =000001C2               HDSIZ		equ	$1c2		; offset to GEMDOS root sect's 
   45                                   
   46                                   
   47                                   ;+
   48                                   ; Constants and Variables
   49                                   ;-
   50           =000055AA               SIG		equ	$55aa		; signature for valid MSDOS boot sects
   51           =00000003               NRETRIES	equ	3		; #retries-1
   52           =00000003               MAXNPART	equ	3		; #partition entries in root sect - 1
   53           =00000012               BPBLEN		equ	18		; length of bpb entry in bytes
   54           =00000006               FATLEN		equ	6		; max fat size = 2**6 = 64 sectors
   55           =00000003               SERLEN		equ	3		; length of a serial # in bytes
   56           =19870422               CHKDATE		equ	$19870422	; ROM date for bootstop checking
   57                                   
   58                                   
   59                                   ;+
   60                                   ; Number of bytes per Buffer Control Block (excluding the data block itself)
   61                                   ;
   62                                   ; struct_bcb {
   63                                   ; 	struct_bcb	*b_link;	/* 4 bytes */
   64                                   ;	int		b_neg1;		/* 2 bytes */
   65                                   ;	int		b_private[5];	/* 10 bytes */
   66                                   ;	char		*b_bufr;	/* 4 bytes */
   67                                   ; };
   68                                   ;
   69                                   ; For GEMDOS buffer lists.
   70                                   ;-
   71           =00000014               BCBLEN		equ	20
   72                                   
   73                                   
   74                                   ;+
   75                                   ; Number of bytes per IDE drive parameters structure
   76                                   ;
   77                                   ; struct_idedp {


                                        defs.h               Page 3       12:13:14 am 18-Feb-1993     Madmac 1.07  (Atari ST)


   78                                   ;	int	nhead;		/* # of data heads */
   79                                   ;	int	nspt;		/* # of physical sectors per track */
   80                                   ; };
   81                                   ;-
   82           =00000004               IDEDPLEN	equ	4
   83                                   
   84                                   
   85                                   ;+
   86                                   ; for extension of OS pool
   87                                   ;-
   88           =00000042               chunksiz	equ	 66		; #bytes/chunk
   89           =00000004               chunkno		equ	 4		; chunk# (4 16-byte chunks)
   90                                   
   91                                   
   92                                   ;+
   93                                   ; for checking existence of fast RAM
   94                                   ;	If long word at _ramvalid == RAMMAGIC
   95                                   ; then  _ramtop is valid.  If _ramtop contains 0, no fast RAM is available,
   96                                   ; else _ramtop contains the address of top (end) of memory
   97                                   ;
   98                                   ; Fast RAM always starts at $01000000.
   99                                   ; _ramtop may hold $01000000 meaning there is no fast RAM!
  100                                   ;
  101                                   ; RAMRSV must be smaller than MAXACSECTS
  102                                   ;-
  103           =1357BD13               RAMMAGIC	equ	$1357bd13	; magic cookie for fast RAM
  104           =01000000               RAMBOT		equ	$01000000	; where fast RAM starts
  105           =00000080               RAMRSV		equ	$80		; # sectors of reserved RAM (64k)
  106                                   
  107                                   
  108                                   ;+
  109                                   ; Vector address
  110                                   ;-
  111           =00000008               BERR		equ	$8		; Bus ERRor vector
  112           =00000010               IINS		equ	$10		; Illegal INStruction vector
  113                                   
  114                                   
   36                                   .include	"sysvar.h"
    1                                   ;+
    2                                   ; Equates for systems variables
    3                                   ;-
    4           =00000404               etv_critic	equ	$404		; critical error handoff vector
    5           =0000042E               phystop		equ	$42e		; physical top of memory
    6           =0000043E               flock		equ	$43e		; FIFO lock variable
    7           =00000446               _bootdev	equ	$446		; default boot device
    8           =0000046A               hdv_init	equ	$46a		; hdv_init()	** UNUSED **
    9           =00000472               hdv_bpb		equ	$472		; hdv_bpb(dev)
   10           =00000476               hdv_rw		equ	$476		; hdv_rw(rw, buf, count, recno, dev)
   11           =0000047A               hdv_boot	equ	$47a		; hdv_boot()	** UNUSED **
   12           =0000047E               hdv_mediach	equ	$47e		; hdv_mediach(dev)
   13           =000004B2               _bufl		equ	$4b2		; 2 buffer-list headers
   14           =000004BA               _hz_200		equ	$4ba		; system 200hz timer
   15           =000004C2               _drvbits	equ	$4c2		; block device bitVector
   16           =000004C6               _dskbufp	equ	$4c6		; pointer to common disk buffer
   17           =000004F2               _sysbase	equ	$4f2		; -> base of OS
   18           =00000516               pun_ptr		equ	$516		; number of physical units


                                        acsi.s               Page 4       12:13:14 am 18-Feb-1993     Madmac 1.07  (Atari ST)


   19           =000005A0               _p_cookie	equ	$5a0		; pointer to cookie jar
   37                                   .include	"mfp.h"
    1                                   ;+
    2                                   ; Oct-04-90	ml.	Created this to share by files that need to
    3                                   ;			 know addresses in MFP.
    4                                   ;-
    5                                   
    6                                   
    7                                   ; Definitions
    8           =00000001               REGBASE		equ	1	; most are on odd part of data bus
    9           =00000002               REGSTEP		equ	2	; for those that are on word boundaries
   10           =00000004               REGLSTEP	equ	4	; for those that are on long word boundaries
   11                                   
   12                                   
   13                                   ; 68901 MFP definitions
   14                                   
   15           =FFFFFA01               MFP	equ	$FFFFFA01
   16                                   
   17           =FFFFFA01               GPIP	equ	MFP+$00
   18           =FFFFFA03               AER	equ	MFP+$02
   19           =FFFFFA05               DDR	equ	MFP+$04
   20           =FFFFFA07               IERA	equ	MFP+$06
   21           =FFFFFA09               ERB	equ	MFP+$08
   22           =FFFFFA0B               IPRA	equ	MFP+$0A
   23           =FFFFFA0D               IPRB	equ	MFP+$0C
   24           =FFFFFA0F               ISRA	equ	MFP+$0E
   25           =FFFFFA11               ISRB	equ	MFP+$10
   26           =FFFFFA13               IMRA	equ	MFP+$12
   27           =FFFFFA15               IMRB	equ	MFP+$14
   28           =FFFFFA17               VR	equ	MFP+$16
   29           =FFFFFA19               TACR	equ	MFP+$18
   30           =FFFFFA1B               TBCR	equ	MFP+$1A
   31           =FFFFFA1D               TCDCR	equ	MFP+$1C
   32           =FFFFFA1F               TADR	equ	MFP+$1E
   33           =FFFFFA21               TBDR	equ	MFP+$20
   34           =FFFFFA23               TCDR	equ	MFP+$22
   35           =FFFFFA25               TDDR	equ	MFP+$24
   36           =FFFFFA27               SCR	equ	MFP+$26
   37           =FFFFFA29               UCR	equ	MFP+$28
   38           =FFFFFA2B               RSR	equ	MFP+$2A
   39           =FFFFFA2D               TSR	equ	MFP+$2C
   40           =FFFFFA2F               UDR	equ	MFP+$2E
   41                                   
   42           =FFFFFA81               MFP2	equ	$FFFFFA81
   43           =FFFFFA81               GPIP2	equ	MFP2+$00
   44           =FFFFFA83               AER2	equ	MFP2+$02
   45           =FFFFFA85               DDR2	equ	MFP2+$04
   46           =FFFFFA87               IERA2	equ	MFP2+$06
   47           =FFFFFA89               IERB2	equ	MFP2+$08
   48           =FFFFFA8B               IPRA2	equ	MFP2+$0A
   49           =FFFFFA8D               IPRB2	equ	MFP2+$0C
   50           =FFFFFA8F               ISRA2	equ	MFP2+$0E
   51           =FFFFFA91               ISRB2	equ	MFP2+$10
   52           =FFFFFA93               IMRA2	equ	MFP2+$12
   53           =FFFFFA95               IMRB2	equ	MFP2+$14
   54           =FFFFFA97               VR2	equ	MFP2+$16


                                        mfp.h                Page 5       12:13:14 am 18-Feb-1993     Madmac 1.07  (Atari ST)


   55           =FFFFFA99               TACR2	equ	MFP2+$18
   56           =FFFFFA9B               TBCR2	equ	MFP2+$1A
   57           =FFFFFA9D               TCDCR2	equ	MFP2+$1C
   58           =FFFFFA9F               TADR2	equ	MFP2+$1E
   59           =FFFFFAA1               TBDR2	equ	MFP2+$20
   60           =FFFFFAA3               TCDR2	equ	MFP2+$22
   61           =FFFFFAA5               TDDR2	equ	MFP2+$24
   62           =FFFFFAA7               SCR2	equ	MFP2+$26
   63           =FFFFFAA9               UCR2	equ	MFP2+$28
   64           =FFFFFAAB               RSR2	equ	MFP2+$2A
   65           =FFFFFAAD               TSR2	equ	MFP2+$2C
   66           =FFFFFAAF               UDR2	equ	MFP2+$2E
   67                                   	
   68                                   
   69                                   
   38                                   .include	"acsi.h"
    1                                   ;  Hardware definitions for ACSI DMA channel
    2           =FFFF8604               WDC		equ	$ffff8604
    3           =FFFF8606               WDL		equ	$ffff8606
    4           =FFFF860F               WDSR		equ	$ffff860f	; Select Register
    5           =FFFF8604               WDCWDL		equ	WDC		; used for long writes
    6           =00000002               XWDL		equ	WDL-WDC		; offset from wdc to wdl
    7                                   
    8           =FFFF8609               DMAHI		equ	$ffff8609
    9           =FFFF860B               DMAMID		equ	DMAHI+2
   10           =FFFF860D               DMALOW		equ	DMAMID+2
   11                                   
   12           =00000003               STA		equ	3		; Internal DMA status bit
   13                                   					;  in the select register
   14                                   
   39                                   .include	"68030.s"
    1                                   	.macro	movecd0vbr
    2                                 . 	dc.w	$4E7B
    3                                 . 	dc.w	$0801
    4                                 . 	.endm
    5                                   
    6                                   	.macro	movecvbrd0
    7                                 . 	dc.w	$4E7A
    8                                 . 	dc.w	$0801
    9                                 . 	.endm
   10                                   
   11                                   	.macro	movecacrd0
   12                                 . 	dc.w	$4E7A
   13                                 . 	dc.w	$0002
   14                                 . 	.endm
   15                                   
   16                                   	.macro	moved0cacr
   17                                 . 	dc.w	$4E7B
   18                                 . 	dc.w	$0002
   19                                 . 	.endm
   20                                   
   21                                   ; unsigned long multiply immediate producing a word in specified register
   22                                   	.macro	mululwi	val,dstreg
   23                                 . 	dc.w	$4C3C
   24                                 . 	dc.w	\dstreg << 12
   25                                 . 	dc.l	\val


                                        68030.s              Page 6       12:13:14 am 18-Feb-1993     Madmac 1.07  (Atari ST)


   26                                 . 	.endm
   27                                   
   28                                   ; unsigned long divide 32/32 -> 32r:32q
   29                                   	.macro	divulr	eareg,regr,regq
   30                                 . 	dc.w	$4C40+\eareg	; divu.l d?,
   31                                 . 	dc.w	(\regq << 12)+\regr
   32                                 . 	.endm
   40                                   
   41                                   
   42                                   ;+
   43                                   ;  Tunable (delay) values for ACSI
   44                                   ;-
   45           =00000258               ACLTMOUT	equ	600		; long-timeout (3 S)
   46           =00000014               ACSTMOUT	equ	20		; short-timeout (100 mS)
   47           =00001388               SLWACLTO	equ	5000		; long-timeout (25 S) for slow ACSI
   48           =0000002A               SLWACSTO	equ	42		; short-timeout (205 mS) for slow ACSI
   49                                   
   50                                   
   51                                   ;+
   52                                   ; Declarations
   53                                   ;-
   54  00000000  00000000               lastacstm:	dc.l	0		; controller last accessed time
   55  00000004  00                     control:	dc.b	0		; flag for sending control byte
   56                                   		.globl	_slwacsi
   57  00000005  00                     _slwacsi:	dc.b	0		; assume not doing slow ACSI
   58                                   .even
   59                                   
   60                                   .extern		_cmdblk
   61                                   
   62                                   
   63                                   ;+
   64                                   ; LONG _qdone() - Wait for command byte handshake
   65                                   ; LONG _fdone() - Wait for operation complete
   66                                   ; Passed:	nothing
   67                                   ;
   68                                   ; Returns:	EQ: no timeout
   69                                   ;		MI: timeout condition
   70                                   ;
   71                                   ; Uses:		D0
   72                                   ;
   73                                   ;-
   74                                   
   75                                   .if	!DRIVER
   76                                 - _slwfdone:				; fdone for slow response
   77                                 - 	move.l	#SLWACLTO,d0
   78                                 - 	bra.s	qd0
   79                                 - .endif
   80                                   
   81  00000006  203C00000258           _fdone:	move.l	#ACLTMOUT,d0
   82  0000000C  60xx                   	bra.s	qd0
   83                                   
   84                                   .if	!DRIVER
   85                                 - _slwqdone:				; qdone for slow response
   86                                 - 	moveq	#SLWACSTO,d0	
   87                                 - 	bra.s	qd0
   88                                 - .endif


                                        acsi.s               Page 7       12:13:14 am 18-Feb-1993     Madmac 1.07  (Atari ST)


   89                                   
   90  0000000E  7014                   _qdone:	moveq	#ACSTMOUT,d0
   91                                   
   92  00000010  4A3900000005           qd0:	tst.b	_slwacsi		; talking to slow ACSI device?
   93  00000016  67xx                   	beq.s	qd1			; if not, go wait for interrupt
   94                                   					; else
   95  00000018  2F00                   	move.l	d0,-(sp)		; save timeout value
   96  0000001A  7002                   	moveq	#2,d0			; busy-wait delay for slow ACSI
   97  0000001C  D0B804BA               sdelay:	add.l	_hz_200,d0		; minimum 20 microsec.
   98  00000020  B0B804BA               	cmp.l	_hz_200,d0
   99  00000024  6CF6                   	bge.s	sdelay
  100  00000026  201F                   	move.l	(sp)+,d0		; restore timeout value
  101                                   
  102  00000028  D0B804BA               qd1:	add.l	_hz_200,d0
  103  0000002C  B0B804BA               qd2:	cmp.l	_hz_200,d0		; timeout?
  104  00000030  65xx                   	bcs.s	qdq			; (i give up, return NE)
  105  00000032  08380005FA01           	btst	#5,GPIP		; interrupt?
  106  00000038  66F2                   	bne.s	qd2			; (not yet)
  107                                   
  108  0000003A  7000                   	moveq	#0,d0			; return EQ (no timeout)
  109  0000003C  4E75                   	rts
  110                                   
  111  0000003E  70FF                   qdq:	moveq	#-1,d0
  112  00000040  4E75                   	rts
  113                                   
  114                                   
  115                                   ;+
  116                                   ; Wait for end of SASI command
  117                                   ;
  118                                   ; Passed:	d1 value to be written to wdl
  119                                   ;
  120                                   ; Returns:	EQ: success (error code in D0.W)
  121                                   ;		MI: timeout (-1 in D0.W)
  122                                   ;		NE: failure (SASI error code in D0.W)
  123                                   ;
  124                                   ; Uses:		d0
  125                                   ;
  126                                   ; Comments: (12/05/89)
  127                                   ;	The flushing of D cache is necessary per Jim Tittsler.  For
  128                                   ; detail, refer to mail sent by jwt on 12/04/89 about ACSI DMA.
  129                                   ;-
  130                                   .if	!DRIVER
  131                                 - 	.globl	_cachexst
  132                                 - _cachexst:	dc.b	0
  133                                 - 
  134                                 - _slwendcmd:
  135                                 - 	bsr	_slwfdone		; wait for operation complete
  136                                 - 	bra.s	end0
  137                                 - .else
  138                                   	.extern	_cachexst
  139                                   .endif
  140                                   
  141                                   _endcmd:
  142  00000042  61C2                   	bsr	_fdone			; wait for operation complete
  143  00000044  6Bxx                   end0:	bmi.s	endce			; (timed-out, so complain)
  144                                   


                                        acsi.s               Page 8       12:13:14 am 18-Feb-1993     Madmac 1.07  (Atari ST)


  145  00000046  4A39xxxxxxxx           cmdcmp:	tst.b	_cachexst		; '030 cache exists
  146  0000004C  67xx                   	beq.s	end1			; if not, fine
  147                                   					; else, dump D cache
  148  0000004E  40E7                   	move.w	sr,-(sp)		; go to IPL 7
  149  00000050  007C0700               	ori.w	#$700,sr		; no interrupts right now kudasai
                                        	movecacrd0			; d0 = (cache control register)
       00000054  4E7A                 @ 	dc.w	$4E7A
  150  00000056  0002                 @ 	dc.w	$0002
  151  00000058  00400800               	ori.w	#$800,d0		; dump the D cache
                                        	moved0cacr			; update cache control register
       0000005C  4E7B                 @ 	dc.w	$4E7B
  152  0000005E  0002                 @ 	dc.w	$0002
  153  00000060  46DF                   	move.w	(sp)+,sr		; restore interrupt state
  154                                   
  155  00000062  31C18606               end1:	move.w	d1,WDL
  156  00000066  30388604               	move.w	WDC,d0			; get the result
  157  0000006A  C07C00FF               	and.w	#$00ff,d0		; (clean it up), if non-zero should
  158                                   					; do a ReadSense command to learn more
  159  0000006E  23F804BA00000000       endce:	move.l	_hz_200,lastacstm	; update controller last accessed time
  160  00000076  54B900000000           	addq.l	#2,lastacstm		; lastacstm = _hz_200 + 2;
  161  0000007C  4E75                   	rts				
  162                                   
  163                                   
  164                                   ;+
  165                                   ;  Unlock DMA chip and return completion status;
  166                                   ;-
  167                                   	.globl	_hdone
  168  0000007E  31FC01808606           _hdone:	move.w	#$180,WDL	; reset the chip for floppy
  169  00000084  6100xxxx               	bsr	rstdelay
  170  00000088  31FC00808606           	move.w	#$80,WDL	; Landon's code seems to presume we put 
  171                                   				;  $80 there
  172  0000008E  4278043E               	clr	flock		; NOW, signal that we are done
  173  00000092  4E75                   	rts
  174                                   
  175                                   
  176                                   ;+
  177                                   ; delay()
  178                                   ;	5 - 10ms kludge delay for message byte sent back by controller.
  179                                   ;-
  180  00000094  2F00                   _delay:	move.l	d0,-(sp)		; preserve d0
  181  00000096  203900000000           	move.l	lastacstm,d0		; d0 = controller last accessed time
  182  0000009C  B0B804BA               wait:	cmp.l	_hz_200,d0		; while (_hz_200 <= lastacstm)
  183  000000A0  64FA                   	bcc.s	wait			;	wait()
  184  000000A2  201F                   	move.l	(sp)+,d0		; restore d0
  185  000000A4  4E75                   	rts
  186                                   
  187                                   
  188                                   ;+
  189                                   ; smplacsi() - send a simple ACSI command (ie. no DMA involved)
  190                                   ;
  191                                   ;	d0.w = physical unit number
  192                                   ;	d1.l = transfer length (in bytes)
  193                                   ;	d2.w = command length (NCMD or LCMD)
  194                                   ;	a0.l = buffer address
  195                                   ;-
  196                                   	.globl	_smplacsi


                                        acsi.s               Page 9       12:13:14 am 18-Feb-1993     Madmac 1.07  (Atari ST)


  197                                   _smplacsi:
  198  000000A6  50F8043E               	st	flock			; lock FIFO
  199  000000AA  61E8                   	bsr	_delay			; delay if necessary
  200  000000AC  227CFFFF8604           	movea.l	#WDC,a1			; a1 = pointer to DMA chip
  201  000000B2  02400007               	andi.w	#7,d0			; mask off the flags to get unit num
  202  000000B6  7200                   	moveq	#0,d1			; no DMA
  203  000000B8  6100xxxx               	bsr	sblkacsi		; send command block
  204  000000BC  60C0                   	bra	_hdone			; cleanup after IRQ
  205                                   
  206                                   
  207                                   ;+
  208                                   ; rcvacsi() - send a ACSI command which receives data back.
  209                                   ;
  210                                   ; Passed:
  211                                   ;	d0.w = physical unit number
  212                                   ;	d1.l = transfer length (in bytes)
  213                                   ;	d2.w = command length (NCMD or LCMD)
  214                                   ;	a0.l = buffer address
  215                                   ;
  216                                   ; Comments:
  217                                   ;	This routine assumes that if you are transferring more than 512
  218                                   ; bytes, the transfer length must be a multiple of 16 bytes.  It also 
  219                                   ; assumes the allocation length byte is always at byte 4 in the command
  220                                   ; block. (Therefore, it won't work with Receive Diagnostic ($1c) if data
  221                                   ; length is not a multiple of 16 bytes.  But Receive Diagnostic has never
  222                                   ; been used.)
  223                                   ;	The transfer length in register D1 MUST be greater than 0.
  224                                   ;-
  225                                   	.globl	_rcvacsi
  226                                   _rcvacsi:
  227  000000BE  50F8043E               	st	flock			; lock FIFO
  228  000000C2  3F03                   	move.w	d3,-(sp)		; preserve d3
  229  000000C4  61CE                   	bsr	_delay			; delay if necessary
  230  000000C6  227CFFFF8604           	movea.l	#WDC,a1			; a1 = pointer to DMA chip
  231                                   
  232  000000CC  6100xxxx               	bsr	setadma			; set DMA pointer
  233  000000D0  337C01900002           	move.w	#$190,XWDL(a1)	;WDL	; toggle DMA chip for "receive"
  234  000000D6  6100xxxx               	bsr	rstdelay		; delay
  235  000000DA  337C00900002           	move.w	#$090,XWDL(a1)	;WDL
  236  000000E0  6100xxxx               	bsr	rstdelay		; delay
  237                                   
  238                                   .if	RDWDL
  239                                 - 	tst.w	XWDL(a1)		; to point MMU to correct direction
  240                                 - .endif	;RDWDL
  241                                   
  242  000000E4  6100xxxx               	bsr	setacnt			; set DMA count
  243                                   
  244  000000E8  02400007               	andi.w	#7,d0			; mask off the flags to get unit num
  245                                   					; find # times need to send it
  246  000000EC  0C8100000200           	cmpi.l	#512,d1			; transferring < 512 bytes?
  247  000000F2  65xx                   	bcs.s	.0			; if so, go find # times to send
  248  000000F4  7200                   	moveq	#0,d1			; else assume it's 16*n, send once
  249  000000F6  60xx                   	bra.s	.4
  250                                   
  251  000000F8  3601                   .0:	move.w	d1,d3			; d3 = transfer length
  252  000000FA  0C410010               	cmpi.w	#16,d1			; transferring < 16 bytes?


                                        acsi.s               Page 10      12:13:14 am 18-Feb-1993     Madmac 1.07  (Atari ST)


  253  000000FE  65xx                   	bcs.s	.1			; if so, find # times to make 16 bytes
  254                                   
  255  00000100  0241000F               	andi.w	#$0f,d1			; else, is it multiple of 16 bytes?
  256  00000104  67xx                   	beq.s	.4			; if so, just do once (d1.w = 0)
  257  00000106  7201                   	moveq	#1,d1			; else, need to do twice
  258  00000108  60xx                   	bra.s	.4
  259                                   
  260  0000010A  7210                   .1:	moveq	#16,d1			; find # times to make 16 bytes
  261  0000010C  82C3                   	divu	d3,d1			; d1.w = 16 / transfer length
  262  0000010E  5341                   	subq.w	#1,d1			; dbra likes one less
  263                                   
  264  00000110  4841                   .2:	swap	d1			; d1.w = remainder
  265  00000112  4A41                   	tst.w	d1			; any remainder?
  266  00000114  66xx                   	bne.s	.3			; if yes, go add one to the quotient
  267  00000116  4841                   	swap	d1			; if no, # times to send = quotient
  268  00000118  60xx                   	bra.s	.4
  269                                   
  270  0000011A  4841                   .3:	swap	d1			; d1.w	= # times to send command
  271  0000011C  5241                   	addq.w	#1,d1			;	= quotient + 1
  272                                   
  273  0000011E  41F9xxxxxxxx           .4:	lea	_cmdblk,a0		; a0 = address of command block
  274  00000124  48E7E080               .5:	movem.l	d0-d2/a0,-(sp)		; save d0 through d2 and a0
  275  00000128  7200                   	moveq	#0,d1			; direction of DMA is IN
  276  0000012A  6100FF68               	bsr	_delay			; delay if necessary
  277  0000012E  6100xxxx               	bsr	sblkacsi		; send the command block
  278  00000132  4A40                   	tst.w	d0			; successful?
  279  00000134  66xx                   	bne.s	.7			; if not, quit
  280  00000136  4CDF0107               	movem.l	(sp)+,d0-d2/a0		; else restore d0 through d2 and a0
  281  0000013A  51C9xxxx               	dbra	d1,.6			; done yet?
  282  0000013E  7000                   	moveq	#0,d0			; command block sent successfully
  283  00000140  60xx                   	bra.s	raend			; phone home...
  284                                   
  285  00000142  70FF                   .6:	moveq	#-1,d0			; unit number already in command block
  286  00000144  11430004               	move.b	d3,4(a0)		; modify transfer length
  287  00000148  60DA                   	bra.s	.5			; send it enough times
  288                                   
  289  0000014A  DEFC0010               .7:	adda	#16,sp			; cleanup stack
  290  0000014E  361F                   raend:	move.w	(sp)+,d3		; restore d3
  291  00000150  6000FF2C               	bra	_hdone			; cleanup after IRQ
  292                                   
  293                                   
  294                                   ;+
  295                                   ; wrtacsi() - send an ACSI command which will write data to the target
  296                                   ;
  297                                   ; Passed:
  298                                   ;	d0.w = physical unit number
  299                                   ;	d1.l = transfer length (in bytes)
  300                                   ;	d2.w = command length (NCMD or LCMD)
  301                                   ;	a0.l = buffer address
  302                                   ;-
  303                                   	.globl	_wrtacsi
  304                                   _wrtacsi:
  305  00000154  50F8043E               	st	flock			; lock FIFO
  306  00000158  6100FF3A               	bsr	_delay
  307  0000015C  227CFFFF8604           	movea.l	#WDC,a1			; a1 = pointer to DMA chip
  308                                   


                                        acsi.s               Page 11      12:13:14 am 18-Feb-1993     Madmac 1.07  (Atari ST)


  309  00000162  6100xxxx               	bsr	setadma			; set DMA pointer
  310  00000166  337C00900002           	move.w	#$90,XWDL(a1)	;WDL	; toggle DMA chip for "send"
  311  0000016C  6100xxxx               	bsr	rstdelay		; delay 
  312  00000170  337C01900002           	move.w	#$190,XWDL(a1)	;WDL
  313  00000176  6100xxxx               	bsr	rstdelay		; delay
  314                                   
  315                                   .if	RDWDL
  316                                 - 	tst.w	XWDL(a1)		; to point MMU to correct direction
  317                                 - .endif	;RDWDL
  318                                   
  319  0000017A  6100xxxx               	bsr	setacnt			; set DMA count
  320                                   	
  321  0000017E  02400007               	andi.w	#7,d0			; mask off the flags to get unit num
  322  00000182  223C00000100           	move.l	#$0100,d1		; d1 = direction of DMA is OUT
  323  00000188  6100xxxx               	bsr	sblkacsi		; send the command block
  324                                   
  325  0000018C  6000FEF0               waend:	bra	_hdone			; cleanup after IRQ
  326                                   
  327                                   
  328                                   ;+
  329                                   ; sblkacsi() - set DMA pointer and count and send command block
  330                                   ;
  331                                   ; Passed:
  332                                   ;	d0.w = physical unit number
  333                                   ;	d1.l = direction of DMA ($0000 for IN or $0100 for OUT)
  334                                   ;	d2.w = command length (NCMD or LCMD)
  335                                   ;	a1.l = pointer to DMA chip
  336                                   ;
  337                                   ; Returns:
  338                                   ;	d0.l =  0 if successful
  339                                   ;	d0.l = -1 if timeout
  340                                   ;
  341                                   ; Trashes:
  342                                   ;	d0, d1, d2, a2
  343                                   ;-
  344                                   sblkacsi:
  345  00000190  123C0088               	move.b	#$88,d1			; next byte is the opcode
  346  00000194  33410002               	move.w	d1,XWDL(a1)	;WDL
  347                                   
  348  00000198  123C008A               	move.b	#$8a,d1			; following bytes are operands
  349  0000019C  45F9xxxxxxxx           	lea	_cmdblk,a2		; a2 = address of command block
  350                                   
  351  000001A2  4A40                   	tst.w	d0			; is unit # already in command block
  352  000001A4  6Bxx                   	bmi.s	.0			; if yes, just send command block
  353                                   					; else integrate unit # into cmd blk
  354  000001A6  EB08                   	lsl.b	#5,d0			; shift unit number into place
  355  000001A8  8112                   	or.b	d0,(a2)			; first command byte = unit # | opcode
  356                                   					; control byte is sent seperately
  357  000001AA  5542                   .0:	subq.w	#2,d2			; and dbra likes one less 
  358  000001AC  4841                   .1:	swap	d1			; d1.hw = operand
  359  000001AE  121A                   	move.b	(a2)+,d1		; d1.lw = tells controller next byte
  360  000001B0  4841                   	swap	d1			;	  is an operand
  361  000001B2  2281                   	move.l	d1,(a1)		;WDCWDL
  362  000001B4  6100FE58               	bsr	_qdone
  363  000001B8  6Bxx                   	bmi.s	sbaend			; if timeout, returns
  364  000001BA  51CAFFF0               	dbra	d2,.1			; else send rest of command block


                                        acsi.s               Page 12      12:13:14 am 18-Feb-1993     Madmac 1.07  (Atari ST)


  365                                   
  366  000001BE  33410002               	move.w	d1,XWDL(a1)	;WDL	; else get ready to send control byte
  367  000001C2  123C0000               	move.b	#0,d1			; signal sending control byte
  368  000001C6  4841                   	swap	d1			; d1.hw = operand
  369  000001C8  1212                   	move.b	(a2),d1			; d1.lw = tells controller it's end
  370  000001CA  4841                   	swap	d1			;	  of command
  371  000001CC  2281                   	move.l	d1,(a1)			; send it
  372                                   
  373  000001CE  123C008A               	move.b	#$8a,d1			; d1 = wdl value
  374  000001D2  6100FE6E               	bsr	_endcmd			; wait for command completion
  375  000001D6  4E75                   sbaend: rts				; heading home
  376                                   
  377                                   
  378                                   ;+
  379                                   ; setadma() - set the ACSI DMA pointer
  380                                   ;
  381                                   ; Passed:
  382                                   ;	a0.l = buffer address
  383                                   ;-
  384                                   	.globl	setadma
  385                                   setadma:
  386  000001D8  2F08                   	move.l	a0,-(sp)		; move it on stack
  387  000001DA  11EF0003860D           	move.b	3(sp),DMALOW		; set low-byte of address
  388  000001E0  11EF0002860B           	move.b	2(sp),DMAMID		; set mid-byte of address
  389  000001E6  11EF00018609           	move.b	1(sp),DMAHI		; set high-byte of address
  390  000001EC  588F                   	addq.l	#4,sp			; clean up stack
  391  000001EE  4E75                   	rts
  392                                   
  393                                   
  394                                   ;+
  395                                   ; setacnt() - set the ACSI DMA counter
  396                                   ;
  397                                   ; Passed:
  398                                   ;	d1.l = transfer length (in bytes)
  399                                   ;	a1.l = pointer to DMA chip
  400                                   ;-
  401                                   	.globl	setacnt
  402                                   setacnt:
  403  000001F0  0C8100000200           	cmpi.l	#512,d1			; transferring more than 512 bytes?
  404  000001F6  62xx                   	bhi.s	.0			; if so, find transfer len in blocks
  405  000001F8  32BC0001               	move.w	#1,(a1)		;WDC	; else set DMA count to 1 block
  406  000001FC  60xx                   	bra.s	sacend
  407  000001FE  48E76000               .0:	movem.l	d1-d2,-(sp)		; save d1 and d2
  408  00000202  2401                   	move.l	d1,d2			; d2 = transfer length (in bytes)
  409  00000204  E089                   	lsr.l	#8,d1			; find transfer length (in blocks)
  410  00000206  E289                   	lsr.l	#1,d1			; d1 >>= 9 = transfer len (in blocks)
  411  00000208  0282000001FF           	andi.l	#$1ff,d2		; multiples of 512?
  412  0000020E  67xx                   	beq.s	.1			; if so, go set count
  413  00000210  D27C0001               	add.w	#1,d1			; else increment count by one	
  414  00000214  3281                   .1:	move.w	d1,(a1)		;WDC	; set DMA count
  415  00000216  4CDF0006               	movem.l	(sp)+,d1-d2		; restore d1 and d2
  416  0000021A  4E75                   sacend:	rts
  417                                   
  418                                   
  419                                   
  420                                   .if	!DRIVER				; not to be included in driver


                                        acsi.s               Page 13      12:13:14 am 18-Feb-1993     Madmac 1.07  (Atari ST)


  421                                 - 
  422                                 - ;+
  423                                 - ; fmtacsi() - format an ACSI unit
  424                                 - ;
  425                                 - ;	d0.w = physical unit number
  426                                 - ;	d2.w = command length (NCMD or LCMD)
  427                                 - ;-
  428                                 - 	.globl	_fmtacsi
  429                                 - 	.extern	_cmdblk
  430                                 - _fmtacsi:
  431                                 - 	st	flock			; lock FIFO
  432                                 - 	bsr	_delay			; delay if necessary
  433                                 - 	movea.l	#WDC,a1			; a1 = pointer to DMA chip
  434                                 - 	andi.w	#7,d0			; mask off the flags to get unit num
  435                                 - 	moveq	#0,d1			; clear d1
  436                                 - 	move.b	#$88,d1			; next byte is the opcode
  437                                 - 	move.w	d1,XWDL(a1)	;WDL
  438                                 - 
  439                                 - 	move.b	#$8a,d1			; following bytes are operands
  440                                 - 	lea	_cmdblk,a2		; a2 = address of command block
  441                                 - 					; integrate unit # into cmd blk
  442                                 - 	lsl.w	#5,d0			; shift unit number into place
  443                                 - 	or.b	d0,(a2)			; first command byte = unit # | opcode
  444                                 - 					; control byte is sent seperately
  445                                 - 	subq.w	#2,d2			; and dbra likes one less 
  446                                 - .0:	swap	d1			; d1.hw = operand
  447                                 - 	move.b	(a2)+,d1		; d1.lw = tells controller next byte
  448                                 - 	swap	d1			;	  is an operand
  449                                 - 	move.l	d1,(a1)		;WDCWDL
  450                                 - 	bsr	_qdone
  451                                 - 	beq.s	.1			; if successful, go on
  452                                 - 	rts				; else it timed-out, returns
  453                                 - .1:	dbra	d2,.0			; send rest of command block
  454                                 - 
  455                                 - 	move.w	d1,XWDL(a1)	;WDL	; else get ready to send control byte
  456                                 - 	move.b	#0,d1			; signal sending control byte
  457                                 - 	swap	d1			; d1.hw = operand
  458                                 - 	move.b	(a2),d1			; d1.lw = tells controller it's end
  459                                 - 	swap	d1			;	  of command
  460                                 - 	move.l	d1,(a1)			; send it
  461                                 - 
  462                                 - 	move.b	#$8a,d1			; d1 = wdl value
  463                                 - .2:	btst	#5,GPIP		; wait forever for command completion
  464                                 - 	bne.s	.2
  465                                 - 	bsr	cmdcmp			; command completed
  466                                 - 	bra	_hdone			; cleanup after IRQ
  467                                 - 
  468                                 - 
  469                                 - ;+
  470                                 - ; stacsi() - start/stop an ACSI unit
  471                                 - ;
  472                                 - ;	d0.w = physical unit number
  473                                 - ;	d2.w = command length (NCMD or LCMD)
  474                                 - ;-
  475                                 - 	.globl	_stacsi
  476                                 - 	.extern	_cmdblk


                                        acsi.s               Page 14      12:13:14 am 18-Feb-1993     Madmac 1.07  (Atari ST)


  477                                 - _stacsi:
  478                                 - 	st	flock			; lock FIFO
  479                                 - 	bsr	_delay			; delay if necessary
  480                                 - 	movea.l	#WDC,a1			; a1 = pointer to DMA chip
  481                                 - 	andi.w	#7,d0			; mask off the flags to get unit num
  482                                 - 	moveq	#0,d1			; clear d1
  483                                 - 	move.b	#$88,d1			; next byte is the opcode
  484                                 - 	move.w	d1,XWDL(a1)	;WDL
  485                                 - 
  486                                 - 	move.b	#$8a,d1			; following bytes are operands
  487                                 - 	lea	_cmdblk,a2		; a2 = address of command block
  488                                 - 					; integrate unit # into cmd blk
  489                                 - 	lsl.w	#5,d0			; shift unit number into place
  490                                 - 	or.b	d0,(a2)			; first command byte = unit # | opcode
  491                                 - 					; control byte is sent seperately
  492                                 - 	subq.w	#2,d2			; and dbra likes one less 
  493                                 - .0:	swap	d1			; d1.hw = operand
  494                                 - 	move.b	(a2)+,d1		; d1.lw = tells controller next byte
  495                                 - 	swap	d1			;	  is an operand
  496                                 - 	move.l	d1,(a1)		;WDCWDL
  497                                 - 	bsr	_slwqdone		; needs a longer short timeout
  498                                 - 	beq.s	.1			; if successful, go on
  499                                 - 	rts				; else it timed-out, returns
  500                                 - .1:	dbra	d2,.0			; send rest of command block
  501                                 - 
  502                                 - 	move.w	d1,XWDL(a1)	;WDL	; else get ready to send control byte
  503                                 - 	move.b	#0,d1			; signal sending control byte
  504                                 - 	swap	d1			; d1.hw = operand
  505                                 - 	move.b	(a2),d1			; d1.lw = tells controller it's end
  506                                 - 	swap	d1			;	  of command
  507                                 - 	move.l	d1,(a1)			; send it
  508                                 - 
  509                                 - 	move.b	#$8a,d1			; d1 = wdl value
  510                                 - 	bsr	_slwendcmd		; wait for command completion
  511                                 - 	bra	_hdone			; cleanup after IRQ
  512                                 - 
  513                                 - .endif	;!DRIVER
  514                                   
  515                                   
  516                                   ;+
  517                                   ; Rstdelay()
  518                                   ;	After talking to the DMA chip in a way that may reset it, 
  519                                   ; we need a 8 8Mhz clocks (ie. 1 microsec) delay, before we can
  520                                   ; talk to the chip again.
  521                                   ;-
  522                                   	.globl	rstdelay
  523                                   rstdelay:
  524  0000021C  4A38FA01               	tst.b	GPIP			; delay for 1 microsec
  525  00000220  4A38FA01               	tst.b	GPIP			; this amounts to 16 16Mhz clocks
  526  00000224  4A38FA01               	tst.b	GPIP
  527  00000228  4A38FA01               	tst.b	GPIP
  528  0000022C  4E75                   	rts
  529                                   


                                                             Page 15      12:13:14 am 18-Feb-1993     Madmac 1.07  (Atari ST)
Symbol Table

                .0 000000F8  t        MAXIDESECTS 00000100 ea             WDCWDL FFFF8604 ea 
                .0 000001AA  t             MAXLOG 0000000E ea                WDL FFFF8606 ea 
                .0 000001FE  t           MAXNPART 00000003 ea               WDSR FFFF860F ea 
                .1 0000010A  t         MAXSCSECTS 0000FFFE ea               XWDL 00000002 ea 
                .1 000001AC  t            MAXSCSI 00000008 ea               _MCH 5F4D4348 ea 
                .1 00000214  t         MAXSPSECTS 00003FFF ea           _bootdev 00000446 ea 
                .2 00000110  t                MFP FFFFFA01 ea              _bufl 000004B2 ea 
                .3 0000011A  t               MFP2 FFFFFA81 ea          _cachexst external  ax
                .4 0000011E  t               MSTE 00010010 ea            _cmdblk external  ax
                .5 00000124  t           NRETRIES 00000003 ea             _delay 00000094  t 
                .6 00000142  t             RAMBOT 01000000 ea           _drvbits 000004C2 ea 
                .7 0000014A  t           RAMMAGIC 1357BD13 ea           _dskbufp 000004C6 ea 
          ACLTMOUT 00000258 ea             RAMRSV 00000080 ea            _endcmd 00000042  t 
           ACSIUNT 00000007 ea              RDWDL 00000000 ea             _fdone 00000006  t 
          ACSTMOUT 00000014 ea            REGBASE 00000001 ea             _hdone 0000007E  tg
               AER FFFFFA03 ea           REGLSTEP 00000004 ea            _hz_200 000004BA ea 
              AER2 FFFFFA83 ea            REGSTEP 00000002 ea          _p_cookie 000005A0 ea 
            BCBLEN 00000014 ea                RSR FFFFFA2B ea             _qdone 0000000E  t 
              BERR 00000008 ea               RSR2 FFFFFAAB ea           _rcvacsi 000000BE  tg
            BPBLEN 00000012 ea                SCR FFFFFA27 ea           _slwacsi 00000005  tg
           CHKDATE 19870422 ea               SCR2 FFFFFAA7 ea          _smplacsi 000000A6  tg
               DDR FFFFFA05 ea             SCSIID 00000006 ea           _sysbase 000004F2 ea 
              DDR2 FFFFFA85 ea            SCSIUNT 0000000F ea           _wrtacsi 00000154  tg
             DEBUG 00000000 ea             SERLEN 00000003 ea            chunkno 00000004 ea 
             DMAHI FFFF8609 ea                SIG 000055AA ea           chunksiz 00000042 ea 
            DMALOW FFFF860D ea           SLWACLTO 00001388 ea             cmdcmp 00000046  t 
            DMAMID FFFF860B ea           SLWACSTO 0000002A ea            control 00000004  t 
             DOSPM 000001BE ea            SPARROW 00030000 ea               end0 00000044  t 
            DOSSIG 000001FE ea                 ST 00000000 ea               end1 00000062  t 
            DRIVER 00000001 ea                STA 00000003 ea              endce 0000006E  t 
               ERB FFFFFA09 ea             STBOOK 00010008 ea         etv_critic 00000404 ea 
            FATLEN 00000006 ea                STE 00010000 ea              flock 0000043E ea 
              GPIP FFFFFA01 ea               TACR FFFFFA19 ea           hdv_boot 0000047A ea 
             GPIP2 FFFFFA81 ea              TACR2 FFFFFA99 ea            hdv_bpb 00000472 ea 
             HDSIZ 000001C2 ea               TADR FFFFFA1F ea           hdv_init 0000046A ea 
          IDEDPLEN 00000004 ea              TADR2 FFFFFA9F ea        hdv_mediach 0000047E ea 
            IDEUNT 00000010 ea               TBCR FFFFFA1B ea             hdv_rw 00000476 ea 
              IERA FFFFFA07 ea              TBCR2 FFFFFA9B ea          lastacstm 00000000  t 
             IERA2 FFFFFA87 ea               TBDR FFFFFA21 ea            phystop 0000042E ea 
             IERB2 FFFFFA89 ea              TBDR2 FFFFFAA1 ea            pun_ptr 00000516 ea 
              IINS 00000010 ea              TCDCR FFFFFA1D ea                qd0 00000010  t 
              IMRA FFFFFA13 ea             TCDCR2 FFFFFA9D ea                qd1 00000028  t 
             IMRA2 FFFFFA93 ea               TCDR FFFFFA23 ea                qd2 0000002C  t 
              IMRB FFFFFA15 ea              TCDR2 FFFFFAA3 ea                qdq 0000003E  t 
             IMRB2 FFFFFA95 ea               TDDR FFFFFA25 ea              raend 0000014E  t 
              IPRA FFFFFA0B ea              TDDR2 FFFFFAA5 ea           rstdelay 0000021C  tg
             IPRA2 FFFFFA8B ea                TSR FFFFFA2D ea             sacend 0000021A  t 
              IPRB FFFFFA0D ea               TSR2 FFFFFAAD ea             sbaend 000001D6  t 
             IPRB2 FFFFFA8D ea                 TT 00020000 ea           sblkacsi 00000190  t 
              ISRA FFFFFA0F ea                UCR FFFFFA29 ea             sdelay 0000001C  t 
             ISRA2 FFFFFA8F ea               UCR2 FFFFFAA9 ea            setacnt 000001F0  tg
              ISRB FFFFFA11 ea                UDR FFFFFA2F ea            setadma 000001D8  tg
             ISRB2 FFFFFA91 ea               UDR2 FFFFFAAF ea              waend 0000018C  t 
        MAXACSECTS 000000FE ea                 VR FFFFFA17 ea               wait 0000009C  t 
           MAXACSI 00000008 ea                VR2 FFFFFA97 ea 
            MAXIDE 00000001 ea                WDC FFFF8604 ea 

