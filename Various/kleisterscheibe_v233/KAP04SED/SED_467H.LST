$c+
RESERVE MAX(FRE(0)/2,130*1024)
'
'
' SED - Der Allzweck-Monitor
'
' Written & Ω 1987/1988/1989/1990  by
'
'
'             Anton Stepper                    Claus Brod
'             Jahnstraûe 5         &           Am Felsenkeller 2
'        8772 Marktheidenfeld             8772 Marktheidenfeld
'             09391/6651                       09391/3206
'
'
ver$="SED_467"
ver2$="SED4.6"
'
'
' Fehler: DISC_NAME (volles Direktory), FAT_CHECK (Ordner-Problem)
'         FAT_CLUSTER (Ordner ...), FAT_TEST (defekte Cluster nicht freigeben)
'         BUFFER_DUMP Abbruch bei GEMDOS-Fehler
'         FDATIME, DIR_SORT, MAUS_KLICK (MK%), FILE_ADDRESS (Change)
'         Abfrage in PART wegen Anzahl der Partitionen
'         Offset%-Anzeige in Routine ZEILE jetzt richtig
'         Fehlerkorrektur in Routine SORT_DIR von Michael Schwingen
'
' NEU:    Sektoren pro Cluster in HDX-PART fÅr jede Partition einstellbar
'         FILE_COPY, DISC_BOOT zeigt Unterschiede BPB <-> Bootsektor!
'         FILE_CRC, OUT_PRINTER, EINGABE-Routine mit OK/Abbruch-Button
'         ct - Vorbereitet ?
'
' ANDERS: ALRT-Routine verdoppelt ERG%-ERG2%
'         FILE_DUMP gibt DateilÑnge aus, FILE-Handling Åberarbeitet
'         HARD_RESTORE Abfrage vor jedem Schreiben, Click auf Uhr->Datum
'         FUNKTION_EXEC Pfad richtig setzen, SEKTOR_COMPARE Åberarbeitet
'         DISC_CHECK markiert auch defekte Sektoren in der FAT
'         SYSTEM_INF ausfÅhrlicher, Routine AUSGABE erwartet in ZX% Spalte
'         Routinen-Namen geÑndert, RAM-Modus keine Bomben mehr ?
'         ***** SEDUTIS und SED.EXE geÑndert *****
'         In Leichen-Clustern keine Alertbox, FAT_TEST verbessert
'         In 'Schreibschutz hilft nix' jetzt Abbruch mîglich
'         BHDI 1.3, ALTernate-Tasten vorbereitet, FUNKTION-CPU ?
'         FAT-GRAPH schneller und Ausgabe kleine Buchstaben - Scrollbar
'         DIR-MAKE-DIR erweitert, Fehler in CHK_SUM beseitigt
'         INFO_SYSTEM gibtr Blitter vorhanden aus
'
'         DISC_CHECK liest keine als defekt gekennzeichneten Sektoren
'
'         CB: Fehler in fsel
'             NotdÅrftiger Hack fÅr TTM194, nicht ausgetestet
'             Versionsnummer geÑndert
'             fselect darf nicht aufgerufen werden, wenn EXE noch nicht da (init_do)
'             Korrekturen nach H. Felger in disc, sektor_cluster, file_repair,
'             fat_cursor, fat_cluster und fat_check
'
' last update:  9.11.91        16:30 Uhr       CB
' ###########################################################################
' --------------------- ! Ab hier Aktion ...
PRINT coff$;            ! Cursor stîrt Bildschirmaufbau
DEFMOUSE 2              ! Busy Bee
init_var
init_ram                ! Speicher holen
felder                  ! OberflÑche malen
felder_text(0)          ! Buttons beschriften
init_do(p_inf$)         ! Info-File abarbeiten + EXE + FKY
boot_sec(1)             ! aktuelle Disk-Daten holen
kleine_boxen            ! ...
VOID XBIOS(21,3,0)      ! Cursor an, nicht blinken
@list                   ! Sektor anzeigen
feld_wahl               ! Endlosschleife
' --------------------------------- I N I T ----------------------------------
PROCEDURE init_var
  mfr%=FRE(0)
  SHOWM
  ON ERROR GOSUB fehler_behandlung
  '
  max_err%=100
  DIM text$(14,14),err_fld$(max_err%),stat$(20),flos$(1,20),fg$(5),m$(30)
  DIM p_flag%(11),p_id$(11),p_start%(11),p_size%(11),po_start%(11),po_size%(11)
  DIM boot$(11),hh_err$(160),ascii$(1),u_men%(7),button%(7),sense$(10)
  '
  ' ------ Auflîsung ------
  res%=XBIOS(4)           ! GETREZ
  IF res%
    IF res%=4 OR res%=5 OR res%=6
      res%=2
    ENDIF
    zh%=8*res%            ! Zeichenhîhe
    a$=MKL$(&HA0002008)+MKL$(&H4E750000)
    a%=VARPTR(a$)
    zpz%=DPEEK(C:a%()-2)
    planes%=DPEEK(C:a%())
    f1%=5*res%            ! FÅr Bildschirm
    o_box%=22*res%        !
    vert%=153*res%        !
    e1%=100               ! Linker Rand
    e2%=70*res%           ! Oberer Rand
    e3%=e1%+450           ! Links + Breite
    e4%=e2%+5*zh%         ! Oben + Hîhe
    IF res%=2
      dtg%=13
      dtk%=6
      hyl%=21*zh%+3*res%  ! Zeile
      hxl%=420            ! Spalte Cursor Anzeige
    ELSE
      dtg%=6
      dtk%=4
      hyl%=21*zh%+4*res%
      hxl%=470
    ENDIF
    DEFTEXT ,,,dtg%
  ELSE
    @alrt(3,"Bitte die mittlere oder|hohe Auflîsung wÑhlen.",1,"Abbruch")
    EDIT
  ENDIF
  '
  n$=STRING$(10,48)       ! fÅr alle formatierten Zahlenausgaben
  esc$=CHR$(27)           ! ESC
  con$=esc$+"e"           ! Cursor an
  coff$=esc$+"f"          ! Cursor aus
  ro$=esc$+"p"            ! Revers an
  rof$=esc$+"q"           ! Revers aus
  cr$=CHR$(13)+CHR$(10)
  tim$=STRING$(9,32)
  inf$=STRING$(3,32)
  inf_ma$=STRING$(45,32)  ! String mit Text fÅr kleine Boxen
  '
  ddm$="Datei|Drucker|Moni"
  dda$="Datei|Drucker|Abbruch"
  gm$="GEMDOS-Fehler"
  '
  ext_magic%=&H43424844   ! ROOT-Erkennung der zusÑtzlichen Partitionen
  ext_magic$="CBHD"
  '
  CLR fp%,xt%,yt%,tz%,status%,seite%,target%,geraet%,block%,dec%,z%,tim%
  CLR prg_adr%,ch!,fil!,hard!,ram!,root_vers%,dis_init%
  '
  disc!=TRUE              ! In normalem Diskmodus
  hpt!=TRUE               ! In Hauptverzeichnis
  hex!=TRUE               ! In Hex-Teil
  help!=FALSE             ! Help-Datei existent ?
  mode%=1                 ! Sektormodus
  hard%=2                 ! Default ist Vortex-Platte ?
  dclick%=0               ! Zeitkonstante fÅr Doppelklick
  buf_size%=2048          ! Grîûe des Puffers, der reserviert wird
  file_open%=-1           ! Flag fÅr kein File geîffnet
  bps%=512
  '
  drive%=GEMDOS(25) AND 255 ! Aktuelles Laufwerk
  @get_pfad               ! Pfad von Gemdos holen
  a$=pfad$+ver$+"."
  exe$=a$+"EXE"           ! Datei mit Mcode
  p_inf$=a$+"INF"         ! Info-Datei
  p_help$=a$+"HLP"        ! Help-Datei
  floskel$=a$+"KEY"       ! Functions-Key's
  logbuch$="DEFAULT.LOG"  ! Standard-Logbuchdatei
  dum$="SED_DUM.DUM"      ! Datei, zum PrÅfen des Schreibschutzes
  '
  fg$(0)="?"              ! FÅr Anzeige in FAT-GRAPH
  fg$(1)="V"
  fg$(2)="x"
  fg$(3)="D"
  fg$(4)="."
  '
  sys_base%=LPEEK(&H4F2)
  blitter%=XBIOS(64,-1) AND 3
  ramend%=LPEEK(&H42E)
  romstart%=LPEEK(sys_base%+8)
  rom_version%=DPEEK(sys_base%+2)
  romend%=romstart%+192*1024
  ram_max%=&H400000
  IF rom_version%>&H104
    romend%=romstart%+256*1024
  ENDIF
  '
  a$=STRING$(256,".")     ! FÅr Dump-Ausgaben auf Datei und Drucker
  FOR i%=32 TO 255
    MID$(a$,i%+1,1)=CHR$(i%)
  NEXT i%
  ascii$(0)=a$
  ascii$(1)=LEFT$(a$,128)+STRING$(128,".")
  ' ------------------------------
  RESTORE menu_daten
  CLR i%
  DO
    READ m$(i%)
    EXIT IF m$(i%)="*"
    INC i%
  LOOP
menu_daten:
  DATA  S E D   ,  öber uns ,----------------------------,1,2,3,4,5,6,""
  DATA  ZurÅck  ,  Pexec,  Back to the Future ,  Desktop,"",""
  DATA *
  ' --------- Copyright ----------
  cpc%=167543
  CLR cp%
  RESTORE copyright
  READ cp$                ! dient zur Anzeige in HELP
  FOR i%=1 TO LEN(cp$)
    cp%=cp%+ASC(MID$(cp$,i%,1))*i%
  NEXT i%
  IF cp%<>cpc%
    @alrt(1,"Keine VerÑnderungen|am COPYRIGHT-TEXT !!",1,"Abbruch")
    EDIT
  ENDIF
  cp$=ver$+cp$
copyright:
  DATA "  Ω 1989 by Anton Stepper & Claus Brod, D-8772 Marktheidenfeld"
  '
  ' -------------- MenÅ ----------
  RESTORE feldertexte     ! Buttontexte einlesen
  FOR i%=0 TO 14
    FOR j%=0 TO 13
      READ text$(i%,j%)
    NEXT j%
  NEXT i%
  '
feldertexte:
  DATA DISK,FAT,FILE,SEKTOR,HARD,RAM,OUT/IN
  DATA DIR,FUNKTION,DATEI,---,HDX,INFOS,OPTIONS
  '
  DATA DISK,NAME,BOOT,ROOT,CHECK,DRIVE,SAVE
  DATA ,CLEAR,QUICK,FREE,COMPARE,,LOAD
  DATA FAT,CLUSTER,READ,WRITE,SHOW,,FAT 1
  DATA HELP,XOR,TEST,GRAPH,,,FAT 2
  DATA FILE,OPEN,CLOSE,WRITE,REPAIR,VERIFY,
  DATA ,RENAME,ATTR,DATE,,,DUMP
  DATA SEKTOR,PHYSIK,READ,WRITE,CLUSTER,COPY,COMPARE
  DATA ,,,,,,MAGIC
  DATA HARD,READ,WRITE,COMMAND,DEVICE,PROTECT,SHIP
  DATA MODE-,-SENSE,-SELECT,,SEARCH,INFO,ROOT
  DATA RAM,SHOW,READ,WRITE,LOAD,SAVE,DISASS
  DATA ,,,,PRG-LOAD,,
  DATA OUT/IN,DUMP,DATA,ERROR,F-KEY,READ,LOG
  DATA PRINTER,,GET-HELP,GET-INFO,PUT-INFO,,
  DATA DIR,ALL,PATH,FILE,FLD-REN,,ROOT-DIR
  DATA HELP,MKDIR,RMDIR,,SORT,GETDIRSEC,
  DATA FUNKTION,,PEXEC,,,MENö,RESET
  DATA ,,,,,CPU,SOUND
  DATA DATEI,COPY,DELETE,,,,
  DATA ,,CONCAT,CUT,,CRC,SECURE
  DATA ,,,,,,
  DATA ,,,,,,
  DATA HDX,FORMAT,ZERO,PART,BAD,INSTALL,INFO
  DATA ,SAVE,RESTORE,,,,ROOT
  DATA INFOS,,SYSTEM,,FKEY,,
  DATA SIEBEN,BUTTONS,CRC,GET-INFO,,FAT-HELP,DIR-HELP
  DATA OPTIONS,ERR-CLR,MEM-CLR,,,,CURSOR
  DATA ,UHR,SET-TIME,SET-DATE,,DCLICK,HD-SEL
  ' -----------------------------------------------------------------------------
  CLR j%
  RESTORE stat_dta        ! Floppyfehler
  DO
    READ stat$(j%)
    EXIT IF stat$(j%)="*"
    INC j%
  LOOP
stat_dta:
  DATA Ok,Allgemeiner Fehler,Laufwerk nicht bereit,Unbekannter Befehl
  DATA CRC-PrÅfsummenfehler,UngÅltiger Befehl,Spur nicht gefunden
  DATA Bootsektor ungÅltig,Sektor nicht gefunden,Kein Papier,Schreibfehler
  DATA Lesefehler,Allgemeiner Fehler,Diskette schreibgeschÅtzt
  DATA Diskette gewechselt,GerÑt unbekannt,Sektor defekt,Floppy nicht eingelegt
  DATA *
  '
  RESTORE hard_err        ! Harddiskfehler
  CLR hh_max%
  DO
    READ hh_err$(hh_max%)
    EXIT IF hh_err$(hh_max%)="*"
    INC hh_max%
  LOOP
  '
  RESTORE sense_data      ! Harddiskfehler Extended Request Sense
  CLR i%
  DO
    READ sense$(i%)
    EXIT IF sense$(i%)="*"
    INC i%
  LOOP
  RESTORE sense_data
sense_data:
  DATA No Sense,Recovered Error,Not Ready,Medium Error,Hardware Error
  DATA Illegal Request,Unit attention,Data Protect,*
  '
RETURN
PROCEDURE init_ram
  init_mem%=18500
  @malloc(init_mem%)    ! Speicher resevieren
  IF fehler%=0
    @alrt(3,"Speicher voll!",3,"Abbruch")
    EDIT
  ENDIF
  ram%=fehler%                  ! Adresse des Speichers merken fÅr Mfree
  '
  hdread%=ram%          !  1400 Bytes fÅr Harddisk-Treiber
  utis%=ram%+1400       !   600 Bytes fÅr diverse Utilities
  zeile%=ram%+2000      ! 10000 Bytes fÅr Putchar+ZeichensÑtze
  buf%=ram%+12000       !  2048 Bytes fÅr Sektordaten
  buf2%=buf%+buf_size%  !  2048 Bytes fÅr Reservepuffer in HARD
  ak%=buf2%+buf_size%   !  2048 Bytes fÅr Statuspuffer
  '                     ! ----------
  '                     ! 18144 Bytes
  @clear_buf
  com_blk%=hdread%+14
RETURN
PROCEDURE init_do(p_inf$)
  LOCAL a$,b$,i%
  '
  WHILE NOT (EXIST(p_inf$))
    PRINT AT(3,2);coff$;"Suche INFO-Datei"
    FILESELECT "\*.INF",ver$+".INF",p_inf$
    CLR invert%
    felder
    felder_text(u1%)
    kleine_boxen
    EXIT IF p_inf$=""
  WEND
  IF p_inf$=""
    @mfree(ram%)
    EDIT
  ENDIF
  '
  @set_pfad(p_inf$)             ! Pfad setzen
  @get_pfad                     ! fÅr ....
  exe$=pfad$+ver$+".EXE"        ! EXE -Datei
  p_help$=pfad$+ver$+".HLP"     ! HELP-Datei
  floskel$=pfad$+ver$+".KEY"    ! FKEY-Datei
  '
  PRINT AT(3,2);coff$;"Lese  INFO-Datei"
  '
  @fopen(p_inf$,0)              ! Datei îffnen
  @fseek(0,handle%,2)
  fll%=fehler%                  ! LÑnge feststellen
  @fseek(0,handle%,0)           ! Offset 0
  @fread(handle%,fll%)          ! Gesamte Datei einlesen
  @fclose(handle%)              ! Datei schliessen
  a%=1
  @end_of_line(a%,buf$)
  hard%=VAL(a$)                 ! HARDDISK
  @end_of_line(a%,buf$)
  dec%=VAL(a$)                  ! Cursoranzeige
  @end_of_line(a%,buf$)
  tim%=1-VAL(a$)
  @clock                        ! Uhr ein?
  @end_of_line(a%,buf$)
  b$=a$
  @end_of_line(a%,buf$)
  dclick%=VAL(a$)               ! Doppelklick
  u1%=MAX(0,VAL(b$))            ! UntermenÅ
  @end_of_line(a%,buf$)
  inf_u_men$=a$
  FOR i%=1 TO 7
    u_men%(i%)=VAL(MID$(inf_u_men$,i%*3-2,2))
  NEXT i%
  @end_of_line(a%,buf$)
  inf_button$=a$
  FOR i%=1 TO 7
    button%(i%)=VAL(MID$(inf_button$,i%*3-2,2))
  NEXT i%
  @end_of_line(a%,buf$)
  inf_ma$=LEFT$(a$+inf_ma$,15*3)
  WHILE a%<LEN(buf$)
    @end_of_line(a%,buf$)
    IF LEFT$(a$,4)="#PR "
      MID$(ascii$(1),VAL("&H"+MID$(a$,5,2))+1,1)=CHR$(VAL("&H"+MID$(a$,8,2)))
    ENDIF
  WEND
  CLR buf$
  IF u1%
    hpt!=FALSE
    ON u1% GOSUB dum,dum,file_on,disc_on,hard_on,ram_on,dum,dum,dum,file_on,dum,hard_on,dum,dum,dum
    @felder_text(u1%)
  ENDIF
  IF hard%=4
    exe$=pfad$+"CT.EXE"
    IF NOT (EXIST(exe$))
      @alrt(3,"Kann '"+RIGHT$(exe$,20)+"'|nicht finden!",1,"Mist")
      hard%=-1
      exe$=pfad$+ver$+".EXE"    ! normale EXE -Datei
    ENDIF
  ENDIF
  '
  WHILE NOT (EXIST(exe$))
    FILESELECT "\*.EXE",ver$+".EXE",exe$
    CLR invert%
    felder
    felder_text(u1%)
    kleine_boxen
    EXIT IF exe$=""
  WEND
  IF exe$=""
    @mfree(ram%)
    EDIT
  ENDIF
  '
  PRINT AT(9,2);coff$;"EXE "
  BLOAD exe$,ram%
  '
  PRINT AT(9,2);coff$;"KEY "
  @init_floskel
  '
  PRINT AT(9,2);coff$;"HELP"
  @init_help
  '
  IF hard%>=0                   ! "-1" keine Platte
    @unit_ready
  ENDIF
RETURN
PROCEDURE init_help
  LOCAL a$,b$,b%,fll%,i%,j%
  IF DIM?(help$())
    ERASE help$()               ! evtl bei Neustart ?
    help!=FALSE
  ENDIF
  IF EXIST(p_help$)
    @fopen(p_help$,0)           ! Datei îffnen
    @fseek(0,handle%,2)
    fll%=fehler%                ! LÑnge feststellen
    @fseek(0,handle%,0)         ! Offset 0
    @fread(handle%,fll%)        ! Gesamte Datei einlesen
    @fclose(handle%)            ! Datei schliessen
    a%=1
    DIM help$(16,13)
    help!=TRUE
    FOR i%=0 TO 16
      FOR j%=0 TO 12
        b%=INSTR(a%,buf$,CHR$(10))
        help$(i%,j%)=MID$(buf$,a%,b%-a%)
        a%=b%+1
      NEXT j%
      a%=INSTR(a%,buf$,CHR$(10))+1
    NEXT i%
    CLR buf$
  ENDIF
RETURN
PROCEDURE in_help
  fselect("\*.HLP","",p_help$)
  @init_help
RETURN
PROCEDURE init_floskel          ! Existiert Floskeldatei?
  IF EXIST(floskel$)
    @read_floskel(floskel$)
  ENDIF
RETURN
PROCEDURE read_floskel(a$)      ! Floskeldatei lesen
  LOCAL b%,f%,fl%,flo%,frp%,j%
  @fopen(a$,0)
  @fseek(0,handle%,2)
  fl%=fehler%
  @fseek(0,handle%,0)
  @fread(handle%,fl%)           ! gesamte Datei einlesen
  @fclose(handle%)
  a%=1                          ! ab Anfang
  WHILE a%
    @end_of_line(a%,buf$)
    b%=VAL(a$)
    EXIT IF b%<1
    IF b%<=20
      @end_of_line(a%,buf$)
      flo%=VAL(a$)              ! LÑnge
      flos$(0,b%)=a$
      IF flo%<64
        f%=flo%
      ELSE
        f%=64
      ENDIF
      frp%=flo% DIV 64          ! wieoft / 64
      fprest%=flo% MOD 64
      IF frp%
        FOR j%=1 TO frp%
          @end_of_line(a%,buf$)
          flos$(1,b%)=flos$(1,b%)+a$
        NEXT j%
      ENDIF
      IF fprest%
        @end_of_line(a%,buf$)
        flos$(1,b%)=flos$(1,b%)+a$
      ENDIF
    ENDIF
  WEND
RETURN
PROCEDURE end_of_line(ab%,b$)
  LOCAL i%                      ! sucht in String ab Position AB%
  i%=INSTR(ab%,b$,CHR$(10))     ! bis CHR$(10) kommt
  IF i%
    a$=MID$(b$,ab%,i%-ab%)
    a%=i%+1
  ELSE
    a%=LEN(b$)
  ENDIF
RETURN
PROCEDURE in_info
  @info_get
RETURN
PROCEDURE info_get
  LOCAL x1%
  x1%=u1%
  fselect(pfad$+"*.INF",ver$+".INF",a$)
  IF LEN(a$) AND RIGHT$(a$)<>"\"
    @init_do(a$)
  ENDIF
  @kleine_boxen
  u1%=x1%
RETURN
PROCEDURE out_info
  LOCAL x1%
  erg%=1
  @dev(ver$+".INF")
  IF device%<>99
    @eingabe("Harddisk",STR$(hard%),11)
    @fwritec(hdl%,a$)
    IF fehler%>=0
      @fwritec(hdl%,STR$(dec%))
      @fwritec(hdl%,STR$(tim%))
      @eingabe("Nummer des StartmenÅs","0",3)
      @fwritec(hdl%,a$)
      @fwritec(hdl%,STR$(dclick%))
      @fwritec(hdl%,inf_u_men$)
      @fwritec(hdl%,inf_button$)
      @fwritec(hdl%,inf_ma$)
      @alrt(1,"Druckeranpassung|auch schreiben ? ",1,"Ok|Nein")
      IF erg%=1
        FOR x1%=1 TO 256
          @fwritec(hdl%,"#PR "+RIGHT$("0"+HEX$(x1%-1),2)+" "+RIGHT$("0"+HEX$(ASC(MID$(ascii$(1),x1%,1))),2))
        NEXT x1%
      ENDIF
    ENDIF
    @fclose(hdl%)
  ENDIF
RETURN
PROCEDURE media_all             ! Media Change auf allen Laufwerken
  LOCAL i%
  @file_is_open
  FOR i%=0 TO 31
    VOID C:utis%(&H100+i%)
  NEXT i%
RETURN
PROCEDURE media(drv%)           ! Media auf einem Laufwerk
  @file_is_open
  VOID C:utis%(&H100+drv%)
RETURN
PROCEDURE malloc(platz%)        ! Speicher anfordern
  fehler%=GEMDOS(72,L:platz%)
RETURN
PROCEDURE mfree(adresse%)       ! Speicher freigeben
  fehler%=GEMDOS(73,L:adresse%)
  IF fehler%
    @alrt(1,"Fehler bei|Speicherfreigabe ",1,"Aha")
  ENDIF
RETURN
'
' //////////////////////////  Harddisk-Routinen  \\\\\\\\\\\\\\\\\\\\\\\\
'
PROCEDURE mach_schon(op%,block%,c%,s%)  ! Direktes Ansprechen der DMA
  LOCAL h1%,h2%,h3%
  h1%=(block% AND &H1F0000)/65536
  h2%=(block% AND &HFF00)/256
  h3%=(block% AND &HFF)
  LPOKE hdread%+2,buf%                  ! Zeiger auf Puffer
  LPOKE hdread%+6,buf2%                 ! Statuspuffer
  IF op%=8 OR op%=10
    LPOKE buf2%,bps%                    ! Sektorgrîûe beim Schreiben+Lesen
  ENDIF
  IF op%<>18                            ! Inquiry ?
    LPOKE hdread%+10,0                  ! Normal
  ELSE
    LPOKE hdread%+10,1                  ! Extended Mode
  ENDIF
  POKE com_blk%,target%*32+op%          ! Target + Opcode
  POKE com_blk%+1,geraet%*32+h1%        ! GerÑt  + Blocknummer Hi
  POKE com_blk%+2,h2%                   ! Blocknummer mid
  POKE com_blk%+3,h3%                   ! Block       low
  POKE com_blk%+4,c%                    ! Sektoranzahl
  POKE com_blk%+5,s%                    ! Kontrollbyte
  CALL hdread%
  h_status%=LPEEK(hdread%+20)           ! Status holen
  h_tim%=LPEEK(hdread%+24)              ! Timeout?
  IF h_tim%<>0
    tim$=" Timeout"
  ELSE
    tim$=STRING$(8,32)
  ENDIF
  IF op%=8 OR op%=10
    hbyte%=LPEEK(hdread%+28)-buf%
    buf_crc%=C:utis%(&H400,L:buf%,L:bps%,L:&HCDB4)
  ELSE
    hbyte%=bps%
  ENDIF
RETURN
PROCEDURE hard_err                      ! DMA-Fehler erkennen
  LOCAL a$
  h_fehler%=(h_status% AND &HFF0000)/65536
  dma_st%=(h_status% AND &HFF)
  IF hard%=2
    IF hbyte%>255
      IF (h_fehler% AND 2)=0
        CLR h_error%
      ELSE
        h_error%=-1
      ENDIF
    ELSE
      h_error%=-1
    ENDIF
  ELSE
    IF hard%=3
      POKE com_blk%,target%*32+3        ! Target + Opcode (Extended Sense)
      POKE com_blk%+1,geraet%*32        ! GerÑt
      POKE com_blk%+2,0                 ! Blocknummer mid
      POKE com_blk%+3,0                 ! Block       low
      POKE com_blk%+4,22                ! Byteanzahl
      POKE com_blk%+5,0                 ! Control
      CALL hdread%
      sense_key%=PEEK(buf2%+2) AND 15
      h_bl%=LPEEK(buf2%+4)
      h_error%=PEEK(buf2%+12)
      h_error_bl=h_bl%
    ELSE
      POKE com_blk%,target%*32+3          ! Target + Opcode (Request Sense)
      POKE com_blk%+1,geraet%*32          ! GerÑt
      POKE com_blk%+2,0                   ! Blocknummer mid
      POKE com_blk%+3,0                   ! Block       low
      POKE com_blk%+4,4                   ! Byteanzahl
      POKE com_blk%+5,0                   ! Control
      CALL hdread%
      h_bl%=LPEEK(buf2%)                  ! 4 Bytes holen
      h_error%=PEEK(buf2%)
      CLR bit$
      sense_key%=-1
      IF h_error% AND 128
        h_err_bl%=(h_bl% AND &H1FFFFF)    ! unterste 21 Bits
        SUB h_error%,128
      ELSE
        bit$="(?)"
        h_err_bl%=block%
      ENDIF
    ENDIF
    '
    IF LPEEK(hdread%+24)                ! Timeout
      h_error%=-1
    ENDIF
    '
    IF fer%<max_err%-1 AND (h_error% OR h_tim%)
      INC fer%
      a$=tim$+" T"+STR$(target%)+"G"+STR$(geraet%)
      IF h_error%<hh_max% AND h_error%>=0
        err_fld$(fer%)=STR$(h_error%)+"  "+hh_err$(h_error%)+"  "+a$
      ELSE
        err_fld$(fer%)=STR$(h_error%)+" Fehler unbekannt "+a$
      ENDIF
      err_fld$(fer%)=err_fld$(fer%)+" Block "+STR$(h_err_bl%)+bit$
      INC fer%
      '
      IF sense_key%>=0
        err_fld$(fer%)=sense$(sense_key%)
        INC fer%
      ENDIF
      '
    ENDIF
  ENDIF
RETURN
PROCEDURE hard_mode_sense
  @do_mode_sense
  @show_hard_data
  IF hard%<>2
    @help_ex
  ENDIF
RETURN
PROCEDURE do_mode_sense
  LOCAL i%,a$
  IF hard%<>2
    IF hard%=3
      @mach_schon(26,4*256,32,0)        ! Mode Sense Page 4
    ELSE
      @mach_schon(26,0,24,0)            ! Mode Sense
    ENDIF
    bps%=PEEK(buf2%+9)*65536+PEEK(buf2%+10)*256+PEEK(buf2%+11)
    @cbps
    hi_cc%=PEEK(buf2%+13)*256+PEEK(buf2%+14)
    hi_dhc%=PEEK(buf2%+15)
    hi_rwcc%=DPEEK(buf2%+16)
    hi_wpc%=DPEEK(buf2%+18)
    hi_lz%=PEEK(buf2%+20)
    hi_rt%=PEEK(buf2%+21)
    hi_spt%=PEEK(buf2%+23)
    hi_size%=hi_cc%*hi_dhc%*hi_spt%
    '
    IF hard%=3
      hi_cc%=PEEK(buf2%+14)*65536+PEEK(buf2%+15)*256+PEEK(buf2%+16)
      hi_size%=PEEK(buf2%+5)*65536+PEEK(buf2%+6)*256+PEEK(buf2%+7)
      hi_dhc%=PEEK(buf2%+17)
      hi_rt%=DPEEK(buf2%+24)
      '
      @mach_schon(18,0,56,0)            ! Inquiry
      a$=STRING$(24,0)
      BMOVE buf2%+8,VARPTR(a$),24
      INC fer%
      err_fld$(fer%)=a$+"  T"+STR$(target%)+"G"+STR$(geraet%)
      '
      @mach_schon(26,3*256,36,0)        ! Mode Sense Page 3
      hi_spt%=PEEK(buf2%+22)*256+PEEK(buf2%+23)
      IF hi_spt%=0 AND hi_cc%<>0 AND hi_dhc%<>0
        hi_spt%=hi_size%/hi_cc%/hi_dhc%
      ENDIF
      hi_bbs%=PEEK(buf2%+24)*256+PEEK(buf2%+25)
      hi_in%=PEEK(buf2%+26)*256+PEEK(buf2%+27)
      hi_rwcc%=hi_cc%+1
      hi_wpc%=hi_cc%+1
    ENDIF
  ELSE
    bps%=512
  ENDIF
RETURN
PROCEDURE show_hard_data
  IF hard%<>2
    @screen
    zz%=1
    erg%=3
    zx%=4
    @ausgabe("Bytes pro Sektor      : "+STR$(bps%))
    @ausgabe("Anzahl der Zylinder   : "+STR$(hi_cc%))
    @ausgabe("Anzahl der Kîpfe      : "+STR$(hi_dhc%))
    @ausgabe("Red. Schreibstrom ab  : "+STR$(hi_rwcc%))
    @ausgabe("Vorkompensation ab    : "+STR$(hi_wpc%))
    @ausgabe("Breite der Parkzone   : "+STR$(hi_lz%))
    @ausgabe("Steprate              : "+STR$(hi_rt%))
    @ausgabe("Sektoren pro Track    : "+STR$(hi_spt%))
    @ausgabe("Grîûe der Platte      : "+STR$(hi_size%))
  ELSE
    @nix_vortex
  ENDIF
RETURN
PROCEDURE hard_mode_select
  IF hard%<>2
    @do_mode_sense
    @show_hard_data
    @hard_param
    @do_mode_select
    @screen
    @list
  ELSE
    @nix_vortex
  ENDIF
RETURN
PROCEDURE do_mode_select
  IF hard%<>3
    @cbps
    POKE buf2%+9,(bps% AND &HFF0000) DIV 65536  ! Sektorgrîûe high
    POKE buf2%+10,(bps% AND &HFF00) DIV 256     !   '     '   mid
    POKE buf2%+11,(bps% AND &HFF)               !   '     '   low
    POKE buf2%+12,1                     ! List Format
    POKE buf2%+13,hi_cc% DIV 256        ! Anzahl der Zylinder
    POKE buf2%+14,hi_cc% MOD 256
    POKE buf2%+15,hi_dhc%               ! Anzahl der Kîpfe
    POKE buf2%+16,hi_rwcc% DIV 256      ! Reduzierter Schreibstrom
    POKE buf2%+17,hi_rwcc% MOD 256      ! ab Zylinder Hi_rwcc
    POKE buf2%+18,hi_wpc% DIV 256       ! Vorkompensation ab
    POKE buf2%+19,hi_wpc% MOD 256       ! Zylinder Hi_wpc
    POKE buf2%+20,hi_lz%                ! Abstand der Parkspur
    POKE buf2%+21,hi_rt%                ! Seekrate
    POKE buf2%+22,0                     !
    POKE buf2%+23,hi_spt%               ! Sektoren pro Track
    IF hard%<>2
      @mach_schon(21,0,24,0)             ! MODE SELECT
      @hard_err
    ENDIF
  ENDIF
RETURN
PROCEDURE hdx_format
  @alrt(1,"Harddisk formatieren?",0," Format |Abbruch")
  IF erg%=1
    @no_protekt
    IF erg2%=1
      @root_sec(1)
      root$=STRING$(bps%,0)
      BMOVE buf%,VARPTR(root$),bps%
      PRINT coff$
      '
      @hard_param
      LPOKE buf2%,8             ! LÑnge der Extent Descriptor List
      LPOKE buf2%+4,0
      POKE buf2%+8,0
      IF hard%<>2
        @do_mode_select
      ENDIF
      b%=pt%*256+2*65536
      b%=b%+(hi_in% DIV 256)
      c%=hi_in% MOD 256
      IF hard%=2 OR hard%=3
        CLR b%
      ENDIF
      LPOKE buf2%,0
      '
      @alrt(1,"Letzte Chance:",0," Format |Abbruch")
      IF erg%=1
        @mach_schon(4,b%,c%,0)          ! Format Drive
        @hard_err
        IF h_error%<>0
          @alrt(1,"Fehler "+STR$(h_error%)+"|beim Formatieren!",1,"Abbruch")
        ELSE
          BMOVE VARPTR(root$),buf%,bps%
          @set_root
          @media_all
          LPOKE buf%+&H1C6,&H147454D
          LPOKE buf%+&H1CA,1            ! fÅr P_start(0)
          LPOKE buf%+&H1CE,100          ! Dummy-Partitions-ID
          FOR t%=buf%+&H156 TO buf%+&H1AE STEP 4
            LPOKE t%,0
          NEXT t%
          FOR t%=buf%+&H1D2 TO buf%+&H1FA STEP 4
            LPOKE t%,0
          NEXT t%                       ! Rest des Rootsektors lîschen
          POKE buf%+&H151,1             ! Root-Version 1
          IF hard%=2
            PAUSE 400                   ! Vortex !!
          ENDIF
          @mach_schon(10,0,1,0)         ! Write Rootsector
          @hard_err
        ENDIF
      ENDIF
      @info
    ENDIF
  ENDIF
RETURN
' Routine liest alle Sektoren einer Partition
' wenn ein Fehler auftritt, wird der betreffende Cluster in der FAT belegt
PROCEDURE hdx_bad
  LOCAL mb%,t%,x1%
  @root_sec(1)
  IF h_error%=0
    @part_select
    IF part%>=0
      IF hard%<>2
        @mach_schon(26,0,24,0)          ! Mode Sense wenns geht
        hi_dhc%=PEEK(buf2%+15)
        hi_spt%=PEEK(buf2%+23)
      ELSE
        @root_sec(1)                    ! Bei VORTEX aus Rootsektor holen
        hi_dhc%=PEEK(buf%+&H1B8)        ! Kîpfe
        hi_spt%=PEEK(buf%+&H1C1)        ! Sektoren pro Track
      ENDIF
      IF (p_flag%(part%) AND 1)=0
        @alrt(1,"Partition existiert nicht!",1,"Abbruch")
      ELSE
        @screen
        @mach_schon(8,p_start%(part%),1,0)      ! Bootsektor lesen
        len_dir%=(PEEK(buf%+18)*256+PEEK(buf%+17))/16
        len_fat%=PEEK(buf%+23)*256+PEEK(buf%+22)
        bps%=PEEK(buf%+12)*256+PEEK(buf%+11)
        @cbps
        anf_dat%=1+len_fat%*2+len_dir%
        fehler%=TRUE
        IF len_fat%>old_len_fat% AND fmal%      ! wenn schon mal reserviert
          @mfree(fatbuf%)                       ! und zu klein, dann freigeben
          CLR fmal%
        ENDIF
        IF fmal%=0
          @ram_for_fat
        ENDIF
        IF fehler%
          fmal%=1
          FOR t%=1 TO len_fat%
            @mach_schon(8,p_start%(part%)+t%+len_fat%,1,0)
            @hard_err
            BMOVE buf%,fatbuf%+(t%-1)*512,512
          NEXT t%
          CLR bad%
          IF status%=0
            PRINT AT(5,6);"Partition  :"'part%
            PRINT AT(5,7);"Sektoren   :"'p_size%(part%)
            PRINT AT(5,10);"Akt. Sektor:"
            PRINT AT(5,11);"Bad        :"
            anz%=buf_size%*2/bps%
            '
            FOR mb%=anf_dat% TO p_size%(part%)-1 STEP anz%
              PRINT AT(18,10);mb%
              @mach_schon(8,mb%+p_start%(part%),anz%,0)
              @hard_err
              IF h_error%
                FOR j%=0 TO anz%
                  @mach_schon(8,mb%+j%+p_start%(part%),1,0)
                  @hard_err
                  IF h_error%
                    INC bad%
                    bw%=MAX(0,INT((mb%+j%-anf_dat%)/spc%)+2)
                    PRINT AT(18,11);bad%;
                    @write_in_fat(&HFFF7,bw%)
                  ENDIF
                NEXT j%
              ENDIF
              @was_ist
              IF abb%=2
                mb%=9999997
              ENDIF
            NEXT mb%
            '
            IF bad%<>0 AND mb%<>9999999
              @alrt(1,"FAT schreiben? ",0,"Jadoch|Abbruch")
              IF erg%=1
                FOR t%=1 TO len_fat%
                  BMOVE fatbuf%+(t%-1)*512,buf%,512
                  @mach_schon(10,p_start%(part%)+t%,1,0)
                  @mach_schon(10,p_start%(part%)+len_fat%+t%,1,0)
                NEXT t%
              ENDIF
            ENDIF
          ENDIF
          @mach_schon(8,block%,1,0)
          @screen
        ELSE
          @alrt(1,"Speicherplatzprobleme",1,"Waaah!")
        ENDIF
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE hard_param
  @eingabe("Sektorgrîûe in Bytes ",STR$(bps%),6)
  bps%=VAL(a$)
  @cbps
  @eingabe("Anzahl der Zylinder",STR$(hi_cc%),6)
  hi_cc%=VAL(a$)
  @eingabe("Anzahl der Kîpfe",STR$(hi_dhc%),4)
  hi_dhc%=VAL(a$)
  @eingabe("Reduzierter Schreibstrom ab",STR$(hi_rwcc%),6)
  hi_rwcc%=VAL(a$)
  @eingabe("Vorkompensation ab",STR$(hi_wpc%),6)
  hi_wpc%=VAL(a$)
  @eingabe("Abstand der Parkspur",STR$(hi_lz%),4)
  hi_lz%=VAL(a$)
  @eingabe("Steprate",STR$(hi_rt%),4)
  hi_rt%=VAL(a$)
  @eingabe("Virgin pattern","$CB",4)
  pt%=VAL(a$)
  @eingabe("Interleavefaktor",STR$(hi_in%),4)
  hi_in%=VAL(a$)
  @eingabe("Sektoren pro Track",STR$(hi_spt%),4)
  hi_spt%=VAL(a$)
RETURN
PROCEDURE set_root
  POKE buf%+&H151,1                     ! Root-Version 1
  DPOKE buf%+&H1B6,hi_cc%               ! Zylinder
  POKE buf%+&H1B8,hi_dhc%               ! Kîpfe
  DPOKE buf%+&H1BA,hi_rwcc%             ! First cyl with reduced write current
  DPOKE buf%+&H1BC,hi_wpc%              !   '    '   with precompensation
  POKE buf%+&H1BE,hi_lz%                ! Breite der Parkzone
  POKE buf%+&H1BF,hi_rt%                ! Steprate
  POKE buf%+&H1C0,hi_in%                ! Interleave
  POKE buf%+&H1C1,hi_spt%               ! Sektoren pro Track
  IF hi_size%=0
    hi_size%=hi_cc%*hi_dhc%*hi_spt%
  ENDIF
  LPOKE buf%+&H1C2,hi_size%             ! Grîûe der Platte
  CLR s%
  FOR t%=0 TO bps%-2 STEP 2
    s%=s%+DPEEK(buf%+t%)                ! Alle Worte zusammenzÑhlen
  NEXT t%
  DPOKE buf%+&H1FE,&H1234-s%            ! Checksumme muû $1234 sein
RETURN
PROCEDURE part_select
  REPEAT
    part%=-1
    a%=p_anz%
    @eingabe("Welche Partition (0-"+STR$(a%)+") :","",4)
    IF el%
      a%=VAL(a$)
      IF a%=0 AND a$<>"0"
        a%=-1
      ENDIF
      IF a%>=0 AND a%<=p_anz%
        part%=a%
      ENDIF
    ENDIF
    erg%=1
    IF part%>=0
      IF p_id$(part%)<>"GEM"
        @alrt(1,"Dies ist keine    |GEM-Partition.|Weitermachen?",0,"OK|Nie")
      ENDIF
    ENDIF
  UNTIL erg%=1
RETURN
PROCEDURE hdx_zero              ! Nur FAT- und Verzeichnissektoren lîschen
  @root_sec(1)
  @part_select
  IF part%>=0
    IF (p_flag%(part%) AND 1)=0
      @alrt(3,"Partition existiert nicht!",1,"Abbruch")
    ELSE
      @no_protekt
      IF erg2%=1
        @find_block(part%)
        @clr_part(part%,block%)
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE get_root_info
  @root_sec(1)
  FOR i%=0 TO 11
    po_size%(i%)=p_size%(i%)
    po_start%(i%)=p_start%(i%)
  NEXT i%
  CLR h_error%
  @alrt(1,"Plattenparameter eingeben?",1,"Nein|Ja")
  IF erg%=1
    @do_mode_sense
    @hard_err
  ELSE
    @hard_param
  ENDIF
RETURN
PROCEDURE hdx_part
  @no_protekt
  IF erg2%=1
    @eingabe("Anzahl der Partitionen:","",3)
    IF el%
      part%=VAL(a$)-1
      IF part%>=0 AND part%<12
        @get_root_info
        IF h_error%=0
          @alrt(0,"Rootsektor laden?",2,"Ja|Nee|Abbruch")
          IF erg%<3
            IF erg%=1
              @read_buf("SEDROOT.DAT")    ! Rootsektor laden ...
              ch!=FALSE
              IF read%=0
                GOTO hdx_part_ex
              ENDIF
            ENDIF
            @set_root                     ! .... in den Puffer und ...
            root$=STRING$(bps%,0)
            BMOVE buf%,VARPTR(root$),bps% ! retten.
            '
            @alrt(0,"Bootsektor laden?",2,"Ja|Nee|Abbruch")
            IF erg%<3
              IF erg%=1
                @read_buf("SEDBOOT.DAT")  ! Bootsektor laden
                ch!=FALSE
                IF read%=0
                  GOTO hdx_part_ex
                ENDIF
              ENDIF
              FOR i%=0 TO part%
                boot$(i%)=STRING$(bps%,0)
                IF p_start%(i%)<>0
                  IF erg%=2
                    @mach_schon(8,p_start%(i%),1,0) ! Lies Bootsektor von Platte
                  ENDIF
                  BMOVE buf%,VARPTR(boot$(i%)),bps% ! von Puffer lesen
                ENDIF
              NEXT i%
              i%=part%+1
              WHILE i%<12
                p_size%(i%)=0     ! Nicht vorhandene Partitionsinfo lîschen
                p_start%(i%)=0
                INC i%
              WEND
              IF p_start%(0)=0
                INC p_start%(0)
              ENDIF
              bg%=6
              bz%=part%+1
              @screen
              @show_part          ! alte Werte anzeigen
              @get_part_size      ! neue Eingeben
              '
              @alrt(2,"Partitionieren |Letzte Chance!",0,"Weiter|Abbruch")
              IF erg%=1
                @do_part          ! Partitionen schreiben
                IF mp%<>99        ! War Fehler oder Abbruch ?
                  @do_root        ! Rootsektor schreiben
                ENDIF
              ENDIF
            hdx_part_ex:
              CLR mx%,my%,block%
              @lesen
              @screen
            ENDIF
          ENDIF
        ELSE
          @alrt(3,"Format-Fehler",1,"Abbruch")
        ENDIF
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE get_part_size         ! Routine lÑût Partitionsgrîûen eingeben
  LOCAL kerg%,gerg%             ! in Verbindung mit SHOW-PART
  DO                            ! Wenn Sektoren Åbrig : AUTO-FUNKTION
    DO
      a$=INKEY$
      MOUSE mx%,my%,mk%
      EXIT IF mk%=2 OR a$=esc$
      IF mk%=1
        IF my%>=(bg%-1)*zh% AND my%<(bg%+bz%)*zh%
          wa%=my%/zh%-5
          IF wa%>=0 AND wa%<part%+1
            IF mx%<380
              @eingabe("Part "+STR$(wa%)+" (Sektoren):",STR$(p_size%(wa%)),6)
              IF LEFT$(UPPER$(a$),1)="R"
                @rest_of
              ELSE
                p_size%(wa%)=VAL(a$)
              ENDIF
            ELSE
              @eingabe("Part "+STR$(wa%)+" (Mbyte):",STR$(INT(p_size%(wa%)/2048)),6)
              IF LEFT$(UPPER$(a$),1)="R"
                @rest_of
              ELSE
                p_size%(wa%)=INT(VAL(a$)*2048)
              ENDIF
            ENDIF
            @show_part          ! geÑnderte Werte zeigen
          ENDIF
        ENDIF
      ENDIF
    LOOP
    kerg%=2                     ! Default Ok
    gerg%=3
    IF s_total%>hi_size%
      @alrt(1,"Sie haben mehr belegt,|als da ist!!",1,"Nochmal|Weiter")
      kerg%=erg%
    ELSE
      IF s_total%<hi_size%
        @alrt(1,"Sie haben weniger belegt,|als da ist!?",1,"AUTO|Nochmal|Weiter")
        gerg%=erg%
        IF gerg%=1
          @auto_part
        ENDIF
      ENDIF
    ENDIF
    EXIT IF kerg%=2 AND gerg%=3
  LOOP
RETURN
PROCEDURE auto_part             ! Partitionen auf Zylindergrenzen legen
  LOCAL i%                      ! Bringt SPEED
  FOR i%=1 TO part%
    @find_block(i%)
    WHILE block% MOD (hi_spt%*hi_dhc%)
      INC block%
      INC p_size%(i%-1)
      @find_block(i%)
    WEND
  NEXT i%
  wa%=part%
  @rest_of
RETURN
PROCEDURE do_part               ! Partitionieren ausfÅhren
  CLR i%
  WHILE po_start%(i%)=p_start%(i%) AND po_size%(i%)=p_size%(i%) AND i%<part%
    INC i%
  WEND
  a$=STR$(i%)
  mp%=i%
  IF i%<>0
    @eingabe("Ab Partition "+STR$(i%)+" partitionieren ?",a$,3)
    IF e.l% OR VAL(a$)>part% OR VAL(a$)<0
      mp%=99
    ELSE
      mp%=VAL(a$)
    ENDIF
  ENDIF
  '
  IF mp%<99
    FOR m%=mp% TO part%         ! Anzahl der Partitionen
      IF p_size%(m%)>0
        PRINT AT(4,17);"Schreibe Partition ";m%;" auf ACSI-Einheit ";target%;", GerÑt ";geraet%
        '
        a%=VAL(MID$(bb$,14,1))
        @eingabe("Clustergrîûe in Sektoren:",STR$(a%),4)
        IF LEN(a$)
          spc%=VAL(a$)
        ELSE
          spc%=2
        ENDIF
        '
        bb$=boot$(m%)                   ! Bootsektor bearbeiten
        MID$(bb$,12,2)=CHR$(0)+CHR$(2)  ! Bytes/Sektor
        MID$(bb$,14,1)=CHR$(spc%)       ! 2 Sektoren/Cluster
        MID$(bb$,15,2)=CHR$(1)+CHR$(0)  ! 1 reservierter Sektor
        MID$(bb$,17,1)=CHR$(2)          ! 2 FATs
        '
        ' Dynamische Berechnung der Dir-LÑnge
        ' 1MB -> 8 Sektoren, 10MB -> 17 Sektoren, 30MB -> 20 Sektoren
        '
        lendir%=INT(MIN(7+p_size%(m%)/2000,20))*16
        '
        MID$(bb$,18,2)=CHR$(lendir% MOD 256)+CHR$(lendir% DIV 256)
        MID$(bb$,20,2)=CHR$(p_size%(m%) MOD 256)+CHR$(p_size%(m%) DIV 256)
        MID$(bb$,22,1)=CHR$(&HF8)               ! Mediabyte
        lenfat%=(p_size%(m%)/bps%+1)*spc%/2     ! Grîûe der Fat
        MID$(bb$,23,2)=CHR$(lenfat%)+CHR$(0)    ! Sektoren/FAT
        MID$(bb$,25,2)=CHR$(hi_spt%)+CHR$(0)    ! Sektoren/Track
        MID$(bb$,27,2)=CHR$(hi_dhc%)+CHR$(0)    ! Seiten
        MID$(bb$,29,2)=CHR$(0)+CHR$(0)          ! 0 versteckte Sektoren
        MID$(bb$,3,6)=ver2$                     ! OEM-Kennung
        @find_block(m%)
        BMOVE VARPTR(bb$),buf%,bps%             ! Block in Buffer
        x1%=&H1C6+m%*12+(m%>3)*&HA0
        IF (PEEK(VARPTR(root$)+x1%) AND 128)    ! war Part. bootfÑhig?
          VOID XBIOS(18,L:buf%,L:4097*4096,-1,1) ! ja, dann ausfÅhrbar machen
        ENDIF
        @media_all
        @mach_schon(10,block%,1,0)              ! schreibe Bootsektor
        @hard_err
        IF h_error%=0
          @clr_part(m%,block%)                  ! Lîsche Partition ab Block%+1
        ELSE
          @alrt(3,"Plattenfehler "+STR$(h_error%)+"|beim Anlegen der|Partition "+STR$(m%),1,"Holla")
        ENDIF
      ENDIF
    NEXT m%
  ENDIF
RETURN
PROCEDURE do_root
  @eingabe("Welche Part. bootbar (-1=keine)","0",2)
  b%=VAL(a$)
  BMOVE VARPTR(root$),buf%,bps%
  FOR i%=0 TO 11
    x1%=buf%+&H1C6+i%*12+(i%>3)*&HA0
    IF p_size%(i%)>0
      POKE x1%,1 OR ABS(128*(i%=b%))    ! Exist-Flag + Bootflag
      @eingabe("Kennung Part. "+STR$(i%)+" ACSI "+STR$(target%)+" :","GEM",3)
      IF LEN(a$)<3
        a$=RIGHT$("   "+a$,3)
      ENDIF
      POKE x1%+1,ASC(a$)
      POKE x1%+2,ASC(MID$(a$,2,1))      ! Kennung schreiben
      POKE x1%+3,ASC(MID$(a$,3,1))
      LPOKE x1%+4,p_start%(i%)          ! Anfang
      LPOKE x1%+8,p_size%(i%)           ! und Grîûe
    ELSE
      LPOKE x1%,0                       ! Nicht benÅtzte Partitionen lîschen
      LPOKE x1%+4,0
      LPOKE x1%+8,0
    ENDIF
  NEXT i%
  POKE buf%+&H151,1                     ! Root-Version 1
  IF part%>3
    LPOKE buf%+&H152,ext_magic%         ! Wenn mehr als 4 Partitionen --> MAGIC
  ENDIF
  IF b%>-1
    VOID XBIOS(18,L:buf%,L:-1,-1,1)     ! Bootbar machen ??
  ENDIF
  @media_all
  @mach_schon(10,0,1,0)                 ! Schreibe Rootsector
  @hard_err
  IF b%>-1
    @find_block(b%)                     ! passenden Bootsektor
    @mach_schon(8,block%,1,0)           ! finden und ausfÅhrbar machen
    VOID XBIOS(18,L:buf%,L:4097*4096,-1,1)
    @mach_schon(10,block%,1,0)
    @hard_err
  ENDIF
RETURN
PROCEDURE find_block(pa%)
  CLR j%
  block%=p_start%(0)
  WHILE j%<pa%
    ADD block%,p_size%(j%)              ! Berechne Blocknummer anhand der
    INC j%                              ! Åbergebenen Partitionsnummer
  WEND
  p_start%(pa%)=block%
RETURN
PROCEDURE clr_part(m%,block%)           ! Partition lîschen (SOFT)
  LOCAL t%,x1%
  @mach_schon(8,block%,1,0)             ! Bootsektor der Partition lesen
  t%=(PEEK(buf%+17)+256*PEEK(buf%+18))/16 ! LÑnge des Verzeichnisses
  x1%=(PEEK(buf%+23)*256+PEEK(buf%+22))*PEEK(buf%+16)+t%
  fat$=STRING$(bps%,0)                  ! Leerstring fÅr FAT+Dir
  BMOVE VARPTR(fat$),buf%,bps%          ! String in Buffer
  @media_all
  fat1%=block%+1
  FOR t%=1 TO x1%
    @mach_schon(10,block%+t%,1,0)       ! FAT+DIR schreiben
    @hard_err
  NEXT t%
RETURN
PROCEDURE show_part                     ! In Verbindung mit PART
  @add_size
  FOR i%=0 TO part%
    PRINT AT(15,i%+bg%);"Partition ";i%'''
    PRINT AT(28,i%+bg%);RIGHT$("       "+STR$(p_size%(i%)),7)'
    PRINT AT(39,i%+bg%);"Sektoren  ";USING "####.##",INT((p_size%(i%)/2048)*100)/100;
    PRINT " Mbyte"
  NEXT i%
  PRINT AT(10,bg%-2);"Sektoren frei : ";RIGHT$("        "+STR$(hi_size%-s_total%),8)'
RETURN
PROCEDURE add_size                      ! Addition aller Partitionen
  LOCAL i%
  s_total%=p_start%(0)
  FOR i%=0 TO part%
    ADD s_total%,p_size%(i%)
  NEXT i%
RETURN
PROCEDURE rest_of                       ! Wenn in PART-Eingabe "r" oder "R"
  @add_size
  p_size%(wa%)=p_size%(wa%)+hi_size%-s_total%
  @show_part
RETURN
PROCEDURE no_protekt
  @alrt2(1,"Achtung:|Schreibschutz|hilft nix!",1,"Klar|Ohhh..")
RETURN
PROCEDURE hard_command          ! Beliebiges Kommando an die Platte schicken
  @alrt(1,"Anzeigepuffer    |mitschicken?",1,"Ja|Nein")
  IF erg%=1
    BMOVE buf%,buf2%,bps%
  ELSE
    a$=STRING$(bps%,0)
    BMOVE VARPTR(a$),buf2%,bps%
    CLR a$
  ENDIF
  @eingabe("Befehls-Code:","",6)
  WHILE LEN(a$)
    code%=VAL(a$)
    @eingabe("Parameterbyte 1 :","",6)
    EXIT IF e.l%
    h1%=VAL(a$)
    @eingabe("Parameterbyte 2 :","",6)
    EXIT IF e.l%
    h2%=VAL(a$)
    @eingabe("Parameterbyte 3 :","",6)
    EXIT IF e.l%
    h3%=VAL(a$)
    h1%=h1%*65536
    h2%=h2%*256
    @eingabe("Parameterbyte 4 :","",6)
    EXIT IF e.l%
    h4%=VAL(a$)
    @eingabe("Parameterbyte 5 :","",6)
    EXIT IF e.l%
    h5%=VAL(a$)
    @media_all
    @mach_schon(code%,h1%+h2%+h3%,h4%,h5%)
    @alrt(1,"RETURN-Puffer kopieren",1,"Ja|Nein")
    IF erg%=1
      BMOVE buf2%,buf%,bps%
    ENDIF
    @hard_err
    EXIT IF 1
  WEND
RETURN
PROCEDURE hard_device           ! Target und GerÑt einstellen
  LOCAL a%
  @eingabe("Targetnummer :",STR$(target%),4)
  IF el%
    a%=VAL(a$)
    IF a%>=0 AND a%<8
      target%=a%
    ENDIF
    @eingabe("GerÑtenummer :",STR$(geraet%),4)
    a%=VAL(a$)
    IF a%>=0 AND a%<8
      geraet%=a%
    ENDIF
    @unit_ready
  ENDIF
RETURN
PROCEDURE unit_ready
  @mach_schon(0,0,0,0)          ! Unit Ready
  @hard_err
  IF h_error%=0
    @root_sec(1)
  ENDIF
RETURN
PROCEDURE hard_dev              ! Target einstellen
  LOCAL a%
  @eingabe("Targetnummer :",STR$(target%),4)
  IF el%
    a%=VAL(a$)
    IF a%>=0 AND a%<8
      @change
      target%=a%
    ENDIF
    @unit_ready
  ENDIF
RETURN
PROCEDURE hard_unit             ! GerÑt einstellen
  LOCAL a%
  @eingabe("GerÑtenummer :",STR$(geraet%),4)
  IF el%
    a%=VAL(a$)
    IF a%>=0 AND a%<8
      @change
      geraet%=a%
    ENDIF
    @unit_ready
  ENDIF
RETURN
PROCEDURE hard_read             ! Blocknummer eingeben und lesen
  @change
  @eingabe("Blocknummer","",6)
  IF el% AND VAL(a$)>=0
    block%=VAL(a$)
    @hard_read_sec(block%)
    ch!=FALSE
  ENDIF
RETURN
PROCEDURE hard_read_sec(block%)
  @mach_schon(8,block%,1,0)     ! Read Sektor
  @hard_err
  IF h_error%=0 AND h_tim%=0
    @translate
  ENDIF
RETURN
PROCEDURE translate     ! Blocknummer in Kopf und Spur umrechnen lassen
  IF hard%=0
    @mach_schon(15,block%,0,0)
    zyl%=PEEK(buf2%)*4096+PEEK(buf2%+1)*256+PEEK(buf2%+2)
    kopf%=PEEK(buf2%+3)
  ELSE
    IF hard%<>2
      IF hi_spt%>0 AND hi_dhc%>0
        zyl%=block%/(hi_spt%*hi_dhc%)   ! oder von Hand umrechnen (MEGAFILE)
        kopf%=(block%-(zyl%*hi_spt%*hi_dhc%))/hi_spt%
      ELSE
        CLR zyl%,kopf%
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE hard_write    ! Blocknummer eingeben und schreiben
  @eingabe("Blocknummer",STR$(block%),6)
  IF el%
    ch!=FALSE
    block%=VAL(a$)
    @media_all
    @mach_schon(10,block%,1,0)
    @hard_err
  ENDIF
RETURN
PROCEDURE hard_ship             ! Parken
  IF hard%=2
    @mach_schon(31,0,0,0)
  ELSE
    @mach_schon(27,0,0,0)
  ENDIF
  @hard_err
  @info
RETURN
PROCEDURE root_sec(rt%)
  LOCAL x1%,i%
  CLR h_error%,block%
  IF rt%=1
    @mach_schon(8,block%,1,0)   ! Rootsektor lesen
    @hard_err
  ENDIF
  IF h_error%=0
    @do_mode_sense
    @cbps
    @hard_err
    IF h_error%<>0 OR hard%=2
      hi_cc%=DPEEK(buf%+&H1B6)          ! Zylinder
      hi_dhc%=PEEK(buf%+&H1B8)          ! Kîpfe
      hi_rwcc%=DPEEK(buf%+&H1BA)        ! 1. Spur mit reduziertem Schreibstrom
      hi_wpc%=DPEEK(buf%+&H1BC)         !   '    '    Vorkompensation
      hi_lz%=PEEK(buf%+&H1BE)           ! Breite der Parkzone
      hi_rt%=PEEK(buf%+&H1BF)           ! Steprate
      hi_spt%=PEEK(buf%+&H1C1)          ! Sektoren pro Track
      hi_size%=LPEEK(buf%+&H1C2)        ! Grîûe der Platte
    ENDIF
    IF hard%<>3
      hi_in%=PEEK(buf%+&H1C0)           ! Interleave
    ENDIF
    bsl_start%=LPEEK(buf%+&H1F6)        ! Bad Sektor List
    bsl_count%=LPEEK(buf%+&H1FA)        ! Bad Sektor Count
    root_vers%=PEEK(buf%+&H151)         ! Version des Rootsektors
    '
    ARRAYFILL p_flag%(),0
    ARRAYFILL p_start%(),0
    ARRAYFILL p_size%(),0
    FOR i%=0 TO 11
      p_id$(i%)="   "                   ! alles lîschen
    NEXT i%
    '
    CLR p_anz%
    @viererblock(buf%+&H1C6,0)
    IF a%>=0
      p_anz%=a%
    ENDIF
    @viererblock(buf%+&H156,4)
    IF a%>=0
      p_anz%=a%+4
    ENDIF
    @viererblock(buf%+&H186,8)
    IF a%>=0
      p_anz%=a%+8
    ENDIF
    '
    @translate                          ! anzeigen wo wir sind
    @chk_sum
  ENDIF
RETURN
PROCEDURE viererblock(pnt%,pnr%)
  LOCAL b%,c%,i%,j%,kennbyte%,p%
  a%=-1
  FOR i%=0 TO 3
    p%=pnt%+i%*12
    kennbyte%=PEEK(p%)
    IF kennbyte%=1 OR kennbyte%=&H81
      b%=1
      FOR j%=1 TO 3
        c%=PEEK(p%+j%)
        IF c%<65 OR c%>ASC("z")
          CLR b%
        ENDIF
      NEXT j%
      IF b%
        b%=LPEEK(p%+4)
        IF b%>0 AND b%<hi_size%
          b%=LPEEK(p%+8)
          IF b%>0 AND b%<hi_size%
            p_flag%(i%+pnr%)=kennbyte%
            p_id$(i%+pnr%)=MID$(ascii$(0),PEEK(p%+1)+1,1)+MID$(ascii$(0),PEEK(p%+2)+1,1)+MID$(ascii$(0),PEEK(p%+3)+1,1)
            p_start%(i%+pnr%)=LPEEK(p%+4)
            p_size%(i%+pnr%)=b%
            a%=i%
          ENDIF
        ENDIF
      ENDIF
    ENDIF
  NEXT i%
RETURN
PROCEDURE hard_root
  LOCAL a$,i%
  @alrt(1,"Rootsektor-Ausgabe auf",3,ddm$)
  @dev("ROOT.TXT")
  IF device%<>99 OR erg%=3
    @screen
    @root_sec(1)
    IF h_error%=0
      zz%=2
      zx%=4
      @ausgabe("Anzahl der Zylinder   : "+STR$(hi_cc%))
      @ausgabe("Anzahl der Kîpfe      : "+STR$(hi_dhc%))
      @ausgabe("Breite der Parkzone   : "+STR$(hi_lz%))
      @ausgabe("Steprate              : "+STR$(hi_rt%))
      @ausgabe("Interleave            : "+STR$(hi_in%))
      @ausgabe("Sektoren pro Spur     : "+STR$(hi_spt%))
      @ausgabe("Sektoren insgesamt    : "+STR$(hi_size%))
      @ausgabe("Bad Sektor List ab    : $"+RIGHT$(n$+HEX$(bsl_start%),6))
      @ausgabe("LÑnge der BSL         : $"+RIGHT$(n$+HEX$(bsl_count%),6))
      @ausgabe("Rootsektorversion     : "+STR$(root_vers%))
      @ausgabe("PrÅfsumme             : $"+RIGHT$(n$+HEX$(chk_sum%),4))
      IF erg%=3
        PRINT AT(4,2);"Rootsektor (Target ";target%;", GerÑt ";geraet%;")    Part ID   Start  Size  Flag"
      ELSE
        @ausgabe("Rootsektor von Target "+STR$(target%)+", GerÑt "+STR$(geraet%))
        @ausgabe("    ID   Start  Size  Flag")
      ENDIF
      FOR i%=0 TO p_anz%
        a$=RIGHT$(n$+STR$(i%),2)+" "
        a$=a$+p_id$(i%)+"  "
        a$=a$+RIGHT$(n$+STR$(p_start%(i%)),6)+"  "
        a$=a$+RIGHT$(n$+STR$(p_size%(i%)),6)+"  "
        a$=a$+RIGHT$(n$+HEX$(p_flag%(i%)),2)+"  "
        IF p_flag%(i%) AND 1
          a$=a$+"Exist "
        ENDIF
        IF p_flag%(i%) AND &H80
          a$=a$+"Boot"
        ENDIF
        IF erg%=3
          PRINT AT(39,i%+4);a$;
        ELSE
          @ausgabe(a$)
        ENDIF
      NEXT i%
    ELSE
      PRINT AT(3,10);"Fehler: Keine Platte dran?"
    ENDIF
  ENDIF
  @look_ex
RETURN
PROCEDURE hdx_install
  LOCAL a%,i%
  @alrt(1,"Platte bootbar machen?",1,"OK|Abbruch")
  IF erg%=1
    @no_protekt
    IF erg2%=1
      @root_sec(1)
      IF h_error%=0
        @screen
        erg%=3                            ! Ausgabe auf Schirm
        zz%=2
        zx%=4
        a%=p_anz%
        @ausgabe("Partition bootbar machen - selektierte Platte:")
        @ausgabe("Target "+STR$(target%)+", GerÑt "+STR$(geraet%))
        @eingabe("Boot-Partition (0-"+STR$(a%)+") :","0",2)
        IF el%
          part%=ASC(UPPER$(a$))-48
          IF part%>=0 AND part%<=a%
            @find_block(part%)            ! Partition suchen
            @mach_schon(8,block%,1,0)     ! Bootsektor lesen
            @hard_err
            IF h_error%=0
              bd$=STRING$(22,0)
              BMOVE buf%+8,VARPTR(bd$),22 ! wichtige Daten holen
              '
              @read_buf("SEDBOOT.DAT")    ! Datei mit Bootprg laden
              ch!=FALSE
              IF read%=1
                bt$=STRING$(bps%,0)
                BMOVE buf%,VARPTR(bt$),bps% ! Bootprogramm retten
                '
                @read_buf("SEDROOT.DAT")    ! Datei mit Rootprg laden
                ch!=FALSE
                IF read%=1
                  DPOKE buf%+&H1B6,hi_cc%   ! Zylinder
                  POKE buf%+&H1B8,hi_dhc%   ! Kîpfe
                  DPOKE buf%+&H1BA,hi_rwcc% ! 1. Spur mit reduziertem Schreibstrom
                  DPOKE buf%+&H1BC,hi_wpc%  !   '    '    Vorkompensation
                  POKE buf%+&H1BE,hi_lz%    ! Breite der Parkzone
                  POKE buf%+&H1BF,hi_rt%    ! Steprate
                  POKE buf%+&H1C0,hi_in%    ! Interleave
                  POKE buf%+&H1C1,hi_spt%   ! Sektoren pro Track
                  LPOKE buf%+&H1C2,hi_size% ! Grîûe der Platte
                  FOR i%=0 TO p_anz%
                    p_flag%(i%)=p_flag%(i%) AND &H7F
                  NEXT i%
                  POKE buf%+&H151,1         ! Root_vers%
                  FOR i%=0 TO p_anz%
                    x1%=buf%+&H1C6+i%*12
                    IF i%>3
                      x1%=buf%+&H156+(i%-4)*12
                    ENDIF
                    POKE x1%,p_flag%(i%)
                    POKE x1%+1,ASC(p_id$(i%))
                    POKE x1%+2,ASC(MID$(p_id$(i%),2,1))
                    POKE x1%+3,ASC(RIGHT$(p_id$(i%)))
                    LPOKE x1%+4,p_start%(i%)
                    LPOKE x1%+8,p_size%(i%)
                  NEXT i%
                  LPOKE buf%+&H1F6,bsl_start%
                  LPOKE buf%+&H1FA,bsl_count%
                  IF p_anz%>3
                    POKE buf%+&H151,1
                    LPOKE buf%+&H152,ext_magic%
                  ENDIF
                  p_flag%(part%)=p_flag%(part%) OR &H80
                  POKE buf%+&H1C6+(part%>3)*&HA0+part%*12,p_flag%(part%)
                  VOID XBIOS(18,L:buf%,L:-1,-1,1)
                  @media_all
                  @mach_schon(10,0,1,0)           ! schreibe Rootsektor
                  @hard_err
                  BMOVE VARPTR(bt$),buf%,bps%     ! Bootprogramm in Puffer
                  BMOVE VARPTR(bd$),buf%+8,22     ! wichtige Daten rein
                  VOID XBIOS(18,L:buf%,L:4097*4096,-1,1)
                  @media_all
                  @mach_schon(10,block%,1,0)      ! Bootsektor schreiben
                  @alrt(1,"CBHD.SYS nach|Reset bitte|selber draufkopieren",1,"OK")
                ENDIF
              ENDIF
            ELSE
              @alrt(1,"Fehler beim|Lesen des Bootsektors!",1,"Mist")
            ENDIF
          ENDIF
        ENDIF
        @screen
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE hard_prot             ! Schreibschutz fÅr Harddisk
  IF hard%<>2
    @mach_schon(26,0,24,0)      ! Mode Sense
    @mach_schon(21,0,24,0)      ! Mode Select
    @hard_err
  ELSE
    @nix_vortex
  ENDIF
RETURN
PROCEDURE nix_vortex
  @alrt(1,"..... geht nicht bei|'VORTEX' ....  ",1,"Warum")
  @alrt(1,"Weiss nich warum|'VORTEX' fragen",1,"Darum")
RETURN
PROCEDURE hard_info
  LOCAL a%,ab%,t%,ta%,tb%,a$
  @alrt(1,"Hardinfo-Ausgabe auf",3,ddm$)
  @dev("HARDINFO.TXT")
  IF device%<>99 OR erg%=3
    @root_sec(1)
    @screen
    @hard_err
    IF h_error%=0
      CLR ta%,tb%
      zz%=-2
      zx%=4
      @ausgabe("Target "+STR$(target%)+", GerÑt "+STR$(geraet%))
      IF erg%<3
        @ausgabe(STRING$(45,"-"))
      ENDIF
      zz%=1
      FOR part%=0 TO p_anz%
        IF p_flag%(part%) AND 1
          IF p_id$(part%)<>"GEM"
            a$="Part "+STR$(part%)+": "
            @ausgabe(a$+"Keine GEM-Partition (Kennung "+p_id$(part%)+")")
          ELSE
            @mach_schon(8,p_start%(part%),1,0)  ! Bootsektor lesen
            len_dir%=(PEEK(buf%+18)*256+PEEK(buf%+17))/16
            len_fat%=PEEK(buf%+23)*256+PEEK(buf%+22)
            bps%=PEEK(buf%+12)*256+PEEK(buf%+11)
            @cbps
            anz_sec%=PEEK(buf%+19)+256*PEEK(buf%+20)
            spc%=MAX(1,PEEK(buf%+13))
            anz_cluster%=(anz_sec%-len_fat%*2-len_dir%-1)/spc%
            fehler%=TRUE
            IF len_fat%>old_len_fat% AND fmal%  ! wenn schon mal reserviert
              @mfree(fatbuf%)                   ! und zu klein, dann freigeben
              CLR fmal%
            ENDIF
            IF fmal%=0
              @ram_for_fat
            ENDIF
            IF fehler%
              fmal%=1
              FOR t%=1 TO len_fat%
                @mach_schon(8,p_start%(part%)+t%+len_fat%,1,0)
                @hard_err
                BMOVE buf%,fatbuf%+(t%-1)*bps%,bps%
              NEXT t%
              a%=INT(anz_sec%/spc%)
              anz%=C:utis%(&H200,L:fatbuf%,L:fatbuf%+anz_cluster%*2,L:0)
              a$="Part "+STR$(part%)+":"+RIGHT$("        "+STR$(a%),8)
              a$=a$+"    frei: "+RIGHT$("        "+STR$(anz%),7)
              ab%=(anz%/a%)*100
              a$=a$+RIGHT$("      "+STR$(ab%),6)+"%"
              ADD ta%,a%
              ADD tb%,anz%
              @ausgabe(a$)
            ENDIF
          ENDIF
        ENDIF
      NEXT part%
      @ausgabe(STRING$(45,"-"))
      a$=STRING$(7,32)+RIGHT$("        "+STR$(ta%),8)
      a$=a$+RIGHT$(STRING$(18,32)+STR$(tb%),17)
      ab%=tb%/ta%*100
      a$=a$+RIGHT$("      "+STR$(ab%),6)+"%"
      @ausgabe(a$)
    ELSE
      PRINT AT(3,10);"Fehler: Keine Platte dran?"
    ENDIF
  ENDIF
  @root_sec(1)
  @look_ex
RETURN
PROCEDURE hard_select
  @screen
  PRINT AT(3,2);"0 = SH205    1 = MEGAFILE    2 = VORTEX    3 = SCSI    4 = ct"
  @eingabe("Auswahl der Platte:",STR$(hard%),2)
  IF el%
    hard%=VAL(a$)
  ENDIF
  @list
RETURN
PROCEDURE hard_search
  LOCAL a%,b%,ab%,b$
  a%=target%            ! jetzigen Zustand merken
  b%=geraet%
  erg%=3
  CLR block%,zz%
  zx%=4
  @screen
  PRINT AT(4,2);"GerÑte am DMA-Bus suchen:"
  FOR target%=0 TO 7
    FOR geraet%=0 TO 1
      a$="Target:"+STR$(target%)+"  GerÑt:"+STR$(geraet%)+"  "
      @lesen
      IF h_error%=0 AND h_tim%=0 AND hbyte%>255
        a$=a$+" ok"
        @mach_schon(18,0,56,0)            ! Inquiry
        IF (h_status% AND &HFF0000)=0
          b$=STRING$(24,0)
          BMOVE buf2%+8,VARPTR(b$),24
          a$=a$+" "+b$
        ELSE
          a$=a$+" SASI (Adaptec 4000/4070 o.Ñ.)"
        ENDIF
      ELSE
        a$=a$+tim$
      ENDIF
      @ausgabe(a$)
    NEXT geraet%
  NEXT target%
  @maus_off
  PRINT AT(4,2);"Maus links = GerÑt am DMA-Bus auswÑhlen,  Maus rechts = EXIT"
  ab%=-1
  REPEAT
    MOUSE mx%,my%,mk%
    IF my%>3*zh%-6 AND my%<19*zh%+4 AND mk%=1
      ab%=(my%-3*zh%)/zh%
    ENDIF
  UNTIL ab%>=0 OR mk%=2 OR INKEY$=esc$
  IF ab%=-1                     ! wenn Maus rechts
    target%=a%
    geraet%=b%
  ELSE
    target%=INT(ab%/2)          ! sonst neue Wahl
    geraet%=FRAC(ab%/2)*2
  ENDIF
  @screen
  @root_sec(1)                  ! neue Daten holen
RETURN
PROCEDURE hdx_save
  @alrt(1,"HDX-Parameter|sichern ?",1,"Ok|Abbruch")
  IF erg%=1
    @dev("HDX_SAVE.SED")
    IF device%<>99
      @root_sec(1)
      @fwrite2(hdl%,buf%,bps%)
      DEFMOUSE 2
      FOR i%=0 TO p_anz%
        IF p_start%(i%)<>0 AND p_size%(i%)<>0
          block%=p_start%(i%)
          @lesen
          @fwrite2(hdl%,buf%,bps%)
          IF fehler%<0
            i%=p_anz%+1
          ENDIF
        ENDIF
      NEXT i%
      @fclose(hdl%)
      DEFMOUSE 0
    ENDIF
  ENDIF
RETURN
PROCEDURE hdx_restore
  @alrt(1,"HDX-RESTORE|"+STRING$(27,"-")+"  |ACHTUNG: Bootsektoren |werden Åberschrieben ! ",1,"Ok|Abbruch")
  IF erg%=1
    fselect(pfad$+"*.SED","HDX_SAVE.SED",hf$)
    IF LEN(hf$) AND RIGHT$(hf$)<>"\"
      @cbps
      @media_all
      @fopen(hf$,0)
      IF handle%>5
        @fread2(handle%,buf%,bps%)
        IF fehler%>=0
          CLR block%
          @alrt(1,"Rootsektor schreiben ?",0,"Ja|Nein")
          IF erg%=1
            @mach_schon(10,block%,1,0)
          ENDIF
          @root_sec(1)
          DEFMOUSE 2
          FOR i%=0 TO p_anz%
            IF p_start%(i%)<>0 AND p_size%(i%)<>0
              block%=p_start%(i%)
              @fread2(handle%,buf%,bps%)
              IF fehler%<0
                i%=p_anz%+1
              ELSE
                @alrt(1,"Bootsektor "+STR$(i%)+" schreiben ?",0,"Ja|Nein")
                IF erg%=1
                  @mach_schon(10,block%,1,0)
                  @hard_err
                ENDIF
              ENDIF
            ENDIF
          NEXT i%
        ENDIF
        @fclose(handle%)
        DEFMOUSE 0
      ENDIF
    ENDIF
  ENDIF
RETURN
'
' ----------------------------- RAM Routinen ---------------------------------
'
PROCEDURE ram_read              ! aus RAM lesen
  @check_addr
  VOID C:utis%(&H600,L:ram_addr%,L:buf%,L:bps%-1)
  old_ram_addr%=ram_addr%
RETURN
PROCEDURE ram_write             ! in RAM schreiben
  @check_addr
  VOID C:utis%(&H600,L:buf%,L:ram_addr%,L:bps%-1)
RETURN
PROCEDURE ram_adress_read       ! Adresse eingeben und lesen
  @change
  @eingabe("ab Adresse:","",9)
  IF el%
    ram_addr%=VAL(a$)
    @ram_read
  ENDIF
RETURN
PROCEDURE ram_show
  @ram_adress_read
  @info
  PRINT coff$;
  HIDEM
  REPEAT
    VOID C:utis%(&H600,L:ram_addr%,L:buf%,L:bps%-1)
    VOID C:zeile%(L:z%+buf%,L:z%+ak%,W:(4*zh%-8) OR 32768,L:z%+offset%-(file_open%=1)*fp%-(ram!=TRUE)*ram_addr%,W:zpz%,W:zh%,W:planes%)
  UNTIL MOUSEK=2 OR INKEY$=esc$
  SHOWM
RETURN
PROCEDURE ram_adress_write      ! Adresse eingeben und schreiben
  @eingabe("ab Adresse :","",9)
  IF el%
    ram_addr%=VAL(a$)
    @ram_write
  ENDIF
RETURN
PROCEDURE check_addr            ! Kontrolle ob RAM-Adresse ok ist
  IF ram_addr%>ram_max%-bps% AND ram_addr%<&HFA0000
    @alrt(1,"Diese Adresse wÅrde |Bomben auslîsen",1,"Abbruch")
    ram_addr%=old_ram_addr%
  ENDIF
RETURN
PROCEDURE ram_save              ! RAM abspeichern von-bis
  @eingabe("Ab Adresse :","",9)
  IF el%
    bc%=VAL(a$)
    @eingabe("bis Adresse :","",9)
    IF el%
      a%=VAL(a$)
      IF EVEN(a%)=FALSE
        INC a%                  ! darf nicht ungerade Anzahl sein ?
      ENDIF
      erg%=1
      @dev("SAVE.RAM")
      IF device%<>99
        b%=a%-bc%
        IF b%>0
          buf$=STRING$(1024,0)
          FOR i%=0 TO b%/1024-1
            BMOVE bc%+i%*1024,VARPTR(buf$),1024         ! 1024 Byte Blîcke
            @fwrite(hdl%,buf$)
          NEXT i%
          IF b%/1024<>INT(b%/1024) AND b%>1024          ! und den Rest
            a%=b%-(INT(b%/1024)*1024)
            buf$=STRING$(a%,0)
            BMOVE bc%+i%*1024,VARPTR(buf$),LEN(buf$)
            @fwrite(hdl%,buf$)
          ENDIF
        ENDIF
        CLR buf$
        @fclose(hdl%)
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE ram_load                      ! Datei ins RAM einlesen
  fselect(pfad$+"*.*","",fi$)
  IF EXIST(fi$)
    @do_pfad(fi$)
    @fopen(fi$,0)
    @fseek(0,handle%,2)
    rfl%=fehler%
    @fseek(0,handle%,0)
    @alrt(1,"Datei ab Cursorposition|einlesen?",1," RAM | Puffer |Abbruch")
    IF erg%=1 OR erg%=2
      @eingabe("Wieviele Bytes einlesen ?",STR$(rfl%),10)
      IF el%
        a%=VAL(a$)
        IF erg%=1
          FOR t%=ram_addr%+tz% TO ram_addr%+tz%+MIN(rfl%,a%)-1
            @fread(handle%,1)
            SPOKE t%,ASC(buf$)
          NEXT t%
        ELSE
          @fread2(handle%,buf%+tz%,MIN(rfl%,a%))
        ENDIF
      ENDIF
    ENDIF
    @fclose(handle%)
  ENDIF
RETURN
PROCEDURE prg_load                      ! Datei einlesen und relozieren
  fselect(pfad$+"*.PRG","",fi$)
  IF EXIST(fi$)
    @do_pfad(fi$)
    prg_load$=fi$
    IF prg_adr%
      @mfree(prg_adr%)
    ENDIF
    SHOWM
    prg_adr%=GEMDOS(75,3,L:VARPTR(prg_load$),L:0,L:0)   ! Pexec
    IF prg_adr%
      ram_addr%=prg_adr%
      CLR tz%,z%,xt%,yt%
      @ram_read
    ELSE
      @alrt(1,"Kein Speicher frei|oder anderer Fehler ",1,"Abbruch")
    ENDIF
  ENDIF
RETURN
'
PROCEDURE clr_prg_load
  IF prg_adr%
    @alrt(1,"Geladenes Programm belegt|noch Speicher.|Freigeben?",1,"Jadoch|Nee")
    IF erg%=1
      @mfree(prg_adr%)
      CLR prg_adr%
    ENDIF
  ENDIF
RETURN
'
' ---------------------- Lesen-Schreiben -------------------------------
'
PROCEDURE lesen         ! Verteiler Lesen: je nach MODUS (SEKTOR,FILE,HARD,RAM)
  ON mode% GOSUB lesen_0,file_read,lesen_2,ram_read
  buf_crc%=C:utis%(&H400,L:buf%,L:bps%,L:&HCDB4)
RETURN
PROCEDURE lesen_0
  SHOWM
  status%=BIOS(4,0,L:buf%,1,lgs%,drive%)
  @err_inf(status%)
  IF status%=-14
    @boot_sec(0)
    SHOWM
    status%=BIOS(4,0,L:buf%,1,lgs%,drive%)
  ENDIF
  @err_inf(status%)
RETURN
PROCEDURE lesen_2
  @hard_read_sec(block%)
RETURN
'
PROCEDURE schreiben     ! Verteiler fÅr Schreiben
  ch!=FALSE
  ON mode% GOSUB schreib_0,file_write,schreib_2,ram_write
  @info
RETURN
PROCEDURE schreib_0
  @media(drive%)
  SHOWM
  status%=BIOS(4,1,L:buf%,1,lgs%,drive%)
  IF status%=-14
    @boot_sec(0)
    SHOWM
    status%=BIOS(4,1,L:buf%,1,lgs%,drive%)
  ENDIF
  @err_inf(status%)
RETURN
PROCEDURE schreib_2
  @media_all
  @mach_schon(10,block%,1,0)
  @hard_err
RETURN
'
PROCEDURE cbps
  IF bps%<=0
    bps%=512
  ENDIF
RETURN
' ---------------------- Sektor Routinen -----------------------------------
PROCEDURE sektor_read           ! Logische Sektoren lesen
  @change
  @eingabe("Logische Sektornummer:","",8)
  IF el%
    a%=VAL(a$)
    IF a%>=spd% OR a%<0
      @alrt(1,"Grîûte Sektornummer:|"+STR$(spd%-1),1,"Abbruch")
    ELSE
      lgs%=a%
      @lesen
    ENDIF
  ENDIF
RETURN
PROCEDURE sektor_write          ! Logische Sektoren schreiben
  @eingabe("Logische Sektornummer",STR$(lgs%),8)
  IF el%
    a%=VAL(a$)
    IF a%>=spd% OR a%<0
      @alrt(1,"Grîûte Sektornummer:|"+STR$(spd%-1),1,"Abbruch")
    ELSE
      lgs%=a%
      @schreiben
    ENDIF
  ENDIF
RETURN
PROCEDURE sektor_cluster        ! Cluster lesen
  @eingabe("Clusternummer","",8)
  IF el%
    a%=VAL(a$)
    IF a%>=0
      lgs%=(a%-2)*spc%+first_sec%
      IF lgs%>=spd%
        @alrt(1,"Grîûte Clusternummer:|"+STR$(cpd%+1),1,"Abbruch")
        CLR lgs%
      ENDIF
      @lesen
    ENDIF
  ENDIF
RETURN
PROCEDURE sektor_physik         ! Hier Track,Sektor und Seite eingeben
  IF drive%>1
    @alrt(1,"Wo sind denn hier|die Spuren?",1,"Abbruch")
  ELSE
    @change
    @eingabe("Spur","",4)
    IF el%
      trk%=VAL(a$)
      @eingabe("Sektor","",4)
      sec%=VAL(a$)
      @eingabe("Seite","",2)
      sd%=VAL(a$)
      IF sid%=2
        a%=(trk%*spt%*sid%)+sec%+sd%*spt%-1
      ELSE
        a%=trk%*spt%+sec%-1
      ENDIF
      lgs%=a%
      @lesen
    ENDIF
  ENDIF
RETURN
PROCEDURE ph_track              ! Hier wenn in Stauszeile TRACK angeklickt
  IF drive%<2
    @change
    @eingabe("Track","",4)
    IF el%
      IF VAL(a$)>tpd% OR VAL(a$)<0
        @alrt(1,"Es gibt nur "+STR$(tpd%)+"|Spuren auf der Disk!",1,"Abbruch")
      ELSE
        trk%=VAL(a$)
        @sektor_physik_do(trk%,sektor%,seite%)
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE ph_sec                ! Hier wenn in Statuszeile SEKTOR angeklickt
  IF drive%<2
    @change
    @eingabe("Sektor:","",4)
    IF el%
      IF VAL(a$)>spt% OR VAL(a$)<1
        @alrt(1,"Es gibt nur "+STR$(spt%)+"|Sektoren pro Spur!",1,"Abbruch")
      ELSE
        sec%=VAL(a$)
        @sektor_physik_do(track%,sec%,seite%)
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE ph_side               ! Hier wenn in Statuszeile SIDE angeklickt
  IF drive%<2
    IF sid%>1
      @change
      sd%=1-seite%
      @sektor_physik_do(track%,sektor%,sd%)
    ENDIF
  ENDIF
RETURN
PROCEDURE sektor_physik_do(trk%,sec%,sd%)       ! Statuszeilenklick ausfÅhren
  IF sid%=2
    lgs%=(trk%*spt%*sid%)+sec%+sd%*spt%-1
  ELSE
    lgs%=trk%*spt%+sec%-1
  ENDIF
  IF lgs%>spd%
    @alrt(1,"Grîûte Sektornummer:|"+STR$(spd%-1),1,"Abbruch")
    CLR lgs%
  ENDIF
  @lesen
  @list
RETURN
PROCEDURE sektor_copy           ! Kopiert einen Sektor
  IF drive%<2
    @eingabe("Zielspur:","",4)
    IF el%
      IF VAL(a$)>tpd% OR VAL(a$)<0
        @alrt(1,"Es gibt nur "+STR$(tpd%)+"|Spuren auf der Disk!",1,"Abbruch")
      ELSE
        trk%=VAL(a$)
        @eingabe("Zielsektor:","",4)
        IF VAL(a$)>spt% OR VAL(a$)<1
          @alrt(1,"Es gibt nur "+STR$(spt%)+"|Sektoren pro Spur!",1,"Abbruch")
        ELSE
          sec%=VAL(a$)
          @eingabe("Seite:","",2)
          IF VAL(a$)>sid% OR VAL(a$)<0
            @alrt(1,"Diskette ist nur einseitig!",1,"Abbruch")
          ELSE
            sd%=VAL(a$)
            DEFMOUSE 2
            IF sid%=2
              a%=(trk%*spt%*sid%)+sec%+sd%*spt%-1
            ELSE
              a%=trk%*spt%+sec%-1
            ENDIF
            @sec_write_sure(a%)
          ENDIF
        ENDIF
      ENDIF
    ENDIF
  ELSE
    @eingabe("Logische Sektornummer:","",6)
    IF el%
      a%=VAL(a$)
      IF a%>=spd% OR a%<0
        @alrt(1,"Grîûte Sektornummer:|"+STR$(spd%-1),1,"Abbruch")
      ELSE
        @sec_write_sure(a%)
      ENDIF
    ENDIF
  ENDIF
  DEFMOUSE 0
RETURN
PROCEDURE sec_write_sure(a%)
  @alrt(1,"Sektor schreiben?",0," OK |Panik")
  IF erg%=1
    lgs%=a%
    @schreiben
  ENDIF
RETURN
PROCEDURE sektor_compare        ! Vergleicht eine Anzahl Sektoren
  LOCAL cmp%,dr%,i%,st_sec%
  @screen
  dr%=drive%
  @eingabe("Startsektor:","",5)
  IF el%
    st_sec%=VAL(a$)
    @eingabe("Sektoranzahl:","",5)
    cmp%=MIN(VAL(a$),spd%)
    IF cmp%>0
      '
      @malloc(cmp%*bps%)
      IF fehler%=0
        @alrt(1,"Speicherplatzprobleme! ",1,"Abbruch")
      ELSE
        cmp1%=fehler%
        @boot_sec(0)
        SHOWM
        status%=BIOS(4,0,L:cmp1%,cmp%,st_sec%,drive%)
        '
        @eingabe("Laufwerk (A-P):",CHR$(drive%+65),2)
        a$=UPPER$(a$)
        IF a$>="A" AND a$<="P"
          drive%=ASC(a$)-65
          @eingabe("Startsektor:",STR$(st_sec%),5)
          IF el%
            st_sec%=VAL(a$)
            '
            @boot_sec(0)
            FOR i%=0 TO cmp%-1
              SHOWM
              status%=BIOS(4,0,L:buf%,1,st_sec%+i%,drive%)
              a%=C:utis%(&H500,L:cmp1%+i%*bps%,L:buf%,L:bps%/4-1)
              IF a%
                IF fer%<max_err%
                  INC fer%
                  err_fld$(fer%)=STR$(st_sec%+i%)+" verschieden"
                ENDIF
                status%=-1
              ENDIF
            NEXT i%
          ENDIF
        ENDIF
        @mfree(cmp1%)
      ENDIF
    ENDIF
  ENDIF
  @screen
  drive%=dr%
  @boot_sec(0)
RETURN
'
' ---------------------------------- OberflÑche ------------------------------
'
PROCEDURE felder
  DEFFILL 1,2,4
  PBOX 0,0,639,res%*200-1               ! Hintergrund
  DEFFILL 1,2,8
  PBOX 14,7*res%,627,20*res%
  PBOX 14,25*res%,627,vert%+3*res%
  DEFFILL 1,0
  PBOX 8,f1%,620,18*res%                ! Statuszeile
  PBOX 8,o_box%,620,vert%               ! Arbeitsfeld
  v_box%=160*res%
  fb%=89
  fh%=10*res%
  FOR j%=1 TO 2                         ! Boxen zeichnen
    FOR i%=0 TO 6
      dx%=10+i%*fb%
      dy%=v_box%+(j%*(fh%+2))*1.2
      DEFFILL 1,2,8
      PBOX dx%+3,dy%+3,dx%+fb%-7,dy%+fh%+3
      DEFFILL 1,0
      PBOX dx%,dy%,dx%+fb%-13,dy%+fh%
    NEXT i%
  NEXT j%
RETURN
PROCEDURE felder_text(x%)               ! Gibt richtigen MenÅtext
  LOCAL dl%,dx%,dy%,dz%,ti%,i%,j%,a$    ! zum richtigen UntermenÅ aus
  DEFFILL 1,0
  FOR j%=0 TO 1
    FOR i%=0 TO 6
      dx%=10+i%*fb%
      dy%=v_box%+((j%+1)*(fh%+2))*1.2
      dz%=i%+j%*7
      dl%=LEN(text$(x%,dz%))
      a$=text$(x%,dz%)
      dl%=LEN(a$)
      PBOX dx%,dy%,dx%+fb%-13,dy%+fh%
      IF (i%=0 AND j%=0) OR x%=0
        DEFTEXT 1,1
        FOR ti%=0 TO dl%-1
          TEXT (fb%-(dl%*9)-11)/2+dx%+ti%*9,dy%+(fh%-zh%)+6*res%,MID$(a$,ti%+1,1)
        NEXT ti%
      ELSE
        DEFTEXT 1,0
        TEXT (fb%-(dl%*8)-11)/2+dx%,dy%+(fh%-zh%)+6*res%,a$
      ENDIF
    NEXT i%
  NEXT j%
  DEFTEXT 1,0
  @maus_off
RETURN
PROCEDURE kleine_boxen
  LOCAL i%
  DEFTEXT ,,,dtk%
  mi%=v_box%-2*res%
  ma%=v_box%+5*res%
  mb%=44
  FOR i%=0 TO 13
    mx%=12+i%*mb%
    DEFFILL 1,2,8
    PBOX mx%,mi%+3,mb%+mx%-8,ma%+2
    DEFFILL 1,0
    PBOX mx%-2,mi%,mb%+mx%-10,ma%
    TEXT mx%+5,ma%-2*res%,MID$(inf_ma$,i%*3+1,3)
  NEXT i%
  DEFTEXT ,,,dtg%
RETURN
PROCEDURE doubleclick
  @eingabe("Zeitkonstante fÅr Doppelklick: ",STR$(dclick%),3)
  IF el%
    dclick%=VAL(a$)
  ENDIF
RETURN
PROCEDURE klick2(taste%)
  t=TIMER
  WHILE MOUSEK=taste% AND TIMER-t<dclick%
  WEND
  IF MOUSEK
    t=-1
  ELSE
    WHILE MOUSEK<>taste% AND TIMER-t<dclick%
    WEND
    IF MOUSEK<>taste%
      t=-1
    ELSE
      WHILE MOUSEK
      WEND
    ENDIF
  ENDIF
RETURN
PROCEDURE feld_wahl
  DO
    @time                               ! Zeitanzeige?
    MOUSE mx%,my%,mk%
    a$=INKEY$                           ! Ist Taste gedrÅckt worden?
    '
    IF mk%
      t=-1
      IF my%>3*zh% AND my%<19*zh%
        @klick2(mk%)                    ! Doppelklick?
      ENDIF
      IF t>0
        @maus_pos
        ON mk% GOSUB ctrl_a,ctrl_b
        CLR mk%
      ENDIF
    ENDIF
    '
    IF LEN(a$) OR mk%=2
      @taste(a$,mk%)                    ! Funktionen Åber Tastatur abrufen
    ENDIF
    '
    IF mk%=1
      '
      IF my%>mi% AND my%<ma%            ! kleine Tasten ?
        FOR ii%=0 TO 13
          ml%=12+ii%*mb%
          IF mx%>ml%-2 AND mx%<ml%+mb%-12
            ON ii%+1 GOSUB top,lend,show_err_inf,ctrl_p,up,down,ctrl_n,frei,frei,frei,frei,frei,frei,frei
            ii%=14
          ENDIF
        NEXT ii%
      ENDIF
      '
      IF mx%>8 AND mx%<620 AND my%>f1% AND my%<18*res%
        @status_line                    ! Statuszeile ist angeklickt worden
      ELSE
        IF mx%>560 AND my%>hyl%-8 AND my%<hyl%
          @dec_hex                      ! Cursoranzeige umschalten
        ENDIF
        IF mx%>5 AND mx%<100 AND my%>hyl%-8 AND my%<hyl%
          @show_date                    ! Datum anzeigen
        ENDIF
        IF my%>3*zh%-6 AND my%<19*zh%+4
          IF mx%<66
            @address                    ! Zeiger ist auf Adresse
          ELSE
            @maus_pos                   ! Zeiger ist im Arbeitsfeld
          ENDIF
        ENDIF
      ENDIF
      '
      FOR y%=0 TO 1                     ! Zwei Zeilen
        FOR x%=0 TO 6                   ! mit jeweils 7 Buttons
          dx%=10+x%*fb%
          dz%=x%+y%*7+1
          dy%=v_box%+((y%+1)*(fh%+2))*1.2
          '
          IF mx%>dx% AND mx%<dx%+fb%-13 AND my%>dy% AND my%<dy%+fh%
            IF hpt!=TRUE
              u1%=dz%
              ON u1% GOSUB dum,dum,file_on,disc_on,hard_on,ram_on,dum,dum,dum,file_on,dum,hard_on,dum,dum,dum
              @felder_text(u1%)
              hpt!=FALSE
              @list
            ELSE                        ! Box gewÑhlt
              @invert_box
              invert%=1
              @show_button(1,u1%,dz%)
              ON u1% GOSUB u_men_1,u_men_2,u_men_3,u_men_4,u_men_5,u_men_6,u_men_7,u_men_8,u_men_9,u_men_10,u_men_11,u_men_12,u_men_13,u_men_14
              IF invert%
                @invert_box
              ENDIF
              @show_button(0,0,0)
              @list
              CLR mx%,my%,mk%
            ENDIF
          ENDIF
        NEXT x%
      NEXT y%
    ENDIF
  LOOP
RETURN
PROCEDURE invert_box
  DEFFILL 1,1
  GRAPHMODE 3
  IF dx%>=0
    PBOX dx%,dy%,dx%+fb%-13,dy%+fh%
  ENDIF
  GRAPHMODE 1
RETURN
PROCEDURE show_button(mna%,mnb%,mnc%)
  IF mna%
    GET 100,hyl%-4*res%,240,hyl%+res%,mnc$
    DEFTEXT ,,,dtk%
    TEXT 100,hyl%,text$(mnb%,0)+":"+text$(mnb%,mnc%-1)
    DEFTEXT ,,,dtg%
  ELSE
    PUT 100,hyl%-4*res%,mnc$
  ENDIF
RETURN
'                         Sprungverteiler in die einzelnen Funktionen
PROCEDURE u_men_1       ! DISC
  ON dz% GOSUB help,disc_name,disc,hard_root,disc_check,disc_drive,disc_save,disc_optimum,disc_clear,disc_quick,disc_free,disc_compare,dum,disc_load
RETURN
PROCEDURE u_men_2       ! FAT
  ON dz% GOSUB help,fat_cluster,fat_read,fat_write,fat_cursor,dum,fat_read1,fat_help,fat_xor,fat_test,fat_graph,dum,dum,fat_read2
RETURN
PROCEDURE u_men_3       ! FILE
  ON dz% GOSUB help,file_open,file_close,file_write,file_repair,file_verify,dum,dum,fil_ren,file_attribut,file_date,dum,dum,file_dump
RETURN
PROCEDURE u_men_4       ! SEKTOR
  ON dz% GOSUB help,sektor_physik,sektor_read,sektor_write,sektor_cluster,sektor_copy,sektor_compare,dum,dum,dum,dum,dum,dum,sektor_magic
RETURN
PROCEDURE u_men_5       ! HARD
  ON dz% GOSUB help,hard_read,hard_write,hard_command,hard_device,hard_prot,hard_ship,dum,hard_mode_sense,hard_mode_select,dum,hard_search,hard_info,hard_root
RETURN
PROCEDURE u_men_6       ! RAM
  ON dz% GOSUB help,ram_show,ram_adress_read,ram_adress_write,ram_load,ram_save,disass,dum,dum,dum,dum,prg_load,dum,dum
RETURN
PROCEDURE u_men_7       ! OUT/IN
  ON dz% GOSUB help,out_dump,out_data,out_error,out_f_key,in_file,out_logbuch,out_printer,dum,in_help,in_info,out_info,dum,dum
RETURN
PROCEDURE u_men_8       ! DIR
  ON dz% GOSUB help,dir_all_files,dir_path,dir_file,dir_fldren,dum,dir_sec,dir_help,make_dir,rm_dir,dum,dir_sort,dir_secsearch,dum
RETURN
PROCEDURE u_men_9       ! FUNKTION
  ON dz% GOSUB help,dum,f_pexec,dum,dum,f_menu,f_reset,dum,dum,dum,dum,dum,f_cpu,f_sound
RETURN
PROCEDURE u_men_10      ! DATEI
  ON dz% GOSUB help,datei_copy,datei_del,dum,dum,dum,dum,dum,dum,datei_concat,datei_cut,dum,datei_crc,datei_secure
RETURN
PROCEDURE u_men_11      ! ---
  ON dz% GOSUB help,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum,dum
RETURN
PROCEDURE u_men_12      ! HDX
  ON dz% GOSUB help,hdx_format,hdx_zero,hdx_part,hdx_bad,hdx_install,hard_info,dum,hdx_save,hdx_restore,dum,dum,dum,hard_root
RETURN
PROCEDURE u_men_13      ! INFO
  ON dz% GOSUB help,dum,info_system,dum,info_fkey,dum,dum,info_sieben,info_buttons,info_crc,info_get,dum,info_fat,info_dir
RETURN
PROCEDURE u_men_14      ! OPTIONS
  ON dz% GOSUB help,err_clr,mem_clr,dum,dum,dum,dec_hex,dum,clock,set_time,set_date,dum,doubleclick,hard_select
RETURN
'
PROCEDURE frei          ! 'FREI' programmierbare kleine Buttons
  LOCAL m1%,m2%,m3%
  m1%=dz%
  m2%=u1%
  m3%=ii%-6
  dz%=button%(m3%)
  @show_button(1,u_men%(m3%),dz%)
  ON u_men%(m3%) GOSUB dum,dum,file_on,disc_on,hard_on,ram_on,dum,dum,dum,file_on,dum,hard_on,dum,dum,dum
  ON u_men%(m3%) GOSUB u_men_1,u_men_2,u_men_3,u_men_4,u_men_5,u_men_6,u_men_7,u_men_8,u_men_9,u_men_10,u_men_11,u_men_12,u_men_13,u_men_14
  @show_button(0,0,0)
  dz%=m1%
  u1%=m2%
  ON u1% GOSUB dum,dum,file_on,disc_on,hard_on,ram_on,dum,dum,dum,file_on,dum,hard_on,dum,dum,dum
  @list
RETURN
'
PROCEDURE disc_on       ! Variablen richtig setzen je nach Modus
  @no_on
  mode%=1
  disc!=TRUE
  DEFMOUSE 2
  @lesen
  DEFMOUSE 0
RETURN
PROCEDURE file_on
  CLR hard!,disc!,ram!
  mode%=2
  fil!=TRUE
  IF file_open%<0
    @clear_buf
  ELSE
    IF file_open%=0
      @fopen(fi_o$,2)
      IF handle%>5
        f_hdl%=handle%
        file_open%=1
      ENDIF
    ENDIF
    @lesen
  ENDIF
RETURN
PROCEDURE hard_on
  @no_on
  mode%=3
  hard!=TRUE
  @do_mode_sense
  @lesen
RETURN
PROCEDURE ram_on
  @no_on
  mode%=4
  ram!=TRUE
  @lesen
RETURN
PROCEDURE no_on
  DEFMOUSE 2
  @boot_sec(0)
  DEFMOUSE 0
  CLR fil!,hard!,disc!,ram!
  mode%=1
RETURN
'
PROCEDURE clear_buf
  a$=STRING$(buf_size%,0)
  BMOVE VARPTR(a$),buf%,buf_size%
  BMOVE VARPTR(a$),ak%,buf_size%
  CLR a$
RETURN
PROCEDURE dum                   ! FÅr noch nicht implementierte Routinen
  @maus_off
RETURN
PROCEDURE status_line           ! Wenn Statuszeile angeklickt wurde
  ON mode% GOSUB disc_line,fil_line,hard_line,ram_line
  @list
  @maus_off
RETURN
PROCEDURE disc_line             ! Statuszeile fÅr Disk
  IF mx%<136
    @sektor_read
  ELSE
    IF mx%<256
      @sektor_cluster
    ELSE
      IF mx%<336
        @ph_track
      ELSE
        IF mx%<408
          @ph_sec
        ELSE
          IF mx%<464
            @ph_side
          ELSE
            IF mx%<528
              @disc_drive
            ELSE
              IF mx%<616
                @show_status
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE fil_line
  IF mx%<120
    @dec_hex                      ! Cursoranzeige umschalten
  ELSE
    IF mx%<240
      @alrt(0,"TOF=Dateianfang|EOF=Dateiende    ",1," Ok ")
    ELSE
      IF mx%<600
        @file_name
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE hard_line
  IF mx%<120
    @hard_read
  ELSE
    IF mx%<192
      @hard_dev
    ELSE
      IF mx%<248
        @hard_unit
      ELSE
        IF mx%<300
          @dum
        ELSE
          IF mx%<375
            @dum
          ELSE
            IF mx%<455
              @show_hard_errors
            ELSE
              IF mx%<541
                @show_hard_status
              ELSE
                IF mx%<600
                  @show_hard_dma
                ENDIF
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE ram_line
  IF mx%>24 AND mx%<250
    @ram_adress_read
  ENDIF
RETURN
PROCEDURE show_status
  LOCAL i%
  @screen
  PRINT AT(5,2);"Statusfehler im Klartext:"
  FOR i%=0 TO 17 STEP 2
    PRINT AT(5,i%/2+6);RIGHT$(n$+STR$(i%),3)''stat$(i%)
    PRINT AT(43,i%/2+6);RIGHT$(n$+STR$(i%+1),3)''stat$(i%+1)
  NEXT i%
  @help_ex
RETURN
PROCEDURE show_hard_errors
  LOCAL a%
  @screen
  zz%=4
  erg%=3
  titel$="Fehlermeldungen der ATARI-Platten"
  PRINT AT(4,2);titel$
  FOR a%=0 TO hh_max%-2 STEP 2
    PRINT AT(3,zz%);RIGHT$(n$+STR$(a%),3)''LEFT$(hh_err$(a%),32)'
    PRINT AT(41,zz%);RIGHT$(n$+STR$(a%+1),3)''LEFT$(hh_err$(a%+1),32);
    IF zz%>18
      @page(titel$)
      ADD zz%,3
    ENDIF
    EXIT IF mk%=2
    INC zz%
  NEXT a%
  IF mk%<>2
    @help_ex
  ENDIF
RETURN
PROCEDURE is_bit(msk%,ze%,sp%)
  LOCAL i%
  FOR i%=0 TO 7
    IF (msk% AND 2^i%)
      PRINT AT(sp%,ze%+i%);"**";
    ENDIF
  NEXT i%
RETURN
'
' ---------------------- Proceduren fÅr FILE --------------------------
'
PROCEDURE file_attribut
  LOCAL a%,ai%
  @show_attr
  PRINT AT(10,17);"Linke Maustaste = Start     Rechte Maustaste = Abbruch"
  @maus_off
  WHILE MOUSEK=0
  WEND
  mk%=MOUSEK
  IF mk%=1
    fselect(pfad$+"*.*","",fi$)
    IF EXIST(fi$)
      @fattrib(fi$,attr%,0)
      ai%=fehler%
      @eingabe("Attributbyte:","$"+HEX$(ai%),10)
      IF el%
        a%=VAL(a$)
        IF a%<>ai%
          @fattrib(fi$,a%,1)
        ENDIF
      ENDIF
    ENDIF
  ENDIF
  @screen
RETURN
PROCEDURE file_name
  IF file_open%=1
    @do_rename(fi_o$)
  ELSE
    @alrt(1,"Hier erscheint nach OPEN|der Dateiname (Rename...)",1,"Aha")
  ENDIF
RETURN
PROCEDURE fil_ren
  fselect(pfad$+"*.*","",fi$)
  IF EXIST(fi$)
    @chk_drv(fi$)
    IF drv%
      @do_pfad(fi$)
      @do_rename(fi$)
    ENDIF
  ENDIF
RETURN
PROCEDURE do_rename(fi$)
  LOCAL i%,old$
  a$=fi$
  CLR i%                        ! Datei umbenennen
  REPEAT
    a$=RIGHT$(a$,LEN(a$)-i%)    ! Pfad vom Filenamen trennen
    i%=INSTR(1,a$,"\")
  UNTIL i%=0
  path$=LEFT$(fi$,LEN(fi$)-LEN(a$))
  @eingabe("Neuer Name:",a$,12)
  old$=fi$
  new$=path$+a$
  IF new$<>old$
    @frename(old$,new$)
    IF fehler%=0
      IF old$=fi_o$
        fi_o$=new$
        @info
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE file_date
  LOCAL dt%,tm%,tm$,dt$
  fselect(pfad$+"*.*","",fi$)
  IF EXIST(fi$)
    @do_pfad(fi$)
    @fopen(fi$,2)
    IF fehler%>0
      dat$=STRING$(4,0)
      @fdatime(VARPTR(dat$),handle%,0)
      tm%=DPEEK(VARPTR(dat$))
      tm$=RIGHT$(n$+STR$((tm% DIV 2048) AND 31),2)
      tm$=tm$+":"+RIGHT$(n$+STR$((tm% DIV 32) AND 63),2)
      tm$=tm$+":"+RIGHT$(n$+STR$((tm% AND 31)*2),2)
      dt%=DPEEK(VARPTR(dat$)+2)
      dt$=RIGHT$(n$+STR$(dt% AND 31),2)
      dt$=dt$+"."+RIGHT$(n$+STR$((dt% DIV 32) AND 15),2)
      dt$=dt$+"."+STR$(1980+((dt% DIV 512) AND 63))
      b$=tm$+"/"+dt$
      @eingabe("Neue Zeit/Datum ",b$,20)
      IF el% AND a$<>b$
        tm%=VAL(LEFT$(a$,2))*2048+VAL(MID$(a$,4,2))*32+VAL(MID$(a$,7,2))/2
        DPOKE VARPTR(dat$),tm%
        dt%=VAL(MID$(a$,10,2))+VAL(MID$(a$,13,2))*32+(VAL(MID$(a$,16,4))-1980)*512
        DPOKE VARPTR(dat$)+2,dt%
        @fdatime(VARPTR(dat$),handle%,1)
      ENDIF
      @fclose(handle%)
    ENDIF
  ENDIF
RETURN
PROCEDURE file_open
  IF file_open%=-1
    fselect(pfad$+"*.*","",fi$)
    IF LEN(fi$) AND RIGHT$(fi$)<>"\"
      @do_pfad(fi$)
      IF EXIST(fi$)
        fi_o$=fi$
        file_open%=1
        @fopen(fi_o$,2)
        IF handle%>5
          f_hdl%=handle%
          @fseek(0,f_hdl%,2)
          fl%=fehler%
        ENDIF
        CLR fp%,z%
        @file_read
      ELSE
        @alrt(2,"Datei nicht gefunden!",1,"Sorry")
      ENDIF
    ENDIF
  ELSE
    @alrt(1,"Bitte erst File schlieûen",1,"Close|Abbruch")
    IF erg%=1
      @file_close
      @info
      @file_open
    ENDIF
  ENDIF
RETURN
PROCEDURE file_close
  IF file_open%>=0
    @change
    @fclose(f_hdl%)
    file_open%=-1
    CLR fl%,fp%,fi_o$,z%
    inf$="   "
    @clear_buf
    @maus_off
    @list
  ELSE
    @alrt(2,"Welches File schlieûen?",1," ??? ")
  ENDIF
RETURN
PROCEDURE file_read
  LOCAL dl%,fr%
  IF file_open%=1
    IF fp%<fl%
      @fseek(fp%,f_hdl%,0)
      fr%=fl%-fp%
      ch!=FALSE
      IF fr%>0
        IF bps%+fp%>=fl%
          inf$="EOF"
        ELSE
          IF fp%=0
            inf$="TOF"
          ELSE
            inf$="   "
          ENDIF
        ENDIF
        dl%=MIN(bps%,fr%)
        @fread2(f_hdl%,buf%,dl%)
        IF dl%<>bps%
          bf$=STRING$(bps%+1-dl%,0)
          BMOVE VARPTR(bf$),buf%+dl%,LEN(bf$)
          CLR bf$
        ENDIF
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE file_write
  LOCAL fr%
  IF file_open%=1
    fr%=MIN(fl%-fp%,bps%)
    @fseek(fp%,f_hdl%,0)
    @fwrite2(f_hdl%,buf%,fr%)
    @file_read
  ELSE
    @alrt(2,"In welche Datei|soll ich schreiben ?  ",1,"Abbruch")
  ENDIF
RETURN
PROCEDURE file_verify
  LOCAL fp1%,fp2%
  @screen
  zx%=4
  PRINT AT(4,2);"Bitte Datei 1 auswÑhlen"
  fselect(pfad$+"*.*","",f1$)
  screen
  IF EXIST(f1$)=TRUE
    @do_pfad(f1$)
    PRINT AT(5,4);RIGHT$(f1$,53)
    PRINT AT(4,2);"Bitte Datei 2 auswÑhlen"
    fselect(pfad$+"*.*","",f2$)
    screen
    PRINT AT(5,4);RIGHT$(f1$,53)
    IF EXIST(f2$)=TRUE
      PRINT AT(5,5);RIGHT$(f2$,53)
      @alrt(1,"Ausgabe auf... ",3,ddm$)
      @dev("VERIFY.DAT")
      IF device%<>99 OR erg%=3
        zz%=3
        CLR anz_diff%,mk%
        PRINT AT(4,2);" GeprÅft: 0      KB      "
        @fopen(f1$,0)
        hdl1%=handle%
        @fopen(f2$,0)
        hdl2%=handle%
        CLR fp1%,fp2%
        @fseek(0,hdl1%,2)
        a1%=fehler%
        @fseek(0,hdl1%,0)
        '
        @fseek(0,hdl2%,2)
        a2%=fehler%
        @fseek(0,hdl2%,0)
        PRINT AT(60,4);RIGHT$(n$+STR$(a1%),7);" Bytes"
        PRINT AT(60,5);RIGHT$(n$+STR$(a2%),7);" Bytes"
        IF erg%<3
          a$=STRING$(80,32)
          MID$(a$,1)=f1$
          MID$(a$,41)=f2$
          @fwritec(hdl%,a$)
          a$=STRING$(80,32)
          MID$(a$,1)=STR$(a1%)+" Bytes"
          MID$(a$,41)=STR$(a2%)+" Bytes"
          @fwritec(hdl%,a$)
        ENDIF
        erg2%=1
        IF a1%<>a2%
          @alrt2(2,"Dateien ungleich lang!",1,"Weiter|Abbruch")
        ENDIF
        IF erg2%=1
          b%=MIN(1024,MIN(a1%,a2%))     ! Wenn File kÅrzer als 1024 Bytes
          st1%=INT(a1%/b%)
          st2%=INT(a2%/b%)
          vi%=1
          fehler%=99
          DO
            @was_ist
            EXIT IF abb%=2
            @fread(hdl1%,b%)
            a1$=buf$
            ADD fp1%,fehler%
            @fread(hdl2%,b%)
            a2$=buf$
            ADD fp2%,fehler%
            IF a1$<>a2$
              PRINT AT(44,2);"Ungleich"
              @vergleich
            ELSE
              PRINT AT(44,2);"  Gleich"
            ENDIF
            EXIT IF fehler%<=0 OR mk%=2
            CLR a1$,a2$
            INC vi%
            PRINT AT(14,2);vi%*b% DIV 1024;
            EXIT IF vi%>st1% OR vi%>st2%
          LOOP
          IF abb%<>2
            st3%=MIN(1024,MIN(a1%-fp1%,a2%-fp2%))
            st4%=MIN(1024,MIN(a1%-fp1%,a2%-fp2%))
            @fread(hdl1%,st3%)
            a1$=buf$
            ADD fp1%,fehler%
            @fread(hdl2%,st4%)
            a2$=buf$
            ADD fp2%,fehler%
            IF a1$<>a2$
              @vergleich
            ENDIF
            IF a1%<>a2% AND anz_diff%=0
              @alrt2(1,"Dateien sind |ungleich lang, aber |sonst identisch! ",1,"Wahnsinn")
            ELSE
              IF anz_diff%
                @alrt2(2,"Dateien nicht identisch! |an mindestens "+STR$(anz_diff%)+" Stellen",1," Shit ")
              ELSE
                @alrt2(1,"Dateien sind identisch! ",1,"Wahnsinn")
              ENDIF
            ENDIF
          ENDIF
        ENDIF
        @fclose(hdl1%)
        @fclose(hdl2%)
        IF erg%<3
          @fclose(hdl%)
        ENDIF
        @screen
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE vergleich
  LOCAL a$
  fehler%=99
  FOR j%=1 TO LEN(a1$) STEP 16
    IF MID$(a1$,j%,16)<>MID$(a2$,j%,16)
      INC anz_diff%
      @verify_out(a1$,"1:")
      @verify_out(a2$,"2:")
    ENDIF
    EXIT IF fehler%<=0 OR mk%=2
  NEXT j%
RETURN
PROCEDURE verify_out(buf$,a$)
  o$=STRING$(65,32)
  FOR i%=1 TO 16
    a%=PEEK(VARPTR(buf$)+j%+i%-2)
    MID$(o$,i%*3-2)=RIGHT$(n$+HEX$(a%),2)
    MID$(o$,i%+49,1)=MID$(ascii$(zgr%),a%+1,1)
  NEXT i%
  @dec_hex_val((vi%-1)*1024+j%-1,5)
  @ausgabe(a$+av$+" "+o$)
  IF erg%=3 AND zz%>15
    @page(" GeprÅft: 0      KB      ")
    CLR zz%
  ENDIF
RETURN
PROCEDURE datei_secure
  LOCAL a$,fs
  @alrt(1,"Datei irreparabel lîschen? ",0,"Weiter|Abbruch")
  IF erg%=1
    fselect(pfad$+"*.*","",sec$)
    IF LEN(sec$) AND RIGHT$(sec$)<>"\"
      @do_pfad(sec$)
      @fopen(sec$,0)
      @fseek(0,handle%,2)       ! FilelÑnge
      flen%=fehler%
      @fclose(handle%)
      fs=flen%/1024
      IF FRAC(fs)
        INC fs
      ENDIF
      fs%=fs
      '
      a%=LEN(sec$)
      IF a%<22
        a$=STRING$((22-a%)/2,32)+sec$+STRING$((22-a%)/2,32)
      ELSE
        a$=RIGHT$(sec$,22)
      ENDIF
      '
      @alrt(2,"Datei lîschen ? |"+a$+" |mit "+STR$(flen%)+" Bytes  ",0,"Ja| Nein ")
      IF erg%=1
        buf$=STRING$(1024,&HCB)         ! Puffer zum Schreiben
        @fopen(sec$,1)                  ! Datei îffnen
        hdl%=handle%
        IF fehler%>0
          DEFMOUSE 2
          FOR sec%=1 TO fs%             ! Fs% = Anzahl der Sektoren
            @fwrite(hdl%,buf$)          ! schreiben
            IF fehler%<0                ! war Fehler?
              sec%=fs%+1                ! Ja, Abbruch
            ENDIF
          NEXT sec%
          IF fehler%>=0                 ! Bisher ales glatt gegangen?
            @fclose(hdl%)               ! Ok
            @fdelete(sec$)              ! und lîschen ....
          ENDIF
          DEFMOUSE 0
        ENDIF
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE file_repair
  PRINT coff$
  @disc_on
  srep%=1
  CLR repair%
  @find_files
  CLR zz%,ay%
  PRINT AT(30,2);"Name        Cluster Attribut   LÑnge"
  FOR i%=1 TO total%
    IF ASC(file$(i%))=&HE5
      INC zz%
      INC ay%
      IF folder$(i%)<>folder$
        PRINT AT(5,zz%+4);ro$;"Ordner";rof$''folder$(i%)
        INC zz%
        folder$=folder$(i%)
      ENDIF
      PRINT AT(25,zz%+4);i%
      PRINT AT(30,zz%+4);file$(i%)
      PRINT AT(45,zz%+4);cluster%(i%)
      PRINT AT(50,zz%+4);RIGHT$(n$+BIN$(att%(i%)),8)
      PRINT AT(60,zz%+4);laenge%(i%)
      IF zz%>13 AND i%<>total%
        @page("")
      ENDIF
    ENDIF
  NEXT i%
  IF ay%
    PRINT AT(3,2);"Welche Datei: ";
    INPUT sf$
    sf%=MAX(0,VAL(sf$))
    IF sf% AND sf%<=total%
      IF ASC(file$(sf%))=&HE5
        kaputt$=file$(sf%)
        @screen
        cpf=laenge%(sf%)/(bps%*spc%)    ! Cluster pro File
        IF cpf<>INT(cpf)
          INC cpf
        ENDIF
        cpf%=cpf
        bac%=cluster%(sf%)
        @read_in_fat(bac%)
        CLR sch%
        IF aa%
          @alrt(1,"Cluster ist nicht frei (?) ",1,"Weiter|Abbruch")
          sch%=erg%
        ENDIF
        IF sch%=2
          GOTO repair_ex
        ENDIF
        foc%=bac%
        @alrt(1,"Repair ohne RÅckfragen? ",1," Ohne | Mit ")
        dmt%=erg%
        '
        DO
          bac%=foc%
          DO
            EXIT IF bac%>cpd%+1
            lgs%=(bac%-2)*spc%+first_sec%
            @lesen
            @list
            rrg%=1
            IF dmt%=2
              @alrt(1,"Ist dies die |gesuchte Datei? ",1," Ja | Nein |Abbruch")
              rrg%=erg%
              IF rrg%=2
                INC bac%
                @read_in_fat(bac%)
                WHILE aa%
                  INC bac%
                  @read_in_fat(bac%)
                WEND
              ENDIF
            ENDIF
            EXIT IF rrg%=1 OR rrg%=3
          LOOP
          '
          EXIT IF bac%>cpd%+1 OR rrg%=3
          '
          cl%=bac%
          @read_in_fat(cl%+1)
          WHILE aa%<>0
            INC cl%
            @read_in_fat(cl%+1)
          WEND
          '
          INC cl%
          IF att%(sf%) AND 16
            @alrt(1,"Datei ist Verzeichnis. |Weitersuchen?",1," Ja | Nein |Abbruch")
            dv%=erg%
            IF dv%=2
              repair%=9999
            ELSE
              IF dv%=3
                GOTO repair_ex
              ELSE
                cpf%=repair%+2
                @write_in_fat(cl%,bac%)
              ENDIF
            ENDIF
          ELSE
            @write_in_fat(cl%,bac%)
          ENDIF
          INC repair%
          EXIT IF repair%>=cpf% OR rrg%=3
          foc%=cl%
        LOOP
        '
        IF rrg%<>3
          @write_in_fat(ed%,bac%)
          @alrt(2,"Datei restauriert!! ",0,"Schreiben|Abbruch")
          IF erg%=1
            sektor%=sec%(sf%)
            SHOWM
            status%=BIOS(4,0,L:VARPTR(puffer$),1,sektor%,drive%)
            IF status%=0
              @err_inf(status%)
              @write_fat(anf_fat1%)
              @write_fat(anf_fat2%)
              '
              FOR i%=1 TO bps% STEP 32
                f$=MID$(puffer$,i%,11)
                IF f$=kaputt$
                  @eingabe("Name des Programms:",kaputt$,12)
                  MID$(puffer$,i%,11)=a$
                  i%=bps%+1
                ENDIF
              NEXT i%
              @media(drive%)
              SHOWM
              status%=BIOS(4,1,L:VARPTR(puffer$),1,sektor%,drive%)
              @err_inf(status%)
            ENDIF
          ENDIF
        ENDIF
      ELSE
        @alrt(1,"Datei ist nicht gelîscht ",1,"Sorry")
      ENDIF
    ENDIF
  ENDIF
repair_ex:
  CLR srep%
  @file_on
  @screen
RETURN
PROCEDURE datei_cut
  LOCAL la%
  '
  IF file_open%<0
    REPEAT
      @file_open
      EXIT IF file_open%<0
      @eingabe("Ab Byte ... abschneiden :","",8)
      fp%=VAL(a$)
      z%=INT(b%/256)*256                ! Cursor ausrichten
      b%=b%-z%
      yt%=b%/16
      xt%=b%-yt%*16+51
      IF hex!=TRUE
        xt%=(b%-yt%*16)*3
      ENDIF
      @set_tz
      @lesen
      @list
    UNTIL 1
  ENDIF
  IF file_open%=1
    @alrt(1,"Datei an aktueller |Cursorposition abschneiden? ",1,"Ok|Abbruch")
    IF erg%=1
      fc%=fp%+tz%+z%
      @dev("FILE_1.CUT")
      IF device%<>99 OR erg%=3
        fz%=z%
        CLR z%,fp%
        @lesen
        fi%=1
        WHILE fi%<=INT(fc%/bps%)
          @fwrite2(hdl%,buf%,bps%)
          ADD fp%,bps%
          @lesen
          INC fi%
        WEND
        bc%=fc%-INT(fc%/bps%)*bps%
        IF bc%
          @fwrite2(hdl%,buf%,bc%)
        ENDIF
        @fclose(hdl%)
        '
        @dev("FILE_2.CUT")
        IF device%<>99 OR erg%=3
          z%=fz%
          fp%=fc%
          @lesen
          fa%=fl%-fc%
          WHILE fa%>=bps%
            @fwrite2(hdl%,buf%,bps%)
            ADD fp%,bps%
            SUB fa%,bps%
            @lesen
          WEND
          '
          IF fa%
            @fwrite2(hdl%,buf%,fa%)
          ENDIF
          @fclose(hdl%)
          '
        ENDIF
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE datei_concat
  PRINT AT(3,2);coff$;"Bitte Datei 1 auswÑhlen"
  fselect(pfad$+"*.*","",f1$)
  IF EXIST(f1$)=TRUE
    @do_pfad(f1$)
    @screen
    PRINT AT(5,5);RIGHT$(f1$,53)
    PRINT AT(4,2);"Bitte Datei 2 auswÑhlen"
    fselect(pfad$+"*.*","",f2$)
    IF EXIST(f2$)=TRUE
      @do_pfad(f2$)
      PRINT AT(5,6);RIGHT$(f2$,53)
      erg%=1
      @dev("FILE.CON")
      IF device%<>99
        @fopen(f1$,0)
        hdl1%=handle%
        @fopen(f2$,0)
        hdl2%=handle%
        @fseek(0,hdl1%,2)
        a1%=fehler%
        @fseek(0,hdl1%,0)
        '
        @fseek(0,hdl2%,2)
        a2%=fehler%
        @fseek(0,hdl2%,0)
        '
        PRINT AT(60,5);RIGHT$(n$+STR$(a1%),7);" Bytes"
        PRINT AT(60,6);RIGHT$(n$+STR$(a2%),7);" Bytes"
        '
        REPEAT
          WHILE a1%>=bps%
            @fread2(hdl1%,buf%,bps%)
            @fwrite2(hdl%,buf%,bps%)
            SUB a1%,bps%
            EXIT IF fehler%<0
          WEND
          EXIT IF fehler%<0
          IF a1%
            @fread2(hdl1%,buf%,a1%)
            @fwrite2(hdl%,buf%,a1%)
          ENDIF
          '
          WHILE a2%>=bps%
            @fread2(hdl2%,buf%,bps%)
            @fwrite2(hdl%,buf%,bps%)
            SUB a2%,bps%
            EXIT IF fehler%<0
          WEND
          EXIT IF fehler%<0
          IF a2%
            @fread2(hdl2%,buf%,a2%)
            @fwrite2(hdl%,buf%,a2%)
          ENDIF
        UNTIL 1
        @fclose(hdl1%)
        @fclose(hdl2%)
        @fclose(hdl%)
      ENDIF
    ENDIF
    @screen
  ENDIF
RETURN
PROCEDURE file_dump
  IF file_open%=1
    @alrt(1,"Datei ausgeben auf... ",3,ddm$)
    zgr%=erg%-1
    @dev("FILE.DMP")
    IF device%<>99 OR erg%=3
      IF erg%<3
        @fwritec(hdl%,"Datei : "+fi_o$+" LÑnge: "+STR$(fl%)+" Bytes")
        @fwritec(hdl%,STRING$(75,"-"))
      ENDIF
      DO
        CLR fehler%
        IF erg%<3
          @buffer_dump
        ELSE
          @list
          PAUSE 3
          @down
        ENDIF
        EXIT IF fehler%<0
        @nxt_blk
        EXIT IF no_nxt%
        @file_read
        @list
        DEFMOUSE 2
        @was_ist
        EXIT IF abb%=2
      LOOP
      IF erg%<3
        @fclose(hdl%)
      ENDIF
    ENDIF
  ELSE
    @alrt(1,"Bitte Datei erst îffnen ",1,"Mach ich")
  ENDIF
RETURN
PROCEDURE buffer_dump
  LOCAL a%,b%,i%,zl%,o$
  CLR z%,zl%
  sav_end%=bps%/16
  REPEAT
    b%=buf%+zl%*16
    o$=STRING$(66,32)
    FOR i%=1 TO 16
      a%=PEEK(b%+i%-1)
      MID$(o$,i%*3-2)=RIGHT$(n$+HEX$(a%),2)
      MID$(o$,i%+50,1)=MID$(ascii$(zgr%),a%+1,1)
    NEXT i%
    @dec_hex_val((offset%+z%+zl%*16+fp%+ram_addr%),6)
    @fwritec(hdl%,av$+"  "+o$)
    EXIT IF fehler%<0
    INC zl%
  UNTIL zl%>=sav_end%
RETURN
PROCEDURE datei_copy
  @screen
  PRINT AT(3,2);coff$;"Quelldatei auswÑhlen"
  fselect(pfad$+"*.*","",f1$)
  IF EXIST(f1$)=TRUE
    @do_pfad(f1$)
    PRINT AT(3,2);"Bitte Zielpfad [ optional Name ] angeben"
    fselect(pfad$+"*.*","",f2$)
    IF f2$<>""
      IF RIGHT$(f2$)="\"
        i%=LEN(f1$)
        WHILE MID$(f1$,i%,1)<>"\" AND i%>1
          DEC i%
        WEND
        f2$=f2$+RIGHT$(f1$,LEN(f1$)-i%)
      ENDIF
      @do_pfad(f2$)
      @do_file_copy(f1$,f2$)
    ENDIF
  ENDIF
RETURN
PROCEDURE do_file_copy(f1$,f2$)
  LOCAL a1%,a2%,ab%,b%,i%
  IF EXIST(f1$)=TRUE                    ! Nur wenn Quelldatei da ist
    DEFMOUSE 2
    @fopen(f1$,0)                       ! Datei îffnen
    @fseek(0,handle%,2)                 ! LÑnge feststellen
    a1%=fehler%
    @fseek(0,handle%,0)                 ! Ab Byte 0 lesen
    @malloc(a1%)                        ! Speicher organisieren
    IF fehler%                          ! Speicher da ?
      a2%=fehler%                       ! Ja, Adresse des Puffers merken
      @fread2(handle%,a2%,a1%)          ! Datei komplett einlesen
      @fclose(handle%)                  ! Quell schliessen
      @fcreate(f2$,0)                   ! Neue Datei erzeugen
      IF handle%>0                      ! Ohne Fehler ?
        @fwrite2(handle%,a2%,a1%)       ! Ja, komplett schreiben
        @fclose(handle%)                ! Fertig
      ENDIF
      @mfree(a2%)                       ! Speicher zurÅckgeben
    ELSE
      PRINT AT(3,2);"Datei stÅckweise kopieren"
      ab%=a1%/bps%                      ! Kein Speicher, Anzahl der Sektoren
      hdl1%=handle%                     ! Quellhandle merken
      @fcreate(f2$,0)                   ! Neue Datei erzeugen
      IF handle%>0                      ! Ohne Fehler ?
        FOR i%=1 TO ab%
          @fread2(hdl1%,buf%,bps%)      ! einen Sektor lesen
          @fwrite2(handle%,buf%,bps%)   ! und auch schreiben
        NEXT i%
        IF a1%>ab%*bps%                 ! wenn LÑnge <> Sektorgrenze
          b%=a1%-ab%*bps%
          @fread2(hdl1%,buf%,b%)        ! Rest lesen
          @fwrite2(handle%,buf%,b%)     !  '   schreiben
        ENDIF
        @fclose(handle%)                ! Zieldatei fertig
      ENDIF
      @fclose(hdl1%)                    ! Quell schliessen
      DEFMOUSE 0
    ENDIF
  ENDIF
RETURN
PROCEDURE file_is_open
  IF file_open%=1
    @fclose(f_hdl%)
    CLR file_open%
  ENDIF
RETURN
PROCEDURE datei_del
  @screen
  PRINT AT(3,2);coff$;"Zu lîschende Datei auswÑhlen"
  fselect(pfad$+"*.*","",f1$)
  IF EXIST(f1$)=TRUE
    @do_pfad(f1$)
    @alrt(3,RIGHT$(f1$,20)+"|lîschen ???",0,"Lîschen|Abbruch")
    IF erg%=1
      @fdelete(f1$)
    ENDIF
  ENDIF
RETURN
PROCEDURE datei_crc
  LOCAL a1%,a2%
  @screen
  PRINT AT(3,2);coff$;"Datei auswÑhlen"
  fselect(pfad$+"*.*","",f1$)
  IF EXIST(f1$)=TRUE
    @do_pfad(f1$)
    DEFMOUSE 2
    @fopen(f1$,0)                       ! Datei îffnen
    @fseek(0,handle%,2)                 ! LÑnge feststellen
    a1%=fehler%
    @fseek(0,handle%,0)                 ! Ab Byte 0 lesen
    @malloc(a1%)                        ! Speicher organisieren
    IF fehler%                          ! Speicher da ?
      a2%=fehler%                       ! Ja, Adresse des Puffers merken
      crc%=&HFFFF           ! @Crc_start
      @fread2(handle%,a2%,a1%)          ! Datei komplett einlesen
      @fclose(handle%)                  ! Quell schliessen
      @mfree(a2%)
      crc%=C:utis%(&H400,L:a2%,L:a1%,L:crc%)
      a$=RIGHT$(n$+HEX$(crc% AND &HFFFF),4)
      @alrt(1,"CRC-PrÅfsumme von |"+RIGHT$(f1$,20)+" :|$"+a$,1," Aha ")
    ELSE
      @alrt(1,"Speicherplatzprobleme ",1,"Abbruch")
    ENDIF
  ENDIF
RETURN
'
' ---------------------- Proceduren fÅr DISC ----------------------------
PROCEDURE disc_name
  @boot_sec(0)                          ! Was ist's denn fÅr eine
  lgs%=fat_anf%+len_fat%                ! Anfang Directory
  @lesen                                ! Sektor holen
  @info
  CLR disc_name$,zg%                    ! ab Anfang suchen
  REPEAT
    DO
      CLR f$
      EXIT IF PEEK(buf%+zg%)=0 OR lgs%>=(fat_anf%+len_fat%+len_dir%)
      f$=STRING$(11,0)
      BMOVE buf%+zg%,VARPTR(f$),11        ! sonst Filennamen holen
      att%=PEEK(buf%+zg%+11)              ! und   Attribut   holen
      EXIT IF (att% AND 8)=8
      ADD zg%,32                          ! Wenn nicht Diskname
      IF zg%>=bps%
        INC lgs%                          ! Wenn Wurzelverzeichnis > 1 Sektor
        @lesen                            ! nÑchsten Sektor holen
        @list
        CLR zg%                           ! und wieder ab Anfang
      ENDIF
    LOOP
    IF lgs%>=fat_anf%+len_fat%+len_dir%
      lgs%=fat_anf%+len_fat%
      @lesen
    ENDIF
    @list
    disc_name$=f$                       ! Name merken
    @eingabe("Diskname:",disc_name$,11) ! Neuen Namen eingeben
    IF LEN(disc_name$) AND el%          ! Wenn was gefunden war
      IF a$<>disc_name$                 ! und neuer Name ist
        a$=LEFT$(a$+STRING$(11,32),11)
        BMOVE VARPTR(a$),buf%+zg%,11    ! dann neuen Namen schreiben
        @schreiben
        @lesen
      ENDIF
    ELSE
      IF LEN(a$)
        REPEAT
          @dsetdrv(drive%)
          EXIT IF fehler%<0
          @dsetpath("\")
          EXIT IF fehler%<0
          a$=a$+CHR$(0)
          @fcreate(a$,8)
        UNTIL 1
        @lesen
      ENDIF
    ENDIF
  UNTIL 1
RETURN
PROCEDURE disc_clear
  @alrt(2,"ACHTUNG:|Laufwerk "+CHR$(drive%+65)+" wird gelîscht ",0,"Weiter|Abbruch")
  IF erg%=1
    @boot_sec(1)
    puffer$=STRING$(bps%,0)
    BMOVE VARPTR(puffer$),buf%,bps%
    BMOVE buf%,buf%+bps%,bps%
    CLR puffer$
    @alrt(2,"Laufwerk "+CHR$(drive%+65)+" mit|"+STR$(cpd%*spc%)+" Sektoren|wird gelîscht!",0,"Weiter|Abbruch")
    IF erg%=1
      @screen
      PRINT AT(4,10);"Laufwerk: ";CHR$(drive%+65);"   Sektor :";
      @media(drive%)
      FOR lgs%=spd%-2 TO 2 STEP -2
        PRINT AT(30,10);RIGHT$(n$+STR$(lgs%),5);
        @was_ist
        EXIT IF abb%=2
        SHOWM
        status%=BIOS(4,1,L:buf%,2,lgs%,drive%)
        EXIT IF status%<0
      NEXT lgs%
      IF status%=0
        SHOWM
        status%=BIOS(4,1,L:buf%,2,1,drive%)
      ENDIF
      @err_inf(status%)
    ENDIF
    @screen
    @lesen
  ENDIF
RETURN
PROCEDURE disc_compare          ! Vergleicht zwei logische Laufwerke
  @screen
  dr1%=drive%
  @boot_sec(0)
  PRINT AT(5,5);"Quell  ";CHR$(65+dr1%);":";spd%
  @malloc(-1)
  cmp%=(fehler%-10000)/(bps%*2)
  cmp%=MIN(cmp%,spd%)
  @malloc(cmp%*bps%)
  cmp_ram%=fehler%
  '
  @alrt(1,"Disc-Compare |"+STR$(spd%)+" Sektoren",1,"Start|Abbruch")
  IF erg%=1
    @eingabe("2.Laufwerk (A-P):",CHR$(drive%+65),2)
    a$=UPPER$(a$)
    IF a$>="A" AND a$<="P"
      dr2%=ASC(a$)-65
      @eingabe("Ab Sektor ... vergleichen?","0",6)
      st_sec%=VAL(a$)
      PRINT AT(5,15);"Read    : ";
      PRINT AT(5,16);"Compare : ";
      PRINT AT(5,10);"Puffer  : ";cmp%;" Sektoren"
      drive%=dr2%
      anz%=spd%
      @boot_sec(0)
      drive%=dr1%
      PRINT AT(5,6);"Ziel   ";CHR$(65+dr2%);":";spd%
      anz_sec%=MIN(anz%,spd%)
      cmp1%=cmp_ram%+cmp%*bps%
      DO
        @was_ist
        EXIT IF abb%=2
        SHOWM
        status%=BIOS(4,0,L:cmp_ram%,cmp%,st_sec%,dr1%)
        PRINT AT(15,15);st_sec%+cmp%
        @was_ist
        EXIT IF abb%=2
        SHOWM
        status%=BIOS(4,0,L:cmp1%,cmp%,st_sec%,dr2%)
        PRINT AT(15,16);st_sec%+cmp%
        '
        anz%=cmp%*bps%
        CLR off%
        IF C:utis%(&H500,L:cmp_ram%,L:cmp1%,L:anz%/4-1)
          DO
            b%=off%*bps%
            IF C:utis%(&H500,L:cmp_ram%+b%,L:cmp1%+b%,L:bps%/4-1)
              IF fer%<max_err%
                INC fer%
                err_fld$(fer%)=STR$(st_sec%+off%)+" verschieden"
              ENDIF
            ENDIF
            INC off%
            EXIT IF off%=cmp%
          LOOP
        ENDIF
        EXIT IF fer%=max_err%
        ADD st_sec%,cmp%
        EXIT IF st_sec%>=anz_sec%
        cmp%=MIN(cmp%,anz_sec%-st_sec%)
      LOOP
    ENDIF
  ENDIF
  IF fer%=max_err%
    @alrt(1,"FehlerÅberlauf ",1,"Abbruch")
  ENDIF
  @mfree(cmp_ram%)
  CLR bb$,bc$
  drive%=dr1%
  @boot_sec(0)
  @screen
RETURN
PROCEDURE disc_save
  LOCAL a%,i%
  @alrt(1,"DISC-SAVE  |auf ...   ",1,"Ok|Abbruch")
  IF erg%=1
    @dev("SAVE_"+CHR$(drive%+65)+".DAT")
    IF device%<>99
      IF ASC(fd$)-65<>drive%
        @boot_sec(1)
        a%=len_fat%*2+len_dir%
        FOR i%=0 TO a%
          lgs%=i%
          @lesen
          @list
          @fwrite2(hdl%,buf%,bps%)
          IF fehler%<0
            i%=a%+1
          ENDIF
        NEXT i%
        @fclose(hdl%)
      ELSE
        @alrt(1,"Bitte nicht auf | dasselbe Laufwerk | DISC-SAVE !",3,"~Ok~")
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE disc_load
  LOCAL i%
  @alrt(1,"DISC-LOAD  |von DATEI ...   ",3,"Ok|Abbruch")
  IF erg%=1
    fselect(pfad$+"*.DAT","SAVE_"+CHR$(drive%+65)+".DAT",fi$)
    IF LEN(fi$) AND RIGHT$(fi$)<>"\"
      @media(drive%)
      @fopen(fi$,0)             ! Datei îffnen
      IF fehler%>=0
        @fseek(0,handle%,2)
        fl%=fehler%             ! LÑnge feststellen
        @fseek(0,handle%,0)     ! Offset 0
        ab%=INT(fl%/bps%)-1
        FOR i%=0 TO ab%
          @fread2(handle%,buf%,bps%)
          IF fehler%<0
            i%=ab%+1
          ENDIF
          @list
          lgs%=i%
          @schreiben
        NEXT i%
        @fclose(hdl%)
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE disc_quick
  @screen
  CLR zz%,alle%,mk%,bytes%
  @alrt(1,"DISC-QUICK ausgeben |auf...   ",3,ddm$)
  @dev("QUICK.TXT")
  IF device%<>99 OR erg%=3
    fselect(pfad$+"*.*","",fi$)
    IF LEN(fi$)
      dta$=STRING$(44,0)
      @fgetdta
      dta%=fehler%
      titel$=fi$
      DEFMOUSE 2
      lies_mode%=1
      PRINT AT(4,2);titel$;
      @lies_all(fi$)
      a$=STR$(alle%)+" Files mit "+STR$(bytes%)+" Bytes"
      IF erg%=3
        PRINT AT(48,2);a$;
      ELSE
        @fwritec(hdl%,cr$+a$)
      ENDIF
      IF mk%<>2
        @look_ex
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE lies_all(p$)
  LOCAL all$,nr%
  CLR nr%
  all$=p$+"*.*"+CHR$(0)
  IF NOT GEMDOS(78,L:VARPTR(all$),63)           ! Fsfirst
    REPEAT
      BMOVE dta%,VARPTR(dta$),44
      INC nr%
      f$=MID$(dta$,31,INSTR(31,dta$,CHR$(0))-31)
      attr%=ASC(MID$(dta$,22,1))
      laenge%=CVL(MID$(dta$,27,4))
      ADD bytes%,laenge%
      IF attr% AND 16                           ! Ordner ?
        IF ASC(f$)<>46                          ! kein "." oder ".."
          @lies_all(p$+f$+"\")
          i%=1
          VOID GEMDOS(78,L:VARPTR(all$),63)
          WHILE i%<nr%
            VOID GEMDOS(79)                     ! Fsnext
            INC i%
          WEND
        ENDIF
      ELSE
        ON lies_mode% GOSUB lies_1,lies_2
        INC alle%
      ENDIF
      EXIT IF mk%=2
    UNTIL GEMDOS(79)
  ENDIF
RETURN
PROCEDURE lies_1
  IF erg%=3
    PRINT AT(4,zz%+4);LEFT$(p$+f$+STRING$(64,32),64);
    INC zz%
    IF zz%>15
      @page(titel$)
    ENDIF
  ELSE
    @fwritec(hdl%,p$+f$)
  ENDIF
RETURN
PROCEDURE disc_free
  @screen
  @boot_sec(0)
  d_fr%=DFREE(drive%+1)
  PRINT AT(4,2);"Laufwerk ";CHR$(drive%+65)
  PRINT AT(4,7);"DiskkapazitÑt      :"'
  PRINT USING "##,###,###",(spd%-first_sec%)*bps%
  PRINT AT(4,8);"Bytes frei         :"'
  PRINT USING "##,###,###",d_fr%
  PRINT AT(4,9);"Bytes belegt       :"'
  PRINT USING "##,###,###",spd%*bps%-d_fr%
  @help_ex
RETURN
PROCEDURE disc_check
  LOCAL a1%,a2%,b%,cl%,i%
  '
  @alrt(1,"Checkdisk Drive "+CHR$(drive%+65)+":",1,"Start|Abbruch")
  IF erg%=1
    @boot_sec(1)
    @bios_block
    IF fatbuf%
      '
      IF drive%<2                 ! ab hier neu
        a1%=spt%
      ELSE
        a1%=17
      ENDIF
      @malloc(a1%*bps%)
      IF fehler%=0
        a1%=1
        a2%=buf%
      ELSE
        a2%=fehler%
      ENDIF
      '
      DO
        @was_ist
        EXIT IF lgs%>=spd% OR abb%=2
        cl%=MAX(0,INT((lgs%-first_sec%)/spc%)+2)
        @info
        '
        IF drive%<2
          '
          CLR df%               ! Check ob defekte Sektoren im Block sind
          FOR i%=lgs% TO lgs%+a1%-1
            cl%=MAX(0,INT((i%-first_sec%)/spc%)+2)
            @read_in_fat(cl%)
            IF aa%=&HFF7
              INC df%
            ENDIF
          NEXT i%
          '
          IF df%=0              ! df=0 keine defekten
            SHOWM
            status%=XBIOS(8,L:a2%,L:0,drive%,sektor%,track%,seite%,a1%)
            IF status%<0
              FOR lgs%=lgs% TO lgs%+a1%-1
                @was_ist
                EXIT IF abb%=2
                @info
                SHOWM
                status%=XBIOS(8,L:buf%,L:0,drive%,sektor%,track%,seite%,1)
                IF status%<0
                  @disc_check_err(lgs%)
                ENDIF
              NEXT lgs%
            ENDIF
          ELSE
            FOR lgs%=lgs% TO lgs%+a1%-1         ! defekte Sektoren
              @was_ist                          ! als einzeln lesen
              EXIT IF abb%=2
              @info
              cl%=MAX(0,INT((lgs%-first_sec%)/spc%)+2)
              @read_in_fat(cl%)
              IF aa%<>&HFF7
                SHOWM
                status%=XBIOS(8,L:buf%,L:0,drive%,sektor%,track%,seite%,1)
                IF status%<0
                  @disc_check_err(lgs%)
                ENDIF
              ENDIF
            NEXT lgs%
          ENDIF
          '
        ELSE
          '
          SHOWM                                 ! auf Platte lesen
          status%=BIOS(4,2,L:a2%,a1%,lgs%,drive%)
          IF status%<0
            FOR lgs%=lgs% TO lgs%+a1%-1
              @was_ist
              EXIT IF abb%=2
              @info
              SHOWM                                 ! auf Platte lesen
              status%=BIOS(4,2,L:buf%,1,lgs%,drive%)
              IF status%<0
                @disc_check_err(lgs%)
              ENDIF
            NEXT lgs%
          ENDIF
        ENDIF
        '
        ADD lgs%,a1%
        EXIT IF abb%=2
      LOOP
      '
      IF b%
        @alrt(1,STR$(b%)+" defekte Sektoren gefunden | FAT schreiben? ",0,"Jadoch|Abbruch")
        IF erg%=1
          @write_fat(anf_fat1%)
          @write_fat(anf_fat2%)
        ENDIF
      ENDIF
      '
      IF a2%
        @mfree(a2%)
      ENDIF
      IF lgs%>=spd%
        CLR lgs%
      ENDIF
      @lesen
    ENDIF
  ENDIF
RETURN
PROCEDURE disc_check_err(a%)
  @err_inf(status%)
  cl%=MAX(0,INT((a%-first_sec%)/spc%)+2)
  IF cl%>0
    @write_in_fat(&HFFF7,cl%)
    INC b%
  ENDIF
RETURN
PROCEDURE disc_drive
  LOCAL old%,oldlgs%
  @change
  SHOWM
  drv_map%=BIOS(10)
  @screen
  PRINT AT(4,2);"Laufwerk auswÑhlen:"
  @drv_sel(drv_map%)
  IF di%>=0
    IF drv_map% AND 2^di%
      old%=drive%
      oldlgs%=lgs%
      drive%=di%
      PRINT AT(4,2);"Lese Bootsektor von Laufwerk ";CHR$(drive%+65)
      @boot_sec(1)
      IF p%
        pfad$=CHR$(drive%+65)+":\"
      ELSE
        @alrt(1,"Kein BIOS-Parameterblock |von Laufwerk "+CHR$(drive%+65),1,"Sch...")
        drive%=old%
        lgs%=oldlgs%
      ENDIF
      @lesen
    ENDIF
  ENDIF
  @screen
  @list
RETURN
PROCEDURE disc_optimum
  @find_files
RETURN
'
' --------------------------------------------------------------------------
PROCEDURE chk_sum
  LOCAL t%
  CLR chk_sum%
  FOR t%=0 TO bps%/2-1
    ADD chk_sum%,DPEEK(buf%+t%*2)       ! Alle Worte zusammenzÑhlen
  NEXT t%
  chk_sum%=chk_sum% AND &HFFFF
RETURN
PROCEDURE boot_sec(mbl%)
  @media(drive%)
  SHOWM
  p%=BIOS(7,W:drive%)
  IF p%
    IF mbl%=1
      CLR lgs%
      SHOWM
      fehler%=BIOS(4,2,L:buf%,1,lgs%,drive%)
      @chk_sum
    ENDIF
    bps%=DPEEK(p%)
    @cbps
    spc%=DPEEK(p%+2)
    bpc%=bps%*spc%
    len_dir%=DPEEK(p%+6)
    len_fat%=DPEEK(p%+8)
    spf%=len_fat%
    fat_anf%=DPEEK(p%+10)
    first_sec%=DPEEK(p%+12)
    cpd%=DPEEK(p%+14)
    bflag%=DPEEK(p%+16)
    IF bflag%=0
      ed%=&HFFF
    ELSE
      ed%=&HFFFF
    ENDIF
    IF drive%<2
      tpd%=DPEEK(p%+18)
      sid%=DPEEK(p%+20)
      spt%=DPEEK(p%+22)/sid%
      spd%=spt%*sid%*tpd%
      hid%=DPEEK(p%+26)
      serie%=DPEEK(p%+28)*256+PEEK(p%+30)
      IF spt%=0
        spt%=9
        @boot_wrong("Tracks = 0")
      ENDIF
    ELSE
      spd%=cpd%*spc%+first_sec%
    ENDIF
    IF spc%=0
      spc%=2
      @boot_wrong("Sektoren pro Cluster = 0")
    ENDIF
    IF spd%=0
      spd%=1440
      @boot_wrong("Sektoren auf Disk = 0")
    ENDIF
    IF bps%>buf_size%
      bps%=512
      @boot_wrong("max. "+STR$(buf_size%)+" Bytes/Sektor")
    ENDIF
  ELSE
    status%=-7
    tpd%=80             ! Dummywerte (sonst Systemcrash)
    sid%=1
    spt%=9
    spc%=2
    spd%=spt%*sid%*tpd%
    CLR hid%
    @err_inf(status%)
  ENDIF
RETURN
PROCEDURE boot_wrong(a$)
  @alrt(3,"Bootsektordaten falsch:|"+a$,1,"Mist")
RETURN
PROCEDURE disc
  @boot_sec(1)
  @alrt(1,"Laufwerksdaten auf ",3,ddm$)
  @dev("BOOT.TXT")
  IF device%<>99 OR erg%=3
    PRINT coff$;
    DEFMOUSE 2
    zx%=4
    IF p%
      IF erg%<3
        @ausgabe("Bootsektor von Laufwerk "+CHR$(drive%+65))
      ELSE
        @screen
        @info
        PRINT coff$;
      ENDIF
      CLR zz%
      @ausgabe("                      BPB     Boot                           Boot")
      @ausgabe("")
      a$=RIGHT$("        "+STR$(PEEK(buf%+11)+256*PEEK(buf%+12)),8)
      @ausgabe("Bytes pro Sektor    : "+STR$(bps%)+a$)
      a$=RIGHT$("        "+STR$(PEEK(buf%+13)),8)
      @ausgabe("Clustergrîûe        : "+STR$(spc%)+a$)
      a$=RIGHT$("        "+STR$(PEEK(buf%+17)+256*PEEK(buf%+18)),8)
      @ausgabe("Grîûe des Rootverz. : "+STR$(len_dir%*bps%/32)+a$)
      a$=RIGHT$("        "+STR$(PEEK(buf%+22)+256*PEEK(buf%+23)),8)
      @ausgabe("FAT-Grîûe           : "+STR$(len_fat%)+a$)
      @ausgabe("Anfang der 2. FAT   : "+STR$(fat_anf%))
      @ausgabe("Erster Datensektor  : "+STR$(first_sec%))
      a$=RIGHT$("        "+STR$(PEEK(buf%+19)+256*PEEK(buf%+20)),8)
      @ausgabe("Sektoren/Disk       : "+STR$(spd%)+a$)
      @ausgabe("Anzahl der Cluster  : "+STR$(cpd%))
      @ausgabe("BFLAGS              : "+STR$(bflag%))
      a$=RIGHT$("        "+STR$(PEEK(buf%+28)+256*PEEK(buf%+29)),8)
      @ausgabe("Versteckte Sektoren : "+STR$(hid%)+a$)
      IF chk_sum%=&H1234
        a$="Ja"
      ELSE
        a$="Nein"
      ENDIF
      @ausgabe("BootfÑhig           :         "+a$)
      @ausgabe("Checksumme          :         $"+RIGHT$(n$+HEX$(chk_sum%),4))
      zx%=45
      zz%=2
      IF drive%<2
        @ausgabe("Seriennummer      : "+STR$(serie%))
        @ausgabe("Spuranzahl        : "+STR$(tpd%))
        @ausgabe("Seiten            : "+STR$(sid%))
        @ausgabe("Sektoren/Spur     : "+STR$(spt%))
      ENDIF
      @ausgabe("")
      @ausgabe("Mediabyte         : $"+HEX$(PEEK(buf%+21)))
    ELSE
      PRINT AT(6,6);"Kein BIOS-Parameterblock"
    ENDIF
  ENDIF
  @look_ex
RETURN
PROCEDURE drv_sel(drv_msk%)
  LOCAL dx%,dy%,db%,dh%,mx%,my%,mk%,i%
  di%=-1
  dr_first%=1
  DO
    MOUSE mx%,my%,mk%
    FOR i%=0 TO 25
      dx%=(i%+3+13*(i%>12))*33
      dy%=90*res%+(20*(i%<13)*res%)
      db%=25
      dh%=15*res%
      IF dr_first%
        DEFFILL 1,2,8
        PBOX dx%+3,dy%+3,dx%+db%,dy%+dh%+3
        DEFFILL 1,0
        PBOX dx%,dy%,dx%+db%-3,dy%+dh%
        IF (drv_msk% AND 2^i%)=0
          DEFTEXT ,2
        ELSE
          DEFTEXT ,0
        ENDIF
        TEXT dx%+7,dy%+10*res%,CHR$(i%+65)
      ELSE
        IF mx%>dx% AND mx%<dx%+db% AND my%>dy% AND my%<dy%+dh% AND mk%=1
          di%=i%
          IF drv_msk% AND 2^i%
            GRAPHMODE 3
            DEFFILL 1,1
            PBOX dx%,dy%,dx%+db%-3,dy%+dh%
            GRAPHMODE 1
          ENDIF
        ENDIF
      ENDIF
    NEXT i%
    CLR dr_first%
    EXIT IF mk%=2 OR di%>=0
  LOOP
  DEFTEXT ,0
RETURN
' ---------------------- Proceduren fÅr DIR -------------------------------
PROCEDURE dir_sort
  fselect(pfad$+"*.*","",fi$)
  IF RIGHT$(fi$)="\"
    @chk_drv(fi$)
    IF drv%
      @do_pfad(fi$)
      @boot_sec(0)
      @get_fld_name(fi$)
      @bios_block
      IF LEN(fld$)
        CLR i%
        IF fatbuf%
          @find_files
          @nam_conv(fld$,1)
          fac$=fil$
          @search_name(fac$)
        ENDIF
        IF i%>total%
          @alrt(1,"Ordner nicht gefunden!",1,"Dumm")
          CLR lgs%
        ELSE
          cl%=cluster%(i%)
          lgs%=(cl%-2)*spc%+first_sec%
        ENDIF
        msflag%=-1
      ELSE
        lgs%=fat_anf%+len_fat%          ! Anfang Wurzelverzeichnis
        msflag%=len_dir%
      ENDIF
      '
      mlgs%=lgs%
      @lesen
      anz%=1
      CLR aa%,zg%,jc%
      mssec%=msflag%
      ' WHILE PEEK(buf%+zg%)
      WHILE 1
        INC anz%
        ADD zg%,32
        EXIT IF zg%>=bps% AND aa%>=ed%
        IF zg%>=bps%
          INC jc%
          IF jc%>=spc% AND msflag%=-1
            cl%=INT((lgs%-first_sec%)/spc%)+2
            @read_in_fat(cl%)
            lgs%=(aa%-2)*spc%+first_sec%
            CLR jc%
          ELSE
            INC lgs%
            DEC mssec%
            IF mssec%=0
              aa%=ed%
            ENDIF
          ENDIF
          IF aa%<ed%
            @lesen
          ENDIF
          CLR zg%
        ENDIF
        EXIT IF aa%>=ed%
      WEND
      '
      IF DIM?(fs$())
        ERASE fs$()
      ENDIF
      DIM fs$(anz%+1)
      '
      CLR zg%,jc%,aa%
      tot%=1
      lgs%=mlgs%
      anz_sec%=1
      @lesen
      '
      ' WHILE PEEK(buf%+zg%)
      mssec%=msflag%
      WHILE 1
        fs$(tot%)=STRING$(32,0)
        BMOVE buf%+zg%,VARPTR(fs$(tot%)),32
        IF PEEK(buf%+zg%)>0 AND PEEK(buf%+zg%)<>&HE5
          INC tot%
        ENDIF
        ADD zg%,32
        '
        EXIT IF zg%>=bps% AND aa%>=ed%
        IF zg%>=bps%
          INC jc%
          IF jc%>=spc% AND msflag%=-1
            cl%=INT((lgs%-first_sec%)/spc%)+2
            @read_in_fat(cl%)
            lgs%=(aa%-2)*spc%+first_sec%
            CLR jc%
          ELSE
            INC lgs%
            DEC mssec%
            IF mssec%=0
              aa%=ed%
            ENDIF
          ENDIF
          IF aa%<ed%
            INC anz_sec%
            @lesen
          ENDIF
          CLR zg%
        ENDIF
        EXIT IF aa%>=ed%
      WEND
      '
      DEFMOUSE 0
      @alrt(1,"Reihenfolge? ",1,"Alfa|Manuell|Raus")
      ON erg% GOSUB alfa_sort,maus_sort
      IF erg%<3
        @alrt(1,"Neue Reihenfolge schreiben? ",0,"Ok|Panik")
        IF erg%=1
          '
          lgs%=mlgs%
          @lesen
          CLR b%,zg%,jc%,aa%
          anz%=1
          IF LEFT$(fs$(anz%),11)=STRING$(11,32) ! Manchmal Fehler in Alphasort
            INC anz%
          ENDIF
          '
          mssec%=msflag%
          REPEAT
            BMOVE VARPTR(fs$(anz%)),buf%+zg%,32 ! Eintrag in Puffer schreiben
            INC anz%
            ADD zg%,32
            EXIT IF zg%>=bps% AND aa%>=ed%
            IF zg%>=bps%                        ! Wenn Puffer voll ist
              INC b%
              @schreiben                        ! dann schreiben
              INC jc%
              IF jc%>=spc% AND msflag%=-1
                cl%=INT((lgs%-first_sec%)/spc%)+2
                @read_in_fat(cl%)
                lgs%=(aa%-2)*spc%+first_sec%
                CLR jc%
              ELSE
                INC lgs%
                DEC mssec%
                IF mssec%=0
                  aa%=ed%
                ENDIF
              ENDIF
              IF aa%<ed%
                @lesen                          ! nÑchsten Lesen
              ENDIF
              CLR zg%
            ENDIF
          UNTIL anz%>tot%                       ! bis alle EintrÑge geschrieben
          '
          a$=STRING$(32,0)                      ! den Rest des Puffers mit 00
          REPEAT                                ! fÅllen.
            WHILE zg%<bps%
              BMOVE VARPTR(a$),buf%+zg%,32
              ADD zg%,32
            WEND
            INC b%
            @schreiben                          ! Puffer schreiben
            INC jc%
            IF jc%>=spc% AND msflag%=-1
              cl%=MAX(0,INT((lgs%-first_sec%)/spc%)+2)
              @read_in_fat(cl%)
              lgs%=(aa%-2)*spc%+first_sec%
              CLR jc%
            ELSE
              INC lgs%
              DEC mssec%
              IF mssec%=0
                aa%=ed%
              ENDIF
            ENDIF
            @lesen
            CLR zg%
          UNTIL b%>=anz_sec%                    ! auch die restlichen Sektoren
        ENDIF
      ENDIF
      lgs%=mlgs%                                ! ersten DIR-Sektor lesen
      @lesen                                    ! und anzeigen
      @screen
    ENDIF
  ENDIF
RETURN
PROCEDURE alfa_sort
  LOCAL m%,k%,j%,i%,l%
  IF tot%>1
    m%=tot%-1
    DO
      m%=INT(m%/2)
      EXIT IF m%=0
      j%=1
      k%=tot%-1-m%
      DO
        i%=j%
        REPEAT
          l%=i%+m%
          EXIT IF fs$(i%)<fs$(l%)
          SWAP fs$(i%),fs$(l%)
          i%=i%-m%
        UNTIL i%<1
        j%=j%+1
        EXIT IF j%>k%
      LOOP
    LOOP
  ENDIF
RETURN
PROCEDURE maus_sort
  @screen
  DEC tot%
  max%=tot%
  min%=1
  pt%=1
  lx%=15
  CLR sel_buf$
  @show_files
  @maus_select
RETURN
PROCEDURE show_files
  LOCAL a%,zz%
  IF tot%<lx%
    pt%=tot%
    min%=1
  ELSE
    pt%=lx%
  ENDIF
  IF min%+pt%>tot%
    min%=MAX(1,tot%-pt%)
  ENDIF
  zz%=4
  FOR a%=min% TO min%+pt%
    IF LEN(fs$(a%))>11 AND (PEEK(VARPTR(fs$(a%))+11) AND 16)
      TEXT 30,zz%*zh%-3,""
    ELSE
      TEXT 30,zz%*zh%-3," "
    ENDIF
    IF PEEK(VARPTR(fs$(a%))+11) AND 8
      TEXT 200,zz%*zh%-3,"LABEL"
    ELSE
      TEXT 200,zz%*zh%-3,"     "
    ENDIF
    PRINT AT(8,zz%);LEFT$(fs$(a%),12);
    INC zz%
  NEXT a%
  IF LEN(sel_buf$) AND (PEEK(VARPTR(sel_buf$)+11) AND 16)<>0
    TEXT 30,2*zh%-3,""
  ELSE
    TEXT 30,2*zh%-3," "
  ENDIF
  PRINT AT(8,2);LEFT$(sel_buf$+STRING$(12,32),12);
  PRINT AT(60,2);"Anzahl: ";anz%-1''
RETURN
PROCEDURE maus_select
  LOCAL i%
  DO
    in$=INKEY$
    IF in$=CHR$(127) AND LEN(sel_buf$)
      CLR sel_buf$
      @screen
      @show_files
      WHILE LEN(INKEY$)
      WEND
    ENDIF
    MOUSE mx%,my%,mk%
    IF mx%<200
      IF my%>3*zh% AND my%<pt%*zh%+4*zh%
        '
        IF mk%=1
          wahl%=(my%-4*zh%)/zh%+1+min%
          IF sel_buf$=""
            IF wahl%<=tot%
              sel_buf$=fs$(wahl%)
              FOR i%=wahl% TO tot%
                fs$(i%)=fs$(i%+1)
              NEXT i%
              fs$(tot%)=""
              DEC tot%
            ENDIF
          ELSE
            IF wahl%<tot%+2 AND wahl%>0
              INC tot%
              FOR i%=tot% DOWNTO wahl%
                fs$(i%)=fs$(i%-1)
              NEXT i%
              fs$(wahl%)=sel_buf$
              CLR sel_buf$
            ENDIF
          ENDIF
          @screen
          @show_files
          @maus_off
        ENDIF
      ELSE
        IF my%<3*zh% AND min%>1
          DEC min%
          @show_files
        ELSE
          IF my%>3*zh%+lx%*zh% AND min%+pt%<max% AND max%>lx%
            INC min%
            @show_files
          ENDIF
        ENDIF
      ENDIF
    ENDIF
    IF mk%=2 AND LEN(sel_buf$)
      @alrt(1,"Sie haben noch eine |Datei im Puffer.",1,"Nochmal")
      CLR mk%
    ENDIF
    EXIT IF mk%=2
  LOOP
RETURN
PROCEDURE dir_secsearch
  fselect(pfad$+"*.*","",fi$)          ! Routine sucht Verzeichnissektor
  IF LEN(fi$)                           ! der eine bestimmte Datei oder Ordner
    @chk_drv(fi$)                       ! enthÑlt.
    IF drv%
      @do_pfad(fi$)
      @boot_sec(0)
      @get_fld_name(fi$)
      IF LEN(fld$)
        @nam_conv(fld$,1)
        fac$=fil$
        '
        i%=LEN(pfad$)-1
        WHILE MID$(pfad$,i%,1)<>"\" AND i%>0
          DEC i%
        WEND
        fac$=LEFT$(pfad$,i%)+fac$
        @find_files
        '
        CLR j%
        REPEAT
          a$=CHR$(drive%+65)+":"+folder$(j%)+"\"+file$(j%)
          EXIT IF fac$=a$
          INC j%
        UNTIL j%>total%
        IF j%<total%
          cl%=cluster%(j%)
          lgs%=(cl%-2)*spc%+first_sec%
        ELSE
          CLR lgs%
          @alrt(1,"Fehler aufgetreten!|Ordner nicht gefunden!",1,"Dumm")
        ENDIF
      ELSE
        lgs%=fat_anf%+len_fat%
      ENDIF
      @lesen
    ENDIF
  ENDIF
RETURN
PROCEDURE search_name(se$)
  i%=1
  WHILE file$(i%)<>se$
    INC i%
    EXIT IF i%>total%
  WEND
RETURN
PROCEDURE dir_path
  @find_files
  IF total%
    titel$="Pfadname"+STRING$(50,32)+"   Startcluster"
    @alrt(1,"Alle Pfade ausgeben |auf...    ",3,ddm$)
    @dev("BAUM_"+CHR$(drive%+65)+".TXT")
    IF device%<>99 OR erg%=3
      IF erg%<3
        @fwritec(hdl%,"Drive: "+CHR$(drive%+65)+cr$)
      ELSE
        PRINT AT(4,2);titel$;
      ENDIF
      FOR i%=1 TO total%
        INC j%
        IF att%(i%) AND 16
          @nam_conv(file$(i%),0)
          a$=folder$(i%)+"\"+fil$
          IF erg%=3
            PRINT AT(3,zz%+4);a$;
            PRINT AT(70,zz%+4);cluster%(i%);
            INC zz%
            IF zz%>15 AND i%<>total%
              @page(titel$)
            ENDIF
          ELSE
            @fwrite(hdl%,a$+SPACE$(65-LEN(a$)))
            @fwritec(hdl%,STR$(cluster%(i%))+SPACE$(5-LEN(STR$(cluster%(i%)))))
          ENDIF
        ENDIF
      NEXT i%
    ENDIF
  ELSE
    @alrt(1,"Keine Dateien ....... ",1,"Na gut")
    erg%=1
  ENDIF
  @look_ex
RETURN
PROCEDURE dir_file
  LOCAL cnt%
  @find_files
  IF total%
    DO
      zx%=4
      CLR zz%
      @alrt(1,"Ausgeben auf... ",3,ddm$)
      @dev("FILES.TXT")
      DEFMOUSE 0
      @eingabe("Suchmuster eingeben:","",12)
      a$=UPPER$(a$)
      @wandeln(a$)
      @alltoone(a$)
      f$=a$
      IF device%<>99 OR erg%=3
        @screen
        CLR cnt%,zz%
        FOR i%=1 TO total%
          s$=LEFT$(file$(i%),8)+"."+RIGHT$(file$(i%),3)
          @n_compare(s$,f$)
          IF gleich!
            INC cnt%
            a$=folder$(i%)+"\"+s$
            b$=a$+SPACE$(52-LEN(a$))
            b$=b$+STR$(cluster%(i%))+SPACE$(5-LEN(STR$(cluster%(i%))))
            b$=b$+RIGHT$(n$+BIN$(att%(i%)),8)+SPACE$(2)+STR$(laenge%(i%))
            @ausgabe(b$)
            IF zz%>15 AND i%<>total%
              @page("")
              IF mk%=2
                i%=total%+1
              ENDIF
            ENDIF
          ENDIF
        NEXT i%
        PRINT AT(4,2);cnt%;" Dateien gefunden."
      ENDIF
      EXIT IF mk%=2 OR erg%<3
      @maus_klick
      EXIT IF mk%=2
    LOOP
  ENDIF
  IF erg%<3
    @fclose(hdl%)
  ENDIF
  @screen
RETURN
PROCEDURE dir_all_files
  @find_files
  IF total%
    titel$=STRING$(26,32)+"Name        Cluster Attribut  LÑnge"
    CLR j%,nm%
    @alrt(1,"Alle Dateien ausgeben |auf...   ",3,ddm$)
    @dev("FILES.ALL")
    IF device%<>99 OR erg%=3
      DEFMOUSE 2
      CLR fehler%
      zx%=4
      IF erg%=3
        PRINT AT(4,2);titel$
      ELSE
        @fwritec(hdl%,"Drive: "+CHR$(drive%+65)+cr$)
        @fwritec(hdl%,"Name        Cluster Attribut   LÑnge")
        @fwritec(hdl%,STRING$(36,"="))
      ENDIF
      IF fehler%>=0
        FOR i%=1 TO total%
          INC j%
          IF folder$(i%)<>folder$
            fs$=folder$(i%)
            IF erg%=3
              PRINT AT(3,zz%+4);ro$;"Ordner";rof$'fs$
              INC zz%
              IF zz%>15 AND i%<>total%
                @page(titel$)
                IF mk%=2
                  i%=total%+1
                ENDIF
              ENDIF
            ELSE
              @fwritec(hdl%,cr$+"Ordner : "+fs$)
            ENDIF
          ENDIF
          folder$=folder$(i%)
          a$=LEFT$(file$(i%),8)+"."+RIGHT$(file$(i%),3)
          b$=LEFT$(a$+"     ",14)
          b$=b$+LEFT$(STR$(cluster%(i%))+"      ",6)
          b$=b$+RIGHT$(n$+BIN$(att%(i%)),8)+"  "
          b$=b$+LEFT$(STR$(laenge%(i%))+"          ",10)
          CLR c$
          IF att%(i%) AND 16
            c$="Folder"
          ENDIF
          IF att%(i%) AND 2
            c$="Hidden"
          ENDIF
          IF att%(i%) AND 8
            nm%=1
            c$="Label"
          ENDIF
          IF erg%=3
            PRINT AT(30,zz%+4);b$'c$'
            INC zz%
            IF zz%>15 AND i%<>total%
              @page(titel$)
              IF mk%=2
                i%=total%+1
              ENDIF
            ENDIF
          ELSE
            @ausgabe(b$)
          ENDIF
        NEXT i%
        IF erg%=3
          PRINT AT(3,2);ro$;"Files";rof$'RIGHT$(n$+STR$(j%-fld%-nm%),4)'
          PRINT ro$;"Ordner";rof$'RIGHT$(n$+STR$(fld%),4)'
        ELSE
          @fwrite(hdl%,cr$+" Files "+RIGHT$(n$+STR$(j%-fld%-nm%),4))
          @fwritec(hdl%," Ordner "+RIGHT$(n$+STR$(fld%),4))
          @fclose(hdl%)
        ENDIF
      ENDIF
    ENDIF
  ELSE
    @alrt(1,"Keine Dateien.... ",1,"Na gut")
    erg%=1
  ENDIF
  IF mk%=2
    @screen
  ELSE
    IF erg%=3
      @help_ex
    ENDIF
  ENDIF
  DEFMOUSE 0
RETURN
PROCEDURE dir_fldren            ! Ordner umbenennen !
  LOCAL i%,j%,sf$,sf%
  fselect(pfad$+"*.*","",fi$) ! Ordner îffnen
  @chk_drv(fi$)
  IF drv%
    @do_pfad(fi$)
    @get_fld_name(fi$)          ! Ordnernamen holen aus Pfadnamen
    @nam_conv(fld$,1)
    fac$=fil$                   ! merken
    IF LEN(fld$)
      @find_files               ! Dateibaum durchsuchen
      @search_name(fac$)        ! ist Ordner da?
      IF (att%(i%) AND 16)<>0 AND i%<=total%
        cl%=cluster%(i%)        ! Cluster des Ordners holen
        folder$=file$(i%)       ! Pfadname
        sct%=sec%(i%)           ! Sektor in dem Ordner steht
        lgs%=(cl%-2)*spc%+first_sec%
        DO
          SHOWM
          status%=BIOS(4,0,L:VARPTR(puffer$),1,sct%,drive%)
          IF status%=-14
            @boot_sec(0)
            SHOWM
            status%=BIOS(4,0,L:VARPTR(puffer$),1,sct%,drive%)
          ENDIF
          @err_inf(status%)
          FOR i%=1 TO bps% STEP 32
            IF ASC(MID$(puffer$,i%,1))=0
              i%=9999
            ELSE
              IF MID$(puffer$,i%,11)=folder$
                @eingabe("Neuer Ordnername",folder$,11)
                a$=LEFT$(a$+"           ",11)
                MID$(puffer$,i%,11)=a$
                i%=9998
              ENDIF
            ENDIF
          NEXT i%
          EXIT IF i%>9997
          INC sct%
        LOOP
        IF i%=9999
          @alrt(1,"Datei nicht gefunden",1,"Abbruch")
        ELSE
          IF a$<>folder$
            @media(drive%)
            SHOWM
            status%=BIOS(4,1,L:VARPTR(puffer$),1,sct%,drive%)
            IF status%=-14
              @boot_sec(0)
              SHOWM
              status%=BIOS(4,1,L:VARPTR(puffer$),1,sct%,drive%)
            ENDIF
            @err_inf(status%)
            lgs%=sct%
            @lesen
          ENDIF
        ENDIF
      ELSE
        @alrt(1,"Fehler aufgetreten!|Ordner nicht gefunden!",1,"Dumm")
      ENDIF
    ENDIF
    @screen
    @lesen
  ENDIF
RETURN
PROCEDURE dir_sec               ! ersten Directory-Sektor einlesen
  IF disc!=TRUE
    @change
    @boot_sec(0)
    lgs%=fat_anf%+len_fat%
    @lesen
    CLR z%,xt%,yt%,tz%
    hex!=TRUE
  ENDIF
RETURN
PROCEDURE make_dir              ! Verzeichnis erzeugen
  fselect(pfad$+"*.*","",fi$)
  IF LEN(fi$)
    IF RIGHT$(fi$)="\"
      @eingabe("Neuen Ordner erzeugen:","",12)
      IF el%
        @set_pfad(fi$)
        IF fehler%>=0
          @dcreate(a$)
        ENDIF
      ENDIF
    ELSE
      i%=LEN(fi$)
      WHILE MID$(fi$,i%,1)<>"\" AND i%>1
        DEC i%
      WEND
      a$=RIGHT$(fi$,LEN(fi$)-i%)
      fi$=LEFT$(fi$,i%-1)
      @set_pfad(fi$)
      IF fehler%>=0
        @dcreate(a$)
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE rm_dir                ! Verzeichnis lîschen
  PRINT AT(3,2);"Bitte zu lîschenden Ordner îffnen"
  fselect(pfad$+"*.*","",fi$)
  IF LEN(fi$) AND RIGHT$(fi$)="\"
    REPEAT
      @screen
      @do_pfad(fi$)
      @get_fld_name(fi$)        ! Ordnernamen holen aus Pfadnamen
      i%=LEN(fi$)-1
      EXIT IF MID$(fi$,i%,1)=":"
      WHILE MID$(fi$,i%,1)<>"\" AND i%>1
        DEC i%
      WEND
      fi$=LEFT$(fi$,i%)
      @set_pfad(fi$)
      EXIT IF fehler%<0
      '
      @ddelete(fld$)
      IF fehler%=-36            ! Wenn Ordner nicht leer
        lies_mode%=2
        dta$=STRING$(44,0)
        @fgetdta
        dta%=fehler%
        @lies_all(fi$)
        @ddelete(fld$)
      ENDIF
      @list
    UNTIL 1
  ENDIF
RETURN
PROCEDURE lies_2
  a$=p$+f$
  i%=LEN(a$)
  WHILE MID$(a$,i%,1)<>"\" AND i%>1
    DEC i%
  WEND
  b$=RIGHT$(a$,LEN(a$)-i%)
  @alrt(1,"Datei lîschen? |"+b$+"|",1,"Ok|Nie|Abbruch")
  IF erg%=3
    mk%=2
  ELSE
    IF erg%=1
      @fdelete(a$)
    ENDIF
  ENDIF
RETURN
' ---------------------- GEMDOS-Routinen ------------------------------
PROCEDURE dsetdrv(drive%)
  SHOWM
  fehler%=GEMDOS(14,W:drive%)
  IF fehler%<0
    @err_inf1(fehler%,"Dsetdrv:",gm$)
  ENDIF
RETURN
PROCEDURE fgetdta
  fehler%=GEMDOS(47)
RETURN
PROCEDURE dcreate(df$)
  df$=df$+CHR$(0)
  SHOWM
  fehler%=GEMDOS(57,L:VARPTR(df$))
  IF fehler%<0
    @err_inf1(fehler%,"Dcreate:",gm$)
  ENDIF
RETURN
PROCEDURE ddelete(df$)
  df$=df$+CHR$(0)
  SHOWM
  fehler%=GEMDOS(58,L:VARPTR(df$))
  IF fehler%<0
    @err_inf1(fehler%,"Ddelete:",gm$)
  ENDIF
RETURN
PROCEDURE dsetpath(df$)
  df$=df$+CHR$(0)
  SHOWM
  fehler%=GEMDOS(59,L:VARPTR(df$))
  IF fehler%<0
    @err_inf1(fehler%,"Dsetpath:",gm$)
  ENDIF
RETURN
PROCEDURE fcreate(name$,attr%)
  df$=name$+CHR$(0)
  SHOWM
  handle%=GEMDOS(60,L:VARPTR(df$),W:attr%)
  fehler%=handle%
  IF fehler%<1
    @err_inf1(fehler%,"Fcreate:",gm$)
  ENDIF
RETURN
PROCEDURE fopen(df$,fmode%)
  LOCAL f%
  df$=df$+CHR$(0)
  SHOWM
  handle%=GEMDOS(61,L:VARPTR(df$),W:fmode%)
  fehler%=handle%
  IF fehler%<0
    @err_inf1(fehler%,"Fopen:",gm$)
  ENDIF
RETURN
PROCEDURE fclose(handle%)
  SHOWM
  fehler%=GEMDOS(62,W:handle%)
  IF fehler%<0
    @err_inf1(fehler%,"Fclose:",gm$)
  ENDIF
RETURN
PROCEDURE fread(fhandle%,bytes%)
  buf$=SPACE$(bytes%)
  SHOWM
  fehler%=GEMDOS(63,W:fhandle%,L:bytes%,L:VARPTR(buf$))
  @freadf
RETURN
PROCEDURE freadf
  IF fehler%<0
    @err_inf1(fehler%,"Fread:",gm$)
  ENDIF
  IF fehler%<>bytes%
    @err_inf1(fehler%,"Fread:Lesen",gm$)
  ENDIF
RETURN
PROCEDURE fread2(fhandle%,fread%,bytes%)
  SHOWM
  fehler%=GEMDOS(63,W:fhandle%,L:bytes%,L:fread%)
  @freadf
RETURN
PROCEDURE fwrite(fhandle%,buf$)
  SHOWM
  fehler%=GEMDOS(64,fhandle%,L:LEN(buf$),L:VARPTR(buf$))
  @fwritef
RETURN
PROCEDURE fwritef
  IF fehler%=0 OR fehler%<>LEN(buf$)
    @err_inf1(fehler%,"Fwrite:",gm$)
    fehler%=-1
  ENDIF
RETURN
PROCEDURE fwritec(fhandle%,buf$)
  buf$=buf$+cr$                         ! Text schreiben + CR+LF
  SHOWM
  fehler%=GEMDOS(64,fhandle%,L:LEN(buf$),L:VARPTR(buf$))
  @fwritef
RETURN
PROCEDURE fwrite2(fhandle%,fw%,fz%)
  SHOWM
  fehler%=GEMDOS(64,fhandle%,L:fz%,L:fw%)
  IF fehler%=0 OR fehler%<>fz%
    @err_inf1(fehler%,"Fwrite:",gm$)
  ENDIF
RETURN
PROCEDURE fdelete(df$)
  df$=df$+CHR$(0)
  SHOWM
  fehler%=GEMDOS(65,L:VARPTR(df$))
  IF fehler%<0
    @err_inf1(fehler%,"Fdelete:",gm$)
  ENDIF
RETURN
PROCEDURE fseek(offset%,fhandle%,modus%)
  SHOWM
  fehler%=GEMDOS(66,L:offset%,W:fhandle%,W:modus%)
  IF fehler%<0
    @err_inf1(fehler%,"Fseek:",gm$)
  ENDIF
RETURN
PROCEDURE fattrib(df$,attr%,fmode%)
  df$=df$+CHR$(0)
  SHOWM
  fehler%=GEMDOS(67,L:VARPTR(df$),fmode%,attr%)
  IF fehler%<0
    @err_inf1(fehler%,"Fattrib:",gm$)
  ENDIF
RETURN
PROCEDURE fsfirst(df$,fmode%)           ! unbenutzt
  SHOWM
  fehler%=GEMDOS(78,L:VARPTR(df$),W:fmode%)
  IF fehler%<>0
    @err_inf1(fehler%,"Fsfirst:",gm$)
  ENDIF
RETURN
PROCEDURE frename(df$,df2$)
  SHOWM
  fehler%=GEMDOS(86,0,L:VARPTR(df$),L:VARPTR(df2$))
  IF fehler%<>0
    @err_inf1(fehler%,"Frename:",gm$)
  ENDIF
RETURN
PROCEDURE fdatime(df%,hdl%,fmode%)
  SHOWM
  fehler%=GEMDOS(87,L:df%,W:hdl%,W:fmode%)
  IF fehler%<>0
    @err_inf1(fehler%,"Fdatime:",gm$)
  ENDIF
RETURN
'
' ----------------------------- Tasteneingabe ------------------------------
PROCEDURE taste(a$,mk%)
  LOCAL a%
  a%=ASC(RIGHT$(a$))
  SHOWM
  '
  IF (BIOS(11,-1) XOR 8)=0      ! = ALT
    @alt(a%)
  ENDIF
  IF (BIOS(11,-1) XOR 4)=0      ! = CTRL
    @control(a%)
  ELSE
    '
    IF LEN(a$)=2                ! Cursor- oder Sondertasten
      @cursor(a$)
    ELSE
      IF mk%=2 OR a%=27         ! ESC oder Mousebutton rechts
        IF hpt!=TRUE
          @change
          @exit
        ELSE
          @change
          @felder_text(0)       ! zurÅck zum Hauptmenö
          @clr_prg_load
          CLR x%,x1%,u1%
          hpt!=TRUE
          @no_on
          disc!=TRUE
          @lesen
          @list
        ENDIF
      ELSE
        IF a%=9
          @tab                  ! Tabulator
        ELSE
          @edit_buf(a$)         ! sonst Edit Buffer
        ENDIF
      ENDIF
    ENDIF
  ENDIF
RETURN
' ----------------------------- Maus positionieren ------------------------
PROCEDURE maus_pos
  IF my%<3*zh%
    @scrolldown
  ELSE
    IF my%>=19*zh%
      @scrollup
    ELSE
      xt%=(mx%-9*8)/8               ! Cursor positionieren
      yt%=(my%-3*zh%)/zh%
      IF xt%>46 AND xt%<51
        xt%=46
      ENDIF
      IF xt%>=0 AND xt%<47
        IF FRAC((xt%+1)/3)<>0
          hex!=TRUE
        ELSE
          xt%=MAX(0,xt%-1)
        ENDIF
      ELSE
        IF xt%>=51 AND xt%<67
          hex!=FALSE
        ENDIF
      ENDIF
    ENDIF
  ENDIF
  @set_tz
  @cursor_anz
RETURN
PROCEDURE edit_buf(a$)
  a%=ASC(a$)
  IF hex!=FALSE                         ! Edit in ASCII-Teil
    dt%=a%
    @edit_ex
  ELSE
    IF (a%>96 AND a%<103) OR (a%>64 AND a%<71) OR (a%>47 AND a%<58)
      IF a%>&H60
        SUB a%,32
      ENDIF
      a%=a%-48+7*(a%>&H40)
      b%=buf%+tz%+z%                    ! Alter Wert
      dtl%=PEEK(b%) AND 15              ! in Lownibble und
      dth%=PEEK(b%) AND 240             !    Hinibble zerlegen
      IF FRAC((xt%+3)/3)=0
        dt%=dtl%+a%*16                  ! Cursor ist auf Hi-Nibble
      ELSE
        dt%=dth%+a%                     !        ist auf Low - "
      ENDIF
      @edit_ex
    ENDIF
  ENDIF
RETURN
PROCEDURE edit_ex
  ch!=TRUE
  POKE buf%+tz%+z%,dt%                  ! in Buffer schreiben
  PRINT coff$;
  @zeile(yt%)                           ! ausgeben in Hex und Ascii
  @cursor(CHR$(0)+CHR$(77))             ! Cursor weiter
RETURN
PROCEDURE info                          ! Statuszeile updaten
  PRINT coff$;
  ON mode% GOSUB disc_inf,fil_inf,hard_inf,ram_inf
  IF FRAC((xt%+1)/3)=0 AND hex!=TRUE
    @cursor(CHR$(0)+CHR$(77))
  ENDIF
  @cursor_anz
  DEFMOUSE 0
RETURN
PROCEDURE cursor_anz
  LOCAL a%,a$
  a%=z%+tz%
  DEFTEXT ,,,dtk%
  a$="$"+RIGHT$(n$+HEX$(PEEK(a%+buf%)),2)+" "+RIGHT$(n$+STR$(PEEK(a%+buf%)),3)+" %"+RIGHT$(n$+BIN$(PEEK(a%+buf%)),8)+" "
  @dec_hex_val(a%+fp%,7)
  TEXT hxl%,hyl%,a$+av$
  DEFTEXT ,,,dtg%
  PRINT AT(xt%+10,yt%+4);con$;
RETURN
PROCEDURE dec_hex
  dec%=1-dec%
  @info
  @maus_off
RETURN
PROCEDURE dec_hex_val(value%,lang%)
  IF dec%
    av$=RIGHT$(n$+STR$(value%),lang%)
  ELSE
    av$="$"+RIGHT$(n$+HEX$(value%),lang%-1)
  ENDIF
RETURN
PROCEDURE fil_inf
  @dec_hex_val(fl%,6)
  PRINT AT(3,2);ro$;"Bytes";rof$;';av$'
  PRINT ro$;"Status";rof$'inf$''''''ro$;"Filename";rof$'
  PRINT RIGHT$(STRING$(36,32)+fi_o$,36);
RETURN
PROCEDURE ram_inf
  @dec_hex_val(ram_addr%,9)
  PRINT AT(3,2);ro$;"Adresse";rof$'av$'
  PRINT STRING$(56,32)'
RETURN
PROCEDURE hard_inf
  @dec_hex_val(block%,6)
  PRINT AT(3,2);ro$;"Block";rof$'av$'
  PRINT ro$;"Target";rof$'target%'ro$;"Unit";rof$'geraet%'
  PRINT ro$;"Head";rof$'RIGHT$(STR$(kopf%),1)'
  PRINT ro$;"Zyl";rof$;" $";RIGHT$(n$+HEX$(zyl%),3)'
  PRINT ro$;"Error";rof$;" ";RIGHT$("   "+STR$(h_error%),3)'
  IF h_tim%
    PRINT ro$;"-TIMEOUT!!-";rof$'
  ELSE
    PRINT ro$;"Status";rof$;" $";RIGHT$(n$+HEX$(h_fehler%),2)'
  ENDIF
  PRINT ro$;"DMA";rof$;" $";RIGHT$(n$+HEX$(dma_st%),2)'
RETURN
PROCEDURE disc_inf
  a%=lgs%                       ! logischen Sektor fÅr Anzeige umrechnen
  IF drive%<2
    track%=a%/spt%              ! in Track und Sektor
    sektor%=(a% MOD spt%)+1
    IF sid%=2
      trk=track%/2
      IF trk=INT(trk)
        CLR seite%
      ELSE
        seite%=1
      ENDIF
      track%=trk
    ELSE
      CLR seite%
    ENDIF
  ENDIF
  cluster%=MAX(0,INT((lgs%-first_sec%)/spc%)+2)
  @dec_hex_val(lgs%,6)
  PRINT AT(3,2);ro$;"Log.Sec";rof$'av$'
  @dec_hex_val(cluster%,6)
  PRINT ro$;"Cluster";rof$'av$'
  IF drive%<2
    PRINT ro$;"Track";rof$'RIGHT$(n$+STR$(track%),2)'
    PRINT ro$;"Sektor";rof$'RIGHT$(n$+STR$(sektor%),2)'
    PRINT ro$;"Side";rof$'seite%'
  ELSE
    PRINT ro$;"Track";rof$''''
    PRINT ro$;"Sektor";rof$''''ro$;"Side";rof$'''
  ENDIF
  PRINT ro$;"Drive";rof$'CHR$(drive%+65)'
  PRINT ro$;"Status";rof$'RIGHT$("   "+STR$(status%),3)'
RETURN
PROCEDURE out_data
  LET data!=TRUE
  LET dump!=FALSE
  @sav_buf
RETURN
PROCEDURE out_dump
  LET data!=FALSE
  LET dump!=TRUE
  @sav_buf
RETURN
PROCEDURE sav_buf
  LOCAL i%,a%,o$
  @alrt(1,"Puffer ausgeben auf... ",1,dda$)
  zgr%=erg%-1
  IF data!=TRUE
    @dev("SAVE.DAT")
  ELSE
    @dev("SAVE.DMP")
  ENDIF
  IF device%<>99
    DEFMOUSE 2
    IF dump!=TRUE
      ON mode% GOSUB sav_0,sav_1,sav_2,sav_3
      @buffer_dump
    ELSE
      IF data!=TRUE
        @fwrite2(hdl%,buf%,bps%)
      ENDIF
    ENDIF
    @fclose(hdl%)
  ENDIF
  DEFMOUSE 0
RETURN
PROCEDURE sav_block
  LOCAL i%,a%,o$
  @alrt(1,"Block ausgeben auf... ",1,dda$)
  zgr%=erg%-1
  IF data!=TRUE
    @dev("BLOCK.DAT")
  ELSE
    @dev("BLOCK.DMP")
  ENDIF
  IF device%<>99
    DEFMOUSE 2
    IF dump!=TRUE
      ON mode% GOSUB sav_0,sav_1,sav_2,sav_3
      @block_dump
    ELSE
      IF data!=TRUE
        @fwrite2(hdl%,buf%,buf_end%-buf_beg%)
      ENDIF
    ENDIF
    @fclose(hdl%)
  ENDIF
  DEFMOUSE 0
RETURN
PROCEDURE sav_0
  cluster%=MAX(0,(lgs%-first_sec%) DIV spc%+2)
  @dec_hex_val(lgs%,6)
  @fwrite(hdl%,"Log.Sec "+av$+" ")
  @dec_hex_val(cluster%,6)
  @fwrite(hdl%,"Cluster "+av$+" ")
  IF drive%<2
    @fwrite(hdl%,"Track "+RIGHT$(n$+STR$(track%),2)+" ")
    @fwrite(hdl%,"Sektor "+RIGHT$(n$+STR$(sektor%),2)+" Side "+STR$(seite%)+" ")
  ELSE
    @fwrite(hdl%,"Track    Sektor    Side   ")
  ENDIF
  @fwritec(hdl%,"Drive "+CHR$(drive%+65)+" Status "+STR$(status%))
RETURN
PROCEDURE sav_1
  @dec_hex_val(fl%,6)
  @fwrite(hdl%,"Bytes "+av$+" ")
  @fwrite(hdl%,"Status "+inf$+"      Filename ")
  @fwritec(hdl%,RIGHT$(STRING$(37,32)+fi$,36))
RETURN
PROCEDURE sav_2
  @dec_hex_val(block%,6)
  @fwrite(hdl%,"Block "+av$+" ")
  @fwrite(hdl%,"Target "+STR$(target%)+" Unit "+STR$(geraet%)+" ")
  @fwrite(hdl%,"Head "+RIGHT$(STR$(kopf%),1)+" Zyl $"+RIGHT$(n$+HEX$(zyl%),3)+" ")
  @fwrite(hdl%,"Error $"+RIGHT$("   "+STR$(h_error%),3)+" ")
  @fwrite(hdl%,"Status $"+RIGHT$(n$+HEX$(h_fehler%),2)+" ")
  @fwritec(hdl%,"DMA $"+RIGHT$(n$+HEX$(dma_st%),2))
RETURN
PROCEDURE sav_3
  @dec_hex_val(ram_addr%,9)
  @fwritec(hdl%,"Adresse "+av$+STRING$(57,32))
RETURN
'
PROCEDURE block_dump
  LOCAL a%,b%,i%,zl%,o$
  CLR z%,zl%
  a%=buf_end%-buf_beg%
  sav_end%=a%/16
  REPEAT
    b%=buf%+zl%*16+buf_beg%
    o$=STRING$(66,32)
    FOR i%=1 TO 16
      a%=PEEK(b%+i%-1)
      MID$(o$,i%*3-2)=RIGHT$(n$+HEX$(a%),2)
      MID$(o$,i%+50,1)=MID$(ascii$(zgr%),a%+1,1)
    NEXT i%
    @dec_hex_val((offset%+z%+zl%*16+fp%+ram_addr%),6)
    @fwritec(hdl%,av$+"  "+o$)
    EXIT IF fehler%<0
    INC zl%
  UNTIL zl%>=sav_end%
RETURN
' --------------------------------------------------------------------------
PROCEDURE scrollup
  IF z%<bps%-256
    ADD z%,16
    IF blitter%=3
      PRINT coff$;                 ! Cursor aus
      GET 20,4*zh%,619,19*zh%,sc$  ! Ausschnitt holen
      PUT 20,3*zh%,sc$             ! eine Zeile hîher wieder rein
      @zeile(15)
    ELSE
      @list
    ENDIF
  ELSE
    @ctrl_n
  ENDIF
RETURN
PROCEDURE scrolldown
  IF z%>=16
    SUB z%,16
    IF blitter%=3
      PRINT coff$;                  ! Cursor aus
      GET 9,3*zh%,619,18*zh%-1,sc$  ! Ausschnitt holen
      PUT 9,4*zh%,sc$               ! eine Zeile tiefer wieder rein
      @zeile(0)
    ELSE
      @list
    ENDIF
  ELSE
    @ctrl_p
  ENDIF
RETURN
PROCEDURE cursor(a$)
  LOCAL a%
  a%=ASC(RIGHT$(a$))
  IF (a%>58 AND a%<69) OR (a%>83 AND a%<94)
    @floskel(a%)
  ELSE
    IF a%=80                    ! DOWN
      IF yt%<15
        INC yt%
      ELSE
        @scrollup
      ENDIF
    ELSE
      '
      IF a%=72                  ! UP
        IF yt%>0
          DEC yt%
        ELSE
          @scrolldown
        ENDIF
      ELSE
        '
        IF a%=75                ! LEFT
          DEC xt%
          IF hex!=TRUE
            IF xt%<0
              xt%=46
              DEC yt%
            ENDIF
          ELSE
            IF xt%<51
              xt%=66
              DEC yt%
            ENDIF
          ENDIF
          IF yt%<0
            @up
            yt%=15
          ENDIF
        ELSE
          '
          IF a%=77              ! RIGHT
            INC xt%
            IF hex!=TRUE
              IF xt%>46
                CLR xt%
                INC yt%
              ENDIF
            ELSE
              IF xt%>66
                xt%=51
                INC yt%
              ENDIF
            ENDIF
            IF yt%>15
              @down
              CLR yt%
            ENDIF
          ENDIF
        ENDIF
      ENDIF
    ENDIF
    '
    IF xt%>=0 AND xt%<47        ! HEX-BEREICH
      IF FRAC((xt%+1)/3)=0
        IF a%=75                ! wenn LEFT und hi_nibble, dann 2 LEFT
          DEC xt%
        ELSE
          INC xt%
        ENDIF
      ENDIF
      hex!=TRUE
    ELSE
      IF xt%>=51 AND xt%<67     ! ASCII - BEREICH
        hex!=FALSE
      ENDIF
    ENDIF
    '
    @set_tz
    IF a%=71                    ! Home
      @top
    ELSE
      IF a%=98
        @help
      ELSE
        IF a%=97
          @show_err_inf         ! Undo
        ENDIF
      ENDIF
    ENDIF
  ENDIF
  @cursor_anz
  WHILE LEN(INKEY$)
  WEND
RETURN
PROCEDURE set_tz
  IF hex!=TRUE
    tz%=xt%/3+yt%*16
  ELSE
    tz%=xt%-51+yt%*16
  ENDIF
RETURN
PROCEDURE alt(a%)
  IF a%>0
    ON a% GOSUB alt_a,alt_b,alt_c
  ENDIF
RETURN
PROCEDURE alt_a
RETURN
PROCEDURE alt_b
RETURN
PROCEDURE alt_c
RETURN
'
PROCEDURE control(a%)
  IF a%>0 AND a%<32
    ON a% GOSUB ctrl_a,ctrl_b,ctrl_c,ctrl_d,dum,ctrl_f,dum,dum,ctrl_tab,ctrl_j,ctrl_plus,ctrl_l,ctrl_m,ctrl_n,ctrl_o,ctrl_p,ctrl_q,ctrl_r,ctrl_s,ctrl_t,ctrl_u,dum,ctrl_w,ctrl_x,dum,dum,dum,log_out,dum,log_out,ctrl_minus
  ELSE
    IF a%=57                    ! Space
      @disass
    ELSE
      IF a%=72
        @up
      ELSE
        IF a%=80
          @down
        ELSE
          IF a%=98
            ux%=u1%
            u1%=15
            @ctrl_help
            u1%=ux%
          ELSE
            IF a%=71
              @top
            ELSE
              IF a%=119
                @lend
              ELSE
                IF a%=116 AND hex!=TRUE           ! ctrl ->
                  hex!=FALSE
                  xt%=xt%/3+51
                ELSE
                  IF a%=115 AND hex!=FALSE        ! ctrl <-
                    hex!=TRUE
                    xt%=(xt%-51)*3
                  ENDIF
                ENDIF
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ENDIF
    ENDIF
  ENDIF
  @cursor_anz
RETURN
PROCEDURE set_stat
  VOID C:utis%(&H300,L:ak%,L:bps%-1)
  IF buf_end%>buf_beg%
    VOID C:utis%(&H301,L:ak%+buf_beg%,L:buf_end%-buf_beg%)
  ENDIF
  @list
RETURN
PROCEDURE ctrl_a                ! Blockanfang markieren
  buf_beg%=tz%+z%
  @set_stat
RETURN
PROCEDURE ctrl_b                ! Blockende markieren
  buf_end%=tz%+z%
  @set_stat
RETURN
PROCEDURE ctrl_c                ! Block kopieren
  bc%=buf_end%-buf_beg%+1
  IF bc%>1
    bb$=STRING$(bc%,0)
    BMOVE buf_beg%+buf%,VARPTR(bb$),bc%
    BMOVE VARPTR(bb$),buf%+tz%+z%,bc%
    CLR bb$
    ch!=TRUE
    @list
  ENDIF
RETURN
PROCEDURE ctrl_d
  @alrt(1,"Was sichern?  ",1,"Dump|Data|Abbruch")
  ON erg% GOSUB out_dump,out_data
RETURN
PROCEDURE ctrl_f                ! Block fÅllen mit Byte unter Cursor
  bc%=buf_end%-buf_beg%
  IF bc%
    INC bc%
    dt%=PEEK(buf%+tz%+z%)
    bb$=STRING$(bc%,dt%)
    BMOVE VARPTR(bb$),buf_beg%+buf%,bc%
    CLR bb$
    ch!=TRUE
    @list
  ENDIF
RETURN
PROCEDURE ctrl_j
  @alrt(1,"Als was sichern?  ",1,"Dump|Data|Abbruch")
  IF erg%=1
    LET data!=FALSE
    LET dump!=TRUE
  ELSE
    LET data!=TRUE
    LET dump!=FALSE
  ENDIF
  @sav_block
RETURN
PROCEDURE ctrl_l
  @alrt(1,"Was laden?  ",1,"Fkey|Info|Abbruch")
  IF erg%<3
    IF erg%=1
      fselect(pfad$+"*.*",floskel$,flo$)
      IF EXIST(flo$)
        @do_pfad(flo$)
        @read_floskel(flo$)
      ENDIF
    ELSE
      fselect(pfad$+"*.*",p_inf$,fi$)
      IF LEN(fi$) AND RIGHT$(fi$)<>"\"
        @do_pfad(fi$)
        @init_do(fi$)
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE ctrl_m
  @magic                ! Pufferinhalt auf Summe $1234
RETURN
PROCEDURE sektor_magic
  @magic
RETURN
PROCEDURE magic
  VOID XBIOS(18,L:buf%,L:-1,-1,1)
  z%=bps%-256
  ch!=TRUE
  @list
RETURN
PROCEDURE ctrl_n        ! Next Sektor
  DEFMOUSE 2
  z%=bps%-256
  @down
  DEFMOUSE 0
RETURN
PROCEDURE ctrl_o
  @eingabe("Anzeige-Offset eingeben:",STR$(offset%),10)
  IF el%
    offset%=VAL(a$)
    @list
  ENDIF
RETURN
PROCEDURE ctrl_p        ! Previous Sektor
  DEFMOUSE 2
  CLR z%
  @up
  DEFMOUSE 0
RETURN
PROCEDURE ctrl_q
  g$="CTRL-Q - "
  REPEAT
    @search
    @info
    EXIT IF found!=FALSE
    search_cont%=1
    ON mode% GOSUB ctrl_q0,ctrl_q1,ctrl_q2,ctrl_q3
  UNTIL found!=FALSE
  CLR search_cont%
  @list
RETURN
PROCEDURE ctrl_q0
  @err_inf2(g$+"in Sektor "+STR$(lgs%)+" at $"+HEX$(tz%+z%))
RETURN
PROCEDURE ctrl_q1
  @err_inf2(g$+" $"+HEX$(fp%+tz%+z%))
RETURN
PROCEDURE ctrl_q2
  @err_inf2(g$+"in Block $"+HEX$(block%)+" at $"+HEX$(tz%+z%))
RETURN
PROCEDURE ctrl_q3
  @err_inf2(g$+"an Adresse $"+HEX$(ram_addr%))
RETURN
PROCEDURE ctrl_r
  @change
  @search
  @list
RETURN
PROCEDURE ctrl_s
  @alrt(1,"Save ........    ",1,"FKEY|INFO|ABBRUCH")
  ON erg% GOSUB out_f_key,out_info
RETURN
PROCEDURE ctrl_t                ! Block auf Funktionstaste legen
  bc%=buf_end%-buf_beg%+1
  IF bc%>1
    @eingabe("Welche F-Taste (1-20):","",4)
    IF el%
      b%=VAL(a$)
      IF b%>0 AND b%<21
        DEFMOUSE 2
        flos$(0,b%)=STR$(bc%*2)
        flos$(1,b%)=STRING$(bc%*2,0)
        j%=1
        FOR i%=1 TO bc%
          fu%=PEEK(buf%+buf_beg%+i%-1)
          MID$(flos$(1,b%),j%)=RIGHT$(n$+HEX$(fu%),2)
          ADD j%,2
        NEXT i%
      ENDIF
    ENDIF
  ENDIF
  DEFMOUSE 0
RETURN
PROCEDURE ctrl_u
  @eingabe("Eingabe fÅr Umrechnen:","",10)
  IF el%
    a%=VAL(a$)
    @alrt(0,"DEZ: "+STR$(a%)+"|HEX:$"+RIGHT$(n$+HEX$(a%),8),1," Danke ")
  ENDIF
RETURN
PROCEDURE ctrl_w
  @change
  search_cont%=1
  @search
  @list
  CLR search_cont%
RETURN
PROCEDURE ctrl_x                ! INTEL
  LOCAL a%,b%
  IF tz%+z%<bps%-1
    b%=buf%+tz%+z%              ! alter Wert
    a%=PEEK(b%)
    POKE b%,PEEK(buf%+tz%+z%+1)
    POKE b%+1,a%
    PRINT coff$;
    @zeile(yt%)
    PRINT con$;
    ch!=TRUE
  ENDIF
  @cursor_anz
RETURN
PROCEDURE tab                   ! Tabulator
  FOR i%=1 TO 8
    @cursor(CHR$(0)+CHR$(77))
  NEXT i%
RETURN
PROCEDURE ctrl_tab              ! Back - Tabulator
  FOR i%=1 TO 8
    @cursor(CHR$(0)+CHR$(75))
  NEXT i%
RETURN
PROCEDURE ctrl_plus
  @eingabe("Plus: 1.Wert:","",10)
  IF el%
    b%=VAL(a$)
    @eingabe("Plus: 2.Wert:","",10)
    IF el%
      a%=VAL(a$)+b%
      @alrt(0,"DEZ: "+STR$(a%)+"|HEX:$"+RIGHT$(n$+HEX$(a%),8),1," Danke ")
    ENDIF
  ENDIF
RETURN
PROCEDURE ctrl_minus
  @eingabe("Minus: 1.Wert:","",10)
  IF el%
    b%=VAL(a$)
    @eingabe("Minus: 2.Wert:","",10)
    IF el%
      a%=b%-VAL(a$)
      @alrt(0,"DEZ: "+STR$(a%)+"|HEX:$"+RIGHT$(n$+HEX$(a%),8),1," Danke ")
    ENDIF
  ENDIF
RETURN
PROCEDURE set_time
  @eingabe("Neue Uhrzeit: HH:MM:SS",TIME$,10)
  IF el%
    SETTIME a$,""
  ENDIF
RETURN
PROCEDURE set_date
  @eingabe("Neues Datum: DD.MM.JJJJ",DATE$,11)
  IF el%
    SETTIME "",a$
  ENDIF
RETURN
'
PROCEDURE clock                 ! Zeitanzeige aktivieren/lîschen
  tim%=1-tim%
  IF tim%=0
    PUT 12,hyl%-4*res%,uhr$
  ELSE
    GET 12,hyl%-4*res%,76,hyl%+res%,uhr$
    tt%=TIMER-400
    @time
  ENDIF
  @maus_off
RETURN
PROCEDURE time                  ! Zeigt die Zeit alle 2 Sekunden an
  IF tim% AND TIMER-tt%>400
    DEFTEXT ,,,dtk%
    TEXT 12,hyl%,TIME$
    DEFTEXT ,,,dtg%
    tt%=TIMER
  ENDIF
RETURN
PROCEDURE show_date
  LOCAL a$
  a$=LEFT$(DATE$,6)+RIGHT$(DATE$,2)
  PUT 12,hyl%-4*res%,uhr$
  DEFTEXT ,,,dtk%
  TEXT 12,hyl%,a$
  DEFTEXT ,,,dtg%
  @maus_off
RETURN
PROCEDURE info_system
  @alrt(1,"SYSTEM INFO Ausgabe auf ",3,ddm$)
  @dev("SYSTEM.TXT")
  IF device%<>99 OR erg%=3
    @screen
    zz%=3
    zx%=4
    @ausgabe(RIGHT$(n$+STR$(mfr%-FRE(0)),8)+" Bytes Variablen")
    @ausgabe(RIGHT$(n$+STR$(init_mem%),8)+" Bytes Puffer")
    @ausgabe(RIGHT$(n$+STR$(res_mem%),8)+" Bytes FAT-Puffer")
    @ausgabe(RIGHT$(n$+STR$(FRE(0)),8)+" Bytes intern RAM frei")
    @malloc(-1)
    @ausgabe(RIGHT$(n$+STR$(fehler%),8)+" Bytes System-RAM frei")
    ADD zz%,3
    @ausgabe(RIGHT$(n$+STR$(bps%),8)+" Bytes im Puffer")
    '
    zz%=3
    zx%=40
    @ausgabe("Romversion     : "+HEX$(rom_version%))
    @ausgabe("Romstart       : $"+HEX$(romstart%))
    @ausgabe("Romende        : $"+HEX$(romend%))
    @ausgabe("")
    @ausgabe("Ramende        : $"+HEX$(ramend%)+" = "+STR$(INT(ramend%/1024))+" KByte")
    @ausgabe("")
    IF blitter%=3
      a$="Ein"
    ELSE
      a$="Nein"
    ENDIF
    @ausgabe("Blitter        : "+a$)
    '
    @look_ex
  ENDIF
RETURN
PROCEDURE info_crc
  IF buf_end%-buf_beg%>0
    @crc_start
    crc%=C:utis%(&H400,L:buf%+buf_beg%,L:buf_end%-buf_beg%+1,L:crc%)
    a$=RIGHT$(n$+HEX$(crc% AND &HFFFF),4)
    @alrt(1,"CRC-PrÅfsumme des  |markierten Blocks :|$"+a$,1,"OK")
  ELSE
    @alrt(0,"Kein Block markiert !",1,"Hmmmm")
  ENDIF
RETURN
PROCEDURE crc_start
  crc%=&HCDB4
  @alrt(1,"CRC-Startwert ",1,"$CDB4|$FFFF")
  IF erg%=2
    crc%=&HFFFF
  ENDIF
RETURN
PROCEDURE out_f_key
  PRINT coff$;
  @alrt(1,"Funktionstasten ausgeben... ",3,ddm$)
  IF erg%=3
    @info_fkey
  ELSE
    @dev(ver$+".KEY")
    IF device%<>99
      @f_key_dev
      @fclose(hdl%)
    ENDIF
  ENDIF
  @info
RETURN
PROCEDURE out_printer
  CLR device%
  @printer
  IF device%<>99
    REPEAT
      @eingabe("Text auf Drucker:","",40)
      IF LEN(a$)
        @fwritec(hdl%,a$)
      ENDIF
    UNTIL LEN(a$)=0
    @fclose(hdl%)
  ENDIF
RETURN
PROCEDURE info_fkey
  @screen
  PRINT AT(4,2);"Funktionstastenbelegung:"
  PRINT AT(4,4);"Nr. Bytes";SPC(31);"Nr. Bytes"
  FOR i%=1 TO 10
    @show_fkey(4,i%+5,i%)
    @show_fkey(44,i%+5,i%+10)
  NEXT i%
  @help_ex
RETURN
PROCEDURE show_fkey(x1%,y1%,nr%)
  LOCAL a%
  a%=VAL(flos$(0,nr%))/2
  PRINT AT(x1%,y1%);RIGHT$(n$+STR$(nr%),2)''RIGHT$(n$+STR$(a%),4)'
  IF a%
    PRINT LEFT$(flos$(1,nr%),25)
  ENDIF
RETURN
PROCEDURE f_key_dev
  FOR i%=1 TO 20
    IF LEN(flos$(0,i%))
      @fwritec(hdl%,STR$(i%))
      IF fehler%>=0
        @fwritec(hdl%,flos$(0,i%))
        j%=1
        DO
          @fwritec(hdl%,MID$(flos$(1,i%),j%,64))
          EXIT IF fehler%<0
          ADD j%,64
          EXIT IF j%>LEN(flos$(1,i%))
        LOOP
      ENDIF
    ENDIF
  NEXT i%
RETURN
' ------------------------------
PROCEDURE floskel(a%)           ! Funktionstasten abarbeiten
  LOCAL fu$
  IF a%>83 AND a%<94            ! mit Shift ??
    SUB a%,15
  ENDIF
  fu$=flos$(1,a%-58)            ! Funktionsstring auswÑhlen
  fu%=VAL(flos$(0,a%-58))       ! LÑnge
  bc%=z%+tz%
  IF fu%>0
    ch!=TRUE
    DEFMOUSE 2
    FOR fi%=1 TO fu% STEP 2
      POKE buf%+bc%,VAL("&h"+MID$(fu$,fi%,2))
      INC bc%
    NEXT fi%
  ENDIF
  @list
RETURN
PROCEDURE printer
  prt%=1
  WHILE OUT?(0)=FALSE
    @alrt(1,"Drucker nicht bereit! ",1,"Nochmal|Abbruch")
    prt%=erg%
    EXIT IF prt%=2
  WEND
  IF prt%=1
    @fopen("PRN:",1)
    hdl%=handle%
  ELSE
    device%=99
  ENDIF
RETURN
' --------------------- Device Handling --------------------------------
PROCEDURE dev(n.ame$)
  LOCAL a%,a$,ex$,ni%,fex%
  CLR device%,ex$
  IF erg%=3
    device%=99
  ELSE
    IF erg%=2
      @printer
    ELSE
      ni%=INSTR(n.ame$,".")
      IF ni%
        ex$=RIGHT$(n.ame$,LEN(n.ame$)-ni%)
      ENDIF
      fselect(pfad$+"*."+ex$,n.ame$,fd$)
      IF LEN(fd$)
        @do_pfad(fd$)
        IF EXIST(fd$)           ! Datei existiert bereits
          a%=LEN(fd$)
          IF a%<22
            a$=STRING$((22-a%)/2,32)+fd$+STRING$((22-a%)/2,32)
          ELSE
            a$=RIGHT$(fd$,22)
          ENDIF
          @alrt2(2,a$+"|existiert bereits!",2,"Ersetzen|AnhÑngen|Abbruch")
          IF erg2%=1
            @chk_create(fd$)    ! öberschreiben
          ELSE
            IF erg2%=2
              @chk_opn(fd$)     ! AnhÑngen
              IF device%<>99
                hdl%=handle%
              ENDIF
            ELSE
              device%=99        ! Abbruch nach EXIST
            ENDIF
          ENDIF
          '
        ELSE
          IF RIGHT$(fd$)<>"\"   ! Datei existiert noch nicht
            @chk_create(fd$)    ! Normal anlegen
          ELSE
            device%=99
          ENDIF
        ENDIF
      ELSE
        device%=99              ! kein Name
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE chk_create(chk$)
  @fcreate(chk$,0)              ! Datei immer mit Fcreate îffnen
  hdl%=handle%                  ! dadurch sofort Schreibschutzerkennung.
  IF hdl%<0
    device%=99                  ! Write-Protekt - Abbruch
  ENDIF
RETURN
PROCEDURE chk_opn(chk$)
  @fcreate(pfad$+dum$,0)        ! Dummy-Datei erzeugen - Schreibschutz?
  IF fehler%>0
    @fclose(handle%)            ! kein Schreibschutz, Dummy schlieûen
    @fdelete(pfad$+dum$)        ! und Dummy wieder lîschen
    @fopen(chk$,2)              ! jetzt Datei îffnen
    IF fehler%>=0
      @fseek(0,handle%,2)       ! LÑnge der Datei ermitteln
      IF fehler%<0
        @fclose(handle%)
        device%=99
      ENDIF
    ELSE
      device%=99
    ENDIF
  ELSE
    device%=99                  ! Write Protekt
  ENDIF
RETURN
' ------------------------------ Funktion -----------------------------------
PROCEDURE f_menu
  PRINT coff$;
  DEFFILL 1,2,4
  PBOX 0,0,638,res%*199         ! Hintergrund grau
  TITLEW #1,""
  INFOW #1,""
  DPOKE WINDTAB+2,1
  DPOKE WINDTAB+8,640
  DPOKE WINDTAB+10,res%*190
  OPENW 1,0,9*res%              ! Window îffnen
  MENU m$()
  menu!=TRUE
  ON MENU GOSUB menu_auswert
  ON MENU MESSAGE GOSUB m_message
  DO
    ON MENU
    EXIT IF mn%=12
  LOOP
  MENU KILL
  menu!=FALSE
  CLOSEW 1
  CLOSEW 0
  CLR mn%
  VOID XBIOS(21,3,0)    ! Cursor
  CLR invert%
  felder
  felder_text(u1%)
  kleine_boxen
  disc_on
  @list
  dx%=-1
RETURN
PROCEDURE menu_auswert
  MENU OFF
  mn%=MENU(0)
  IF mn%=1
    alrt(1,ver$+" |- der etwas andere|Diskmonitor|aus dem SCHEIBENKLEISTER",1,"Kapiert")
  ENDIF
  IF mn%=11
    f_pexec
  ENDIF
  IF mn%=13
    exit
  ENDIF
RETURN
PROCEDURE m_message
  IF MENU(1)=20
    DEFFILL 1,2,4
    PBOX 0,9*res%,639,res%*200
  ENDIF
RETURN
' ------------------------
PROCEDURE f_pexec
  @malloc(-1)
  @alrt(1,"Programm ausfÅhren ?| "+STR$(fehler%)+" Bytes RAM frei",0,"Ok|Abbruch")
  IF erg%=1
    fselect(pfad$+"*.*","",pex$)
    IF EXIST(pex$)
      PRINT coff$;
      @set_pfad(pex$)
      SHOWM
      EXEC 0,pex$,"",""
      @felder
      @felder_text(u1%)
      @kleine_boxen
      @invert_box
    ENDIF
  ENDIF
RETURN
PROCEDURE f_reset
  @alrt(0,"System-RESET?",3,"Warm|Kalt|Nieee")
  IF erg%<3
    VOID GEMDOS(&H20,L:0)               ! SUPER
    IF erg%=2
      LPOKE &H420,0
      LPOKE &H426,0
      LPOKE &H43A,0
    ENDIF
    reset_vektor%=LPEEK(&HFC0004)
    CALL reset_vektor%
  ENDIF
RETURN
PROCEDURE f_sound
  @alrt(1,"Bit 6 im Soundchip ? ",1,"Set|Clear|Abbruch")
  IF erg%<3
    IF erg%=1
      a%=XBIOS(30,W:64)         ! Ongibit
    ELSE
      a%=XBIOS(29,W:NOT 64)     ! Offgibit
    ENDIF
  ENDIF
RETURN
PROCEDURE f_cpu
  LOCAL a%,i%
  @screen
  PRINT AT(5,5);"CPU-SPEED:"
  REPEAT
    FOR i%=1 TO 10
      a%=C:utis%(&H800)
    NEXT i%
    PRINT AT(18,5);USING "~ ##.## MHz ",a%/104
  UNTIL MOUSEK=2 OR INKEY$=esc$
  @screen
  @list
RETURN
' --------------------------------------------------------------------------
PROCEDURE log_out
  IF log_dev%<>99
    IF NOT (EXIST(logbuch$))
      @alrt(1,"Logbuch ist noch nicht|aktiviert worden.",1,"Abbruch")
    ELSE
      DEFMOUSE 2
      @chk_opn(fd$)
      IF device%<>99
        @fwrite2(handle%,buf%,bps%)
        @fclose(handle%)
      ENDIF
    ENDIF
    DEFMOUSE 0
  ENDIF
RETURN
PROCEDURE out_logbuch
  erg%=1
  @extract(logbuch$)
  fx$=ext$
  @dev(fx$)
  logbuch$=fd$
  log_dev%=device%
  IF device%<>99
    @fclose(handle%)
  ENDIF
RETURN
' ------------------------------
PROCEDURE err_inf(fehler%)
  LOCAL a$
  IF fehler%<>0
    IF fer%<max_err%
      INC fer%
      a$=STR$(lgs%)
      IF ABS(fehler%)>20
        fehler%=1
      ENDIF
      err_fld$(fer%)=CHR$(drive%+65)+": LGS "+a$+" "+stat$(ABS(fehler%))
    ELSE
      err_fld$(max_err%)="Fehler-öberlauf"
      fer%=max_err%
    ENDIF
  ENDIF
RETURN
PROCEDURE err_inf1(fehler%,txt$,txt2$)
  IF fer%<max_err%
    INC fer%
    err_fld$(fer%)=CHR$(drive%+65)+": "+txt$+" "+txt2$+" "+STR$(fehler%)
  ELSE
    err_fld$(max_err%)="Fehler-öberlauf"
    fer%=max_err%
  ENDIF
  @alrt(1,txt$+"|"+txt2$+" "+STR$(fehler%),1," Aha ")
  IF fehler%>0
    status%=-1
  ENDIF
RETURN
PROCEDURE err_inf3(fehler%,txt$,txt2$)
  IF fer%<max_err%
    INC fer%
    err_fld$(fer%)=CHR$(drive%+65)+": "+txt$+" "+txt2$+" "+STR$(fehler%)
  ELSE
    err_fld$(max_err%)="Fehler-öberlauf"
    fer%=max_err%
  ENDIF
RETURN
PROCEDURE err_inf2(txt$)
  IF fer%<max_err%
    INC fer%
    err_fld$(fer%)=txt$
  ELSE
    err_fld$(max_err%)="Fehler-öberlauf"
    fer%=max_err%
  ENDIF
RETURN
PROCEDURE show_err_inf
  @screen
  titel$="Fehlerliste:"
  PRINT AT(4,2);titel$
  @show_err
  @screen
  @list
RETURN
PROCEDURE show_err      ! Fehlerseite ausgeben
  LOCAL i%
  IF fer%
    CLR zz%
    FOR i%=1 TO fer% STEP 2
      IF zz%>15
        @page(titel$)
      ENDIF
      @print_err(err_fld$(i%),4)
      @print_err(err_fld$(i%+1),44)
      INC zz%
      IF zz%>15
        @page(titel$)
      ENDIF
    NEXT i%
  ELSE
    PRINT AT(4,6);"Kein Fehler....."
  ENDIF
  @maus_klick
RETURN
PROCEDURE print_err(a$,sp%)
  IF LEN(a$)>78-sp%
    sp%=4
    INC zz%
    IF zz%>15
      @page(titel$)
    ENDIF
  ENDIF
  PRINT AT(sp%,zz%+4);a$;
RETURN
PROCEDURE err_clr
  IF fer%
    @alrt(1,"Fehlerseite lîschen? ",1,"Ja|Nein")
    IF erg%=1
      ERASE err_fld$()
      DIM err_fld$(max_err%)
      CLR fer%
    ENDIF
  ELSE
    @alrt(1,"Keine Fehler ",1," Toll ")
  ENDIF
  @maus_off
RETURN
PROCEDURE out_error
  @alrt(1,"Fehlerausgabe auf... ",1,dda$)
  @dev("ERROR.TXT")
  IF device%<>99
    @fwritec(hdl%," Fehlerliste:")
    @show_err_dev
    @fclose(hdl%)
  ENDIF
  @err_clr
RETURN
PROCEDURE show_err_dev
  LOCAL i%
  i%=1
  REPEAT
    @fwritec(hdl%,err_fld$(i%))
    EXIT IF fehler%<0
    INC i%
  UNTIL i%>fer%
RETURN
PROCEDURE mem_clr
  IF prg_adr%
    @mfree(prg_adr%)
    CLR prg_adr%
  ENDIF
  IF fmal%
    @mfree(fatbuf%)
    CLR res_mem%,fmal%,find%
    IF rdim%
      @dim_clr
    ENDIF
  ENDIF
RETURN
' ---------------------- Proceduren fÅr Bildschirm -------------------
PROCEDURE top
  CLR z%,xt%,yt%,tz%
  IF hex!=FALSE
    xt%=51
  ENDIF
  IF file_open%=1
    @change
    CLR fp%
    @lesen
  ENDIF
  @list
RETURN
PROCEDURE lend
  IF file_open%=1
    @change
    fp%=MAX(0,fl%-bps%)
    @lesen
  ELSE
    z%=bps%-256
    xt%=45
    IF hex!=FALSE
      xt%=66
    ENDIF
    yt%=15
    @set_tz
  ENDIF
  @list
RETURN
PROCEDURE down_0
  IF lgs%+1<spd%
    INC lgs%
  ELSE
    @alrt(1,"Grîûte Sektornummer: |"+STR$(spd%-1),1,"Abbruch")
  ENDIF
RETURN
PROCEDURE down_1
  IF file_open%=1
    IF fp%+bps%<fl%
      ADD fp%,bps%
    ENDIF
  ENDIF
RETURN
PROCEDURE down_2
  INC block%
RETURN
PROCEDURE down_3
  ADD ram_addr%,bps%
  @check_addr
RETURN
PROCEDURE down
  IF z%+256<bps%
    ADD z%,256
  ELSE
    @change
    CLR z%
    ON mode% GOSUB down_0,down_1,down_2,down_3
    @lesen
  ENDIF
  @list
RETURN
PROCEDURE up
  IF z%-256>=0
    SUB z%,256
  ELSE
    @change
    z%=bps%-256
    @dec
    yt%=15
    @set_tz
    @lesen
  ENDIF
  @list
RETURN
PROCEDURE dec_0
  IF lgs%>0
    DEC lgs%
  ENDIF
RETURN
PROCEDURE dec_1
  IF file_open%=1
    IF fp%
      fp%=fp%-bps%
      fp%=MAX(0,fp%)
    ENDIF
  ENDIF
RETURN
PROCEDURE dec_2
  IF block%>0
    DEC block%
  ENDIF
RETURN
PROCEDURE dec_3
  ram_addr%=MAX(ram_addr%-bps%,0)
RETURN
PROCEDURE dec
  ON mode% GOSUB dec_0,dec_1,dec_2,dec_3
RETURN
PROCEDURE nxt_blk
  CLR no_nxt%
  ON mode% GOSUB nxt0,nxt1,nxt2,nxt3
  IF no_nxt%=0
    @lesen
  ENDIF
RETURN
PROCEDURE nxt0
  INC lgs%
  IF lgs%+1>VAL(bis$)
    DEC lgs%
    no_nxt%=1
  ENDIF
RETURN
PROCEDURE nxt1
  IF file_open%=1
    ADD fp%,bps%
    IF fp%>=fl%
      SUB fp%,bps%
      no_nxt%=1
    ENDIF
  ENDIF
RETURN
PROCEDURE nxt2
  INC block%
  IF block%>VAL(bis$)
    no_nxt%=1
  ENDIF
RETURN
PROCEDURE nxt3
  ADD ram_addr%,bps%
  IF ram_addr%>=VAL(bis$)
    no_nxt%=1
  ENDIF
RETURN
PROCEDURE address
  @eingabe("List-Adresse :","",8)
  IF el%
    @change
    la%=VAL(a$)
    IF file_open%=1
      IF offset%-la%>0
        la%=la%-offset%
      ENDIF
      @alrt(0,"Adressierung? ",rel%,"Absolut|Relativ")
      rel%=erg%
      IF rel%=1
        fp%=la%
      ELSE
        fp%=fp%+la%
      ENDIF
    ELSE
      IF ram!=TRUE
        ram_addr%=la%
        @check_addr
      ELSE
        IF la%<=256
          z%=la%
        ENDIF
      ENDIF
    ENDIF
    hex!=TRUE
    @set_tz
    @lesen
    @list
  ENDIF
  @cursor_anz
RETURN
' ---------------------- FAT-Routinen ----------------------------
PROCEDURE fat_read1
  @boot_sec(0)
  lgs%=fat_anf%-len_fat%
  DEFMOUSE 2
  @lesen
RETURN
PROCEDURE fat_read2
  @boot_sec(0)
  lgs%=fat_anf%
  DEFMOUSE 2
  @lesen
RETURN
PROCEDURE fat_write     ! Cluster in FAT belegen/freigeben
  @eingabe("Wo lesen (xxx C/xxx S)","",10)
  IF el%
    @bios_block
    IF RIGHT$(a$)="S" OR RIGHT$(a$)="s"
      cluster%=MAX(0,(VAL(a$)-first_sec%) DIV spc%+2)
    ELSE
      cluster%=VAL(a$)
    ENDIF
    @read_in_fat(cluster%)
    @alrt(1,"Wert im Clustereintrag |Nr. "+STR$(cluster%)+":   $"+HEX$(aa%)+" = "+STR$(aa%),3,"Belegen|Frei|Wert")
    IF erg%=1
      @write_in_fat(ed%,cluster%)
    ELSE
      IF erg%=2
        @write_in_fat(0,cluster%)
      ELSE
        IF erg%=3
          @eingabe("Bitte neuen Wert eingeben","",6)
          IF el%
            @write_in_fat(VAL(a$),cluster%)
          ENDIF
        ENDIF
      ENDIF
    ENDIF
    @alrt(1,"FAT zurÅckschreiben ",0,"Ok|Abbruch")
    IF erg%=1
      @write_fat(anf_fat1%)
      @write_fat(anf_fat2%)
    ENDIF
  ENDIF
RETURN
PROCEDURE fat_read
  @eingabe("Clusternummer:","",6)
  IF el%
    bel_sec%=VAL(a$)
    @bios_block
    @read_in_fat(bel_sec%)
    @alrt(1,"Wert im Clustereintrag |Nr. "+STR$(bel_sec%)+":   $"+HEX$(aa%)+" = "+STR$(aa%),1," So So ")
  ENDIF
RETURN
PROCEDURE fat_cursor
  @eingabe("Clusternummer:","",6)
  IF el%
    clus%=VAL(a$)
    IF clus%<cpd%+2
      @bios_block
      IF bflag%=1
        lgs%=anf_fat1%+((clus%*2)/bps%)
        b%=clus%*2
      ELSE
        lgs%=anf_fat1%+((clus%*1.5)/bps%)
        b%=clus%*1.5
      ENDIF
      @lesen
      '
      WHILE b%>=bps%
        SUB b%,bps%
      WEND
      z%=INT(b%/256)*256
      b%=b%-z%
      yt%=b%/16
      xt%=b%-yt%*16+51
      IF hex!=TRUE
        xt%=(b%-yt%*16)*3
      ENDIF
      @set_tz
      @list
      @cursor_anz
      @read_in_fat(clus%)
      @alrt(1,"Wert im Clustereintrag |Nr. "+STR$(clus%)+":   $"+HEX$(aa%)+" = "+STR$(aa%),1," So So ")
    ENDIF
  ENDIF
RETURN
PROCEDURE fat_cluster
  LOCAL a$
  zx%=4
  fselect(pfad$+"*.*","",fi$)
  IF LEN(fi$)
    @chk_drv(fi$)
    IF drv%
      @screen
      @do_pfad(fi$)
      IF RIGHT$(fi$)="\"
        @get_fld_name(fi$)
        fac$=fld$
      ELSE
        @extract(fi$)
        s$=ext$
        fac$=s$
      ENDIF
      IF fac$="" AND RIGHT$(fi$)="\"
        @boot_sec(0)
        lgs%=fat_anf%+len_fat%
        PRINT AT(4,2);"Wurzelverzeichnis ab Sektor ";lgs%;" fÅr ";len_dir%;" Sektoren "
        j%=total%+1
        @maus_klick
      ELSE
        @nam_conv(fac$,1)
        IF RIGHT$(fi$)="\"
          fac$=LEFT$(pfad$,LEN(pfad$)-1)+SPACE$(11-LEN(fac$))
        ELSE
          fac$=fil$
          fac$=pfad$+fac$
        ENDIF
      ENDIF
      IF LEN(fac$)
        @find_files
        CLR j%
        REPEAT
          a$=CHR$(drive%+65)+":"+folder$(j%)+"\"+file$(j%)
          EXIT IF fac$=a$
          INC j%
        UNTIL j%>total%
        '
        cl%=cluster%(j%)
        IF j%<=total%
          @alrt(1,"Clusternummern |ausgeben auf...",3,ddm$)
          @dev("CLUSTER.TXT")
          IF device%<>99 OR erg%=3
            titel$=LEFT$(fi$+STRING$(70,32),58)
            IF erg%<3
              @fwritec(hdl%,fi$+"  Cluster : ")
            ELSE
              PRINT AT(4,2);titel$;
            ENDIF
            CLR anz%
            DO
              CLR a$
              WHILE LEN(a$)<70
                INC anz%
                @read_in_fat(cl%)
                a$=a$+RIGHT$("       "+STR$(cl%),7)
                cl%=aa%
                EXIT IF aa%>=ed%-8 OR aa%=0 OR (aa%>=cpd%+2 AND aa%<ed%-8)
              WEND
              IF erg%=3
                PRINT AT(3,zz%+4);a$
              ELSE
                @ausgabe(a$)
              ENDIF
              EXIT IF aa%>=ed%-8 OR aa%=0
              INC zz%
              IF zz%>15 AND erg%=3
                @page(titel$)
              ENDIF
              @was_ist
              EXIT IF abb%=2
            LOOP
            IF erg%=3
              PRINT AT(64,2);"Anzahl: ";anz%
              @maus_klick
            ELSE
              @ausgabe("Anzahl: "+STR$(anz%))
            ENDIF
          ENDIF
        ENDIF
      ENDIF
      @screen
    ENDIF
  ENDIF
RETURN
PROCEDURE fat_test
  @alrt(1,"Falls herrenlose Cluster|herumliegen sollten?",1,"Sammeln|Nichts|Abbruch")
  fterg%=erg%
  CLR device%,fu%
  IF fterg%<>3
    IF fterg%=1
      erg%=1
      @dev("LEICHEN.CLU")
    ENDIF
    IF device%<>99
      IF ASC(fd$)-65=drive%
        @alrt(1,"Sammeln bitte auf einem |anderem Laufwerk! ",1,"Ok")
      ELSE
        @fat_check
        IF fatbuf%
          PRINT AT(4,2);"Suche Leichen-Cluster"
          cc%=ed%-8
          FOR fat_tst%=2 TO anz_cluster%
            @read_in_fat(fat_tst%)
            IF aa% AND fat%(fat_tst%)=0
              IF aa%=cc%
                @err_inf1(fat_tst%,"CLUSTER defekt","Clusternr.")
              ELSE
                @err_inf3(fat_tst%,"CLUSTER-Leiche","Clusternr.")
                IF fterg%=1
                  INC fu%
                  @write_in_fat(0,fat_tst%)
                  lgs%=(fat_tst%-2)*spc%+first_sec%
                  @fat_get_leiche
                  INC lgs%
                  @fat_get_leiche
                ENDIF
              ENDIF
            ENDIF
          NEXT fat_tst%
          IF fterg%=1
            @fclose(hdl%)
          ENDIF
          IF fu%
            @alrt(2,STR$(fu%)+"Leichen-Cluster gefunden. |Sollen diese Cluster |freigegeben werden?",0,"Ja|Nein")
            IF erg%=1
              @write_fat(anf_fat1%)
              @write_fat(anf_fat2%)
            ENDIF
          ENDIF
        ENDIF
        ERASE fat%()
        @screen
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE fat_get_leiche
  @lesen
  @list
  @fwrite2(hdl%,buf%,bps%)
RETURN
PROCEDURE fat_check
  LOCAL i%
  @find_files
  IF fatbuf%
    PRINT AT(4,2);"Teste FAT-Belegung"
    DIM fat%(anz_cluster%+2)
    cc%=ed%-8
    '
    FOR fat_tst%=1 TO total%
      IF (att%(fat_tst%) AND 8)=0
        cl%=cluster%(fat_tst%)
        IF cl%<anz_cluster%
          IF fat%(cl%)=0
            fat%(cl%)=fat_tst%
          ELSE
            @fat_check_do
          ENDIF
          DO
            EXIT IF laenge%(fat_tst%)=0 AND (att%(fat_tst%) AND &H10)=0   ! Ordner
            @read_in_fat(cl%)
            IF aa%>=cpd%+2 AND aa%<ed%
              @err_inf1(cl%,"FAT-Test ","Clusternummer zu gross")
              aa%=cc%
            ENDIF
            EXIT IF aa%>=cc%                    ! Or Aa%=0
            cl%=aa%
            IF fat%(cl%)=0
              fat%(cl%)=fat_tst%
            ELSE
              @fat_check_do
            ENDIF
          LOOP
          IF (aa%=0 AND laenge%(fat_tst%)<>0)
            @nam_conv(file$(fat_tst%),0)
            f$=folder$(fat_tst%)+"\"+fil$
            @err_inf1(cl%,"Clustereintrag=0 |in Datei | "+f$,"Clusternr.")
          ENDIF
        ENDIF
      ENDIF
    NEXT fat_tst%
    '
    fat%(0)=-3
    fat%(1)=-3
  ENDIF
RETURN
PROCEDURE fat_check_do
  LOCAL a%,f1$,f2$
  IF laenge%(fat_tst%)
    a%=MAX(0,fat%(cl%))
    @nam_conv(file$(a%),0)
    f1$=folder$(a%)+"\"+fil$
    @nam_conv(file$(fat_tst%),0)
    f2$=folder$(fat_tst%)+"\"+fil$
    @err_inf1(cl%,f1$+" + |    "+f2$,"verklebt bei Cluster:")
    fat%(cl%)=-4
  ENDIF
RETURN
PROCEDURE fat_xor
  @boot_sec(0)
  @bios_block
  IF fatbuf%
    CLR fu%
    fat1$=STRING$(bps%,0)
    fat2$=STRING$(bps%,0)
    FOR fat_tst%=0 TO len_fat%-1
      SHOWM
      status%=BIOS(4,0,L:VARPTR(fat1$),1,anf_fat1%+fat_tst%,drive%)
      @err_inf(status%)
      BMOVE fatbuf%+((fat_tst%)*bps%),VARPTR(fat2$),bps%
      IF fat1$<>fat2$
        INC fu%
        @err_inf1(fat_tst%+1,"FAT-Sektor verschieden","Sektornr.")
        status%=-1
      ENDIF
    NEXT fat_tst%
  ENDIF
  @info
RETURN
PROCEDURE fat_leiche_12
  LOCAL cz%
  FOR fat_tst%=2 TO anz_cluster%
    '
    cz%=fatbuf%+fat_tst%*1.5
    IF EVEN(fat_tst%)=-1
      aa%=(PEEK(cz%+1) AND 15)*256+PEEK(cz%)
    ELSE
      aa%=PEEK(cz%+1)*16+(PEEK(cz%) AND 240)/16
    ENDIF
    '
    IF aa%>0 AND fat%(fat_tst%)=0
      fat%(fat_tst%)=-2-(aa%=cc%)
    ENDIF
  NEXT fat_tst%
RETURN
PROCEDURE fat_leiche_16
  LOCAL cz%
  FOR fat_tst%=2 TO anz_cluster%
    cz%=fat_tst%*2+fatbuf%
    IF PEEK(cz%)+PEEK(cz%+1)*256>0
      IF fat%(fat_tst%)=0
        fat%(fat_tst%)=-2-(aa%=cc%)
      ENDIF
    ENDIF
  NEXT fat_tst%
RETURN
PROCEDURE fat_graph
  zx%=4
  @fat_check
  IF fatbuf%
    PRINT AT(4,2);"Suche Leichen-Cluster"
    cc%=ed%-8
    '
    IF bflag%=1
      @fat_leiche_16
    ELSE
      @fat_leiche_12
    ENDIF
    '
    CLR erg2%
    @alrt(1,"FAT ausgeben auf... ",3,ddm$)
    @dev("GRAPH.FAT")
    '
    IF device%<>99 OR erg%=3
      IF erg%<3
        @fwritec(hdl%,"Drive : "+CHR$(drive%+65)+"      Anzahl Cluster : "+STR$(anz_cluster%))
        @alrt2(1,"Auch zu allen Clustern |das File ausgeben?",2,"Ja|Nein")
      ENDIF
      PRINT AT(4,2);STRING$(60,32)
      CLR fg%
      '
      DO
        old_fg%=fg%
        fg%=MIN(anz_cluster%-31*64,fg%)
        fg%=MAX(0,fg%)
        @fat_ganz
        IF erg%=3
          @fat_show
          @screen
          CLR zz%
        ENDIF
        EXIT IF mk%=2 OR in$=esc$
      LOOP
      '
    ENDIF
    '
    IF erg2%=1
      @fwritec(hdl%,STRING$(40,"-"))
      CLR of$,cl$
      FOR cl%=2 TO anz_cluster%
        IF fat%(cl%)>0
          @dec_hex_val(cl%,5)
          IF LEN(cl$)>70
            @fwritec(hdl%,cl$+"  ")
            CLR cl$
          ENDIF
          @nam_conv(file$(fat%(cl%)),0)
          f$=folder$(fat%(cl%))+"\"+fil$
          IF att%(fat%(cl%)) AND 16
            f$=f$+"\"
          ENDIF
          IF f$<>of$
            @fwritec(hdl%,cl$)
            @fwritec(hdl%,f$)
            CLR cl$
            of$=f$
          ENDIF
        ENDIF
      NEXT cl%
      IF LEN(cl$)
        @fwritec(hdl%,cl$)
        @fwritec(hdl%,f$)
      ENDIF
    ENDIF
    '
    IF erg%<3 AND device%<>99
      @fwritec(hdl%,STRING$(79,"-"))
      @fclose(hdl%)
    ENDIF
    ERASE fat%()
    IF erg%=3 AND mk%<>2
      @help_ex
    ELSE
      @screen
    ENDIF
  ENDIF
RETURN
PROCEDURE fat_ganz
  LOCAL fgs%,i%,gz%
  gz%=54
  CLR zz%
  REPEAT
    @dec_hex_val(fg%,5)
    la$=av$+"  "
    lb$=STRING$(64,32)
    fgs%=1
    fgg%=MIN(64,anz_cluster%-fg%)
    FOR i%=fg% TO fg%+fgg%
      IF fat%(i%)>0
        MID$(lb$,fgs%,1)="B"
      ELSE
        MID$(lb$,fgs%,1)=fg$(fat%(i%)+4)
      ENDIF
      INC fgs%
    NEXT i%
    IF erg%=3
      DEFTEXT ,,,dtk%
      TEXT 24,gz%,la$+lb$
      DEFTEXT ,,,dtg%
      ADD gz%,8
      INC zz%
    ELSE
      @ausgabe(la$+lb$)
    ENDIF
    ADD fg%,64
  UNTIL zz%>31 OR fg%+fgs%-64>=anz_cluster%
RETURN
PROCEDURE fat_show
  LOCAL a%,mt%,mx%,my%,mz%,a$,in$
  DEFMOUSE 0
  CLR mz%
  DO
    @time
    MOUSE mx%,my%,mk%
    in$=INKEY$
    '
    IF LEN(in$)
      mz%=1
      mt%=(BIOS(11,-1) AND 4)/4         ! Control ?
      a%=ASC(RIGHT$(in$))
      b%=mt%*31*64
      IF a%=80
        fg%=MIN(anz_cluster%-b%,old_fg%+64+b%)
      ELSE
        IF a%=72
          fg%=MAX(0,old_fg%-64-b%)
        ELSE
          IF a%=71
            fg%=0+(anz_cluster%-31*64)*mt%
          ENDIF
        ENDIF
      ENDIF
    ENDIF
    '
    IF mx%>560 AND my%>hyl%-8 AND my%<hyl% AND mk%=1
      @dec_hex
      PRINT coff$;
      mz%=1
    ENDIF
    '
    IF mx%>80 AND mx%<590 AND mk%=1
      IF my%>o_box% AND my%<vert%
        cl%=(mx%-72)/8+64*INT((my%-o_box%-4)/8)-1+(fg%-zz%*64)
        IF cl%>=0 AND cl%<anz_cluster%
          @dec_hex_val(cl%,5)
          PRINT AT(4,2);av$'
          IF fat%(cl%)>0
            @nam_conv(file$(fat%(cl%)),0)
            f$=folder$(fat%(cl%))+"\"+fil$
            IF att%(fat%(cl%)) AND 16
              f$=f$+"\"
            ENDIF
            PRINT AT(11,2);f$;STRING$(60-LEN(f$),32);
          ELSE
            PRINT AT(11,2);STRING$(60,32);
          ENDIF
        ENDIF
      ENDIF
    ENDIF
    EXIT IF in$=esc$ OR mk%=2 OR mz%
  LOOP
RETURN
' ------------------------------ so manch anderes ------------------------
PROCEDURE read_buf(file$)
  LOCAL a%
  CLR read%
  fselect(pfad$+"*.*",file$,fi$)
  IF LEN(fi$) AND RIGHT$(fi$)<>"\"
    @do_pfad(fi$)
    IF EXIST(fi$)=TRUE
      ch!=TRUE
      @fopen(fi$,0)
      @fseek(0,handle%,2)
      a%=MIN(bps%,fehler%)
      @fseek(0,handle%,0)
      @fread2(handle%,buf%,a%)
      @fclose(handle%)
      read%=1
    ENDIF
  ENDIF
RETURN
PROCEDURE in_file
  @read_buf("")
RETURN
PROCEDURE change
  LOCAL a%
  DEFMOUSE 2
  a%=C:utis%(&H400,L:buf%,L:bps%,L:&HCDB4)
  IF ch!=TRUE AND a%<>buf_crc%
    ch!=FALSE
    IF u1%=3 OR u1%=4 OR u1%=5 OR u1%=6 OR u1%=12
      PRINT coff$;
      @alrt(1,"Sie haben Daten geÑndert! ",0,"Schreiben|Abbruch")
      IF erg%=1
        @schreiben
      ENDIF
    ELSE
      @alrt(1,"Sie sollten Daten nur|in den dafÅr zustÑndigen|UntermenÅs verÑndern!",1,"Mach ich")
    ENDIF
  ENDIF
  DEFMOUSE 0
RETURN
' ----------------------
PROCEDURE list
  PRINT coff$;
  HIDEM
  VOID C:zeile%(L:z%+buf%,L:z%+ak%,W:(4*zh%-8) OR 32768,L:z%+offset%-(fil!=TRUE)*fp%-(ram!=TRUE)*ram_addr%,W:zpz%,W:zh%,W:planes%)
  @info
  SHOWM
RETURN
PROCEDURE zeile(zl%)
  LOCAL zg%
  HIDEM
  zg%=z%+zl%*16
  VOID C:zeile%(L:zg%+buf%,L:zg%+ak%-offset%,W:(zl%+4)*zh%-8,L:zg%+offset%-(fil!=TRUE)*fp%-(ram!=TRUE)*ram_addr%,W:zpz%,W:zh%,W:planes%)
  SHOWM
RETURN
PROCEDURE exit
  SOUND 1,15,#284
  WAVE 1,1,1,15535,0
  @alrt(1,"Ist fÅr heute |wirklich Schluû (schnÅff)?",1,"Ja doch!|Nie!")
  IF erg%=1
    ' @Alrt(1,"Heute ist nicht |alle Tage -|ich komm wieder,",0,"keine|Frage!")
    SOUND 1,15,#350
    WAVE 1,1,1,15535,0
    @mfree(ram%)
    '
    IF file_open%=1
      @fclose(f_hdl%)
    ENDIF
    '
    IF fmal%
      @mfree(fatbuf%)
    ENDIF
    IF prg_adr%
      @mfree(prg_adr%)
      CLR prg_adr%
    ENDIF
    '
    PRINT coff$
    IF menu!=TRUE
      MENU KILL
    ENDIF
    CLOSEW 1
    CLOSEW 0
    CLOSE
    EDIT
    DEFMOUSE 0
  ENDIF
  @maus_off
RETURN
PROCEDURE search
  LOCAL sz%
  search!=TRUE
  PRINT coff$;
  sz%=tz%+2+z%
  IF search_cont%=0
    @eingabe("Bitte Suchstring eingeben:",in1$,38)
    in1$=a$
    @wandlung(in1$)
    search$=w$
    search!=FALSE
    IF LEN(search$)
      '
      @eingabe("Bitte Tauschstring eingeben:",in2$,38)
      in2$=a$
      @wandlung(in2$)
      replace$=w$
      '
      IF disc!=TRUE
        @eingabe("Suchen bis log.Sektor:",bis$,8)
        IF VAL(a$)>spd%-1
          @alrt(1,"Das Laufwerk hat nur |"+STR$(spd%)+" Sektoren!|Verwende dieses Maximum.",1,"ôha")
          a$=STR$(spd%-1)
        ENDIF
      ELSE
        IF hard!=TRUE
          @eingabe("Suchen bis Block:",bis$,8)
        ELSE
          IF ram!=TRUE
            @eingabe("Suchen bis Adresse:",bis$,10)
          ENDIF
        ENDIF
      ENDIF
      bis$=a$
    ENDIF
  ENDIF
  DEFMOUSE 2
  ch!=FALSE
  found!=FALSE
  bb$=STRING$(bps%*2,0)
  DO
    @was_ist
    EXIT IF abb%=2
    BMOVE buf%,VARPTR(bb$),bps%         ! Pufferinhalt holen in 1.HÑlfte
    @nxt_blk                            ! nÑchsten Sektor lesen
    ' EXIT IF no_nxt%=1                   ! Ende ....
    BMOVE buf%,VARPTR(bb$)+bps%,bps%    ! Pufferinhalt holen in 2.HÑlfte
    b%=INSTR(sz%,bb$,search$)
    IF b%                               ! Ist was gefunden ?
      found!=TRUE
      search!=FALSE
      DEC b%
      IF b%>bps%-1
        SUB b%,bps%
      ELSE
        @dec
        BMOVE VARPTR(bb$),buf%,bps%
      ENDIF
      z%=INT(b%/256)*256                ! Cursor ausrichten
      b%=b%-z%
      yt%=b%/16
      xt%=b%-yt%*16+51
      IF hex!=TRUE
        xt%=(b%-yt%*16)*3
      ENDIF
      @set_tz
      IF LEN(replace$)
        IF tz%+z%+LEN(replace$)>bps%
          @alrt(1,"Ersetzen Åber|Sektorgrenzen ist|noch ein Problem",1,"Abbruch")
        ELSE
          ch!=TRUE
          BMOVE VARPTR(replace$),buf%+z%+tz%,LEN(replace$)
        ENDIF
      ENDIF
    ELSE
      sz%=1                     ! nicht gefunden
    ENDIF
    EXIT IF found!=TRUE OR no_nxt%
  LOOP
  IF no_nxt%<>0 AND found!=FALSE
    @alrt(1,"Keine (weitere) |Fundstelle!",1," Ok ")
  ENDIF
  search!=FALSE
  DEFMOUSE 0
  @maus_off
RETURN
PROCEDURE wandlung(in$)
  LOCAL i%,j%,h$,h%
  CLR h$,w$
  i%=1
  il%=LEN(in$)
  DO
    EXIT IF i%>il%
    IF MID$(in$,i%,1)="," OR MID$(in$,i%,1)=" "
      INC i%
    ENDIF
    IF MID$(in$,i%,1)="$"
      CLR h$
      DO
        INC i%
        EXIT IF i%>il% OR MID$(in$,i%,1)=","
        h$=h$+MID$(in$,i%,1)
      LOOP
      IF FRAC(LEN(h$)/2)<>0 OR LEN(h$)=0
        @alrt(2,"Hex-Data falsch ",1," Ok ")
        CLR h$
        i%=il%+1
      ENDIF
      FOR j%=1 TO LEN(h$) STEP 2
        w$=w$+CHR$(VAL("&H"+MID$(h$,j%,2)))
      NEXT j%
    ELSE
      IF MID$(in$,i%,1)>="0" AND MID$(in$,i%,1)<="9"
        CLR h$
        DO
          EXIT IF i%>il% OR MID$(in$,i%,1)=","
          h$=h$+MID$(in$,i%,1)
          INC i%
        LOOP
        h%=VAL(h$)
        IF h%>255
          @alrt(2,"Dezimale Werte |zwischen 0 und 255!",1," Ok ")
          h%=h% AND 255
        ENDIF
        w$=w$+CHR$(h%)
      ELSE
        IF MID$(in$,i%,1)="%"
          CLR h$
          DO
            INC i%
            EXIT IF i%>il% OR MID$(in$,i%,1)=","
            h$=h$+MID$(in$,i%,1)
          LOOP
          INC i%
          s%=VAL("&X"+h$)
          IF s%>255
            @alrt(2,"BinÑre Werte max. 8 Bit! ",1," Ok ")
            s%=s% AND 255
          ENDIF
          w$=w$+CHR$(s%)
        ELSE
          IF MID$(in$,i%,1)=CHR$(34)
            DO
              INC i%
              EXIT IF i%>il% OR MID$(in$,i%,1)=CHR$(34)
              w$=w$+MID$(in$,i%,1)
            LOOP
            INC i%
          ENDIF
        ENDIF
      ENDIF
      INC i%
    ENDIF
  LOOP
RETURN
PROCEDURE eingabe(txt$,ta$,laenge%)
  LOCAL ex%,i%,egf$,i$,mx%,my%,mk%,in$
  '
  PRINT coff$;
  GET e1%,e2%,e3%,e4%,egf$
  DEFFILL 1,2,8
  PBOX e1%+5,e2%+f1%,e3%,e4%
  DEFFILL 1,0
  PBOX e1%,e2%,e3%-5,e4%-f1%
  DEFFILL 1,1
  PRINT AT(17,10);txt$
  PRINT AT(17,13);STRING$(laenge%,"-")
  in$=ta$
  @line
  '
  DEFTEXT ,,,dtk%
  DEFFILL 1,2,8
  PBOX e3%-76,e4%-33*res%,e3%-10,e4%-23*res%
  PBOX e3%-78,e4%-19*res%,e3%-12,e4%-9*res%
  DEFFILL 1,0
  PBOX e3%-80,e4%-20*res%,e3%-14,e4%-10*res%
  PBOX e3%-80,e4%-35*res%,e3%-14,e4%-25*res%
  '
  TEXT 497,81*res%+res%,"OK"
  TEXT 475-8*(res%=1),97*res%,"Abbruch"
  DEFTEXT ,,,dtg%
  '
  PRINT con$;
  CLR ex%
  REPEAT
    i$=INKEY$
    '
    IF i$<>""
      IF i$=CHR$(13)
        ex%=1
      ELSE
        IF i$=esc$
          in$=""
          @line
        ELSE
          IF i$=CHR$(8)
            in$=LEFT$(in$,MAX(0,LEN(in$)-1))
            @line
          ELSE
            IF LEN(in$)<laenge%
              in$=in$+i$
              @line
            ELSE
              PRINT CHR$(7);
            ENDIF
          ENDIF
        ENDIF
      ENDIF
    ENDIF
    '
    IF MOUSEK
      MOUSE mx%,my%,mk%
      IF mx%>e3%-80 AND mx%<e3%-14
        IF my%>e4%-35*res% AND my%<e4%-25*res%
          ex%=1
        ELSE
          IF my%>e4%-20*res% AND my%<e4%-10*res%
            in$=""
            ex%=1
          ENDIF
        ENDIF
      ENDIF
    ENDIF
  UNTIL ex%=1
  '
  PRINT coff$;
  PUT e1%,e2%,egf$
  a$=in$
  IF search!=FALSE
    IF LEFT$(a$,1)="$"
      a$=STR$(VAL("&H"+RIGHT$(a$,LEN(a$)-1)))
    ELSE
      IF LEFT$(a$,1)="%"
        a$=STR$(VAL("&"+a$))
      ENDIF
    ENDIF
  ENDIF
  el%=LEN(a$)
  CLR e.l%
  IF el%=0
    e.l%=1
  ENDIF
  @maus_off
RETURN
PROCEDURE line
  PRINT AT(17,12);STRING$(laenge%,32);
  PRINT AT(17,12);in$;
RETURN
'
' ----------------------
PROCEDURE find_files
  CLR zz%
  erg%=1
  IF drive%=old_drive% AND find%=1
    @alrt(1,"Verzeichnisse einlesen? ",2,"Ok|Nee")
  ENDIF
  @screen
  IF find%=0 OR erg%=1
    PRINT AT(4,2);"Lese Verzeichnisse"
    DEFMOUSE 2
    CLR total%,fld%,tiefe%,folder$
    old_drive%=drive%
    find%=1
    @floppy_param
    IF fatbuf%
      @ordner_suche
      total%=MIN(max_files%,total%)
    ELSE
      CLR find%
    ENDIF
  ENDIF
RETURN
PROCEDURE ordner_suche
  CLR b%
  j%=1
  DO
    @time
    DO
      IF (l_att%(j%) AND 16) AND ASC(fil$(j%))<>&HE5
        INC fld%
        stack%(b%)=j%+1                 ! RÅcksprung in Stack
        INC b%                          ! Stack eins tiefer
        @open_fld(j%)                   ! Ordner îffnen
        CLR j%                          ! Ordner von vorne suchen
      ENDIF
      INC j%                            ! sonst nÑchste Datei...
      EXIT IF j%>anzahl% OR status%<0   ! bis alle Dateien im Ordner durchsucht
    LOOP
    EXIT IF (j%>anzahl% AND b%=0) OR status%<0
    REPEAT
      @close_fld                        ! Ok, nach oben
      DEC b%                            ! Stack nach oben
      EXIT IF b%<0                      ! Oben ???
      j%=stack%(b%)                     ! sonst im Ordner an alter Pos. weiter
    UNTIL j%<=anzahl%
    EXIT IF b%<0
  LOOP
RETURN
PROCEDURE read_sec(sct%)
  SHOWM
  status%=BIOS(4,0,L:VARPTR(puffer$),1,sct%,drive%)
  IF status%=0
    FOR m%=1 TO bps% STEP 32
      f$=MID$(puffer$,m%,11)
      cluster%=CVI(MID$(puffer$,m%+27,1)+MID$(puffer$,m%+26,1))
      att%=ASC(MID$(puffer$,m%+11,1))
      laenge%=CVL(MID$(puffer$,m%+31,1)+MID$(puffer$,m%+30,1)+MID$(puffer$,m%+29,1)+MID$(puffer$,m%+28,1))
      IF ASC(f$)=0
        m%=bps%+1
      ELSE
        IF ASC(f$) AND ASC(f$)<>&HE5 AND ASC(f$)<>46
          IF flag!=FALSE
            IF total%<max_files%
              INC total%
              file$(total%)=f$
              cluster%(total%)=cluster%
              att%(total%)=att%
              sec%(total%)=sct%
              folder$(total%)=folder$
              laenge%(total%)=laenge%
            ELSE
              IF total%>max_files%
                @alrt(1,"Sie haben leider |zu viele Dateien! ",1,"Abbruch")
                total%=max_files%
              ENDIF
            ENDIF
          ENDIF
          INC anzahl%
          IF anzahl%<300
            fil$(anzahl%)=f$
            clu%(anzahl%)=cluster%
            l_att%(anzahl%)=att%
          ENDIF
        ENDIF
      ENDIF
    NEXT m%
  ELSE
    @err_inf(status%)
  ENDIF
RETURN
PROCEDURE sread_sec(sct%)
  SHOWM
  status%=BIOS(4,0,L:VARPTR(puffer$),1,sct%,drive%)
  IF status%=0
    FOR m%=1 TO bps% STEP 32
      f$=MID$(puffer$,m%,11)
      cluster%=CVI(MID$(puffer$,m%+27,1)+MID$(puffer$,m%+26,1))
      att%=ASC(MID$(puffer$,m%+11,1))
      laenge%=CVL(MID$(puffer$,m%+31,1)+MID$(puffer$,m%+30,1)+MID$(puffer$,m%+29,1)+MID$(puffer$,m%+28,1))
      IF ASC(f$)=0
        m%=bps%+1
      ELSE
        IF ASC(f$) AND ASC(f$)<>46
          IF ASC(f$)=&HE5 OR (att% AND 16)
            IF flag!=FALSE
              IF total%<max_files%
                INC total%
                file$(total%)=f$
                cluster%(total%)=cluster%
                att%(total%)=att%
                sec%(total%)=sct%
                folder$(total%)=folder$
                laenge%(total%)=laenge%
              ELSE
                IF total%>max_files%
                  @alrt(1,"Sie haben leider |zu viele Dateien!",1,"Abbruch")
                  total%=max_files%
                ENDIF
              ENDIF
            ENDIF
            INC anzahl%
            IF anzahl%<300
              fil$(anzahl%)=f$
              clu%(anzahl%)=cluster%
              l_att%(anzahl%)=att%
            ENDIF
          ENDIF
        ENDIF
      ENDIF
    NEXT m%
  ELSE
    @err_inf(status%)
  ENDIF
RETURN
PROCEDURE bios_block
  @media(drive%)
  SHOWM
  bpb_blk%=BIOS(7,drive%)
  IF bpb_blk%
    bps%=DPEEK(bpb_blk%)
    @cbps
    spc%=DPEEK(bpb_blk%+2)
    bpc%=DPEEK(bpb_blk%+4)
    len_dir%=DPEEK(bpb_blk%+6)
    len_fat%=DPEEK(bpb_blk%+8)
    anf_fat2%=DPEEK(bpb_blk%+10)
    anf_dat%=DPEEK(bpb_blk%+12)
    anz_cluster%=DPEEK(bpb_blk%+14)
    anz_sector%=anz_cluster%*spc%+anf_dat%
    anf_dir%=anf_fat2%+len_fat%
    anf_fat1%=anf_fat2%-len_fat%
    fehler%=TRUE
    IF len_fat%>old_len_fat% AND fmal%  ! wenn schon mal reserviert
      @mfree(fatbuf%)                   ! und zu klein, dann freigeben
      CLR fmal%
    ENDIF
    IF fmal%=0
      @ram_for_fat
    ENDIF
    IF fehler%=0
      @alrt(1,"Speicherplatzprobleme ",1,"Abbruch")
    ELSE
      fmal%=1
      SHOWM
      status%=BIOS(4,0,L:fatbuf%,len_fat%,anf_fat2%,drive%)
      IF status%=-14
        @boot_sec(0)
        SHOWM
        status%=BIOS(4,0,L:fatbuf%,len_fat%,anf_fat2%,drive%)
      ENDIF
      @err_inf(status%)
    ENDIF
    puffer$=STRING$(bps%,0)
  ENDIF
RETURN
PROCEDURE ram_for_fat
  @malloc(len_fat%*bps%)
  fatbuf%=fehler%
  IF fatbuf%<>0
    res_mem%=len_fat%*bps%
    old_len_fat%=len_fat%
  ENDIF
RETURN
PROCEDURE floppy_param
  @boot_sec(0)
  @bios_block
  IF fatbuf%
    @flex_dim
    IF status%=0
      CLR tiefe%
      @read_first
    ELSE
      @err_inf(status%)
    ENDIF
  ENDIF
RETURN
PROCEDURE read_in_fat(clus%)
  LOCAL cz%
  IF bflag%=1
    cz%=clus%*2+fatbuf%
    aa%=PEEK(cz%)+PEEK(cz%+1)*256
  ELSE
    cz%=fatbuf%+clus%*1.5
    IF EVEN(clus%)=-1
      aa%=(PEEK(cz%+1) AND 15)*256+PEEK(cz%)
    ELSE
      aa%=PEEK(cz%+1)*16+(PEEK(cz%) AND 240)/16
    ENDIF
  ENDIF
RETURN
PROCEDURE write_in_fat(was%,wohin%)
  LOCAL cz%
  IF bflag%
    cz%=fatbuf%+wohin%*2
    POKE cz%,(was% AND 255)
    POKE cz%+1,(was% AND &HFF00)/256
  ELSE
    cz%=fatbuf%+wohin%*1.5
    IF EVEN(wohin%)=-1
      POKE cz%+1,(PEEK(cz%+1) AND 240)+(was% AND &HF00)/256
      POKE cz%,(was% AND 255)
    ELSE
      POKE cz%+1,(was% AND &HFF0)/16
      POKE cz%,(PEEK(cz%) AND 15)+(was% AND 15)*16
    ENDIF
  ENDIF
RETURN
PROCEDURE write_fat(a%)
  @media(drive%)
  SHOWM
  status%=BIOS(4,1,L:fatbuf%,len_fat%,a%,drive%)
  IF status%=-14
    SHOWM
    status%=BIOS(4,1,L:fatbuf%,len_fat%,a%,drive%)
  ENDIF
  @err_inf(status%)
RETURN
PROCEDURE fat_16
  anf%=C:utis%(&H700,L:fatbuf%,L:fatbuf%+anz_cluster%*2,L:ed%-9)
RETURN
PROCEDURE fat_12
  LOCAL ci%,cz%,ca%
  FOR ci%=2 TO anz_cluster%
    cz%=ci%*1.5+fatbuf%
    IF EVEN(ci%)=TRUE
      ca%=(PEEK(cz%+1) AND 15)*256+PEEK(cz%)
    ELSE
      ca%=PEEK(cz%+1)*16+(PEEK(cz%) AND 240)/16
    ENDIF
    IF ca%>=ed%-8
      INC anf%
    ENDIF
  NEXT ci%
RETURN
PROCEDURE flex_dim
  CLR anf%
  ON bflag%+1 GOSUB fat_12,fat_16
  s%=MAX(anf%*1.1,112)
  IF rdim%
    @dim_clr
  ENDIF
  max_files%=s%
  rdim%=1
  DIM file$(s%),cluster%(s%),laenge%(s%),att%(s%),sec%(s%)
  DIM ordner$(s%),ordner%(s%),folder$(s%)
  DIM fil$(300),clu%(300),l_att%(300),stack%(30)
RETURN
PROCEDURE dim_clr
  ERASE file$()
  ERASE cluster%()
  ERASE laenge%()
  ERASE att%()
  ERASE sec%()
  ERASE ordner$()
  ERASE ordner%()
  ERASE folder$()
  ERASE fil$()
  ERASE clu%()
  ERASE l_att%()
  ERASE stack%()
RETURN
PROCEDURE read_first
  CLR anzahl%
  zeiger%=1
  FOR ri%=anf_dir% TO anf_dir%+len_dir%-1
    IF srep%=0
      @read_sec(ri%)
    ELSE
      @sread_sec(ri%)
    ENDIF
    EXIT IF status%<>0
  NEXT ri%
RETURN
PROCEDURE read_fld
  clus%=ordner%(tiefe%)         ! Startcluster des Verzeichnisses
  CLR anzahl%
  zeiger%=1
  REPEAT
    FOR ri%=1 TO spc%
      par%=((clus%-2)*spc%-1+ri%+anf_dat%)
      IF par%<spd%
        IF srep%=0
          @read_sec(par%)
        ELSE
          @sread_sec(par%)
        ENDIF
      ENDIF
      EXIT IF status%<>0
    NEXT ri%
    @read_in_fat(clus%)
    clus%=aa%
  UNTIL aa%>=ed%-8 OR aa%<=0 OR (aa%>spd% AND aa%<ed%-8)
RETURN
PROCEDURE open_fld(zeiger%)
  INC tiefe%
  @nam_conv(fil$(zeiger%),0)
  ordner$(tiefe%)=ordner$(tiefe%-1)+"\"+fil$
  ordner%(tiefe%)=clu%(zeiger%)
  folder$=ordner$(tiefe%)
  @read_fld
RETURN
PROCEDURE close_fld
  DEC tiefe%
  CLR anzahl%
  flag!=TRUE
  IF tiefe%>0
    @read_fld
  ELSE
    @read_first
  ENDIF
  flag!=FALSE
RETURN
PROCEDURE nam_conv(tst$,par%)
  LOCAL i%,j%
  IF par%
    i%=INSTR(tst$,".")
    IF i%
      fil$=LEFT$(tst$,i%-1)+LEFT$("        ",9-i%)+RIGHT$(tst$,LEN(tst$)-i%)
    ELSE
      fil$=tst$
    ENDIF
    fil$=LEFT$(fil$+"           ",11)
  ELSE
    fil$=LEFT$(tst$,8)+"."+RIGHT$(tst$,3)
    DO
      WHILE RIGHT$(fil$,1)=" "
        fil$=LEFT$(fil$,LEN(fil$)-1)
      WEND
      EXIT IF RIGHT$(fil$)<>"."
      fil$=LEFT$(fil$,LEN(fil$)-1)
    LOOP
    CLR i%
    j%=LEN(fil$)
    REPEAT
      INC i%
    UNTIL MID$(fil$,i%,1)=" " OR i%>j%
    IF i%<j%
      fil$=LEFT$(fil$,i%-1)+RIGHT$(fil$,j%-INSTR(1,fil$,".")+1)
    ENDIF
  ENDIF
RETURN
' ----------------------
PROCEDURE screen
  PRINT coff$;
  DEFFILL 1,0
  PBOX 8,f1%,620,18*res%
  PBOX 8,o_box%,620,vert%
  DEFFILL 1,1
RETURN
PROCEDURE page(pt$)
  DEFMOUSE 3
  @maus_klick
  CLR zz%
  @screen
  PRINT AT(4,2);pt$
  DEFMOUSE 0
RETURN
PROCEDURE maus_klick
  DEFMOUSE 3
  @maus_off
  DO
    @time
    in$=INKEY$
    mk%=MOUSEK
    EXIT IF LEN(in$) OR mk%
  LOOP
  WHILE MOUSEK<>0 OR LEN(INKEY$)
  WEND
  IF in$=esc$ OR ASC(in$)=3
    mk%=2
  ENDIF
  DEFMOUSE 0
RETURN
PROCEDURE look_ex
  IF erg%=3
    @help_ex
  ELSE
    @fclose(hdl%)
    @screen
  ENDIF
RETURN
PROCEDURE maus_off
  WHILE MOUSEK
  WEND
RETURN
PROCEDURE was_ist
  CLR abb%
  IF INKEY$=esc$ OR MOUSEK=2
    @alrt2(0,"Was ist los ? ",1,"Weiter|Abbruch")
    abb%=erg2%
  ENDIF
RETURN
PROCEDURE chk_drv(chk$)         ! kontrolliert ob in Fileselectorbox
  drv%=1                        ! Drive gewechselt worden ist
  IF MID$(chk$,2,1)=":"
    IF (ASC(chk$)-65)<>drive%
      CLR drv%
      @alrt(1,"Laufwerke bitte nur|in DRIVE wechseln",1,"Schei...")
    ENDIF
  ENDIF
RETURN
PROCEDURE set_pfad(ff$)
  CLR fehler%
  IF MID$(ff$,2,1)=":"          ! Falls nîtig Drive wechseln
    @dsetdrv(ASC(UPPER$(ff$))-65)
    ff$=RIGHT$(ff$,LEN(ff$)-2)
  ENDIF
  IF fehler%>=0
    WHILE RIGHT$(ff$)<>"\" AND LEN(ff$)>0
      ff$=LEFT$(ff$,LEN(ff$)-1)
    WEND
    @dsetpath(ff$)
  ENDIF
RETURN
'
PROCEDURE get_pfad
  pfad$=STRING$(256,0)
  fehler%=GEMDOS(71,L:VARPTR(pfad$),0)
  IF fehler%=0
    pfad$=CHR$(drive%+65)+":"+LEFT$(pfad$,INSTR(pfad$,CHR$(0))-1)
    IF RIGHT$(pfad$,1)<>"\"
      pfad$=pfad$+"\"
    ENDIF
  ENDIF
RETURN
PROCEDURE wandeln(b$)
  ' Wandelt Dateinamen (Beispiel: willi.img, w*.xx) in einen 12 Zeichen langen
  ' String             (Beispiel: willi   .img, w*      .xx )
  LOCAL a%
  a$=b$
  a%=INSTR(a$,".")
  IF a%
    b$=LEFT$(a$,a%-1)
    b$=b$+STRING$(8-LEN(b$),32)
    a$=b$+RIGHT$(a$,LEN(a$)-a%+1)
    a$=a$+STRING$(12-LEN(a$),32)
  ELSE
    a$=a$+STRING$(12-LEN(a$),32)
    MID$(a$,9,1)="."
  ENDIF
RETURN
PROCEDURE alltoone(b$)
  '
  ' Wandelt Allquantor ("*") in Einfachquantor ("?") um
  ' (w*      .*  -->w???????.???)
  LOCAL t%
  a$=b$
  FOR t%=1 TO 8
    IF MID$(a$,t%,1)="*"
      MID$(a$,t%)=STRING$(9-t%,"?")
      t%=8
    ENDIF
  NEXT t%
  FOR t%=10 TO 12
    IF MID$(a$,t%,1)="*"
      MID$(a$,t%)=STRING$(13-t%,"?")
      t%=12
    ENDIF
  NEXT t%
RETURN
PROCEDURE n_compare(a$,b$)
  '
  ' Zwei Strings vergleichen
  ' Die Strings mÅssen per @Wandeln und @Alltoone vorbehandelt werden
  ' OUT: Gleich!=True, wenn Vergleich paût
  IF LEN(a$)=0 AND LEN(b$)=0
    gleich!=TRUE
  ELSE
    IF LEN(a$)<>LEN(b$)
      gleich!=FALSE
    ELSE
      IF LEFT$(a$,1)=LEFT$(b$,1) OR LEFT$(a$,1)="?" OR LEFT$(b$,1)="?"
        @n_compare(MID$(a$,2),MID$(b$,2))
      ELSE
        gleich!=FALSE
      ENDIF
    ENDIF
  ENDIF
RETURN
'
PROCEDURE do_pfad(xpf$)
  LOCAL i%
  i%=LEN(xpf$)
  WHILE i%>1 AND MID$(xpf$,i%,1)<>"\"
    DEC i%
  WEND
  pfad$=LEFT$(xpf$,i%)
RETURN
PROCEDURE extract(xtr$)
  WHILE INSTR(1,xtr$,"\")
    xtr$=RIGHT$(xtr$,LEN(xtr$)-INSTR(1,xtr$,"\"))
  WEND
  ext$=xtr$
RETURN
PROCEDURE get_fld_name(fi$)             ! Holt aus Pfadname den letzten Ordner
  LOCAL i%,a%,b%
  i%=LEN(fi$)                           ! z.B.: D:\ALLERLEI\TEST\GRUMMEL.LST
  WHILE MID$(fi$,i%,1)<>"\" AND i%>0    !       FLD$="TEST"
    DEC i%
  WEND
  a%=i%
  IF a%
    DEC i%
    WHILE MID$(fi$,i%,1)<>"\" AND i%>0
      DEC i%
    WEND
    b%=i%
  ENDIF
  IF a%<>b% AND b%>0 AND a%>0
    fld$=MID$(fi$,b%+1,a%-b%-1)         ! letzten Ordner isolieren
  ELSE
    CLR fld$                            ! sonst im Wurzelverzeichnis
  ENDIF
RETURN
PROCEDURE alrt(icon%,text$,default%,butext$)
  LOCAL a$,i%,j%
  org%=erg%
  text$="    "+text$
  i%=1
  REPEAT
    j%=INSTR(i%,text$,"|")
    IF j%
      text$=LEFT$(text$,j%)+"    "+RIGHT$(text$,LEN(text$)-j%)
      i%=j%+4
    ENDIF
  UNTIL j%=0
  a$="["+STR$(icon%)+"]["+text$+" ]["+butext$+"]"+CHR$(0)
  LPOKE ADDRIN,VARPTR(a$)
  DPOKE GINTIN,default%
  GEMSYS 52
  erg%=DPEEK(GINTOUT)
RETURN
PROCEDURE alrt2(icon%,text$,default%,butext$)
  LOCAL a$,i%,j%
  text$="    "+text$
  i%=1
  REPEAT
    j%=INSTR(i%,text$,"|")
    IF j%
      text$=LEFT$(text$,j%)+"    "+RIGHT$(text$,LEN(text$)-j%)
      i%=j%+4
    ENDIF
  UNTIL j%=0
  a$="["+STR$(icon%)+"]["+text$+" ]["+butext$+"]"+CHR$(0)
  LPOKE ADDRIN,VARPTR(a$)
  DPOKE GINTIN,default%
  GEMSYS 52
  erg2%=DPEEK(GINTOUT)
RETURN
PROCEDURE fehler_behandlung
  @alrt(3,"Systemfehler: "+STR$(ERR)+" ",1,"Abbruch")
  IF utis%
    @media_all
  ENDIF
  @exit
RETURN
PROCEDURE fat_help
  @info_fat
RETURN
PROCEDURE info_fat
  @screen
  PRINT AT(4,2);"Aufbau der FAT:"
  PRINT AT(7,5);"16 Bit-FAT"
  PRINT AT(7,7);"00 00 00 00 FF FF 04 00 05 00 06 00 FF FF FF FF   ................"
  TEXT 25*8-7,8*zh%-3,"---"
  PRINT AT(11,9);"Clustereintrag 3 zeigt auf Cluster 4 (INTEL-Format)"
  PRINT AT(11,10);"4 zeigt auf 5, 5 zeigt auf 6, und der ist der letzte"
  PRINT AT(7,12);"12 Bit-FAT"
  PRINT AT(7,14);"F7 FF FF 03 40 00 FF 0F 00 00 00 00 00 00 00 00   ................"
  TEXT 16*8-7,15*zh%-3,"   = 003"
  TEXT 19*8-7,16*zh%-3,"   = 004"
  PRINT AT(11,17);"Clustereintrag 2 zeigt auf Cluster 3"
  PRINT AT(11,18);"3 zeigt auf 4, und der ist der letzte"
  @help_ex
RETURN
PROCEDURE dir_help
  @info_dir
RETURN
PROCEDURE info_dir
  @screen
  PRINT AT(4,2);"Aufbau eines Directory-Eintrags:"
  PRINT AT(32,7);"Das Attributbyte"
  TEXT 40*8-7,8*zh%-3,""
  PRINT AT(7,9);"47 52 55 4D 4D 45 4C 20 54 53 54 10 00 00 00 00   GRUMMEL TST....."
  PRINT AT(7,10);"00 00 00 00 00 00 86 03 46 0C 02 00 98 13 00 00   ................"
  TEXT 25*8-7,11*zh%-3,"--------- --- ---------"
  PRINT AT(43,12);"LÑnge der Datei (INTEL-Format)"
  PRINT AT(37,13);"Der Start-Cluster     (INTEL-Format)"
  PRINT AT(25,14);"Datum und Uhrzeit (Siehe SCHEIBENKLEISTER Kap.3)"
  @maus_klick
  @show_attr
  @help_ex
RETURN
PROCEDURE show_hard_status
  @screen
  PRINT AT(5,2);" Status - Zustand "'
  PRINT AT(16,7);"Bit   7 6 5 4 3 2 1 0    ";RIGHT$(n$+BIN$(h_fehler%),8)
  PRINT AT(22,9);"| | | | | | |  ->  : $01   reserviert (immer 0)"
  PRINT AT(22,10);"| | | | | |  --->  : $02   CHECK  (1: Fehler)"
  PRINT AT(22,11);"| | | | |  ----->  : $04   EQUAL"
  PRINT AT(22,12);"| | | |  ------->  : $08   BUSY"
  PRINT AT(22,13);"| | |  --------->  : $10   reserviert (immer 0)"
  PRINT AT(22,14);"| |  ----------->  : $20"
  PRINT AT(22,15);"|  ------------->  : $40"
  PRINT AT(22,16);" --------------->  : $80"
  @is_bit(h_fehler%,9,72)
  @help_ex
RETURN
PROCEDURE show_hard_dma
  @screen
  PRINT AT(5,2);" DMA - Zustand "'
  PRINT AT(16,7);"Bit   7 6 5 4 3 2 1 0    ";RIGHT$(n$+BIN$(dma_st%),8)
  PRINT AT(22,9);"| | | | | | |  ->  : $01   0: DMA-Fehler"
  PRINT AT(22,10);"| | | | | |  --->  : $02   0: SektorzÑhler<>0"
  PRINT AT(22,11);"| | | | |  ----->  : $04   DATA REQUEST"
  PRINT AT(22,12);"| | | |  ------->  : $08"
  PRINT AT(22,13);"| | |  --------->  : $10"
  PRINT AT(22,14);"| |  ----------->  : $20"
  PRINT AT(22,15);"|  ------------->  : $40"
  PRINT AT(22,16);" --------------->  : $80"
  @is_bit(dma_st%,9,72)
  @help_ex
RETURN
PROCEDURE show_attr
  @screen
  PRINT AT(32,2);"Attribut-Byte"
  PRINT AT(25,6);" Bit   7 6 5 4 3 2 1 0  "
  PRINT AT(32,7);"| | | | | | |  ->  : $01  Nur lesen"
  PRINT AT(32,8);"| | | | | |  --->  : $02  versteckte Datei"
  PRINT AT(32,9);"| | | | |  ----->  : $04  Systemdatei"
  PRINT AT(32,10);"| | | |  ------->  : $08  Diskname"
  PRINT AT(32,11);"| | |  --------->  : $10  Ordner"
  PRINT AT(32,12);"| |  ----------->  : $20  Archiv-Bit"
  PRINT AT(32,13);"|  ------------->  : $40"
  PRINT AT(32,14);" --------------->  : $80"
RETURN
PROCEDURE info_sieben
  @alrt(1,"INFO-SIEBEN Ausgabe auf ",3,ddm$)
  @dev("SIEBEN.TXT")
  IF device%<>99 OR erg%=3
    @screen
    zx%=4
    zz%=4
    FOR i%=1 TO 7
      a$=LEFT$(text$(u_men%(i%),0)+STRING$(10,32),10)
      b$=LEFT$(text$(u_men%(i%),button%(i%)-1)+STRING$(10,32),10)
      @ausgabe(STR$(i%)+". "+a$+" "+b$)
    NEXT i%
    @look_ex
  ENDIF
RETURN
' ------------------------------ Info ---------------------------------------
PROCEDURE info_buttons
  LOCAL a$,b$
  @alrt(1,"Buttontext-Ausgabe auf ",3,ddm$)
  @dev("BUTTONS.TXT")
  IF device%<>99 OR erg%=3
    @screen
    CLR zz%,a$
    zx%=4
    b$=STRING$(10,32)
    FOR i%=1 TO 14
      FOR j%=0 TO 6
        a$=a$+LEFT$(text$(i%,j%)+b$,10)
      NEXT j%
      @ausgabe(a$)
      CLR a$
      FOR j%=7 TO 13
        a$=a$+LEFT$(text$(i%,j%)+b$,10)
      NEXT j%
      @ausgabe(a$)
      CLR a$
      IF zz%>13 AND i%<14
        @page("")
      ENDIF
    NEXT i%
  ENDIF
  @look_ex
RETURN
PROCEDURE help_lp(hlp%)
  LOCAL i%
  @screen
  PRINT AT(4,2);cp$;
  zz%=5
  FOR i%=0 TO 12
    PRINT AT(5,zz%);help$(hlp%,i%);
    INC zz%
  NEXT i%
RETURN
PROCEDURE help
  IF help!=TRUE
    hlp%=u1%
    @help_lp(hlp%)
    @help_ex
  ELSE
    @no_help
  ENDIF
RETURN
PROCEDURE ctrl_help
  IF help!=TRUE
    hlp%=u1%
    @help_lp(hlp%)
    INC hlp%
    @maus_klick
    @help_lp(hlp%)
    @help_ex
  ELSE
    @no_help
  ENDIF
RETURN
PROCEDURE no_help
  @alrt(1,"Keine HELP-Datei geladen",1,"Abbruch|Laden")
  IF erg%=2
    @in_help
    @kleine_boxen
  ENDIF
RETURN
PROCEDURE help_ex
  @maus_klick
  @screen
  @list
RETURN
PROCEDURE ausgabe(aus$)
  IF erg%<3
    @fwritec(hdl%,aus$)
  ELSE
    PRINT AT(zx%,zz%+4);aus$
    INC zz%
  ENDIF
RETURN
PROCEDURE fselect(muster$,vorschlag$,VAR ergebnis$)
  FILESELECT muster$,vorschlag$,ergebnis$
  CLR invert%
  felder
  felder_text(u1%)
  kleine_boxen
  @list
RETURN
PROCEDURE disass
  CLR mk%,in$
  zx%=4
  @alrt(1,"Was disassemblieren? ",1,"Buffer|RAM|Abbruch")
  was%=erg%
  IF was%<3
    IF was%=1
      pc%=buf%+z%+tz%
      drel%=buf%                ! Wenn Buffer dann Adresse auf 0000 umrechnen
    ELSE
      CLR drel%
      pc%=ram_addr%             ! +Tz%
    ENDIF
    IF EVEN(pc%)=FALSE
      INC pc%
    ENDIF
    @alrt(1,"Wohin disassemblieren? ",3,"Datei|Drucker|Moni")
    @dev("DISASS.TXT")
    IF device%<>99 OR erg%=3
      IF erg%<3 AND was%<>1
        @eingabe("Wieviele Zeilen disassemblieren?","",4)
        sanz%=MAX(VAL(a$),1)
      ENDIF
      CLR tanz%
      CLR zz%
      @screen
      DO
        @68000_disassembler(pc%,TRUE,TRUE,TRUE)
        location$=location$+" "
        hexdump$=hexdump$+SPACE$(21-LEN(hexdump$))
        mnemonic$=mnemonic$+SPACE$(8-LEN(mnemonic$))
        operand$=operand$+SPACE$(MAX(0,28-LEN(operand$)))
        @ausgabe(location$+hexdump$+mnemonic$+operand$+d_ascii$)
        INC tanz%
        IF zz%>15 AND erg%=3
          @page("")
        ENDIF
        EXIT IF mk%=2 OR in$=esc$
        IF branch!
          @ausgabe(location$+STRING$(66,"-"))
        ENDIF
        IF zz%>15 AND erg%=3
          @page("")
        ENDIF
        SWAP pc%,adjusted_pc%
        EXIT IF erg%<3 AND sanz%<=tanz% AND was%<>1
        EXIT IF was%=1 AND pc%-buf%>bps%
      LOOP
    ENDIF
    IF erg%<3
      @fclose(hdl%)
    ENDIF
    IF mk%<>2 AND in$<>esc$
      IF erg%=3
        @maus_klick
      ENDIF
    ENDIF
  ENDIF
  @screen
  @list
RETURN
' ******************************************************
' * AUTOR         : ERIK HANSEN  (Copyright (C) by ST-Computer)
' * GESCHRIEBEN   : FEBRUAR 1987. IN KRUSAA. DéNEMARK
' ******************************************************
PROCEDURE 68000_disassembler(pc%,location!,hexdump!,ascii!)
  IF dis_init%=0
    @initiate_68000_disassembler
  ENDIF
  CLR location$,hexdump$,mnemonic$,operand$,d_ascii$
  CLR d_offset%,destination!,extendflag%,branch!
  legal=TRUE
  ' * DIE MNEMONICS DER M68000 SIND IN 16 GRUPPEN AUFGETEILT. DIESE GRUPPEN
  ' * SIND IN DEN HôCHSTEN 4 BITS DER OPCODES CODIERT. HIER WERDEN DIE GRUPPEN
  ' * ERMITTELT UND DIE DAZU GEHôRENDE PROCEDURE ANGESPRUNGEN.
  instruction%=DPEEK(pc%)
  instruction_group%=(instruction% AND 61440) DIV 4096
  ON instruction_group%+1 GOSUB 0,1,1,1,4,5,6,7,8,9,10,11,12,9,14,15
  ' * HIER WERDEN EINIGE VON DEN VARIABLEN DEFINIERT,
  ' * DIE NOCH NICHT DEFINIERT WURDEN
  ' * ----------------------------------
  ' * ALLE VARIABLEN, DIE ZURöCKGELIEFERT WERDEN KôNNEN, SIND
  ' * ----------------------------------
  ' * Location$                 : DIE ADRESSE DES OPCODES IN HEX$
  ' * Hexdump$                  : DER OPCODE UND ZUGEHôRENDE BYTES IN HEX$
  ' * Mnemonic$                 : DER öBERSETZTE OPCODE
  ' * Operand$                  : DIE DEM OPCODE FOLGENDEN OPERANDEN
  ' * D_Ascii$                  : Hexdump$ IN ASCII öBERSETZT
  ' * ----------------------------------
  ' * Branch                    : KôNNEN ZWEI WERTE ANNEHMEN.  (True/False)
  ' *        True - LETZER OPCODE WAR EINER VON: JMP/BRA/RTS/RTE/RTR
  ' *       False - LETZER OPCODE WAR ALLES ANDERE
  ' * ----------------------------------
  ' * Adjusted_pc%              : ZEIGER AUF DEN NéCHSTEN OPCODE
  IF location!
    location$=RIGHT$(n$+HEX$(pc%-drel%),6)
  ENDIF
  d_offset%=d_offset% AND legal
  adjusted_pc%=pc%+2+d_offset%*2
  IF hexdump!
    FOR hexdump%=pc% TO adjusted_pc%-1
      hexdump$=hexdump$+RIGHT$(n$+HEX$(PEEK(hexdump%)),2)
    NEXT hexdump%
  ENDIF
  IF ascii!
    FOR char%=pc% TO adjusted_pc%-1
      ascii%=PEEK(char%)
      IF ascii%<32
        ascii%=46
      ENDIF
      d_ascii$=d_ascii$+CHR$(ascii%)
    NEXT char%
  ENDIF
  IF NOT legal
    mnemonic$=miscellaneous$(4)
    operand$="$"+hexdump$
  ENDIF
RETURN
PROCEDURE 0
  ' * BEFEHLE DER GRUPPE 0
  ' * ----------------------------------
  ' * BCLR       : BCHG      : BTST        : BSET       : MOVEP(W/L) :
  ' * ORI        : ANDI      : SUBI        : ADDI       : EORI       : CMPI
  ' * ORI TO CCR : ORI TO SR : ANDI TO CCR : ANDI TO SR : EORI TO SR :
  @isolate_single_bits
  status_register%=instruction% AND 60
  pc_memory%=pc%
  IF bit_eight%=1
    IF dmode%<>1
      IF dmode%=7
        IF (size%=0 AND register%>3) OR (size%>0 AND register%>1)
          CLR legal
        ENDIF
      ENDIF
      @assemble_operands
      mnemonic$=bittest$(size%)
      operand$=register$(0,function%)+","+operand$
    ELSE
      sign$="$"
      displacement%=DPEEK(pc%+2)
      IF displacement%>&H7FFF
        displacement%=&H10000-displacement%
        sign$="-$"
      ENDIF
      displacement$=sign$+HEX$(displacement%)
      IF size%=0 OR size%=2
        mnemonic$="MOVEP.W"
      ELSE
        mnemonic$="MOVEP.L"
      ENDIF
      IF size%<2
        operand$=displacement$+register$(2,register%)+","+register$(0,function%)
      ELSE
        operand$=register$(0,function%)+","+displacement$+register$(2,register%)
      ENDIF
      INC d_offset%
    ENDIF
  ELSE
    check%=DPEEK(pc%)
    IF function%<4
      IF check%<>&H3C AND check%<>&H7C AND check%<>&H23C AND check%<>&H27C
        IF (dmode%=7 AND register%>1) OR (dmode%=1)
          CLR legal
        ENDIF
      ENDIF
    ENDIF
    IF function%=0
      mnemonic$="ORI"
      @immediate_addressing_two
      IF check%=&H7C
        operand$=operand$+" ; Privilege"
      ENDIF
    ENDIF
    IF function%=1
      mnemonic$="ANDI"
      @immediate_addressing_two
      IF check%=&H27C
        operand$=operand$+" ; Privilege"
      ENDIF
    ENDIF
    IF function%=2
      mnemonic$="SUBI"
      @immediate_addressing_three
    ENDIF
    IF function%=3
      mnemonic$="ADDI"
      @immediate_addressing_three
    ENDIF
    IF function%=4
      INC extendflag%
      IF dmode%=7
        IF (size%=0 AND register%>3) OR (size%>0 AND register%>1)
          CLR legal
        ENDIF
      ENDIF
      IF dmode%=1
        CLR legal
      ENDIF
      IF dmode%=0
        IF PEEK(pc_memory%+3)>31
          CLR legal
        ENDIF
      ELSE
        IF PEEK(pc_memory%+3)>7
          CLR legal
        ENDIF
      ENDIF
      mnemonic$=bittest$(size%)
      CLR size%
      @immediate_addressing_three
    ENDIF
    IF function%=5 OR function%=6
      IF check%<>&HA3C AND check%<>&HA7C
        IF (dmode%=7 AND register%>1) OR (dmode%=1)
          CLR legal
        ENDIF
      ENDIF
      IF function%=5
        mnemonic$="EORI"
        @immediate_addressing_two
        IF check%=&HA7C
          operand$=operand$+" ; Privilege"
        ENDIF
      ELSE
        mnemonic$="CMPI"
        @immediate_addressing_three
      ENDIF
    ENDIF
    IF function%=7
      CLR legal
    ENDIF
    IF extendflag%=0
      mnemonic$=mnemonic$+extend$(size%)
    ENDIF
  ENDIF
  SWAP pc%,pc_memory%
RETURN
PROCEDURE 1
  ' * BEFEHLE DER GRUPPEN 1, 2 UND 3
  ' * ------------------------------
  ' * MOVE.B  : MOVE.W  : MOVE.L
  ' * MOVEA.W : MOVEA.L :
  pc_memory%=pc%
  size%=(instruction% AND 12288) DIV 4096
  IF size%=1
    DEC size%
  ENDIF
  IF size%=3
    SUB size%,2
  ENDIF
  dmode%=(instruction% AND 56) DIV 8
  register%=instruction% AND 7
  @assemble_operands
  operand_memory$=operand$
  destination!=TRUE
  register%=(instruction% AND 3584) DIV 512
  dmode%=(instruction% AND 448) DIV 64
  IF dmode%=1
    operand$=register$(1,register%)
    mnemonic$="MOVEA"
  ELSE
    mnemonic$="MOVE"
    ADD pc%,d_offset%*2
    @assemble_operands
    IF dmode%=7 AND register%>1
      CLR legal
    ENDIF
  ENDIF
  operand$=operand_memory$+","+operand$
  mnemonic$=mnemonic$+extend$(size%)
  SWAP pc%,pc_memory%
  IF DPEEK(pc%)=&H3F3C
    ' MOVE.W #xx,-(sp)
    trap%=DPEEK(pc%+4)
    IF trap%>=&H4E40 AND trap%<=&H4E4F
      trap%=trap% AND 15
      fn%=DPEEK(pc%+2)
      CLR a$
      IF trap%=1 AND fn%<88
        a$=gd$(fn%)
      ELSE
        IF trap%=13 AND fn%<12
          a$=bi$(fn%)
        ELSE
          IF trap%=14 AND fn%<65
            a$=xb$(fn%)
          ENDIF
        ENDIF
      ENDIF
      operand$=operand$+" ; "+a$
    ENDIF
  ENDIF
RETURN
PROCEDURE 4
  ' * BEFEHLE DER GRUPPE 4
  ' * --------------------
  ' * CHK     : LEA          :      :          :       :       :
  ' * NEGX    : MOVE FROM SR : CLR  :          :       :       :
  ' * NEG     : MOVE TO CCR  :      :          :       :       :
  ' * NOT     : MOVE TO SR   :      :          :       :       :
  ' * NBCD    : SWAP         : PEA  : EXT      : MOVEM :       :
  ' * ILLEGAL : TAS          : TST  :          :       :       :
  ' * JSR     : JMP          :      :          :       :       :
  ' * RESET   : NOP          : STOP : RTE      : RTS   : TRAPV : RTR
  ' * TRAP    : LINK         : UNLK : MOVE USP :       :       :
  @isolate_single_bits
  IF bit_eight%=1
    IF size%=2
      DEC size%
      @assemble_operands
      IF dmode%=1
        CLR legal
      ENDIF
      mnemonic$="CHK"
      operand$=operand$+","+register$(0,function%)
    ELSE
      @assemble_operands
      IF (dmode%<5 AND dmode%<>2) OR (dmode%=7 AND register%>3)
        CLR legal
      ENDIF
      mnemonic$="LEA"
      operand$=operand$+","+register$(1,function%)
    ENDIF
  ELSE
    IF function%<2
      IF (dmode%=7 AND register%>1) OR dmode%=1
        CLR legal
      ENDIF
    ENDIF
    IF function%=0
      @assemble_operands
      IF size%<3
        mnemonic$="NEGX"+extend$(size%)
      ELSE
        mnemonic$="MOVE"
        operand$="SR,"+operand$
      ENDIF
    ENDIF
    IF function%=1
      @assemble_operands
      mnemonic$="CLR"+extend$(size%)
    ENDIF
    IF function%=2
      @assemble_operands
      IF size%<3
        IF (dmode%=7 AND register%>1) OR dmode%=1
          CLR legal
        ENDIF
        mnemonic$="NEG"+extend$(size%)
      ELSE
        IF dmode%=1
          CLR legal
        ENDIF
        mnemonic$="MOVE"
        operand$=operand$+",CCR"
      ENDIF
    ENDIF
    IF function%=3
      @assemble_operands
      IF size%<3
        IF (dmode%=7 AND register%>1) OR dmode%=1
          CLR legal
        ENDIF
        mnemonic$="NOT"+extend$(size%)
      ELSE
        IF dmode%=1
          CLR legal
        ENDIF
        IF legal
          mnemonic$="MOVE"
          operand$=operand$+",SR ; Privilege"
        ENDIF
      ENDIF
    ENDIF
    IF function%=4
      IF size%=0
        IF (dmode%=7 AND register%>1) OR dmode%=1
          CLR legal
        ENDIF
        mnemonic$="NBCD"
        @assemble_operands
      ENDIF
      IF size%=1
        IF dmode%=0
          mnemonic$="SWAP"
          operand$=register$(0,register%)
        ELSE
          IF (dmode%<5 AND dmode%<>2) OR (dmode%=7 AND register%>3)
            CLR legal
          ENDIF
          mnemonic$="PEA"
          @assemble_operands
        ENDIF
      ENDIF
      IF size%=2 OR size%=3
        SUB size%,1
        IF dmode%=0
          mnemonic$="EXT"+extend$(size%)
          operand$=register$(0,register%)
        ELSE
          IF (dmode%=7 AND register%>1) OR (dmode%<4 AND dmode%<>2)
            CLR legal
          ENDIF
          mnemonic$="MOVEM"+extend$(size%)
          @assemble_registerlist
          operand$=registerlist$+","+operand$
        ENDIF
      ENDIF
    ENDIF
    IF function%=5
      IF instruction%=&H4AFC
        mnemonic$="ILLEGAL"
      ELSE
        IF (dmode%=7 AND register%>1) OR dmode%=1
          CLR legal
        ENDIF
        IF size%=3
          mnemonic$="TAS"
        ELSE
          mnemonic$="TST"+extend$(size%)
        ENDIF
        @assemble_operands
      ENDIF
    ENDIF
    IF function%=6
      IF dmode%<5 AND dmode%<>2 AND dmode%<>3
        CLR legal
      ENDIF
      IF size%=2
        mnemonic$="MOVEM.W"
      ELSE
        mnemonic$="MOVEM.L"
      ENDIF
      @assemble_registerlist
      operand$=operand$+","+registerlist$
    ENDIF
    IF function%=7
      IF size%=2 OR size%=3
        IF (dmode%<5 AND dmode%<>2) OR (dmode%=7 AND register%>3)
          CLR legal
        ENDIF
        @assemble_operands
        IF size%=2
          mnemonic$="JSR"
        ELSE
          mnemonic$="JMP"
        ENDIF
        IF legal AND mnemonic$="JMP"
          branch!=TRUE
        ENDIF
      ELSE
        IF dmode%=6
          IF register%=4
            CLR legal
          ENDIF
          mnemonic$=miscellaneous$(register%)
          IF register%=0 OR register%=3
            operand$="; Privilege"
          ENDIF
          IF register%=2
            operand$="#$"+HEX$(DPEEK(pc%+2))+" ; Privilege"
            INC d_offset%
          ENDIF
          IF register%=2 OR register%=3 OR register%=5 OR register%=7
            branch!=TRUE
          ENDIF
        ELSE
          trap%=(instruction% AND 48) DIV 16
          IF trap%=0
            mnemonic$="TRAP"
            trap_number%=instruction% AND 15
            operand$="#$"+HEX$(trap_number%)
            IF trap_number%=2
              IF DPEEK(pc%-2)=&HC8
                operand$=operand$+" ; AES"
              ELSE
                IF (DPEEK(pc%-2) AND &H73)=&H73
                  operand$=operand$+" ; VDI"
                ELSE
                  operand$=operand$+trap$(trap_number%)
                ENDIF
              ENDIF
            ELSE
              operand$=operand$+trap$(trap_number%)
            ENDIF
            '
            '  Hier evtl TRAP-Aufrufe dekodieren
            '
          ELSE
            SUB dmode%,2
            IF dmode%=0
              sign$="$"
              CLR com$
              displacement%=DPEEK(pc%+2)
              IF displacement%>&H7FFF
                displacement%=&H10000-displacement%
                sign$="-$"
              ELSE
                com$=" ; Nonstandard"
              ENDIF
              mnemonic$="LINK"
              displacement$=sign$+HEX$(displacement%)
              operand$=register$(1,register%)+",#"+displacement$+com$
              INC d_offset%
            ENDIF
            IF dmode%=1
              mnemonic$="UNLK"
              operand$=register$(1,register%)
            ENDIF
            IF dmode%=2 OR dmode%=3
              mnemonic$="MOVE"
              IF dmode%=2
                operand$=register$(1,register%)+",USP ; Privilege"
              ELSE
                operand$="USP,"+register$(1,register%)+" ; Privilege"
              ENDIF
            ENDIF
            IF dmode%>3
              CLR legal
            ENDIF
          ENDIF
        ENDIF
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE 5
  ' * BEFEHLE DER GRUPPE 5
  ' * ------------------------------------------
  ' * ADDQ : SUBQ
  ' * Scc  : cc=Bedingung=(cc.cs.eq.f.ge.gt.hi.le.ls.lt.mi.ne.pl.t.vc.vs)
  ' * DBRA : (Oder DBF)
  ' * DBcc : cc=Bedingung=(cc.cs.eq.f.ge.gt.hi.le.ls.lt.mi.ne.pl.t.vc.vs)
  pc_memory%=pc%
  @isolate_single_bits
  IF dmode%=7 AND register%>1
    CLR legal
  ENDIF
  IF size%<>3
    @assemble_operands
    IF function%=0
      ADD function%,8
    ENDIF
    operand$="#$"+STR$(function%)+","+operand$
    IF bit_eight%=0
      mnemonic$="ADDQ"+extend$(size%)
    ELSE
      mnemonic$="SUBQ"+extend$(size%)
    ENDIF
  ELSE
    conditioncode%=(instruction% AND 3840) DIV 256
    IF dmode%<>1
      mnemonic$="S"+conditioncode$(conditioncode%)
      @assemble_operands
    ELSE
      IF conditioncode%=1
        mnemonic$="DBRA"
      ELSE
        mnemonic$="DB"+conditioncode$(conditioncode%)
      ENDIF
      destination%=DPEEK(pc%+2)
      IF destination%>&H7FFF
        SUB destination%,&H10000
      ENDIF
      destination%=(pc%+2)+destination%-drel%
      destination$=HEX$(destination%)
      operand$=register$(0,register%)+",$"+destination$
      INC d_offset%
    ENDIF
  ENDIF
RETURN
PROCEDURE 6
  ' * BEFEHLE DER GRUPPE 6
  ' * ------------------------------------------
  ' * BRA : BSR
  ' * Bcc : cc=Bedingung=(cc.cs.eq.ge.gt.hi.le.ls.lt.mi.ne.pl.vc.vs)
  conditioncode%=(instruction% AND 3840) DIV 256
  distance%=instruction% AND 255
  CLR com$
  IF conditioncode%<2
    IF conditioncode%=0
      mnemonic$="BRA"
      branch!=TRUE
    ELSE
      mnemonic$="BSR"
    ENDIF
  ELSE
    mnemonic$="B"+conditioncode$(conditioncode%)
  ENDIF
  IF distance%=0
    mnemonic$=mnemonic$+".W"
    destination%=DPEEK(pc%+2)
    IF (destination%>&HFF80) OR (destination%<&H80)
      com$=" ; (.W Could Be .S)"
    ENDIF
    IF destination%>&H7FFF
      SUB destination%,&H10000
    ENDIF
    INC d_offset%
  ELSE
    mnemonic$=mnemonic$+".S"
    IF distance%>&H7F
      SUB distance%,&H100
    ENDIF
    destination%=distance%
  ENDIF
  operand$="$"+HEX$((pc%+2)+destination%-drel%)+com$
RETURN
PROCEDURE 7
  ' * BEFEHLE DER GRUPPE 7
  ' * ------------------------------------------
  ' * MOVEQ
  mnemonic$="MOVEQ"
  constant$=HEX$(instruction% AND 255)
  register%=(instruction% AND 3584) DIV 512
  operand$="#$"+constant$+","+register$(0,register%)
RETURN
PROCEDURE 8
  ' * BEFEHLE DER GRUPPE 8
  ' * ------------------------------------------
  ' * DIVU : DIVS
  ' * SBCD :
  ' * OR   :
  @isolate_single_bits
  IF size%=3
    IF dmode%=1
      CLR legal
    ENDIF
    @assemble_operands
    operand$=operand$+","+register$(0,function%)
    IF bit_eight%=0
      mnemonic$="DIVU"
    ELSE
      mnemonic$="DIVS"
    ENDIF
  ELSE
    IF bit_eight%=1 AND dmode%<2
      mnemonic$="SBCD"
      IF dmode%=0
        operand$=register$(0,register%)+","+register$(0,function%)
      ELSE
        operand$=register$(4,register%)+","+register$(4,function%)
      ENDIF
    ELSE
      IF dmode%=1
        CLR legal
      ENDIF
      @assemble_operands
      mnemonic$="OR"+extend$(size%)
      IF bit_eight%=0
        operand$=operand$+","+register$(0,function%)
      ELSE
        operand$=register$(0,function%)+","+operand$
        IF dmode%=7 AND register%>1
          CLR legal
        ENDIF
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE 9
  ' * BEFEHLE DER GRUPPEN 9 UND 13
  ' * ------------------------------------------
  ' * SUBA : ADDA
  ' * SUBX : ADDX
  ' * SUB  : ADD
  IF instruction_group%=9
    mnemonic$="SUB"
  ELSE
    mnemonic$="ADD"
  ENDIF
  @isolate_single_bits
  IF size%=3
    IF bit_eight%<>0
      DEC size%
    ENDIF
    @assemble_operands
    operand$=operand$+","+register$(1,function%)
    IF bit_eight%=0
      mnemonic$=mnemonic$+"A.W"
    ELSE
      mnemonic$=mnemonic$+"A.L"
    ENDIF
  ELSE
    IF dmode%<2 AND bit_eight%=1
      mnemonic$=mnemonic$+"X"+extend$(size%)
      IF dmode%=0
        operand$=register$(0,register%)+","+register$(0,function%)
      ELSE
        operand$=register$(4,register%)+","+register$(4,function%)
      ENDIF
    ELSE
      @assemble_operands
      IF bit_eight%=0
        operand$=operand$+","+register$(0,function%)
      ELSE
        operand$=register$(0,function%)+","+operand$
        IF dmode%=7 AND register%>1
          CLR legal
        ENDIF
      ENDIF
      mnemonic$=mnemonic$+extend$(size%)
    ENDIF
  ENDIF
RETURN
PROCEDURE 10
  ' * BEFEHLE DER GRUPPE 10
  ' * ------------------------------------------
  ' * KEINE. WERDEN MIT DC.W $Axxx (+ evt. LINEA VARIABLE) öBERSETZT
  ' *
  ' * FALLS ES SICH UM EINEN DER LINEA OPCODES HANDELT, WIRD DER NAME DES
  ' * OPCODES IN FORM EINES KOMMENTARS AN DEN OPERANDEN ANGEHéNGT.
  ' *
  ' * Zb.   DC.W $A000 ; LINEA INIT.
  ' *
  ' * DIE WERTE VON $A000 BIS $A00F SIND BEIM ATARI ST DIE LINEA OPCODES
  IF instruction%<&HA010
    mnemonic$=miscellaneous$(4)
    hexdump%=DPEEK(pc%)
    operand$="$"+HEX$(hexdump%)+" ; "+linea$(PEEK(pc%+1))
  ELSE
    CLR legal
  ENDIF
RETURN
PROCEDURE 11
  ' * BEFEHLE DER GRUPPE 11
  ' * ------------------------------------------
  ' * CMPA : CMPM
  ' * EOR  : CMP
  @isolate_single_bits
  IF size%=3 AND bit_eight%=1
    mnemonic$="CMPA.L"
    DEC size%
    @assemble_operands
    operand$=operand$+","+register$(1,function%)
  ELSE
    IF bit_eight%=1
      IF dmode%=1
        mnemonic$="CMPM"+extend$(size%)
        operand$=register$(2,register%)+","+register$(2,function%)
      ELSE
        IF dmode%=7 AND register%>1
          CLR legal
        ENDIF
        mnemonic$="EOR"+extend$(size%)
        @assemble_operands
        operand$=register$(0,function%)+","+operand$
      ENDIF
    ELSE
      @assemble_operands
      IF size%<3
        mnemonic$="CMP"+extend$(size%)
        operand$=operand$+","+register$(0,function%)
      ELSE
        mnemonic$="CMPA.W"
        operand$=operand$+","+register$(1,function%)
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE 12
  ' * BEFEHLE DER GRUPPE 12
  ' * ------------------------------------------
  ' * MULU : MULS
  ' * ABCD : EXG
  ' * AND  :
  @isolate_single_bits
  IF size%=3
    IF dmode%=1
      CLR legal
    ENDIF
    IF bit_eight%=0
      mnemonic$="MULU"
    ELSE
      mnemonic$="MULS"
    ENDIF
    @assemble_operands
    operand$=operand$+","+register$(0,function%)
  ELSE
    IF dmode%<2 AND bit_eight%=1
      IF size%=0
        mnemonic$="ABCD"
        IF dmode%=0
          operand$=register$(0,register%)+","+register$(0,function%)
        ELSE
          operand$=register$(4,register%)+","+register$(4,function%)
        ENDIF
      ELSE
        mnemonic$="EXG"
        IF size%=1 AND dmode%=0
          operand$=register$(0,function%)+","+register$(0,register%)
        ENDIF
        IF size%=2
          operand$=register$(0,function%)+","+register$(1,register%)
        ENDIF
        IF size%<>2 AND dmode%<>0
          operand$=register$(1,function%)+","+register$(1,register%)
        ENDIF
      ENDIF
    ELSE
      IF dmode%=1
        CLR legal
      ENDIF
      mnemonic$="AND"+extend$(size%)
      @assemble_operands
      d_register$="D"+STR$(function%)
      IF bit_eight%=0
        operand$=operand$+","+register$(0,function%)
      ELSE
        IF (dmode%=7 AND register%>1)
          CLR legal
        ENDIF
        operand$=register$(0,function%)+","+operand$
      ENDIF
    ENDIF
  ENDIF
RETURN
PROCEDURE 14
  ' * BEFEHLE DER GRUPPE 14
  ' * ------------------------------------------
  ' * ASL : ASR :      :
  ' * ROL : ROR : ROXL : ROXR
  @isolate_single_bits
  IF (instruction% AND 256) DIV 256=1
    shift_direction$="L"
  ELSE
    shift_direction$="R"
  ENDIF
  IF size%=3
    shift%=(instruction% AND 1536) DIV 512
  ELSE
    shift%=(instruction% AND 24) DIV 8
  ENDIF
  mnemonic$=arithmetic_shift$(shift%)+shift_direction$+extend$(size%)
  IF size%<3
    counter%=function%
    IF (instruction% AND 32) DIV 32=0
      IF counter%=0
        ADD counter%,8
      ENDIF
      operand$="#$"+STR$(counter%)
    ELSE
      operand$=register$(0,function%)
    ENDIF
    operand$=operand$+","+register$(0,register%)
  ELSE
    @assemble_operands
    IF (dmode%=7 AND register%>1) OR dmode%<2
      CLR legal
    ENDIF
  ENDIF
RETURN
PROCEDURE 15
  ' * BEFEHLE DER GRUPPE 15
  ' * ------------------------------------------
  ' * KEINE. WERDEN MIT DC.W $Fxxx öBERSETZT.
  CLR legal
RETURN
PROCEDURE assemble_operands
  IF dmode%<7
    IF dmode%<5
      ' *   Dn   : DATENREGISTER DIREKT
      ' *   An   : ADRESSREGISTER DIREKT
      ' *  (An)  : ADRESSREGISTER INDIREKT
      ' *  (An)+ : ADRESSREGISTER INDIREKT MIT POSTINKREMENT
      ' * -(An)  : ADRESSREGISTER INDIREKT MIT PREDEKREMENT
      operand$=register$(dmode%,register%)
    ELSE
      IF dmode%=5
        ' * d16(An) : ADRESSREGISTER INDIREKT MIT ADRESSDISTANZ
        displacement%=DPEEK(pc%+2)
        IF displacement%<>0
          sign$="$"
          IF displacement%>&H7FFF
            displacement%=&H10000-displacement%
            sign$="-$"
          ENDIF
          displacement$=sign$+HEX$(displacement%)
        ELSE
          CLR displacement$
        ENDIF
        operand$=displacement$+register$(2,register%)
        INC d_offset%
      ELSE
        ' * d8(An,Rx.X) : ADRESSREGISTER INDIREKT MIT INDEX + ADRESSDISTANZ
        reg%=PEEK(pc%+2)
        ext%=reg%
        IF (reg% AND 128) DIV 128=1
          reg$="A"
        ELSE
          reg$="D"
        ENDIF
        IF (ext% AND 8) DIV 8=1
          ext$=".L"
        ELSE
          ext$=".W"
        ENDIF
        index$=reg$+STR$((reg% AND 112) DIV 16)+ext$
        displacement%=PEEK(pc%+3)
        IF displacement%<>0
          sign$="$"
          IF displacement%>&H7F
            displacement%=&H100-displacement%
            sign$="-$"
          ENDIF
          displacement$=sign$+HEX$(displacement%)
        ELSE
          CLR displacement$
        ENDIF
        reg%=(PEEK(pc%+1) AND 7)
        IF instruction_group%=0
          reg%=(PEEK(pc_memory%+1) AND 7)
        ENDIF
        IF destination!
          IF instruction_group%>0 AND instruction_group%<4
            reg%=((PEEK(pc_memory%) AND 14) DIV 2)
          ENDIF
        ENDIF
        operand$=displacement$+"("+register$(1,reg%)+","+index$+")"
        INC d_offset%
      ENDIF
    ENDIF
  ELSE
    IF register%=0
      ' * $xxxx : ABSOLUT KURZ
      operand$="$"+HEX$(DPEEK(pc%+2))
      INC d_offset%
    ENDIF
    IF register%=1
      ' * $xxxxxxxx: ABSOLUT LANG
      operand$="$"+HEX$(LPEEK(pc%+2))
      ADD d_offset%,2
    ENDIF
    IF register%=2
      ' * d16(PC) : PROGRAMMZéHLERRELATIV MIT ADRESSDISTANZ
      displacement%=DPEEK(pc%+2)
      IF displacement%>&H7FFF
        SUB displacement%,&H10000
      ENDIF
      displacement$=HEX$((pc%+2)+displacement%-drel%)
      operand$="$"+displacement$+"(PC)"
      INC d_offset%
    ENDIF
    IF register%=3
      ' * d8(PC,Rx.X) : PROGRAMMZéHLERRELATIV MIT INDEX + ADRESSDISTANZ
      reg%=PEEK(pc%+2)
      ext%=reg%
      IF (reg% AND 128) DIV 128=1
        reg$="A"
      ELSE
        reg$="D"
      ENDIF
      IF (ext% AND 8) DIV 8=1
        ext$=".L"
      ELSE
        ext$=".W"
      ENDIF
      index$=reg$+STR$((reg% AND 112) DIV 16)+ext$
      displacement%=PEEK(pc%+3)
      IF displacement%>&H7F
        SUB displacement%,&H100
      ENDIF
      displacement$=HEX$((pc%+2)+displacement%-drel%)
      operand$="$"+displacement$+"(PC,"+index$+")"
      INC d_offset%
    ENDIF
    IF register%=4
      @immediate_addressing_one
    ENDIF
    IF register%>4
      CLR legal
    ENDIF
  ENDIF
RETURN
PROCEDURE assemble_registerlist
  ' * zb. MOVEM.L D0-D7/A0-A6,-(SP)
  CLR high$,low$,registerlist$
  d_registerbyte%=3
  a_registerbyte%=2
  IF dmode%=4
    SWAP d_registerbyte%,a_registerbyte%
  ENDIF
  highbyte$=RIGHT$(n$+BIN$(PEEK(pc%+d_registerbyte%)),8)
  lowbyte$=RIGHT$(n$+BIN$(PEEK(pc%+a_registerbyte%)),8)
  IF dmode%<>4
    FOR i%=8 DOWNTO 1
      high$=high$+MID$(highbyte$,i%,1)
      low$=low$+MID$(lowbyte$,i%,1)
    NEXT i%
    SWAP highbyte$,high$
    SWAP lowbyte$,low$
  ENDIF
  highbyte$=highbyte$+"0"
  lowbyte$=lowbyte$+"0"
  FOR first_position%=0 TO 7
    last_position%=first_position%
    IF MID$(highbyte$,first_position%+1,1)="1"
      DO
        INC last_position%
        EXIT IF MID$(highbyte$,last_position%+1,1)="0"
      LOOP
      IF last_position%-first_position%=1
        registerlist$=registerlist$+register$(0,first_position%)+"/"
      ELSE
        registerlist$=registerlist$+register$(0,first_position%)
        registerlist$=registerlist$+"-"+register$(0,last_position%-1)+"/"
      ENDIF
      first_position%=last_position%-1
    ENDIF
  NEXT first_position%
  FOR first_position%=0 TO 7
    last_position%=first_position%
    IF MID$(lowbyte$,first_position%+1,1)="1"
      DO
        INC last_position%
        EXIT IF MID$(lowbyte$,last_position%+1,1)="0"
      LOOP
      IF last_position%-first_position%=1
        registerlist$=registerlist$+register$(1,first_position%)+"/"
      ELSE
        registerlist$=registerlist$+register$(1,first_position%)
        registerlist$=registerlist$+"-"+register$(1,last_position%-1)+"/"
      ENDIF
      first_position%=last_position%-1
    ENDIF
  NEXT first_position%
  registerlist$=LEFT$(registerlist$,LEN(registerlist$)-1)
  INC d_offset%
  pc_memory%=pc%
  ADD pc%,d_offset%*2
  @assemble_operands
  SWAP pc%,pc_memory%
RETURN
PROCEDURE immediate_addressing_one
  IF size%=0
    ' * #$xx       : BYTE-KONSTANTENADRESSIERUNG
    operand$="#$"+HEX$(PEEK(pc%+3))
  ENDIF
  IF size%=1 OR size%=3
    ' * #$xxxx     : WORT-KONSTANTENADRESSIERUNG
    operand$="#$"+HEX$(DPEEK(pc%+2))
  ENDIF
  IF size%=2
    ' * #$xxxxxxxx : LANGWORT-KONSTANTENADRESSIERUNG
    operand$="#$"+HEX$(LPEEK(pc%+2))
    INC d_offset%
  ENDIF
  INC d_offset%
RETURN
PROCEDURE immediate_addressing_two
  ' * #$xx/#$xxxx/#$xxxxxxxx,<EA> : KONSTANTENADRESSIERUNG,<EA>
  @immediate_addressing_one
  operand_memory$=operand$+","
  ADD pc%,d_offset%*2
  IF status_register%<>60
    @assemble_operands
    operand$=operand_memory$+operand$
  ELSE
    ' * SR/CCR : STATUSREGISTER DIREKT
    INC extendflag%
    IF size%=0
      status_register$="CCR"
    ELSE
      IF legal
        status_register$="SR"
      ENDIF
    ENDIF
    operand$=operand_memory$+status_register$
  ENDIF
RETURN
PROCEDURE immediate_addressing_three
  ' * #$xx/#$xxxx/#$xxxxxxxx,<EA> : KONSTANTENADRESSIERUNG,<EA>
  @immediate_addressing_one
  operand_memory$=operand$+","
  ADD pc%,d_offset%*2
  @assemble_operands
  operand$=operand_memory$+operand$
RETURN
PROCEDURE isolate_single_bits
  ' * Function% = BIT 11-9 : Bit_eight% = BIT   8 : Size% = BIT 7-6
  ' * Dmode%    = BIT  5-3 : Register%  = BIT 2-0
  function%=(instruction% AND 3584) DIV 512
  bit_eight%=(instruction% AND 256) DIV 256
  size%=(instruction% AND 192) DIV 64
  dmode%=(instruction% AND 56) DIV 8
  register%=instruction% AND 7
RETURN
PROCEDURE initiate_68000_disassembler
  ' * DIESE ROUTINE WIRD NUR EINMAL BEIM START DURCHGEFöRHT
  dis_init%=1
  DIM arithmetic_shift$(3),extend$(3),bittest$(3)
  DIM conditioncode$(15),trap$(15),linea$(15),miscellaneous$(7)
  DIM gd$(87),xb$(64),bi$(11)
  DIM register$(4,7)
  RESTORE 68000_disassembler_data
  FOR index%=0 TO 3
    READ arithmetic_shift$(index%)
    READ extend$(index%)
    READ bittest$(index%)
  NEXT index%
  FOR index%=0 TO 15
    READ conditioncode$(index%)
    READ trap$(index%)
    READ linea$(index%)
  NEXT index%
  FOR index%=0 TO 11
    READ bi$(index%)
  NEXT index%
  FOR index%=0 TO 64
    READ xb$(index%)
  NEXT index%
  FOR index%=0 TO 87
    READ gd$(index%)
  NEXT index%
  FOR index%=0 TO 7
    READ miscellaneous$(index%)
  NEXT index%
  FOR dmode%=0 TO 4
    FOR register%=0 TO 7
      READ register$(dmode%,register%)
    NEXT register%
  NEXT dmode%
68000_disassembler_data:
  ' * Arithmetic_shift$() + Extend$() + Bittest$()
  DATA AS,.B,BTST,LS,.W,BCHG,ROX,.L,BCLR,RO,.W,BSET
  ' * Conditioncode$()    + Trap$()   + Linea$()
  DATA T,,LINE-A Init,F, ; Gemdos,Put Pixel,HI, ; VDI/AES,Get Pixel,LS,
  DATA Line,CC,,Horizontal Line,CS,,Filled Rectangle,NE,,Filled Polygon
  DATA EQ,,Bitblt,VC,,Textblt,VS,,Show Mouse,PL,,Hide Cursor,MI,
  DATA Transform Mouse,GE,,Undraw Sprite,LT, ; Bios,Draw Sprite
  DATA GT, ; Xbios,Copy Raster Form,LE,,Seedfill
  ' Bios-Funktionen
  DATA Getmpb,Bconstat,Bconin,Bconout,Rwabs,Setexc,Tickcal,Getbpb,Bcostat
  DATA Mediach,Drvmap,Kbshift
  ' Xbios-Funktionen
  DATA Initmous,Ssbrk,Physbase,Logbase,Getrez,Setscreen,Setpalette
  DATA Setcolor,Floprd,Flopwr,Flopfmt,Getdsb,Midiws,Mfpint,Iorec
  DATA Rsconf,Keytbl,Random,Protobt,Flopver,Scrdmp,Cursconf
  DATA Settime,Gettime,Bioskeys,Ikbdws,Jdisint,Jenabint
  DATA Giaccess,Offgibit,Ongibit,Xbtimer,Dosound,Setprt,Kbdvbase
  DATA Kbrate,Prtblk,Vsync,Supexec,Puntaes,40,41,42,43,44,45,46,47,48,49
  DATA 50,51,52,53,54,55,56,57,58,59,60,61,62,63,Blitmode
  ' Gemdos-Funktionen
  DATA Pterm0,Cconin,Cconout,Cauxin,Cauxout,Cprnout,Crawio,Crawcin
  DATA Cnecin,Cconws,Cconrs,Cconis,12,13,Dsetdrv,15,Cconos,Cprnos
  DATA Cauxis,Cauxos,20,21,22,23,24,Dgetdrv,Fsetdta,27,28,29,30,31
  DATA Super,33,34,35,36,37,38,39,40,41
  DATA Tgetdate,Tsetdate,Tgettime,Tsettime,46,Fgetdta,Sversion
  DATA Ptermres,50,51,52,53,Dfree,55,56,Dcreate,Ddelete,Dsetpath
  DATA Fcreate,Fopen,Fclose,Fread,Fwrite,Fdelete,Fseek,Fattrib
  DATA 68,Fdup,Fforce,Dgetpath,Malloc,Mfree,Mshrink,Pexec
  DATA Pterm,77,Fsfirst,Fsnext,80,81,82,83,84,85,Frename,Fdatime
  ' * Miscellaneous$()
  DATA RESET,NOP,STOP,RTE,DC.W,RTS,TRAPV,RTR
  ' * Register$(,)
  DATA D0,D1,D2,D3,D4,D5,D6,D7
  DATA A0,A1,A2,A3,A4,A5,A6,SP
  DATA (A0),(A1),(A2),(A3),(A4),(A5),(A6),(SP)
  DATA (A0)+,(A1)+,(A2)+,(A3)+,(A4)+,(A5)+,(A6)+,(SP)+
  DATA -(A0),-(A1),-(A2),-(A3),-(A4),-(A5),-(A6),-(SP)
RETURN
'
hard_err:
DATA OK,Kein Indeximpuls,Suche noch,Schreibfehler
DATA Laufwerk nicht bereit,Laufwerk nicht selektiert,Spur 0 nicht gefunden
DATA Mehrere Laufwerke selektiert,,,,,,,,
DATA CRC-Fehler im Adreûfeld,Unkorrigierbarer Datenfehler
DATA ID-Adreûmarke verschollen,Daten-Adreûmarke verschollen,Sektor nicht gefunden
DATA Spur nicht gefunden,Behobener Fehler in Data AM,Behobener Datenfeld-Fehler
DATA ECC-korrigierter Datenfeld-Fehler
DATA Fehler in Defektliste/ECC-Fehler (Verify),ParameterÅberlauf (Interleave?)
DATA ,Plattenformat defekt/keine Defektliste,,,
DATA UngÅltiger Befehl,UngÅltige Blockadresse,UngÅltige Funktion
DATA UngÅltige Endadresse,Parameterfehler,UngÅltige GerÑtenummer
DATA UngÅltiges Parameterfeld,Medium schreibgeschÅtzt,Medium gewechselt
DATA Reset seit letztem Kommando,,,FehlerzÑhler Åbergelaufen
DATA ,,,Medium inkompatibel,Formatierfehler,
DATA Message-Fehler,SCSI-Hardwarefehler,(Re)Select-Fehler
DATA Fehler bei Software-Reset,ParitÑtsfehler,Initiator nicht erkannt
DATA Message ungÅltig
DATA ,,,,,,,
DATA ,,,,,,,
DATA ,,,,,,,
DATA ,,,,,,,
DATA ,,,,,,,
DATA ,,,,,,,
DATA ,,,,,
DATA Selbsttest-Fehler,Selbsttest-Fehler 1,Selbsttest-Fehler 2
DATA Selbsttest-Fehler 3,Selbsttest-Fehler 4,Selbsttest-Fehler 5
DATA Selbsttest-Fehler 6,Selbsttest-Fehler 7,Selbsttest-Fehler 8
DATA Selbsttest-Fehler 9,Selbsttest-Fehler 10,Selbsttest-Fehler 11
DATA Selbsttest-Fehler 12,Selbsttest-Fehler 13,Selbsttest-Fehler 14
DATA Selbsttest-Fehler 15,0 Bits ECC-korrigiert,1 Bit ECC-korrigiert
DATA 2 Bits ECC-korrigiert,3 Bits ECC-korrigiert,4 Bits ECC-korrigiert
DATA 5 Bits ECC-korrigiert,6 Bits ECC-korrigiert,7-Bits ECC-korrigiert
DATA 8 Bits ECC-korrigiert,9 Bits ECC-korrigiert,10 Bits ECC-korrigiert
DATA 11 Bits ECC-korrigiert,12 Bits ECC-korrigiert,13 Bits ECC-korrigiert
DATA 14 Bits ECC-korrigiert,15 Bits ECC-korrigiert
DATA Data Check In No Retry Mode,ECC-Fehler,Interleave-Fehler
DATA UngÅltiges Format,UngÅltige Endadresse,ParitÑtsfehler
DATA MODE-SENSE-Fehler,Falscher Kopf,Falscher Zylinder
DATA DMA-Timeout,Timeout beim Schreiben,Feinjustierungs-Fehler
DATA FehlerzÑhler Åbergelaufen,Medienwechsel angefordert,Verify-Fehler
DATA *
' ------------------------------ End of Text -------------------------------
