$m50000
$c+
'
'                            CHECKHD V8.3
'                       Written & Ω 1989/90 by
'
'
'            Anton Stepper                       Claus Brod
'            Jahnstr. 5                          Am Felsenkeller
'       8772 Marktheidenfeld                8772 Marktheidenfeld
'            09391/6651                          09391/3206
'
'
' 21.1. Ausgabeformat beim Lesetest geÑndert
' 20.2. Anpassung an QUANTUM P105S
' FEHLER im Spurwechseltest: Max% wird manchmal falsch berechnet, beispiels-
'       weise bei QUANTUM P105S, mîglicherweise auch bei Seagate-Platten
'       jetzt vorlÑufiger Patch in Spur_zu_Spur - nochmal durchdenken!
' 24.2. neue Methode zur Messung der Spurwechselzeiten (s. Dummy2)
'       Zugriff II entfernt, Form_dos korrigiert
'       Erstes Target ist vorgewÑhlt
'       Routine fÅr Fehlerbehandlung
'       Start% war doppelt belegt
'       Zugriffstest laeuft jetzt auch mit SH204
' 9.3.  nochmal neue Methode in Doseek
'       beim Suchtest jeweils 1000 Seeks statt 100
'       Zugriffszeiten werden auf eine Stelle nach dem Komma gerundet
' 10.5. Ausgabe der Daten auch auf Diskette mîglich
'       SH204 wird beim Spurwechseltest automatisch erkannt
'       Fehlermeldungen gekÅrzt
' 22.5. Anpassung an GFA 3.0
' 2.6.  Anpassung an DataJet, erkennt automatisch HDplus/DataJet
'       setzt startsec% im Vortex-Modus nach allgemeiner Formel
' 23.6. 'Total' lÑût sich jetzt wirklich edieren
'       reagiert auf $4711 von GEMINI, lÑuft wieder als ACC
' 7.7.  Bei Fehlern im Lesetest funktioniert auch 'Abbruch'
'       Lesetest schiesst nicht mehr uebers Ziel hinaus
'       Abbruchmeldung meldet nicht mehr "Fehler -2"
'       Lesetest schaltet bei ATARI- und SCSI-Platten die
'       Fehlerkorrektur aus, Parameterdialog wird initialisiert
'       Start- und Endsektor kînnen angegeben werden
'       Maschinenprogramm per INLINE (Tnx Werner!)
'       Shrink/Growboxen per Default abgeschaltet, kînnen durch Klick auf Icon
'       aktiviert werden
'       Fehler nach FILESELECT behoben (Abfrage auf \ am Ende fehlte)
'       BITBLT statt PUT/GET
' 6.8.  Fehlermeldungen und Hilfstexte in SCR-Datei ausgelagert
'       Vorbereitungen fÅr mehrsprachige Version
'       auch beim Lesetest wird der Speicher wieder freigegeben
'       Anpassungen an neue Quantum-Platten, Optimierungen
'       Wenn ein nicht-deutsches TOS verwendet wird, schaltet CHECKHD
'       auf englische Ausgaben um
' 21.8. Neue Meûmethode fÅr Transfer bei SQ555, liefert endlich Sollwerte
'       Fehler in lesetest behoben (anzahl% wurde berechnet, aber nie verwendet)
'       Hauptdialog beweglich; "Griff" der Dialoge ist jetzt das Rootobjekt
' 31.12. Icon wird transformiert und zentriert
'       Clipping beim Blitten; neue meinform_do-Routine mit Wegklappen
'
'       last update: 21.8.90   14:00 Uhr       CB
' ----------------------------------------------------------------------------
' ON ERROR GOSUB fehlerbehandlung
'
DIM nachricht%(3),fehler$(255),p$(7,7)
' ------------------------------------------
form1%=0            !  form/dialog
aussen1%=0          !  BOX in tree FORM1
titel%=2            !  BOXTEXT in tree FORM1
icon%=3             !  IMAGE in tree FORM1
titel2%=4           !  BOXTEXT in tree FORM1
titel3%=5           !  BOXTEXT in tree FORM1
t0%=7               !  BUTTON in tree FORM1
t1%=8               !  BUTTON in tree FORM1
t2%=9               !  BUTTON in tree FORM1
t3%=10              !  BUTTON in tree FORM1
t4%=11              !  BUTTON in tree FORM1
t5%=12              !  BUTTON in tree FORM1
t6%=13              !  BUTTON in tree FORM1
t7%=14              !  BUTTON in tree FORM1
g0%=17              !  BUTTON in tree FORM1
g1%=18              !  BUTTON in tree FORM1
g2%=19              !  BUTTON in tree FORM1
g3%=20              !  BUTTON in tree FORM1
g4%=21              !  BUTTON in tree FORM1
g5%=22              !  BUTTON in tree FORM1
g6%=23              !  BUTTON in tree FORM1
g7%=24              !  BUTTON in tree FORM1
step%=26            !  BUTTON in tree FORM1
lesen%=27           !  BUTTON in tree FORM1
transfer%=28        !  BUTTON in tree FORM1
alles%=29           !  BUTTON in tree FORM1
sh205%=31           !  BUTTON in tree FORM1
vortex%=32          !  BUTTON in tree FORM1
scsi%=33            !  BUTTON in tree FORM1
help%=34            !  BUTTON in tree FORM1
start%=35           !  BOXTEXT in tree FORM1
exit%=36            !  BOXTEXT in tree FORM1
form3%=1            !  form/dialog
aktion%=2           !  BOXTEXT in tree FORM3
aktuell%=3          !  BOXTEXT in tree FORM3
form4%=2            !  form/dialog
d1%=4               !  FTEXT in tree FORM4
d2%=6               !  FTEXT in tree FORM4
d3%=8               !  FTEXT in tree FORM4
d4%=10              !  FTEXT in tree FORM4
endsec%=12          !  FTEXT in tree FORM4
d5%=14              !  FTEXT in tree FORM4
l1%=15              !  BOXTEXT in tree FORM4
l2%=16              !  BOXTEXT in tree FORM4
l3%=17              !  BOXTEXT in tree FORM4
l4%=18              !  BOXTEXT in tree FORM4
l5%=19              !  BOXTEXT in tree FORM4
l6%=20              !  BOXTEXT in tree FORM4
l7%=21              !  BOXTEXT in tree FORM4
l8%=22              !  BOXTEXT in tree FORM4
info%=23            !  BUTTON in tree FORM4
f4cancel%=24        !  BUTTON in tree FORM4
tree2%=3            !  form/dialog
text1%=2            !  BOXTEXT in tree TREE2
text2%=3            !  BOXTEXT in tree TREE2
text3%=4            !  BOXTEXT in tree TREE2
text4%=5            !  BOXTEXT in tree TREE2
text5%=6            !  BOXTEXT in tree TREE2
text6%=7            !  BOXTEXT in tree TREE2
text7%=8            !  BOXTEXT in tree TREE2
text8%=9            !  BOXTEXT in tree TREE2
text9%=10           !  BOXTEXT in tree TREE2
text10%=11          !  BOXTEXT in tree TREE2
text11%=12          !  BOXTEXT in tree TREE2
text12%=13          !  BOXTEXT in tree TREE2
text13%=14          !  BOXTEXT in tree TREE2
text14%=15          !  BOXTEXT in tree TREE2
text15%=16          !  BOXTEXT in tree TREE2
helpex%=18          !  BUTTON in tree TREE2
genug%=19           !  BUTTON in tree TREE2
interror%=4         !  form/dialog
interr1%=5          !  BOXTEXT in tree INTERROR
interr2%=6          !  BOXTEXT in tree INTERROR
djet%=5             !  form/dialog
djklar%=3           !  BUTTON in tree DJET
djnie%=4            !  BUTTON in tree DJET
djraus%=5           !  BUTTON in tree DJET
djet1%=6            !  BOXTEXT in tree DJET
djet2%=7            !  BOXTEXT in tree DJET
djet3%=8            !  BOXTEXT in tree DJET
djet4%=9            !  BOXTEXT in tree DJET
errinf%=6           !  form/dialog
erri1%=4            !  BOXTEXT in tree ERRINF
erri2%=5            !  BOXTEXT in tree ERRINF
chkerr%=7           !  form/dialog
chkerr1%=5          !  BOXTEXT in tree CHKERR
chkerr2%=6          !  BOXTEXT in tree CHKERR
chkerr3%=7          !  BOXTEXT in tree CHKERR
vendor%=0           !  Alert string index
keinscr%=1          !  Alert string index
tgtalert%=2         !  Alert string index
ausgabe%=3          !  Alert string index
noprn%=4            !  Alert string index
fexist%=5           !  Alert string index
nomem%=6            !  Alert string index
sh204alt%=7         !  Alert string index
hdplalt%=8          !  Alert string index
memfree%=9          !  Alert string index
keinrsc%=10         !  Alert string index
redrerr%=11         !  Alert string index
' ------------------------------------------
'
vs$="CHKHD83"
version$="CHECKHD V8.3"
cr$=CHR$(13)+CHR$(10)
'
acc!=FALSE
IF LPEEK(BASEPAGE+&H24)=0
  acc!=TRUE
ENDIF
land%=SHR(DPEEK(LPEEK(&H4F2)+28),1)
deutsch!=FALSE
IF land%=1 OR land%=8
  deutsch!=TRUE
ENDIF
IF deutsch!=FALSE
  v$=v$+"E"
ENDIF
rsc$=vs$+".RSC"
scr$=vs$+".SCR"+STRING$(128,0)
~SHEL_FIND(scr$)
'
IF @memory(rsc$)
  IF acc!                               ! Bin ich ein ACC?
    ap_id%=APPL_INIT()
    VOID MENU_REGISTER(ap_id%,"  CHECKHD V8.3")
  ENDIF
  REPEAT
    IF acc!
      VOID EVNT_MESAG(VARPTR(nachricht%(0)))
    ENDIF
    IF ((nachricht%(0)\65536)=40) OR (NOT acc!) OR ((nachricht%(0)\65536)=&H4711)
      menu
    ENDIF
  UNTIL NOT acc!
ELSE                            ! wenn bei Init etwas schiefgeht
  IF acc!
    DO
      VOID EVNT_MESAG(VARPTR(nachricht%(0)))
    LOOP
  ENDIF
ENDIF
exit
END
'
' ----------------------------------------------------------------------------
PROCEDURE menu
  LOCAL erg%,i%,baum%
  VOID RSRC_GADDR(0,form4%,baum%)
  CLR firstsec%,shrinkgrow%
  change_text(baum%,d1%,"0")  ! Zylinder
  change_text(baum%,d2%,"0")  ! Sektoren
  change_text(baum%,d3%,"0")  ! Kîpfe
  change_text(baum%,d4%,"0")  ! Startsektor
  change_text(baum%,endsec%,"0") ! Endsektor
  change_text(baum%,d5%,"0")  ! Bytes/Sektor
main:
  VOID GRAF_MOUSE(0,0)
  VOID WIND_UPDATE(1)                       ! Redraw sperren
  VOID RSRC_GADDR(0,form1%,baum%)
  hauptbaum%=baum%
  DO
    baum%=hauptbaum%
    init_target
    do_objc(baum%,g0%,&H1)
    undo_objc(baum%,g1%,&H1)
    '
    DO
      baum%=hauptbaum%
      ex_obj%=@simpledial(hauptbaum%,0)      ! Dialog ausfÅhren
      '
      a%=@is_objc(baum%,step%,1)         ! Buttons auslesen
      b%=@is_objc(baum%,lesen%,1)
      c%=@is_objc(baum%,transfer%,1)
      d%=@is_objc(baum%,alles%,1)
      a1%=@is_objc(baum%,sh205%,1)
      b1%=@is_objc(baum%,vortex%,1)
      c1%=@is_objc(baum%,scsi%,1)
      h1%=@is_objc(baum%,help%,1)
      '
      CLR geraet%
      geraet%=@is_objc(baum%,g1%,1)      ! Geraet feststellen
      IF geraet%<>0
        geraet%=1
      ENDIF
      '
      target%=-1
      FOR i%=0 TO 7
        t%=@is_objc(baum%,i%+t0%,1)      ! Target ?
        IF t%
          target%=i%
          i%=99
        ENDIF
      NEXT i%
      '
      '
      EXIT IF ex_obj%=exit% OR ex_obj%=titel2%   ! Raus ?
      '
      SELECT ex_obj%
      CASE icon%
        VOID @form_alert(1,vendor%)
        shrinkgrow%=1-shrinkgrow%
      CASE titel3%
        VOID @show_data(0)
      DEFAULT
        wastun%=a%+b%*2+c%*3+d%*4         ! Aktion ausrechnen
        hard%=a1%+b1%*2+c1%*3+h1%*4
        IF hard%<>4
          IF target%>=0
            ON wastun% GOSUB step_by_step,lies_schnell,transfer_test,alles
          ELSE
            erg%=@form_alert(1,tgtalert%)
          ENDIF
        ELSE
          hilfe
        ENDIF
      ENDSELECT
    LOOP
    EXIT IF ex_obj%=exit%
  LOOP
  VOID WIND_UPDATE(0)
RETURN
'
PROCEDURE init_target
  first%=TRUE
  FOR i%=t0% TO t7%
    undo_objc(baum%,i%,&H1)
  NEXT i%
  FOR target%=0 TO 7
    del_flag(baum%,target%+t0%,&H1)
    do_objc(baum%,target%+t0%,&H8) ! disable
    FOR geraet%=0 TO 1
      p$(target%,geraet%)=STRING$(24,0)
      mach_schon(0,0,0,0)
      IF (h_status% AND &H20000)=0 AND h_tim%=0
        mach_schon(8,0,1,0)
        IF (h_status% AND &H20000)=0 AND h_tim%=0 AND bytes%=512
          IF first%=TRUE
            do_objc(baum%,target%+t0%,&H1)
            CLR first%
          ENDIF
          set_flag(baum%,target%+t0%,&H1)
          undo_objc(baum%,target%+t0%,&H8)
          mach_schon(18,0,56,0)          ! Inquire
          IF (h_status% AND &H20000)=0 AND h_tim%=0
            BMOVE buf2%+8,VARPTR(p$(target%,geraet%)),24
          ENDIF
          IF (h_status% AND &H20000)
            IF deutsch!
              p$(target%,geraet%)="SASI-Typ"
            ELSE
              p$(target%,geraet%)="SASI type"
            ENDIF
          ENDIF
        ENDIF
      ENDIF
    NEXT geraet%
  NEXT target%
  CLR geraet%
RETURN
'
FUNCTION show_data(modus%)                     ! Data Display
  LOCAL zylinder%,koepfe%,sektoren%,bytespersec%,ssec%,esec%
  LOCAL zyl$,kopf$,sek$,bps$,ssec$,endsec$
  VOID RSRC_GADDR(0,form4%,baum%)
  '
  zylinder%=@ptadr(baum%,d1%,0)
  sektoren%=@ptadr(baum%,d2%,0)
  koepfe%=@ptadr(baum%,d3%,0)
  ssec%=@ptadr(baum%,d4%,0)
  esec%=@ptadr(baum%,endsec%,0)
  bytespersec%=@ptadr(baum%,d5%,0)
  '
  ex_obj%=@simpledial(baum%,d1%)
  '
  zylinder%=VAL(CHAR{zylinder%})
  sektoren%=VAL(CHAR{sektoren%})
  koepfe%=VAL(CHAR{koepfe%})
  ssec%=VAL(CHAR{ssec%})
  esec%=VAL(CHAR{esec%})
  bytespersec%=VAL(CHAR{bytespersec%})
  '
  IF ex_obj%=f4cancel%
    set_p
    RETURN -1          ! und raus
  ENDIF
  '
  IF zylinder%>0 AND zylinder%<32767
    cyl%=zylinder%
  ENDIF
  IF sektoren%>0 AND sektoren%<100
    spt%=sektoren%
  ENDIF
  IF koepfe%>0 AND koepfe%<100
    heads%=koepfe%
  ENDIF
  IF bytespersec%>0 AND bytespersec%<=32768 AND (bytespersec% MOD 256)=0
    bps%=bytespersec%
  ENDIF
  IF ssec%>=0 AND ssec%<9999999
    firstsec%=ssec%
  ENDIF
  IF esec%>0 AND esec%<9999999 AND esec%>ssec%
    blocks%=esec%
  ENDIF
  set_p
  '
  IF modus%=0
    erg%=@form_alert(3,ausgabe%)
    SELECT erg%
    CASE 1                   ! Drucker
      IF OUT?(0)=TRUE
        fopen("PRN:",1)
        IF fehler%>=0
          datenschreiben
          fclose(fhandle%)
        ENDIF
      ELSE
        dum%=@form_alert(1,noprn%)
      ENDIF
    CASE 2                   ! Disk
      FILESELECT "\*.*","checkhd.dat",fi$
      IF fi$<>"" AND RIGHT$(fi$,1)<>"\"
        dum%=1
        IF EXIST(fi$)
          dum%=@form_alert(1,fexist%)
        ENDIF
        SELECT dum%
        CASE 1
          fcreate(fi$,0)
          IF fehler%>=0
            datenschreiben
            fclose(fhandle%)
          ENDIF
        CASE 2
          fopen(fi$,2)
          IF fehler%>0
            fseek(0,fhandle%,2)
            IF fehler%>0
              datenschreiben
            ENDIF
            fclose(fhandle%)
          ENDIF
        ENDSELECT   ! select dum%
      ENDIF     ! if fi$<>""
    ENDSELECT   ! select erg%
  ENDIF
  RETURN 0
ENDFUNC
'
PROCEDURE datenschreiben
  LOCAL tosvs%
  tosvs%=DPEEK(LPEEK(&H4F2)+2)
  fwrite(fhandle%,version$+"  "+DATE$+"  "+TIME$+"  TOS "+STR$(tosvs% DIV 256)+"."+RIGHT$("0"+STR$(tosvs% AND 255),2))
  IF deutsch!
    fwrite(fhandle%,"Zylinder:         "+STR$(cyl%))
    fwrite(fhandle%,"Sektoren/Spur:    "+STR$(spt%))
    fwrite(fhandle%,"Kîpfe:            "+STR$(heads%))
    fwrite(fhandle%,"Startsektor:      "+STR$(firstsec%))
    fwrite(fhandle%,"Letzter Sektor:   "+STR$(blocks%))
    fwrite(fhandle%,"Bytes pro Sektor: "+STR$(bps%))
  ELSE
    fwrite(fhandle%,"Cylinders:        "+STR$(cyl%))
    fwrite(fhandle%,"Sectors/track:    "+STR$(spt%))
    fwrite(fhandle%,"Heads:            "+STR$(heads%))
    fwrite(fhandle%,"First sector:     "+STR$(firstsec%))
    fwrite(fhandle%,"Last Sector:      "+STR$(blocks%))
    fwrite(fhandle%,"Bytes per sector: "+STR$(bps%))
  ENDIF
  fwrite(fhandle%,"")
  fwrite(fhandle%,a1$)
  fwrite(fhandle%,a2$)
  fwrite(fhandle%,a3$)
  fwrite(fhandle%,a4$)
  fwrite(fhandle%,a5$)
  fwrite(fhandle%,a6$)
  fwrite(fhandle%,a7$)
  fwrite(fhandle%,a8$)
  fwrite(fhandle%,cr$)
RETURN
'
PROCEDURE set_p
  LOCAL a$
  VOID RSRC_GADDR(0,form4%,baum%)
  change_text(baum%,d1%,STR$(cyl%))
  change_text(baum%,d2%,STR$(spt%))
  change_text(baum%,d3%,STR$(heads%))
  change_text(baum%,d4%,STR$(firstsec%))
  change_text(baum%,endsec%,STR$(blocks%))
  change_text(baum%,d5%,STR$(bps%))
  SELECT hard%
  CASE 2
    a$=" (VORTEX)"
  CASE 3
    a$=" (SCSI)"
  DEFAULT
    a$=" (ATARI)"
  ENDSELECT
  a8$="T"+STR$(target%)+"G"+STR$(geraet%)+": "+p$(target%,geraet%)+" "+a$
  change_text(baum%,l8%,a8$)
RETURN
'
PROCEDURE clr_text
  VOID RSRC_GADDR(0,form4%,baum%)
  change_text(baum%,l1%,"")
  change_text(baum%,l2%,"")
  change_text(baum%,l3%,"")
  change_text(baum%,l4%,"")
  change_text(baum%,l5%,"")
  change_text(baum%,l6%,"")
  change_text(baum%,l7%,"")
RETURN
'
PROCEDURE aktion(txt$)
  VOID RSRC_GADDR(0,form3%,baum%)
  change_text(baum%,aktion%,txt$)
  change_text(baum%,aktuell%,"")
  box_draw(baum%,0,0,0,0)
RETURN
'
PROCEDURE step_by_step
  checkdev
  IF fehler%=0
    clr_text
    spurwechsel
    VOID @show_data(0)
  ELSE
    errinf2(fehler%)
  ENDIF
RETURN
'
PROCEDURE spurwechsel
  LOCAL oldsh!,erg%,pointer
  DEFFN runden(x)=INT((INT(x*100)/100)*10+0.5)/10
  REPEAT
    fehler%=MALLOC(254*bps%)
    IF fehler%=0
      VOID @form_alert(1,nomem%)
      box_undraw(baum%,0,0,0,0)
    ENDIF
    pointer=fehler%
    EXIT IF fehler%=0
    @readsec(target%,geraet%,2^21-1,1,pointer,FALSE)
    oldsh!=FALSE
    IF fehler%=0 AND hard%=1
      erg%=@form_alert(1,sh204alt%)
      IF erg%=2
        oldsh!=TRUE
      ENDIF
    ENDIF
    IF deutsch!
      aktion("SPURWECHSELTEST lÑuft...")
    ELSE
      aktion("Testing access times...")
    ENDIF
    max%=cyl%
    IF hard%=2 OR blocks%<>cyl%*heads%*spt%
      IF heads%<>0 AND spt%<>0
        max%=blocks%/heads%/spt%
      ELSE
        internesproblem("heads="+STR$(heads%),"spt="+STR$(spt%))
      ENDIF
      IF INSTR(p$(target%,geraet%),"QUANTUM P")
        max%=cyl%
      ENDIF
    ENDIF
    IF max%=0
      IF deutsch!
        internesproblem("Max. cyl="+STR$(max%),"Setze Wert auf 500.")
      ELSE
        internesproblem("Max. cyl="+STR$(max%),"Forcing value to 500.")
      ENDIF
      max%=500
    ENDIF
    n%=max%/3
    a1$=STRING$(40,32)
    IF deutsch!
      MID$(a1$,1)="Zyl. zu Zyl. ("+STR$(6*n%)+" Wechsel):"
    ELSE
      MID$(a1$,1)="Cyl. to cyl. ("+STR$(6*n%)+" seeks):"
    ENDIF
    rdusage(target%,geraet%)
    doseek(n%,oldsh!)
    t1=TIMER
    FOR i%=1 TO 3
      FOR j%=n% TO max%*2/3
        doseek(j%,oldsh!)
      NEXT j%
      FOR j%=max%*2/3 TO n%
        doseek(j%,oldsh!)
      NEXT j%
    NEXT i%
    wait
    t2=TIMER
    IF oldsh!
      liesblock(3*2*(max%*2/3-n%),pointer)
    ENDIF
    FOR i%=1 TO 3
      FOR j%=n% TO max%*2/3
        dummy2(j%,oldsh!)
      NEXT j%
      FOR j%=max%*2/3 TO n%
        dummy2(j%,oldsh!)
      NEXT j%
    NEXT i%
    t3=TIMER
    rate=((t2-t1-(t3-t2))*5)/(6*n%)
    MID$(a1$,30)=STR$(FN runden(rate))+" ms"
    change_text(baum%,aktuell%,a1$)
    objc_update(baum%,aktuell%)
    '
    IF @tastentest=0
      n%=max%/3
      a2$=STRING$(40,32)
      IF deutsch!
        MID$(a2$,1)="1000 zufÑllige Wechsel:"
      ELSE
        MID$(a2$,1)="1000 random seeks:"
      ENDIF
      rdusage(target%,geraet%)
      t1=TIMER
      FOR i%=1 TO 1000
        doseek(RND(1)*max%,oldsh!)
      NEXT i%
      wait
      t2=TIMER
      IF oldsh!
        liesblock(1000,pointer)
      ENDIF
      FOR i%=1 TO 1000
        dummy2(RND(1)*max%,oldsh!)
      NEXT i%
      t3=TIMER
      rate=(t2-t1-(t3-t2))*5/1000
      MID$(a2$,30)=STR$(FN runden(rate))+" ms"
      change_text(baum%,aktuell%,a2$)
      objc_update(baum%,aktuell%)
      IF @tastentest=0
        IF INSTR(p$(target%,geraet%),"SQ555")
          a3$=STRING$(40,32)
          IF deutsch!
            MID$(a3$,1)="1000 maximale Wechsel:"
          ELSE
            MID$(a3$,1)="1000 maximal seeks:"
          ENDIF
          rdusage(target%,geraet%)
          t1=TIMER
          doseek(max%/2-1,oldsh!)
          FOR i%=1 TO 500
            doseek(0,oldsh!)
            doseek(max%/2-1,oldsh!)
          NEXT i%
          wait
          t2=TIMER
          FOR i%=1 TO 500
            dummy2(0,oldsh!)
            dummy2(max%/2-1,oldsh!)
          NEXT i%
          t3=TIMER
        ELSE
          a3$=STRING$(40,32)
          IF deutsch!
            MID$(a3$,1)="1000 Wechsel/"+STR$(max%)+" Zyl.:"
          ELSE
            MID$(a3$,1)="1000 seeks/"+STR$(max%)+" cyl.:"
          ENDIF
          rdusage(target%,geraet%)
          doseek(max%-1,oldsh!)
          t1=TIMER
          FOR i%=1 TO 500
            doseek(0,oldsh!)
            doseek(max%-1,oldsh!)
          NEXT i%
          wait
          t2=TIMER
          IF oldsh!
            liesblock(2*500,pointer)
          ENDIF
          FOR i%=1 TO 500
            dummy2(0,oldsh!)
            dummy2(max%-1,oldsh!)
          NEXT i%
          t3=TIMER
        ENDIF
        rate=((t2-t1-(t3-t2))*5)/1000
        MID$(a3$,30)=STR$(FN runden(rate))+" ms"
        change_text(baum%,aktuell%,a3$)
        objc_update(baum%,aktuell%)
        IF @tastentest=0
          a4$=STRING$(40,32)
          IF deutsch!
            MID$(a4$,1)="1000 Wechsel/"+STR$(n%)+" Zyl.:"
          ELSE
            MID$(a4$,1)="1000 seeks/"+STR$(n%)+" cyl.:"
          ENDIF
          rdusage(target%,geraet%)
          doseek(n%,oldsh!)
          t1=TIMER
          FOR i%=1 TO 500
            doseek(n%*2,oldsh!)
            doseek(n%,oldsh!)
          NEXT i%
          wait
          t2=TIMER
          IF oldsh!
            liesblock(2*500,pointer)
          ENDIF
          FOR i%=1 TO 500
            dummy2(n%*2,oldsh!)
            dummy2(n%,oldsh!)
          NEXT i%
          t3=TIMER
          rate=(t2-t1-(t3-t2))*5/1000
          MID$(a4$,30)=STR$(FN runden(rate))+" ms"
          change_text(baum%,aktuell%,a4$)
          objc_update(baum%,aktuell%)
        ENDIF
      ENDIF
    ENDIF
    box_undraw(baum%,0,0,0,0)
    VOID RSRC_GADDR(0,form4%,baum%)
    change_text(baum%,l1%,a1$)
    change_text(baum%,l2%,a2$)
    change_text(baum%,l3%,a3$)
    change_text(baum%,l4%,a4$)
  UNTIL 1
  IF pointer
    mfree(pointer)
  ENDIF
RETURN
'
PROCEDURE liesblock(anzahl%,puffer)
  LOCAL i%
  FOR i%=0 TO anzahl% DIV 254
    @readsec(target%,geraet%,0,254,puffer,FALSE)
  NEXT i%
  anzahl%=anzahl%-anzahl% DIV 254
  IF anzahl%
    @readsec(target%,geraet%,0,anzahl%,puffer,FALSE)
  ENDIF
RETURN
'
PROCEDURE calcsecs
  maxsecs%=spt%*heads%
  IF INSTR(p$(target%,geraet%),"QUANTUM P")
    maxsecs%=35*heads%-(heads%/3)
  ENDIF
  IF INSTR(p$(target%,geraet%),"SQ555")
    maxsecs%=spt%
  ENDIF
  IF INSTR(p$(target%,geraet%),"SEAGATE")
    DEC maxsecs%
  ENDIF
  IF maxsecs%>254
    maxsecs%=254
  ENDIF
RETURN
'
PROCEDURE ecc_on(eccold%)
  LOCAL erg%
  SELECT hard%
  CASE 1
    LPOKE buf2%,&H65000000
    mach_schon(&H1D,0,4,0)
  CASE 3
    ' SCSI-Platten
    mach_schon(&H1A,1*256,100,0)
    IF (h_status% AND &H20000)=0 AND h_tim%=0
      ' Fehlerseite per MODE SENSE einlesen
      POKE buf2%+14,eccold%
      ' alten Wert einsetzen
      POKE buf2%,0
      POKE buf2%+12,PEEK(buf2%+12) AND &H7F
      mach_schon(&H15,0,12+PEEK(buf2%+13),0)
      ' Fehlerseite per MODE SELECT abschicken
    ENDIF
  ENDSELECT
RETURN
'
FUNCTION ecc_off
  LOCAL erg%,eccold%
  eccold%=0
  SELECT hard%
  CASE 1
    ' ATARI-PLatten
    LPOKE buf2%,&H65000200
    mach_schon(&H1D,0,4,0)     ! Fehlerkorrektur ausschalten
  CASE 3
    ' SCSI-Platten
    mach_schon(&H1A,1*256,100,0)
    IF (h_status% AND &H20000)=0 AND h_tim%=0
      ' Fehlerseite per MODE SENSE einlesen
      eccold%=PEEK(buf2%+14)
      POKE buf2%+14,(eccold% AND &HF0) OR 5
      ' EER=0, PER=1, DTE=0, DCR=1
      ' alten Wert merken, Fehlerbits umdrehen
      POKE buf2%,0
      POKE buf2%+12,PEEK(buf2%+12) AND &H7F
      mach_schon(&H15,0,12+PEEK(buf2%+13),0)
      ' Fehlerseite per MODE SELECT abschicken
    ENDIF
  ENDSELECT
  RETURN eccold%
ENDFUNC
'
PROCEDURE lies_schnell
  LOCAL eccold%
  checkdev
  IF fehler%=0
    clr_text
    eccold%=@ecc_off
    lesetest
    ecc_on(eccold%)
    VOID @show_data(0)
  ELSE
    errinf2(fehler%)
  ENDIF
RETURN
'
PROCEDURE lesetest
  LOCAL zeit%,t%,anzahl%
  CLR zeit%
  REPEAT
    IF deutsch!
      aktion("LESETEST lÑuft")
    ELSE
      aktion("Reading sectors...")
    ENDIF
    '
    rdusage(target%,geraet%)
    calcsecs
    fehler%=MALLOC(maxsecs%*bps%)
    IF fehler%=0
      VOID @form_alert(1,nomem%)
      box_undraw(baum%,0,0,0,0)
    ENDIF
    EXIT IF fehler%=0
    pointer=fehler%
    '
    IF wastun%=4
      bis%=2000
    ELSE
      bis%=blocks%-1
    ENDIF
    FOR t%=firstsec% TO bis% STEP maxsecs%
      IF deutsch!
        a$="PrÅfe Block ab Sektor "+STR$(t%)
      ELSE
        a$="Checking block starting at "+STR$(t%)
      ENDIF
      t1=TIMER
      anzahl%=MIN(maxsecs%,bis%-t%)
      IF hard%=2
        @readsec(target%,geraet%,t%,anzahl%,pointer,FALSE)
      ELSE
        @readsec(target%,geraet%,t%,anzahl%,pointer,TRUE)
      ENDIF
      t2=TIMER
      ADD zeit%,t2-t1
      rate%=(t%-firstsec%+anzahl%)*100/zeit%
      erg%=0
      IF wastun%=2
        IF fehler%
          erg%=@errinf(t%)
        ENDIF
      ENDIF
      IF erg%=1
        t%=blocks%
      ENDIF
      a$=a$+" ("+STR$(INT(rate%*100)/100)+" KB/s)"
      change_text(baum%,aktuell%,a$)
      objc_update(baum%,aktuell%)
      IF @tastentest=1
        t%=blocks%
      ENDIF
    NEXT t%
    box_undraw(baum%,0,0,0,0)
    IF deutsch!
      a6$="Lesetest: "
    ELSE
      a6$="Read test:"
    ENDIF
    a6$=a6$+"                   "+STR$(INT(rate%*100)/100)+" KB/s"
    VOID RSRC_GADDR(0,form4%,baum%)
    change_text(baum%,l6%,a6$)
  UNTIL 1
  IF pointer
    mfree(pointer)
  ENDIF
RETURN
'
PROCEDURE transfer_test
  checkdev
  IF fehler%=0
    clr_text
    transfer
    VOID @show_data(0)
  ELSE
    errinf2(fehler%)
  ENDIF
RETURN
'
PROCEDURE transfer
  LOCAL t%
  REPEAT
    IF deutsch!
      aktion("TRANSFERTEST lÑuft...")
    ELSE
      aktion("Testing transfer rates...")
    ENDIF
    '
    rdusage(target%,geraet%)
    calcsecs
    fehler%=MALLOC(maxsecs%*bps%)
    IF fehler%=0
      VOID @form_alert(1,nomem%)
      box_undraw(baum%,0,0,0,0)
    ENDIF
    EXIT IF fehler%=0
    pointer=fehler%
    loops=20
    IF INSTR(p$(target%,geraet%),"SQ555")
      loops=80
    ENDIF
    @readsec(target%,geraet%,startsec%,maxsecs%,pointer,FALSE)
    wait
    t1=TIMER
    FOR t%=1 TO loops
      @readsec(target%,geraet%,startsec%,maxsecs%,pointer,FALSE)
    NEXT t%
    wait
    t2=TIMER
    '
    t=(t2-t1)/200
    a$=STR$(INT(t*100)/100)
    IF deutsch!
      a$=a$+" Sekunden fÅr "
    ELSE
      a$=a$+" seconds for "
    ENDIF
    a$=a$+STR$(loops*maxsecs%*bps%/1024)+" KB"
    kbrate=loops*maxsecs%*bps%/(1024*t)
    change_text(baum%,aktuell%,a$)
    objc_update(baum%,aktuell%)
    '
    SUB maxsecs%,spt% DIV 2
    @readsec(target%,geraet%,startsec%,maxsecs%,pointer,FALSE)
    wait
    t1=TIMER
    FOR t%=1 TO loops
      @readsec(target%,geraet%,startsec%,maxsecs%,pointer,FALSE)
    NEXT t%
    wait
    t2=TIMER
    t=(t2-t1)/200
    a$=STR$(INT(t*100)/100)
    IF deutsch!
      a$=a$+" Sekunden fÅr "
    ELSE
      a$=a$+" seconds for "
    ENDIF
    a$=a$+STR$(loops*(maxsecs%+spt% DIV 2)*bps%/1024)+" KB"
    kbrate2=loops*(maxsecs%+spt% DIV 2)*bps%/(1024*t)
    change_text(baum%,aktuell%,a$)
    objc_update(baum%,aktuell%)
    mfree(pointer)
    VOID EVNT_TIMER(500)
    box_undraw(baum%,0,0,0,0)
    '
    a7$="Transfer I: "
    a7$=a7$+STR$(INT(kbrate*10)/10)
    a7$=a7$+" KB/s, II: "+STR$(INT(kbrate2*10)/10)+" KB/s"
    VOID RSRC_GADDR(0,form4%,baum%)
    change_text(baum%,l7%,a7$)
  UNTIL 1
RETURN
'
PROCEDURE alles
  checkdev
  IF fehler%=0
    spurwechsel
    lesetest
    transfer
    VOID @show_data(0)
  ELSE
    errinf2(fehler%)
  ENDIF
RETURN
' ----------------------------------------------------------------------------
' Sieht nach, ob Target%, Geraet% am ACSI-Bus finden ist
' OUT: Fehler% =0: kein Fehler; Blocks%,Spt%,Cyl%,Heads% sind dann gÅltig
'              =-2: Abbruch durch User, =-1: Timeout, =2: Sonstiger Fehler
'              =3: kein DMA-Transfer (SH204!)
PROCEDURE checkdev
  LOCAL erg%
  CLR fehler%,firstsec%,startsec%,voffset%    ! Defaultwerte
  @readsec(target%,geraet%,0,1,buf%,FALSE)    ! Sektor 0 lesen
  IF LPEEK(hdc%+24)=-1 OR (DPEEK(hdc%+20) AND 2) OR (LPEEK(hdc%+28)-buf%<256)
    fehler%=-1
    IF DPEEK(hdc%+20) AND 2
      fehler%=-2
    ENDIF
    IF LPEEK(hdc%+28)-buf%<256
      fehler%=3
    ENDIF
  ELSE
    IF hard%=2
      vortextest
      @readsec(target%,geraet%,0,1,buf%,FALSE)
    ENDIF
    '
    IF hard%=3
      erg%=@form_alert(1,hdplalt%)
      IF erg%=2
        fehler%=-2                     ! Anwender unterbricht
      ELSE
        mach_schon(&H1A,3*256,50,0)   ! MODE SENSE
        IF h_tim%=-1                   ! Timeout?
          fehler%=-1
        ELSE
          IF DPEEK(hdc%+20) AND 2      ! DMA-Fehler?
            fehler%=2
          ELSE
            blocks%=PEEK(buf2%+5)*65536+DPEEK(buf2%+6)
            IF blocks%=0
              blocks%=@pruefe_rtsek
            ENDIF
            bps%=PEEK(buf2%+9)*65535+DPEEK(buf2%+10)
            spt%=DPEEK(buf2%+22)       ! MODE-Daten auswerten
            IF bps%<>DPEEK(buf2%+24)
              IF bps%<>0 AND DPEEK(buf2%+24)<>0
                spt%=spt%/(bps%/DPEEK(buf2%+24))
              ELSE
                internesproblem("bps="+STR$(bps%),"via MDSENSE="+STR$(DPEEK(buf2%+24)))
              ENDIF
            ENDIF
            mach_schon(&H1A,4*256,50,0) ! nochmal MODE SENSE
            IF h_tim%=-1               ! Timeout?
              fehler%=-1
            ELSE
              IF DPEEK(hdc%+20) AND 2  ! DMA-Fehler?
                fehler%=2
              ELSE
                cyl%=DPEEK(buf2%+14)*256+PEEK(buf2%+16)
                heads%=PEEK(buf2%+17)  ! MODE-Daten auswerten
                IF spt%=0
                  IF cyl%<>0 AND heads%<>0
                    spt%=blocks%/cyl%/heads%
                  ELSE
                    internesproblem("cyls="+STR$(cyl%),"heads="+STR$(heads%))
                  ENDIF              ! cyl%<>0 and heads%<>0
                ENDIF                ! spt%=0
                set_p
              ENDIF                  ! Dpeek(hdc%+20) and 2
            ENDIF                    ! h_tim%=-1
          ENDIF                      ! Dpeek(hdc%+20) and 2
        ENDIF                        ! h_tim%=-1
      ENDIF                          ! erg%=2
    ELSE
      IF hard%=1
        erg%=@form_alert(1,hdplalt%)
        IF erg%=2
          fehler%=-2
        ELSE
          mach_schon(&H1A,0,24,0)
          IF h_tim%=-1
            fehler%=-1
          ELSE
            IF DPEEK(hdc%+20) AND 2
              fehler%=2
            ELSE
              get_param
            ENDIF                    ! Dpeek(hdc%+20) and 2
          ENDIF                      ! if h_tim%=-1
        ENDIF                        ! if erg%=2
      ELSE
        param2
      ENDIF                          ! if hard%=1
    ENDIF                            ! if hard%=3
  ENDIF                              ! if lpeek(hdc%+28)-buf%<256 or ... or
  IF fehler%=0
    spcyl%=spt%*heads%
    IF LEFT$(p$(target%,geraet%),7)="SEAGATE"
      DEC spcyl%
    ENDIF
    IF voffset% MOD spcyl%
      startsec%=spcyl%-(voffset% MOD spcyl%)
    ENDIF
    IF @show_data(1)=-1
      fehler%=-2
    ENDIF
  ENDIF
RETURN
'
PROCEDURE internesproblem(a$,b$)
  LOCAL ex_obj%,baum%
  VOID RSRC_GADDR(0,interr%,baum%)
  change_text(baum%,interr1%,a$)
  change_text(baum%,interr2%,b$)
  VOID @simpledial(baum%,0)
RETURN
'
FUNCTION pruefe_rtsek
  LOCAL blocks%,i%,sum%
  CLR blocks%
  mach_schon(8,0,1,0)          ! Rootsektor lesen
  IF (h_status% AND &H20000)=0 AND h_tim%=0 AND bytes%=512
    CLR sum%
    FOR i%=0 TO 511 STEP 2
      ADD sum%,DPEEK(i%+buf%)
    NEXT i%
    sum%=sum% AND &HFFFF
    IF (sum%=&H1234) AND (LPEEK(buf%+&H1C2)>0)
      blocks%=LPEEK(buf%+&H1C2)
    ENDIF
  ENDIF
  RETURN blocks%
ENDFUNC
'
PROCEDURE vortextest
  LOCAL og%,o$,a$,k$,hdplus%,baum%
  og%=geraet%
  geraet%=7
  hdplus%=1
  @readsec(target%,geraet%,&H1F0000,1,buf%,FALSE)
  CLR o$
  IF fehler%=0
    voffset%=PEEK(buf%+1)*256+PEEK(buf%)
    FOR i%=2 TO 14
      o$=o$+CHR$(PEEK(buf%+i%))
    NEXT i%
    k$=CHR$(PEEK(buf%+39))+CHR$(PEEK(buf%+40))+CHR$(PEEK(buf%+41))
    mach_schon(0,&HAA*256,0,0)
    IF h_tim%=-1
      fehler%=-1
    ENDIF
    IF DPEEK(hdc%+20) AND 2
      fehler%=2
    ENDIF
    IF fehler%=0
      IF (DPEEK(hdc%+20) AND 16)!=0 AND LEFT$(o$,1)="D"  ! Kennzeichen fÅr DataJet
        CLR hdplus%
      ENDIF
    ENDIF
    VOID RSRC_GADDR(0,djet%,baum%)
    IF hdplus%=1
      a$="HDplus"
    ENDIF
    IF hdplus%=0
      a$="DataJet"
    ENDIF
    change_text(baum%,djet2%,a$+" "+k$)
    change_text(baum%,djet3%,"BIOS"+LEFT$(o$,14-4*hdplus%)+".")
    erg%=@simpledial(baum%,0)-djklar%+1
    IF erg%=3 OR erg%=2
      fehler%=-2
    ENDIF
    geraet%=og%
    IF erg%=1
      IF hdplus%=0
        hard%=3
      ENDIF
      IF hdplus%=1
        p$(target%,geraet%)="HDplus "+k$
      ENDIF
    ENDIF
  ENDIF
RETURN
'
PROCEDURE get_param
  cyl%=PEEK(buf2%+13)*256+PEEK(buf2%+14)
  heads%=PEEK(buf2%+15)
  spt%=PEEK(buf2%+23)
  blocks%=heads%*cyl%*spt%
  bps%=PEEK(buf2%+9)*65536+PEEK(buf2%+10)*256+PEEK(buf2%+11)
  set_p
RETURN
'
PROCEDURE param2
  cyl%=DPEEK(buf%+&H1B6)       ! Zylinder
  heads%=PEEK(buf%+&H1B8)      ! Kîpfe
  spt%=PEEK(buf%+&H1C1)        ! Sektoren pro Track
  blocks%=LPEEK(buf%+&H1C2)    ! Anzahl der Blîcke
  bps%=512
  set_p
RETURN
'
PROCEDURE wait
  LOCAL i%
  DPOKE com_blk%,(target%*256+geraet%)*32
  LPOKE com_blk%+2,0
  i%=hdc%+20
  REPEAT
    CALL hdc%
  UNTIL DPEEK(i%)=0
RETURN
'
PROCEDURE doseek(zylinder%,oldsh!)
  LOCAL sector%,i%
  sector%=spcyl%*zylinder%+startsec%
  IF oldsh!
    POKE com_blk%,8+target%*32
    POKE com_blk%+1,(sector% DIV 65536)+geraet%*32
    DPOKE com_blk%+2,sector% AND 65535
    DPOKE com_blk%+4,256
    CALL hdc%
  ELSE
    POKE com_blk%,11+target%*32
    POKE com_blk%+1,(sector% DIV 65536)+geraet%*32
    DPOKE com_blk%+2,sector% AND 65535
    DPOKE com_blk%+4,0
    i%=hdc%+20
    REPEAT
      CALL hdc%
    UNTIL DPEEK(i%)<>8
  ENDIF
RETURN
'
PROCEDURE dummy2(zylinder%,oldsh!)
  LOCAL sector%,i%
  sector%=startsec%
  IF oldsh!=FALSE
    LPOKE com_blk%+2,0
    i%=hdc%+20
    sector%=startsec%
    POKE com_blk%,11+target%*32     ! Seek
    POKE com_blk%+1,(sector% DIV 65536)+geraet%*32
    DPOKE com_blk%+2,sector% AND 65535
  ENDIF
RETURN
'
PROCEDURE readsec(target%,geraet%,sector%,cnt%,buf%,pruef!)
  POKE com_blk%,8+target%*32
  POKE com_blk%+1,sector% DIV 65536+geraet%*32
  DPOKE com_blk%+2,sector% AND 65535
  DPOKE com_blk%+4,cnt%*256
  LPOKE hdc%+2,buf%
  LPOKE hdc%+6,buf3%
  LPOKE buf3%,512
  LPOKE hdc%+10,0
  CALL hdc%
  '
  CLR fehler%
  IF pruef!
    IF hard%=1 OR hard%=3
      LPOKE hdc%+6,buf2%
      POKE com_blk%,3+target%*32
      POKE com_blk%+1,geraet%*32
      LPOKE com_blk%+2,0
      LPOKE hdc%+10,0
      IF hard%=3
        POKE com_blk%+4,50
      ELSE
        POKE com_blk%+4,4
      ENDIF
      CALL hdc%
      fehler%=PEEK(buf2%)
      valid%=fehler% AND &H80
      IF hard%=3
        fehler%=PEEK(buf2%+12)
      ENDIF
      IF LPEEK(hdc%+24)
        fehler%=-1
        valid%=0
      ENDIF
    ELSE
      IF hard%=2
        IF LPEEK(hdc%+20) AND &H20000
          fehler%=1
        ENDIF
        IF LPEEK(hdc%+24)
          fehler%=-1
        ENDIF
        valid%=0
      ENDIF
    ENDIF
  ELSE
    IF LPEEK(hdc%+20) AND &H20000
      fehler%=-1
    ENDIF
  ENDIF
RETURN
'
PROCEDURE rdusage(target%,geraet%)
  IF hard%=1 OR hard%=3
    LPOKE hdc%+6,buf2%
    LPOKE hdc%+2,buf%
    LPOKE hdc%+10,0
    POKE com_blk%,&H11+target%*32
    POKE com_blk%+1,geraet%*32
    LPOKE com_blk%+2,0
    CALL hdc%
  ENDIF
RETURN
'
PROCEDURE mach_schon(op%,block%,c%,s%)
  LOCAL h1%,h2%,h3%
  h1%=(block% AND &H1F0000)/65536
  h2%=(block% AND &HFF00)/256
  h3%=(block% AND &HFF)
  LPOKE hdc%+2,buf%                     ! Zeiger auf Puffer
  LPOKE hdc%+6,buf2%                    ! Statuspuffer
  LPOKE hdc%+10,0                       ! Extended Mode
  IF op%=18
    LPOKE hdc%+10,1
  ENDIF
  IF op%=8 OR op%=10
    LPOKE buf2%,512
  ENDIF
  POKE com_blk%,target%*32+op%          ! Target + Opcode
  POKE com_blk%+1,geraet%*32+h1%        ! GerÑt  + Blocknummer Hi
  POKE com_blk%+2,h2%                   ! Blocknummer mid
  POKE com_blk%+3,h3%                   ! Block       low
  POKE com_blk%+4,c%                    ! Sektoranzahl
  POKE com_blk%+5,s%                    ! Kontrollbyte
  CALL hdc%
  h_status%=LPEEK(hdc%+20)              ! Status holen
  h_tim%=LPEEK(hdc%+24)                 ! Timeout?
  bytes%=LPEEK(hdc%+28)-LPEEK(hdc%+2)
RETURN
' ------------------------------
FUNCTION tastentest
  IF INKEY$=CHR$(27) OR MOUSEK=2
    RETURN 1
  ENDIF
  RETURN 0
ENDFUNC
'
' errinf
' OUT: 0  OK-Button
'      -1 Abbruch-Button
FUNCTION errinf(sec%)
  LOCAL t%,ex_obj%,block%
  fehler%=fehler% AND &H7F
  fehler$(&H7F)="Timeout!"
  SELECT hard%
  CASE 3
    block%=PEEK(buf2%+3)*65536+DPEEK(buf2%+4)
    block%=block%*256+PEEK(buf2%+5)
  CASE 1
    block%=PEEK(buf2%+1) AND 31
    block%=block%*65536+DPEEK(buf2%+2)
  CASE 2
    block%=0
  ENDSELECT
  a$=fehler$(fehler%)
  IF deutsch!
    b$="Fehlernummer "
  ELSE
    b$="Error "
  ENDIF
  b$=b$+STR$(fehler%)+" ($"+HEX$(fehler%)+")"
  c$="Block "+STR$(sec%)
  IF deutsch!
    c$=c$+", Sektor "
  ELSE
    c$=c$+", sector "
  ENDIF
  c$=c$+STR$(block%)+", "
  IF valid%=0
    IF deutsch!
      c$=c$+"un"
    ELSE
      c$=c$+"in"
    ENDIF
  ENDIF
  IF deutsch!
    c$=c$+"gÅltig"
  ELSE
    c$=c$+"valid"
  ENDIF
  IF deutsch!
    d$="Fehlerinfo: "
  ELSE
    d$="Error info: "
  ENDIF
  FOR t%=0 TO 3
    d$=d$+RIGHT$("0"+HEX$(PEEK(buf2%+t%)),2)+"  "
  NEXT t%
  '
  box_undraw(baum%,0,0,0,0)
  VOID RSRC_GADDR(0,form4%,baum%)
  change_text(baum%,l1%,a$)
  change_text(baum%,l2%,b$)
  change_text(baum%,l3%,c$)
  change_text(baum%,l4%,d$)
  ex_obj%=@simpledial(baum%,d1%)
  IF deutsch!
    aktion("LESETEST lÑuft...")
  ELSE
    aktion("Testing sectors...")
  ENDIF
  IF ex_obj%=f4cancel%
    RETURN 1
  ENDIF
  RETURN 0
ENDFUNC
'
PROCEDURE errinf2(error%)
  LOCAL a$,b$,baum%
  b$=""
  SELECT error%
  CASE -2
    IF deutsch!
      a$="Wer nicht will,"
      b$="hat schon gehabt."
    ELSE
      a$="Everything's got to end"
      b$="some time."
    ENDIF
  CASE -1
    a$="Timeout,"
    IF deutsch!
      b$="Platte antwortet nicht"
    ELSE
      b$="Drive doesn't respond."
    ENDIF
  CASE 2
    IF deutsch!
      a$="Fehler beim Zugriff"
    ELSE
      a$="Error while accessing drive"
    ENDIF
  CASE 3
    IF deutsch!
      a$="öbertragung klappt nicht"
    ELSE
      a$="DMA transfer error"
    ENDIF
  DEFAULT
    a$=STR$(error%)
  ENDSELECT
  VOID RSRC_GADDR(0,errinf%,baum%)
  change_text(baum%,erri1%,a$)
  change_text(baum%,erri2%,b$)
  VOID @simpledial(baum%,0)
RETURN
'
FUNCTION neueseite
  LOCAL ex_obj%
  VOID RSRC_GADDR(0,tree2%,baum%)
  WHILE cn%<text15%+1
    change_text(baum%,cn%," "+CHR$(0))
    objc_update(baum%,cn%)
    INC cn%
  WEND
  cn%=text1%
  ex_obj%=@meinform_do(baum%,0)
  undo_objc(baum%,ex_obj%,1)
  objc_update(baum%,ex_obj%)
  RETURN ex_obj%
ENDFUNC
'
PROCEDURE set_rsc(tree%)
  LOCAL obj%,type%
  LOCAL dummy%,hbox%,wbox%
  LOCAL ib%
  '
  ~GRAF_HANDLE(dummy%,dummy%,wbox%,hbox%)
  obj%=0
  WHILE obj%>=0
    type%=OB_TYPE(tree%,obj%)
    IF (type% DIV 256)=20         ! BOXTITEL
      OB_Y(tree%,obj%)=OB_Y(tree%,obj%)-hbox%/2
    ENDIF
    IF (type% DIV 256)=21         ! ZENTRIERT
      OB_Y(tree%,obj%)=OB_Y(tree%,obj%)-hbox%/2
      OB_X(tree%,obj%)=OB_X(tree%,obj%)+wbox%/4
    ENDIF
    IF type%=31          ! G_ICON
      ib%=OB_SPEC(tree%,obj%)    ! Zeiger auf ICONBLK-Struktur
      OB_H(tree%,obj%)=DPEEK(ib%+28)+DPEEK(ib%+30)
      ' Objekthîhe = Y-Position der Beschriftung +
      ' Hîhe der Beschriftung
      trans_gimage(tree%,obj%)
    ENDIF
    IF type%=23        ! G_IMAGE
      ib%=OB_SPEC(tree%,obj%)    ! Zeiger auf BITBLK-Struktur
      OB_H(tree%,obj%)=DPEEK(ib%+6)
      ' Objekthîhe = Hîhe des Icons in Pixelzeilen
      trans_gimage(tree%,obj%)
    ENDIF
    IF OB_FLAGS(tree%,obj%) AND 32       ! LASTOB
      obj%=-1
    ELSE
      INC obj%
    ENDIF
  WEND
RETURN
'
PROCEDURE trans_gimage(tree%,obj%)
  LOCAL type%,wb%,hl%
  LOCAL ib%,taddr%
  '
  type%=OB_TYPE(tree%,obj%)
  IF type%=31       ! G_ICON
    ib%=OB_SPEC(tree%,obj%)
    taddr%=LPEEK(ib%)
    wb%=DPEEK(ib%+22) DIV 8   ! Breite ib_wicon
    hl%=DPEEK(ib%+24)         ! Hîhe ib_hicon
    vdi_trans(taddr%,wb%,taddr%,wb%,hl%)
    taddr%=LPEEK(ib%+4)
  ENDIF
  IF type%=23      ! G_IMAGE
    ib%=OB_SPEC(tree%,obj%)
    taddr%=LPEEK(ib%)
    wb%=DPEEK(ib%+4)
    hl%=DPEEK(ib%+6)
  ENDIF
  vdi_trans(taddr%,wb%,taddr%,wb%,hl%)
RETURN
'
PROCEDURE vdi_trans(saddr%,swb%,daddr%,dwb%,h%)
  LOCAL src$,dst$
  src$=STRING$(50,0)
  dst$=STRING$(50,0)   ! Platz fÅr MFDBs
  vdi_fix(VARPTR(src$),saddr%,swb%,h%)
  DPOKE VARPTR(src$)+10,1   ! Standardformat
  vdi_fix(VARPTR(dst$),daddr%,dwb%,h%)
  DPOKE VARPTR(src$)+10,0    ! GerÑteabhÑngiges Format
  vr_trnfm(V~H,VARPTR(src$),VARPTR(dst$))
RETURN
'
PROCEDURE vdi_fix(pfd%,theaddr%,wb%,h%)
  LPOKE pfd%,theaddr%
  DPOKE pfd%+4,wb%*8
  DPOKE pfd%+6,h%
  DPOKE pfd%+8,wb%/2
  DPOKE pfd%+12,1
RETURN
'
PROCEDURE vr_trnfm(handle%,src%,dst%)
  DPOKE CONTRL,110
  LPOKE CONTRL+2,0
  LPOKE CONTRL+6,0
  DPOKE CONTRL+12,handle%
  LPOKE CONTRL+14,src%
  LPOKE CONTRL+18,dst%
  VDISYS
RETURN
'
FUNCTION meinform_do(tree%,objc%)
  LOCAL edit_obj%,next_obj%
  LOCAL which&,idx&,cont&,i%,dummy%,mb%
  LOCAL mx&,my&,mb&,ks&,key&,clicks&
  '
  ~WIND_UPDATE(3)
  '
  next_obj%=@fm_inifld(tree%,objc%)
  CLR edit_obj%
  cont&=1
  '
  WHILE cont&
    IF (next_obj%<>0) AND (edit_obj%<>next_obj%)
      edit_obj%=next_obj%
      CLR next_obj%
      ~OBJC_EDIT(tree%,edit_obj%,0,idx&,1,idx&) ! EDINIT
    ENDIF
    '
    which&=EVNT_MULTI(&X11,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,mx&,my&,mb&,ks&,key&,clicks&)
    IF (which& AND 1)
      cont&=@form_keybd(tree%,edit_obj%,next_obj%,key&)
      next_obj%=nextone&
      key&=nextkey&
      IF key&
        ~OBJC_EDIT(tree%,edit_obj%,key&,idx&,2,idx&)    ! EDCHAR
      ENDIF
      IF (next_obj%<>0) AND ((next_obj%<>edit_obj%) OR (cont&=0))
        ~OBJC_EDIT(tree%,edit_obj%,0,idx&,3,idx&)       ! EDEND
      ENDIF
    ENDIF
    IF (which& AND 2)
      next_obj%=OBJC_FIND(tree%,0,8,mx&,my&)
      IF next_obj%=-1
        FOR i%=1 TO 10
          SOUND 1,15,RND(1)*1000
          WAVE 1,1,1,15535,0
          SOUND 1,15,RND(1)*1000
          WAVE 1,1,1,15535,0
        NEXT i%
        CLR next_obj%
      ELSE
        IF next_obj%=0
          IF mem%(0)>0
            ~OBJC_EDIT(tree%,edit_obj%,0,idx&,1,idx&)
            IF ((mb& AND 2)=2) OR (ks& AND 8)
              hole_dialog(tree%)
            ENDIF
            ~GRAF_DRAGBOX(OB_W(tree%,0),OB_H(tree%,0),OB_X(tree%,0),OB_Y(tree%,0),dx%+3,dy%+3,dw%+OB_W(tree%,0)-16,dh%+OB_H(tree%,0)-16,neu_x%,neu_y%)
            hole_dialog(tree%)
            OB_X(tree%,0)=neu_x%
            OB_Y(tree%,0)=neu_y%
            rette_dialog(tree%)
            ~OBJC_DRAW(tree%,0,8,dx%,dy%,dw%,dh%)
            ~OBJC_EDIT(tree%,edit_obj%,0,idx&,3,idx&)
          ENDIF
          next_obj%=edit_obj%
        ELSE
          cont&=FORM_BUTTON(tree%,next_obj%,clicks&,next_obj%)
          IF (next_obj%<>0) AND ((next_obj%<>edit_obj%) OR (cont&=0))
            ~OBJC_EDIT(tree%,edit_obj%,0,idx&,3,idx&)           ! EDEND
          ENDIF
        ENDIF
      ENDIF
    ENDIF
  WEND
  '
  ~WIND_UPDATE(2)
  RETURN next_obj%
ENDFUNC
FUNCTION form_keybd(tree%,edit_obj&,next_obj&,key%)
  LPOKE ADDRIN,tree%
  DPOKE GCONTRL,55
  DPOKE GCONTRL+2,3
  DPOKE GCONTRL+4,3
  DPOKE GCONTRL+6,1
  DPOKE GCONTRL+8,0
  '
  DPOKE GINTIN,edit_obj&
  DPOKE GINTIN+2,key&
  DPOKE GINTIN+4,next_obj&
  GEMSYS 55
  nextone&=DPEEK(GINTOUT+2)
  nextkey&=DPEEK(GINTOUT+4)
  RETURN DPEEK(GINTOUT)
ENDFUNC
FUNCTION find_obj(tree%,objc%,which&)
  LOCAL obj%
  LOCAL flag&,theflag&,inc&
  '
  CLR obj%
  flag&=8       ! EDITABLE
  inc&=1
  SELECT which&
  CASE -1
    inc&=-1
    obj%=objc%+inc&
  CASE 1
    obj%=objc%+inc&
  CASE 0
    flag&=2     ! DEFAULT
  ENDSELECT
  '
  WHILE obj%>=0
    theflag&=OB_FLAGS(tree%,obj%)
    IF theflag& AND flag&
      RETURN obj%
    ENDIF
    IF theflag& AND &H20        ! LASTOB
      obj%=-1
    ELSE
      obj%=obj%+inc&
    ENDIF
  WEND
  RETURN objc%
ENDFUNC
FUNCTION fm_inifld(tree%,objc%)
  IF objc%=0
    objc%=@find_obj(tree%,0,1)  ! FMD_FORWARD
  ENDIF
  RETURN objc%
ENDFUNC
PROCEDURE rette_dialog(baum%)
  LOCAL x%,y%,w%,h%
  IF mem%(0)>0
    x%=OB_X(baum%,0)-3
    y%=OB_Y(baum%,0)-3
    w%=OB_W(baum%,0)+6
    h%=OB_H(baum%,0)+6
    par%(0)=x%
    par%(1)=y%
    par%(2)=x%+w%-1
    par%(3)=y%+h%-1
    par%(4)=0
    par%(5)=0
    par%(6)=w%-1
    par%(7)=h%-1
    '
    mem%(1)=w%
    mem%(2)=h%
    mem%(3)=(w%+15) DIV 16
    CLIP dx%,dy%,dw%,dh%
    BITBLT scr%(),mem%(),par%()
  ENDIF
RETURN
'
PROCEDURE hole_dialog(baum%)
  LOCAL x%,y%,w%,h%
  IF mem%(0)>0
    x%=OB_X(baum%,0)-3
    y%=OB_Y(baum%,0)-3
    w%=OB_W(baum%,0)+6
    h%=OB_H(baum%,0)+6
    par%(4)=x%
    par%(5)=y%
    par%(6)=x%+w%-1
    par%(7)=y%+h%-1
    par%(0)=0
    par%(1)=0
    par%(2)=w%-1
    par%(3)=h%-1
    '
    mem%(1)=w%
    mem%(2)=h%
    mem%(3)=(w%+15) DIV 16
    '
    CLIP dx%,dy%,dw%,dh%
    BITBLT mem%(),scr%(),par%()
  ENDIF
RETURN
'
PROCEDURE hilfe
  LOCAL ex_obj%
  VOID RSRC_GADDR(0,tree2%,baum%)
  FOR cn%=text1% TO text15%
    change_text(baum%,cn%," "+CHR$(0))
  NEXT cn%
  box_draw(baum%,0,0,0,0)
  IF EXIST(scr$)
    OPEN "I",#1,scr$
    cn%=text1%
    DO
      INPUT #1,a$
      IF UPPER$(a$)=".PAGE"
        ex_obj%=@neueseite
        INPUT #1,a$
      ENDIF
      EXIT IF ex_obj%=genug%
      EXIT IF a$="***"
      change_text(baum%,cn%,a$+CHR$(0))
      objc_update(baum%,cn%)
      INC cn%
      IF cn%=text15%+1
        ex_obj%=@neueseite
      ENDIF
      EXIT IF ex_obj%=genug%
    LOOP
    IF ex_obj%=helpex%
      WHILE cn%<text15%+1
        change_text(baum%,cn%,CHR$(0))
        objc_update(baum%,cn%)
        INC cn%
      WEND
      ex_obj%=@meinform_do(baum%,0)
    ENDIF
    box_undraw(baum%,0,0,0,0)            ! Dialog weg
    undo_objc(baum%,ex_obj%,1)
    CLOSE #1
  ELSE
    ex_obj%=@form_alert(1,keinscr%)
  ENDIF
RETURN
'
PROCEDURE mfree(adresse%)               ! Speicher freigeben
  LOCAL erg%
  fehler%=GEMDOS(&H49,L:adresse%)
  IF fehler%<>0
    IF rscok%
      VOID @form_alert(1,memfree%)
    ELSE
      ALERT 3,"    CHECKHD:|    Memory error",1,"OK",erg%
    ENDIF
  ENDIF
RETURN
'
FUNCTION memory(rsc$)
  LOCAL erg%,baum%
  fehler%=RSRC_LOAD(rsc$)
  rscok%=fehler%
  IF fehler%=0
    ALERT 3,"    CHECKHD:|    Sorry, can't find |    my RSC file!",1,"OK",erg%
  ELSE
    '
    VOID RSRC_GADDR(0,form1%,baum%)    ! Baum traversieren
    set_rsc(baum%)                     ! und anpassen
    '
    fehler%=MALLOC(2000)
    IF fehler%=0
      VOID @form_alert(1,nomem%)
    ELSE
      buf%=fehler%
      buf2%=buf%+512
      buf3%=buf2%+512
      INLINE hdc%,1200
      com_blk%=hdc%+14
      init_vdi
      fehler%=@rderrors
    ENDIF
  ENDIF
  RETURN fehler%
ENDFUNC
'
FUNCTION rderrors
  LOCAL t%
  FOR t%=0 TO 255
    fehler$(t%)="Err "+STR$(t%)
  NEXT t%
  CLR t%
  IF EXIST(scr$)
    OPEN "I",#1,scr$
    REPEAT
      INPUT #1,fehler$(t%)
    UNTIL fehler$(t%)="***"
    REPEAT
      INPUT #1,fehler$(t%)
      INC t%
    UNTIL fehler$(t%-1)="***"
    CLOSE #1
    RETURN 1
  ELSE
    VOID @form_alert(1,keinscr%)
    RETURN 0
  ENDIF
ENDFUNC
'
PROCEDURE exit
  mfree(buf%)
  VOID RSRC_FREE()
RETURN
'
PROCEDURE fehlerbehandlung
  LOCAL erg%
  ALERT 1,"    Program error    |    "+STR$(ERR),1,"Again|Exit",erg%
  IF acc! OR erg%=1
    RESUME main
  ELSE
    exit
  ENDIF
RETURN
' ============================== RSC-Routinen =================================
PROCEDURE init_vdi
  LOCAL phandle%,wchar%,hchar%,wbox%,hbox%,w%,h%,x%,y%
  LOCAL planes%,baum%
  LOCAL erg%
  DIM scr%(5),mem%(5),par%(8)
  '
  phandle%=GRAF_HANDLE(wchar%,hchar%,wbox%,hbox%)
  vq_extnd(phandle%,1)
  planes%=DPEEK(INTOUT+8)
  '
  VOID WIND_GET(0,4,dx%,dy%,dw%,dh%)   ! Innenmaûe des DESKTOP-Fensters
  VOID RSRC_GADDR(0,form3%,baum%)
  VOID FORM_CENTER(baum%,maxx%,maxy%,maxw%,maxh%)
  VOID RSRC_GADDR(0,interror%,baum%)
  VOID FORM_CENTER(baum%,maxx%,maxy%,maxw%,maxh%)
  VOID RSRC_GADDR(0,djet%,baum%)
  VOID FORM_CENTER(baum%,maxx%,maxy%,maxw%,maxh%)
  VOID RSRC_GADDR(0,errinf%,baum%)
  VOID FORM_CENTER(baum%,maxx%,maxy%,maxw%,maxh%)
  VOID RSRC_GADDR(0,chkerr%,baum%)
  VOID FORM_CENTER(baum%,maxx%,maxy%,maxw%,maxh%)
  VOID RSRC_GADDR(0,form4%,baum%)
  VOID FORM_CENTER(baum%,maxx%,maxy%,maxw%,maxh%)
  VOID RSRC_GADDR(0,form1%,baum%)
  VOID FORM_CENTER(baum%,maxx%,maxy%,maxw%,maxh%)
  VOID RSRC_GADDR(0,tree2%,baum%)
  VOID FORM_CENTER(baum%,x%,y%,w%,h%)
  maxw%=MAX(maxw%+6,w%+6)
  maxh%=MAX(maxh%+6,h%+6)
  maxx%=MIN(maxx%-3,x%-3)
  maxy%=MIN(maxy%-3,y%-3)
  maxw%=((maxw%+15) DIV 16)*16
  maxh%=((maxh%+15) DIV 16)*16
  fehler%=MALLOC(maxw%*maxh%*planes%/8)
  IF fehler%<=0
    VOID @form_alert(1,redrerr%)
  ENDIF
  scr%(0)=0
  mem%(0)=fehler%
  mem%(4)=0
  mem%(5)=planes%
  par%(8)=3
RETURN
'
PROCEDURE vq_extnd(handle%,owflag%)
  DPOKE CONTRL,102
  LPOKE CONTRL+2,6
  DPOKE CONTRL+8,45
  DPOKE CONTRL+12,handle%
  DPOKE INTIN,owflag%
  VDISYS
RETURN
'
PROCEDURE form_dial(flag%,littlx%,littly%,littlw%,littlh%,bigx%,bigy%,bigw%,bigh%)
  IF (shrinkgrow%<>0 OR mem%(0)<=0)  ! or flag%=3 or flag%=0
    VOID FORM_DIAL(flag%,littlx%,littly%,littlw%,littlh%,bigx%,bigy%,bigw%,bigh%)
  ENDIF
RETURN
'
FUNCTION simpledial(baum%,startob%)
  LOCAL ex_obj%
  box_draw(baum%,0,0,0,0)
  ex_obj%=@meinform_do(baum%,startob%)
  undo_objc(baum%,ex_obj%,1)
  box_undraw(baum%,0,0,0,0)
  RETURN ex_obj%
ENDFUNC
'
FUNCTION form_alert(defbutton%,alertnr%)
  LOCAL baum%
  VOID RSRC_GADDR(5,alertnr%,baum%)
  DPOKE GCONTRL+2,1
  DPOKE GCONTRL+4,1
  DPOKE GCONTRL+6,1
  DPOKE GCONTRL+8,0
  DPOKE GINTIN,defbutton%
  LPOKE ADDRIN,baum%
  GEMSYS 52
  RETURN DPEEK(GINTOUT)
ENDFUNC
'
PROCEDURE box_draw(tree%,x%,y%,w%,h%)
  rette_dialog(tree%)
  VOID WIND_UPDATE(1)
  fo_cx%=OB_X(tree%,0)-3
  fo_cy%=OB_Y(tree%,0)-3
  fo_cw%=OB_W(tree%,0)+6
  fo_ch%=OB_H(tree%,0)+6
  form_dial(0,x%,y%,w%,h%,fo_cx%,fo_cy%,fo_cw%,fo_ch%)
  form_dial(1,x%,y%,w%,h%,fo_cx%,fo_cy%,fo_cw%,fo_ch%)
  VOID OBJC_DRAW(tree%,0,8,fo_cx%,fo_cy%,fo_cw%,fo_ch%)
  VOID WIND_UPDATE(0)
RETURN
'
PROCEDURE box_undraw(tree%,x%,y%,w%,h%)
  VOID WIND_UPDATE(1)
  fo_cx%=OB_X(tree%,0)-3
  fo_cy%=OB_Y(tree%,0)-3
  fo_cw%=OB_W(tree%,0)+6
  fo_ch%=OB_H(tree%,0)+6
  form_dial(2,x%,y%,w%,h%,fo_cx%,fo_cy%,fo_cw%,fo_ch%)
  form_dial(3,x%,y%,w%,h%,fo_cx%,fo_cy%,fo_cw%,fo_ch%) ! restauriert Hintergrund
  VOID WIND_UPDATE(0)
  hole_dialog(tree%)
RETURN
'
PROCEDURE do_objc(tree%,obj_index%,bit%)
  obj_adresse%=tree%+24*obj_index%+10
  DPOKE obj_adresse%,DPEEK(obj_adresse%) OR bit%
RETURN
'
PROCEDURE undo_objc(tree%,obj_index%,bit%)
  obj_adresse%=tree%+24*obj_index%+10
  DPOKE obj_adresse%,DPEEK(obj_adresse%) AND NOT bit%
RETURN
'
FUNCTION is_objc(tree%,obj_index%,bit%)
  RETURN OB_STATE(tree%,obj_index%) AND bit%
ENDFUNC
'
PROCEDURE set_flag(tree%,obj_index%,bit%)
  obj_adresse%=tree%+24*obj_index%+8
  DPOKE obj_adresse%,DPEEK(obj_adresse%) OR bit%
RETURN
'
PROCEDURE del_flag(tree%,obj_index%,bit%)
  obj_adresse%=tree%+24*obj_index%+8
  DPOKE obj_adresse%,DPEEK(obj_adresse%) AND NOT bit%
RETURN
'
PROCEDURE objc_update(tree%,obj_index%)
  LOCAL x%,y%
  VOID OBJC_OFFSET(tree%,obj_index%,x%,y%)
  obj_adresse%=tree%+24*obj_index%
  VOID OBJC_DRAW(tree%,obj_index%,8,x%,y%,DPEEK(obj_adresse%+20),DPEEK(obj_adresse%+22))
RETURN
'
PROCEDURE change_text(baum%,obj%,txt$)       ! Text in G_BOXTEXT Ñndern !
  CHAR{LPEEK(LPEEK(baum%+24*obj%+12))}=txt$
RETURN
'
FUNCTION ptadr(tree%,obj_index%,flag%)
  LOCAL txt_adresse%
  txt_adresse%=LPEEK(LPEEK(tree%+24*obj_index%+12))
  IF flag%=1
    POKE txt_adresse%,0
  ENDIF
  RETURN txt_adresse%
ENDFUNC
'
' ---------------------------------------------------------------------------
PROCEDURE fopen(nm$,mode%)
  nm$=nm$+CHR$(0)
  fhandle%=GEMDOS(&H3D,L:VARPTR(nm$),W:mode%)
  fehler%=fhandle%
  err_inf(fehler%,"(Fopen)")
RETURN
'
PROCEDURE fclose(fhandle%)
  fehler%=GEMDOS(&H3E,W:fhandle%)
  err_inf(fehler%,"(Fclose)")
RETURN
'
PROCEDURE fwrite(fhandle%,buf$)
  buf$=buf$+cr$
  fehler%=GEMDOS(&H40,fhandle%,L:LEN(buf$),L:VARPTR(buf$))
  IF fehler%>=0 AND fehler%<LEN(buf$)
    fehler%=-1
  ENDIF
  err_inf(fehler%,"(Fwrite)")
RETURN
'
PROCEDURE fcreate(nm$,attr%)
  nm$=nm$+CHR$(0)
  fhandle%=GEMDOS(60,L:VARPTR(nm$),W:attr%)
  fehler%=fhandle%
  err_inf(fehler%,"(Fcreate)")
RETURN
'
PROCEDURE fseek(offset%,fhandle%,modus%)
  fehler%=GEMDOS(66,L:offset%,W:fhandle%,W:modus%)
  err_inf(fehler%,"(Fseek)")
RETURN
'
PROCEDURE err_inf(fehler%,a$)
  LOCAL baum%
  IF fehler%<0
    VOID RSRC_GADDR(0,chkerr%,baum%)
    change_text(baum%,chkerr1%,STR$(fehler%))
    change_text(baum%,chkerr2%,a$)
    change_text(baum%,chkerr3%,"")
    VOID @simpledial(baum%,0)
  ENDIF
RETURN
