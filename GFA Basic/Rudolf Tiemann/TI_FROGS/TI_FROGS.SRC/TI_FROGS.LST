' ============================================================
'    Ti_FROGs
' D:
'    Dieses Listing darf ausschlieûlich privat benutzt werden.
'    Wenn Sie mehr wollen, wenden Sie sich an den Autor.
'    Wenn Sie das Programm verÑndern, schicken Sie dem Autor
'    bitte ein Belegexemplar.
' NL:
'    De listing mag alleen strikt privÇ gebruikt worden.
'    Wilt u meer neem dan kontakt op met de auteur.
'    Ook wanneer u voor eigen gebruik veranderingen aanbrengt
'    wordt hij graag op de hoogte gehouden.            GfA gg.
'
'        +++  8 INLINEs  in 'pre.set'  +++
' D:
'    Wenn das LST-File mit Merge geladen wird,
'    mÅssen die INLINEs mit HELP nachgeladen werden!
' NL:
'    Als de LST-file (met Merge) geladen wordt,
'    moeten de INLINE's met HELP apart geladen worden.
'
' ============================================================
'       Label und VormenÅ zur Wahl der Sprache:
1.wahl:
DATA
DATA "  V.:  3.O / O6.12.91  "
DATA "(public domain)"
DATA "Ω"
DATA "Rudolf Tiemann"
DATA "Tel.: O6733-62O5"
DATA "Donnersbergstr.14"
DATA "65O9 Gau-Odernheim"
DATA "(West Germany)"
DATA
DATA *
DATA "",""
DATA "Deutsch","032"
DATA "Nederlands","049"
DATA "",""
DATA "    Escape    ","001"
DATA "",""
DATA *,""
'
prg_daten:
DATA "Ti_FROGs.PRG"
DATA "=52983 Bytes ΩTi"
' D:
'    ->^^^^^^<- hier drÅber muû nach dem 1.Compilieren
'    linksbÅndig die genaue Grîûe eingetragen werden,
'    dann folgt das endgÅltige 2.Compilieren
'    (wichtig fÅr den Linkvirentest)
' NL:
'    ->^^^^^^<- hierboven moet na de eerste keer compileren
'    links-aangeschoven de exacte grootte aangegeven worden.
'    Pas daarna kan definitief gecompileerd worden.
'    (i.v.m. Linkvirustest)
'
'   > Compiler-Anweisungen:
$S&  !2-Byte-Select-Parameter
$S<  !Select optimieren auf LÑnge
$P>  !Procedures: als GFA-Routinen
$%3  !IntDiv immer als Integer
$*%  !LongMul nicht mit MULS
$B+  !Meldung statt Bomben
$E$  !Fehler-Texte  (fÅr Routine 'shit')
$C+  !bei C:-Aufrufen Register auf Stack retten und restaurieren
$I+  !Interrupt zulassen
' $U+  !hinter jedem Befehl C&S&A, EVERY, AFTER prÅfen
'
'
' ===========================================================
'
@pre.set
'
neu_start:
' ON ERROR GOSUB shit
DO
  @1.wahl
LOOP
END
'
' ===========================================================
'
'
PROCEDURE pre.set  !+++++  8 INLINEs  +++++
  LOCAL hig1%,hig2%,h_cb%,low1%,low2%,l_cb%,prg_pal%,rat_spr%
  LOCAL f_ho&,frog_len&,cube_len&
  '
  INLINE hig1%,446
  INLINE hig2%,446
  INLINE h_cb%,2484
  INLINE low1%,454
  INLINE low2%,454
  INLINE l_cb%,2436
  INLINE prg_pal%,32
  INLINE rat_spr%,74
  '  Ratte als Sprite (funktioniert in allen Auflîsungen)
  MENU KILL
  DEFMOUSE 2
  SHOWM
  old_484|=PEEK(&H484)  !Einstellung retten
  SPOKE &H484,BCLR(PEEK(&H484),0)  !T-Klick aus
  SPOKE &H484,BSET(PEEK(&H484),1)  !Key-rep ein
  SPOKE &H484,BCLR(PEEK(&H484),2)  !Klingel aus
  alf&=XBIOS(4)   !0 1 2
  hf&=2+(alf&<1)  !1 2 2 Horizontalfaktor
  vf&=2+(alf&<2)  !1 1 2 Vertikalfaktor
  '  Die Positionen werden gewîhnlich so angegeben,
  '  daû sie fÅr die niedrige Auflîsung stimmen.
  '  Sie werden vom Programm mittels der Faktoren
  '  hf& und vf& an die aktuelle Auflîsung angepaût.
  h_max&=WORK_OUT(0)
  v_max&=WORK_OUT(1)
  CLIP 0,0 TO h_max&,v_max&  !Clipping richtig(!) setzen
  CLS
  y_kz&=7*vf&        !y Kopfzeile
  y_kl&=y_kz&+2+vf&  !y Kopflinie
  h_br&=h_max&+1
  h_mid&=h_br&\2
  v_ho&=v_max&+1
  v_mid&=v_ho&\2
  ratte$=SPACE$(74)
  BMOVE rat_spr%,V:ratte$,74
  top_pal$=""
  @get.palette(top_pal$)  !Farbpalette des Desktop retten
  check!=TRUE  !fÅr Linvirentest
  '
  '  programmspezifisch:
  '
  IF alf&=2
    cube_len&=414
    frog_len&=446
  ELSE
    cube_len&=406
    frog_len&=454
  ENDIF
  DIM wz$(6)  !WÅrfel
  frog_1$=SPACE$(frog_len&)
  frog_2$=SPACE$(frog_len&)
  IF alf&=2
    BMOVE hig1%,V:frog_1$,frog_len&
    BMOVE hig2%,V:frog_2$,frog_len&
    FOR ni&=1 TO 6
      wz$(ni&)=SPACE$(cube_len&)
      BMOVE h_cb%,V:wz$(ni&),cube_len&
      ADD h_cb%,cube_len&
    NEXT ni&
    VSETCOLOR 0,7,7,7  !weiû
  ELSE
    BMOVE low1%,V:frog_1$,frog_len&
    BMOVE low2%,V:frog_2$,frog_len&
    FOR ni&=1 TO 6
      wz$(ni&)=SPACE$(cube_len&)
      BMOVE l_cb%,V:wz$(ni&),cube_len&
      ADD l_cb%,cube_len&
    NEXT ni&
    prg_pal$=SPACE$(32)
    BMOVE prg_pal%,V:prg_pal$,32
    @set.palette(prg_pal$)  !eigene Palette
  ENDIF
  zl_h&=9*vf&           !Zeilenhîhe
  zl_max&=v_ho&\zl_h&-2
  sp_max&=h_br&\8       !Textspalten
  zl_ofs&=12*vf&-1      !Zeilenoffset
  '  nun der Fusselkram
  sp_z&=10              !Spaltenzahl
  zl_z&=6               !Zeilenzahl
  fr_z&=5               !Froschzahl
  fd_z&=sp_z&*zl_z&     !Felderzahl
  frog_br&=27*hf&
  frog_ho&=27*vf&
  h_di&=2*hf&
  v_di&=2*vf&
  fd_br&=frog_br&+h_di&*2
  fd_ho&=frog_ho&+v_di&*2
  f_li&=(h_max&-fd_br&*sp_z&)\2
  f_re&=h_max&-f_li&
  f_ho&=fd_ho&*zl_z&-v_di&
  f_ob&=(v_max&-y_kl&-f_ho&+1)\2+y_kl&+vf&
  f_un&=f_ob&+f_ho&
  f_xof&=f_li&-fd_br&
  f_yof&=f_ob&-fd_ho&
  x_esl&=f_li&-h_di&*2
  x_esr&=x_esl&+16*hf&+24
  x_til&=h_mid&-40
  x_tir&=h_mid&+39
  DIM pos&(zl_z&,3)   !fÅr Besitzerkontrolle
  DIM xp&(sp_z&)      ! Bildschirm-
  DIM yp&(zl_z&)      ! Positionen
  DIM am_ziel&(3)     !fÅr Zielkontrolle
  DIM wert&(zl_z&)    !fÅr Bewertung beim Computerspiel
  DIM zeit&(5)        !fÅr Pausen
  zeit&(3)=50         !1 sec
  zeit&(4)=100        !2 sec
  zeit&(5)=150        !3 sec
  aus_zeit&=3         !Default 1 sec
  yf&=f_ob&
  FOR zl&=1 TO zl_z&
    yp&(zl&)=yf&
    ADD yf&,fd_ho&
  NEXT zl&
  xf&=f_li&
  xp&(1)=xf&
  ADD xf&,fd_br&
  ADD xf&,h_di&
  FOR sp&=2 TO sp_z&-1
    xp&(sp&)=xf&
    ADD xf&,fd_br&
  NEXT sp&
  ADD xf&,h_di&
  xp&(sp_z&)=xf&
  mitspieler&=2        !Default
  bei_6_nochmal!=TRUE
  ' Auswahl-Strings fÅr Siegerehrung
  ' enthÑlt jeweils zweistellig die Nummer der Antwort
  ' fÅr zufÑllige Auswahl und Umsortierung
  ' * muû mit der Anzahl der DATAs Åbereinstimmen! *
  sp_g$="010203040506070809101112131415161718"
  sp_v$="01020304050607080910"
  sp_u$="0102030405"
  '
  @set.grafik.normal
  @set.1.wahl
  DEFMOUSE 0
RETURN
'
PROCEDURE get.palette(VAR pal$)
  pal$=""
  FOR ni&=0 TO 15
    pal$=pal$+MKI$(XBIOS(7,ni&,-1))
  NEXT ni&
RETURN
PROCEDURE set.palette(VAR pal$)
  ~XBIOS(6,L:V:pal$)
RETURN
'
PROCEDURE test.virus
  LOCAL pfad$,prg$,pln$,al$,prg_len%,d_l%,antw&
  pfad$=CHR$(GEMDOS(25)+65)+":"+DIR$(0)
  IF RIGHT$(pfad$,1)<>"\"
    pfad$=pfad$+"\"
  ENDIF
  RESTORE prg_daten
  READ prg$,pln$
  prg$=pfad$+prg$
  prg_len%=VAL(MID$(pln$,2))
  IF EXIST(prg$)
    OPEN "I",#1,prg$
    d_l%=LOF(#1)
    CLOSE #1
    IF d_l%<prg_len%
      al$="[3][ | | ???  ERROR  ???     | ][  EXIT  ]"
      @show.alert(1,al$,antw&)
      @short.exit
    ELSE IF d_l%>prg_len%
      al$="[3][ | |  !!!  LINKVIRUS  !!!      | ][  KILL  |EXIT]"
      @show.alert(1,al$,antw&)
      IF antw&=1
        @kill.virus
      ENDIF
      @short.exit
    ENDIF
  ELSE
    @zeig.warnung
  ENDIF
RETURN
PROCEDURE kill.virus
  LOCAL prg_adr%,frei%
  al$="[3][ | MALLOC-ERROR!      | ][  shit  ]"
  frei%=(prg_len%+255) AND &HFFFF00  !durch 256 teilbar
  RESERVE -frei%
  prg_adr%=MALLOC(frei%)
  IF prg_adr%
    OPEN "I",#1,prg$
    BGET #1,prg_adr%,prg_len%
    CLOSE #1
    '  Null ans Ende schreiben, kînnte gelîscht sein
    POKE prg_adr%+prg_len%-1,0
    BSAVE prg$,prg_adr%,prg_len%
    prg_adr%=MFREE(prg_adr%)
    IF prg_adr%
      @show.alert(1,al$,antw&)
    ENDIF
  ELSE
    @show.alert(1,al$,antw&)
  ENDIF
  RESERVE  !wie vorher
RETURN
PROCEDURE zeig.warnung
  IF taal$="NL"
    al$="[3][ |  De test op een Link-virus |  kon niet (!)|"
    al$=al$+"  uitgevoerd worden. | ][  zeer verdacht !  ]"
  ELSE  !D
    al$="[3][ |  Der Linkvirentest       |   konnte nicht(!)|"
    al$=al$+" durchgefÅhrt werden| ][  hîchst verdÑchtig!  ]"
  ENDIF
  @show.alert(1,al$,antw&)
RETURN
PROCEDURE show.alert(bn&,VAR al$,ret&)
  @no.but
  @no.key
  DEFMOUSE 0
  SHOWM
  ret&=FORM_ALERT(bn&,al$)
  @no.but
  @no.key
RETURN
'
PROCEDURE ausgang
  ON ERROR  !damit's ein Ende hat
  SOUND 1,0,0,0,0  !Gib AIDA
  WAVE 0,0         !keine Chance
  ~XBIOS(6,L:V:top_pal$)  !alte Palette
  @set.grafik.normal
  @short.exit
RETURN
PROCEDURE short.exit
  SPOKE &H484,old_484|  !alte Einstellung
  CLS
  @no.but
  DEFMOUSE 0
  SHOWM
  EDIT
RETURN
'
PROCEDURE white.box(li&,ob&,re&,un&)
  @set.grafik.normal
  PBOX li&,ob&,re&,un&
RETURN
PROCEDURE clean
  '  fÅllt den Bildschirm (ohne Kopfzeile) mit "Hintergrund"
  ~FORM_DIAL(3,0,0,0,0,0,0,WORK_OUT(0),WORK_OUT(1))
RETURN
PROCEDURE zent(ty&,ti$)
  '  zentriert den Text an der gewÅnschten y-Position
  TEXT h_mid&-LEN(ti$)*4,ty&*vf&,ti$
  '  (Angabe fÅr low-res ^^^ wird angepaût)
RETURN
PROCEDURE set.titel(ti$)
  LOCAL tl&,xt&
  @white.box(-1,-1,h_br&,y_kl&)
  tl&=LEN(ti$)
  IF tl&
    xt&=h_mid&-tl&*4
    GRAPHMODE 4
    TEXT xt&-8,y_kz&,SPACE$(tl&+2)
    GRAPHMODE 3
    TEXT xt&,y_kz&,ti$
    GRAPHMODE 1
  ENDIF
RETURN
PROCEDURE shit
  ON ERROR  !aus
  ~FORM_ALERT(1,ERR$(ERR))  !Original Fehlermeldung
  RESUME neu_start
RETURN
'
PROCEDURE set.1.wahl
  RESTORE 1.wahl                              !DATA-Pointer setzen
  @test.wahl(ti1&,pw1&)                       !zÑhlen
  DIM ti1$(ti1&),pw1$(pw1&),pk1$(pw1&)        !dimesionieren
  RESTORE 1.wahl                              !DATA-Pointer zurÅcksetzen
  @read.wahl(ti1&,pw1&,ti1$(),pw1$(),pk1$())  !Arrays fÅllen
RETURN
PROCEDURE set.wahl.main
  @da.is.main
  @test.wahl(ti2&,pw2&)
  ERASE ti2$(),pw2$(),pk2$()
  DIM ti2$(ti2&),pw2$(pw2&),pk2$(pw2&)
  @da.is.main
  @read.wahl(ti2&,pw2&,ti2$(),pw2$(),pk2$())
  '  separat abhaken, damit die Wahl auch nach
  '  einem Wechsel der Sprache beachtet wird
  @abhaken.bei.6
  @abhaken.mitspieler
RETURN
PROCEDURE da.is.main                             !~NL~D~
  IF taal$="NL"
    RESTORE wahl_main_nl
  ELSE
    RESTORE wahl_main_d
  ENDIF
  '  ohne Infozeilen
  wahl_main_nl:
  DATA *
  DATA "",""
  DATA "INFO","023"
  DATA "Regels","019"
  DATA "  6 -> nog eens  ","007 108 049"
  DATA "Tegenstander :","1"
  DATA "  Mens    ","050"
  DATA "  Computer","046"
  DATA "   Pauze..","025"
  DATA "",""
  DATA "Start","031"
  DATA "------------------","2"
  DATA "       Escape       ","001"
  DATA "",""
  DATA *,""
  '
  wahl_main_d:
  DATA *
  DATA "",""
  DATA "INFO","023"
  DATA "Regeln","019"
  DATA "  bei 6 weiter  ","007 108 017"
  DATA "Mitspieler:","1"
  DATA "  Mensch  ","050"
  DATA "  Computer","046"
  DATA "   Pause..","025"
  DATA "",""
  DATA "Spielen","031"
  DATA "------------------","2"
  DATA "       Escape       ","001"
  DATA "",""
  DATA *,""
RETURN
PROCEDURE set.wahl.pause
  @da.is.pause
  @test.wahl(ti3&,pw3&)
  ERASE ti3$(),pw3$(),pk3$()
  DIM ti3$(ti3&),pw3$(pw3&),pk3$(pw3&)
  @da.is.pause
  @read.wahl(ti3&,pw3&,ti3$(),pw3$(),pk3$())
  '  separat abhaken
  @abhaken.pause(aus_zeit&)
RETURN
PROCEDURE da.is.pause                            !~NL~D~
  IF taal$="NL"
    RESTORE wahl_pause_nl
  ELSE
    RESTORE wahl_pause_d
  ENDIF
  '
  wahl_pause_nl:
  DATA
  DATA "  Hoeveel seconden moet  "
  DATA "de computer wachten ?"
  DATA
  DATA *
  DATA "",""
  DATA "  0  ","011 112"
  DATA "  1  ","002 109"
  DATA "  2  ","003 110"
  DATA "  3  ","004 111"
  DATA "",""
  DATA "  Escape  ","001"
  DATA "",""
  DATA *,""
  '
  wahl_pause_d:
  DATA
  DATA "  Wieviele Sekunden soll  "
  DATA "der Computer warten?"
  DATA
  DATA *
  DATA "",""
  DATA "  0  ","011 112"
  DATA "  1  ","002 109"
  DATA "  2  ","003 110"
  DATA "  3  ","004 111"
  DATA "",""
  DATA "  Escape  ","001"
  DATA "",""
  DATA *,""
RETURN
PROCEDURE set.wahl.genug
  @da.is.genug
  @test.wahl(ti4&,pw4&)
  ERASE ti4$(),pw4$(),pk4$()
  DIM ti4$(ti4&),pw4$(pw4&),pk4$(pw4&)
  @da.is.genug
  @read.wahl(ti4&,pw4&,ti4$(),pw4$(),pk4$())
RETURN
PROCEDURE da.is.genug                            !~NL~D~
  IF taal$="NL"
    RESTORE wahl_genug_nl
  ELSE
    RESTORE wahl_genug_d
  ENDIF
  '
  wahl_genug_nl:
  DATA
  DATA "  Stoppen ?  "
  DATA
  DATA *
  DATA "",""
  DATA "Ja","036 028 114"
  DATA "",""
  DATA "  Nee  ","049 057 001"
  DATA "",""
  DATA *,""
  '
  wahl_genug_d:
  DATA
  DATA "    Aus?    "
  DATA
  DATA *
  DATA "",""
  DATA "ja","036 028 114"
  DATA "",""
  DATA "  nein  ","049 057 001"
  DATA "",""
  DATA *,""
RETURN
'
PROCEDURE set.wahl.neu
  @da.is.neu
  @test.wahl(ti5&,pw5&)
  ERASE ti5$(),pw5$(),pk5$()
  DIM ti5$(ti5&),pw5$(pw5&),pk5$(pw5&)
  @da.is.neu
  @read.wahl(ti5&,pw5&,ti5$(),pw5$(),pk5$())
RETURN
PROCEDURE da.is.neu                              !~NL~D~
  IF taal$="NL"
    IF computer!
      RESTORE wahl_neu_nl_1
    ELSE
      RESTORE wahl_neu_nl_2
    ENDIF
  ELSE
    IF computer!
      RESTORE wahl_neu_d_1
    ELSE
      RESTORE wahl_neu_d_2
    ENDIF
  ENDIF
  '
  wahl_neu_nl_1:
  DATA
  DATA "Je bent zeker"
  DATA "  aan het verliezen !?  "
  DATA
  DATA "Opnieuw beginnen ?"
  DATA
  DATA *
  DATA "",""
  DATA "Ja","036 028 114"
  DATA "",""
  DATA "  Nee  ","049 001 057"
  DATA "",""
  DATA *,""
  '
  wahl_neu_nl_2:
  DATA
  DATA "  Opnieuw beginnen ?  "
  DATA
  DATA *
  DATA "",""
  DATA "Ja","036 028 114"
  DATA "",""
  DATA "  Nee  ","049 001 057"
  DATA "",""
  DATA *,""
  '
  wahl_neu_d_1:
  DATA
  DATA "Du bist wohl"
  DATA "  am Verlieren!  "
  DATA
  DATA "Neues Spiel?"
  DATA
  DATA *
  DATA "",""
  DATA "ja","036 028 114"
  DATA "",""
  DATA "  nein  ","049 001 057"
  DATA "",""
  DATA *,""
  '
  wahl_neu_d_2:
  DATA
  DATA "  Spiel neu beginnen?  "
  DATA
  DATA *
  DATA "",""
  DATA "ja","036 028 114"
  DATA "",""
  DATA "  nein  ","049 001 057"
  DATA "",""
  DATA *,""
RETURN
'
PROCEDURE test.wahl(VAR ti&,pw&)
  LOCAL test$,dummy$
  ti&=-1  !Info-Zeilen zÑhlen
  REPEAT
    INC ti&
    READ test$
  UNTIL test$="*"
  pw&=-1  !Wahl-Zeilen zÑhlen
  REPEAT
    INC pw&
    READ test$,dummy$
  UNTIL test$="*"
RETURN
PROCEDURE read.wahl(VAR ti&,pw&,pt$(),pw$(),pk$())
  LOCAL dummy$
  ni&=0
  WHILE ni&<ti&
    INC ni&
    READ pt$(ni&)
  WEND
  READ dummy$  !*=Info-Ende
  ni&=0
  WHILE ni&<pw&
    INC ni&
    READ pw$(ni&),pk$(ni&)
  WEND
RETURN
'
PROCEDURE pop.wahl(li&,ob&,hoz!,vez!,mk2&,VAR pt_&,az_&,pt_$(),aw_$(),cd_$(),pw_&)
  '  li& / ob&   = links/oben
  '  hoz!/vez!   = horizontal/vertikal zentriert (relativ zur Position)
  '  pt_&/pt_$() = Infotext
  '  az_&/aw_$() = Auswahlzeilen
  '  lcd&/cd_$() = LÑnge/Scancodes (bzw. Textart)
  '         mk2& = Default fÅr rechten Mausknopf
  '         pw_& = gewÑhlt (RÅckmeldung)
  '
  LOCAL ai&,aw&,re&,un&,th&,tb&,td&,lzl&,lcd&,ax&,ay&,aw$,mi&,cd$,pop_pic$
  '
  th&=8*vf&                          !Texthîhe
  td&=9*vf&                          !Textdistanz (vertikal)
  tb&=8                              !Textbreite
  HIDEM
  SGET pop_pic$                      !Hintergrund retten
  @search.max.len(re&,az_&,aw_$())
  lzl&=re&*4+4                       !Info-LÑnge merken
  @search.max.len(re&,pt_&,pt_$())
  @pop.center
  @pop.box
  mi&=(li&+re&)\2
  li&=mi&-lzl&-1
  re&=mi&+lzl&
  ay&=ob&-td&\2+vf&
  ni&=0
  WHILE ni&<pt_&                     !Infozeilen
    ADD ay&,td&
    INC ni&
    lzl&=LEN(pt_$(ni&))
    IF lzl&
      ax&=mi&-lzl&*4                 !zentriert
      TEXT ax&,ay&,pt_$(ni&)
    ENDIF
  WEND
  IF ni&                             !wenn Infozeilen:
    ADD ay&,td&\2                    !1/2 Zeile frei
    DRAW li&-tb&,ay& TO re&+tb&,ay&  !Trennlinie
  ELSE                               !sonst:
    ADD ay&,td&\4                    !1/4 Zeile frei
  ENDIF
  ob&=ay&+td&\2-2*vf&                !Auswahl oben merken
  ni&=0
  WHILE ni&<az_&                     !Auswahlzeilen
    INC ni&
    ADD ay&,td&
    lcd&=LEN(cd_$(ni&))
    IF lcd&
      IF lcd&>2                      !Auswahl:
        DEFTEXT ,0                   !normal
      ELSE IF lcd&>0                 !Kommentar:
        DEFTEXT ,VAL(cd_$(ni&))      !~Textstil
      ELSE                           !Default:
        DEFTEXT ,4                   !kursiv
      ENDIF
      ax&=mi&-LEN(aw_$(ni&))*4       !zentrieren
      TEXT ax&,ay&,aw_$(ni&)
    ENDIF
  WEND
  un&=ay&+td&\2-2*vf&                !Auswahl unten merken
  GRAPHMODE 3                        !XOR
  DEFFILL 1,1                        !voll
  pw_&=0                             !gewÑhlt
  ay&=0                              !alt
  @no.but
  @no.key
  SHOWM
  REPEAT
    @get.tom
    IF scan|                         !Taste
      cd$=RIGHT$("00"+STR$(scan|),3)
    ELSE IF mk&=2                    !MK2
      pw_&=mk2&                      !Default-Wahl
      mk&=0                          !fÅr Anzeige
    ENDIF
    '                                !innerhalb
    IF mx&>li& AND mx&<re& AND my&>ob& AND my&<un&
      aw&=(my&-ob&)\td&+1
      IF mk&=1 AND LEN(cd_$(aw&))>2  !wÑhlbar   ( mk&=1 nur innerhalb! )
        pw_&=aw&                     !gewÑhlt
      ENDIF
      my&=aw&*td&+ob&-td&
      IF my&<>ay&                    !neu
        IF ay&                       !da war noch was
          PBOX li&,ay&,re&,ay&+th&   !alt weg
          ay&=0
        ENDIF
        IF LEN(cd_$(aw&))>2          !wÑhlbar
          PBOX li&,my&,re&,my&+th&   !neu hin
          ay&=my&                    !und merken
        ENDIF
        SHOWM
      ENDIF
    ELSE                             !auûerhalb
      IF ay&                         !da war was
        PBOX li&,ay&,re&,ay&+th&     !weg
      ENDIF
      ay&=0
    ENDIF
    IF scan|                         !Taste
      ai&=1
      REPEAT                         !suchen
        IF LEN(cd_$(ai&))>2          !wÑhlbar
          IF INSTR(cd_$(ai&),cd$)    !gefunden
            pw_&=ai&                 !gewÑhlt
          ENDIF
        ENDIF
        INC ai&
      UNTIL ai&>az_& OR pw_&
    ENDIF
  UNTIL pw_&                         !bis was gewÑhlt ist!
  IF mk&=0                           !Tastenwahl zeigen
    IF ay&                           !da war noch was
      PBOX li&,ay&,re&,ay&+th&       !alt weg
    ENDIF
    my&=pw_&*td&+ob&-td&
    PBOX li&,my&,re&,my&+th&         !neu hin
    PAUSE 10                         !kurz warten
  ENDIF
  @set.grafik.normal
  SPUT pop_pic$
  @no.but
RETURN
PROCEDURE search.max.len(VAR sl&,sz&,st$())
  ni&=0
  WHILE ni&<sz&
    INC ni&
    sl&=MAX(sl&,LEN(st$(ni&)))
  WEND
RETURN
'
PROCEDURE pop.info(li&,ob&,hoz!,vez!,sec%)
  LOCAL pt_&,az_&,ai&,re&,un&,td&,tb&,lzl&,ax&,ay&,mi&,az$,pop_pic$
  HIDEM
  SGET pop_pic$
  td&=9*vf&                          !Textdistanz (vertikal)
  tb&=8                              !Textbreite
  DIM az_$(22)                       !local array
  '  "pop.info" liest die Zeilen selbst ein.
  '  Der DATA-Pointer muû deshalb vorher von
  '  der aufrufenden Routine gestellt sein.
  REPEAT
    INC az_&
    READ az_$(az_&)
    lzl&=LEN(az_$(az_&))
    re&=MAX(re&,lzl&)                !lÑngsten Eintrag finden
  UNTIL az_$(az_&)="*"
  @pop.center
  DEC az_&
  @pop.box
  mi&=(li&+re&)\2
  ay&=ob&
  FOR ai&=1 TO az_&
    az$=az_$(ai&)
    lzl&=LEN(az$)
    ax&=mi&-lzl&*4
    ADD ay&,td&
    TEXT ax&,ay&,az$
  NEXT ai&
  ERASE az_$()                       !kann weg
  SPRITE ratte$,re&-10,un&-8
  @wart.mal(sec%*200)                !Beamtenmikado
  @set.grafik.normal
  SPRITE ratte$
  SPUT pop_pic$
  SHOWM
RETURN
PROCEDURE wart.mal(wt%)
  LOCAL ax&,ay&
  @no.key
  @no.but
  IF wt%<0
    wt%=12000   !Default max. 1 min warten
  ENDIF
  ADD wt%,TIMER
  ax&=MOUSEX
  ay&=MOUSEY
  REPEAT        !Beamtenmikado
    @get.tom
  UNTIL mk& OR scan| OR TIMER>wt% OR ABS(mx&-ax&)>30*hf& OR ABS(my&-ay&)>30*vf&
  @no.but
RETURN
PROCEDURE pop.center
  MUL re&,tb&
  ADD re&,4
  un&=(pt_&+az_&)*td&
  '  Wenn hoz! (vez!) = TRUE, gibt li& (ob&)
  '  die relative Abweichung von der Mitte an,
  '  andernfalls die absolute Position
  '  der linken oberen Ecke.
  '  re& und un& wird berechnet und hÑngt
  '  von der Textbreite bzw. Zeilenzahl ab.
  '  Die Umrahmung (s. 'pop.box') geht jeweils
  '  um 7*hf& bzw. 7*vf& Åber diese Ecken hinaus.
  IF hoz!
    ADD li&,(h_br&-re&)\2
  ENDIF
  IF vez!
    ADD ob&,(v_ho&-un&)\2
  ENDIF
  ADD un&,ob&
  ADD re&,li&
RETURN
PROCEDURE pop.box
  @set.grafik.normal
  DEC li&
  PBOX li&-7*hf&,ob&-7*vf&,re&+7*hf&,un&+7*vf&
  BOX li&-5*hf&,ob&-5*vf&,re&+5*hf&,un&+5*vf&
  INC li&
  BOUNDARY FALSE
RETURN
PROCEDURE set.grafik.normal
  GRAPHMODE 1
  BOUNDARY TRUE
  COLOR 1
  DEFFILL 1,0,0
  DEFLINE 1,1,0,0
  DEFTEXT 1,0,0,7*vf&-1  !6/13
RETURN
PROCEDURE get.tom
  '  Taste oder Maustaste abliefern (nicht warten)
  MOUSE mx&,my&,mk&
  KEYTEST key%
  IF key%
    scan|=AND(key%,&HFF0000)\&HFFFF
    @no.key
    mk&=0
  ELSE
    scan|=0
  ENDIF
RETURN
PROCEDURE no.key
  '  Tastaturpuffer lîschen
  LPOKE XBIOS(14,1)+6,0
RETURN
PROCEDURE no.but
  WHILE MOUSEK  !fÑngt ÅberschÅssige Mausklicks ab (meistens, Sch... GEM)
    REPEAT
      ~EVNT_BUTTON(0,0,0)
      MOUSE mx&,my&,mk&
    UNTIL mk&=0
  WEND
RETURN
'
PROCEDURE 1.wahl
  @set.titel(" T i _ F R O G s ")
  @clean
  @pop.wahl(0,0,TRUE,TRUE,0,ti1&,pw1&,ti1$(),pw1$(),pk1$(),wahl&)
  SELECT wahl&
  CASE 2,3
    @set.sprache(wahl&-1)
    IF check!
      @test.virus
      check!=FALSE
    ENDIF
    IF alf&=1
      @geht.nicht
    ELSE
      @wahl.main
    ENDIF
  CASE 5
    @last.info
    @ausgang
  ENDSELECT
RETURN
PROCEDURE set.sprache(ni&)
  IF ni&=2
    taal$="NL"
  ELSE
    taal$="D"
  ENDIF
  @set.wahl.main
  @set.wahl.pause
  @set.wahl.genug
RETURN
PROCEDURE geht.nicht
  @da.is.geht.nicht
  @test.wahl(ti2&,pw2&)
  ERASE ti2$(),pw2$(),pk2$()
  DIM ti2$(ti2&),pw2$(pw2&),pk2$(pw2&)
  @da.is.geht.nicht
  @read.wahl(ti2&,pw2&,ti2$(),pw2$(),pk2$())
  @pop.wahl(0,0,TRUE,TRUE,2,ti2&,pw2&,ti2$(),pw2$(),pk2$(),wahl&)
  @ausgang
RETURN
PROCEDURE da.is.geht.nicht                       !~NL~D~
  IF taal$="NL"
    RESTORE geht_nicht_nl
  ELSE
    RESTORE geht_nicht_d
  ENDIF
  '
  geht_nicht_nl:
  DATA
  DATA " Dit programma loopt "
  DATA "helaas alleen in"
  DATA "LAGE en HOGE"
  DATA "resolutie !"
  DATA
  DATA *
  DATA "",""
  DATA "  Lastig  ","001 057 028 114"
  DATA "",""
  DATA *,""
  '
  geht_nicht_d:
  DATA
  DATA " Dieses Programm lÑuft "
  DATA "leider nur in"
  DATA "niedriger oder hoher"
  DATA "Auflîsung!"
  DATA
  DATA *
  DATA "",""
  DATA "  lÑstig  ","001 057 028 114"
  DATA "",""
  DATA *,""
RETURN
'
PROCEDURE wahl.main
  REPEAT
    @set.titel(" T i _ F R O G s ")
    @clean
    @pop.wahl(0,0,TRUE,TRUE,12,ti2&,pw2&,ti2$(),pw2$(),pk2$(),wahl&)
    SELECT wahl&
    CASE 2
      @prg.info
    CASE 3
      @spiel.regeln
    CASE 4
      @bei.6.weiter
    CASE 6,7  !Mensch/Computer
      @mitspieler
    CASE 8
      @wahl.pause
    CASE 10
      @spielen
    ENDSELECT
  UNTIL wahl&=12
RETURN
PROCEDURE wahl.pause
  @pop.wahl(0,0,TRUE,TRUE,7,ti3&,pw3&,ti3$(),pw3$(),pk3$(),wahl&)
  IF wahl&<6
    @abhaken.pause(wahl&)
  ENDIF
RETURN
PROCEDURE abhaken.pause(nr&)
  IF nr&<>aus_zeit&
    MID$(pw3$(aus_zeit&),1)=" "
  ENDIF
  aus_zeit&=nr&
  MID$(pw3$(nr&),1)=""
RETURN
PROCEDURE wahl.genug
  @pop.wahl(0,0,TRUE,TRUE,4,ti4&,pw4&,ti4$(),pw4$(),pk4$(),wahl&)
  IF wahl&=2
    spiel_abbruch!=TRUE
    genug_gespielt!=TRUE
  ENDIF
RETURN
PROCEDURE wahl.neu
  @pop.wahl(0,0,TRUE,TRUE,4,ti5&,pw5&,ti5$(),pw5$(),pk5$(),wahl&)
  IF wahl&=2
    spiel_abbruch!=TRUE
  ENDIF
RETURN
PROCEDURE last.info                              !~NL~D~
  IF taal$="NL"
    RESTORE last_info_nl
  ELSE
    RESTORE last_info_d
  ENDIF
  @pop.info(0,0,TRUE,TRUE,1)
  last_info_nl:
  DATA " tot uw dienst "
  DATA *
  last_info_d:
  DATA " servus "
  DATA *
RETURN
'
PROCEDURE prg.info
  IF taal$="NL"
    RESTORE prg_info_nl
  ELSE
    RESTORE prg_info_d
  ENDIF
  @zeig.info("Info")
  '
  prg_info_d:
  DATA
  DATA
  DATA "   Ti_FROGs ist 'public domain',"
  DATA "lÑuft in 'low' und 'high' und hat"
  DATA "'was gegen Linkviren."
  DATA
  DATA "   Das Programm ist in GfA-BASIC 3.0"
  DATA "geschrieben und compiliert und darf"
  DATA "und soll weitergegeben werden - aber"
  DATA "natÅrlich ausschlieûlich kostenlos!"
  DATA
  DATA "   Und damit es auch kostenlos bleibt,"
  DATA "schicken Sie dem Autor bitte kein(!)"
  DATA "Geld."
  DATA
  DATA
  DATA "              Viel Spaû!"
  DATA *
  prg_info_nl:
  DATA "   Ti_FROGs is 'public domain',"
  DATA "loopt in LAGE en HOGE resolutie en"
  DATA "'heeft iets' tegen Linkvirussen."
  DATA "   Het programma is in GfA-BASIC 3.0"
  DATA "geschreven en gecompileerd en mag,"
  DATA "nee, m¢Çt verder gegeven worden - maar"
  DATA "natuurlijk uitsluitend kosteloos !"
  DATA "   En om te zorgen dat het ook"
  DATA "kosteloos blijft, stuurt U de auteur"
  DATA "a.u.b. geen (!) geld."
  DATA "            Veel plezier !"
  DATA
  DATA "Nederlandse vertaling van:"
  DATA
  DATA "         Philip van Rijthoven"
  DATA "         Paul Krugerstraat 58"
  DATA "         NL  6543 MX Nijmegen"
  DATA "             080 - 782457"
  DATA "               (Danke!)"
  DATA *
RETURN
PROCEDURE zeig.info(ti$)
  LOCAL zl_zahl&
  DIM zl$(60)  !local
  REPEAT
    INC zl_zahl&
    READ zl$(zl_zahl&)
  UNTIL zl$(zl_zahl&)="*"
  INSERT zl$(0)=""
  @ed.text(ti$,zl_zahl&,zl$())
  ERASE zl$()
RETURN
PROCEDURE ed.text(VAR tit$,ed_max&,ed$())
  LOCAL x0r&,x3l&,x3r&,x5l&,x5r&,xtl&,xtr&,pl&,pr&,po&,pu&,esc!
  LOCAL zl_ofs&,ed_ofs&,ed_pg&,ed_dn&,ed_x&,y_di&,y_ol&,y_ul&,tl&
  LOCAL leer$,part$
  @ed.set
  REPEAT
    @get.tom
    IF mk&
      @ed.maus
    ELSE IF scan|
      @ed.taste
    ENDIF
  UNTIL esc!
RETURN
PROCEDURE ed.set
  ed_pg&=MIN(zl_max&,ed_max&)
  ed_dn&=ed_max&-ed_pg&
  ed_x&=h_mid&-152
  pl&=ed_x&-6*hf&*hf&
  zl_ofs&=(v_max&-y_kl&-zl_max&*zl_h&)\2+y_kl&-vf&-1
  y_ol&=zl_ofs&
  pr&=h_max&-pl&
  leer$=SPACE$((pr&-ed_x&-1)\8)
  po&=zl_ofs&+vf&+1
  pu&=po&+ed_pg&*zl_h&-1
  y_ul&=pu&+2*vf&+2
  y_di&=zl_h&-vf&-1
  @set.titel(tit$)
  GRAPHMODE 4
  TEXT 1,y_kz&,SPACE$(3+2*hf&)
  GRAPHMODE 3
  TEXT 8*hf&+1,y_kz&,"ESC"
  GRAPHMODE 1
  tl&=LEN(tit$)
  xal&=56+8*hf&
  x0r&=26+16*hf&
  x3l&=50*hf&*hf&
  x3r&=x3l&+16+16*hf&
  xtl&=h_mid&-tl&*4-8
  xtr&=h_max&-xtl&
  x5l&=h_max&-x3r&
  x5r&=h_max&-x3l&
  IF ed_max&>ed_pg&
    @ed.set.buttons
  ENDIF
  @clean
  @ed.seite
RETURN
PROCEDURE ed.set.buttons
  GRAPHMODE 4
  TEXT x3l&,y_kz&,SPACE$(2+2*hf&)
  TEXT x5l&,y_kz&,SPACE$(2+2*hf&)
  GRAPHMODE 3
  TEXT x3l&+4+8*hf&,y_kz&,""
  TEXT x5l&+4+8*hf&,y_kz&,""
  GRAPHMODE 1
RETURN
PROCEDURE ed.maus
  IF my&<y_kl&
    @ed.button
  ENDIF
RETURN
PROCEDURE ed.button
  IF mx&<x0r&
    SETMOUSE mx&,12*vf&
    esc!=TRUE
  ELSE IF mx&>x3l& AND mx&<x3r&
    @ed.up(mk&>1)
  ELSE IF mx&>xtl& AND mx&<xtr&
    @show.ed.info
  ELSE IF mx&>x5l& AND mx&<x5r&
    @ed.down(mk&>1)
  ENDIF
RETURN
PROCEDURE show.ed.info
  IF taal$="NL"
    RESTORE ed_info_nl
  ELSE
    RESTORE ed_info_d
  ENDIF
  @pop.info(0,0,TRUE,TRUE,3)
  '
  ed_info_nl:
  DATA "  Daar kijkt U naar !  "
  DATA *
  ed_info_d:
  DATA "  Das sehen Sie vor sich!  "
  DATA *
RETURN
PROCEDURE ed.taste
  SELECT scan|
  CASE 1
    esc!=TRUE
  CASE 71
    @ed.home
  CASE 72
    @ed.up(shift!)
  CASE 80
    @ed.down(shift!)
  ENDSELECT
RETURN
PROCEDURE ed.home
  IF shift!
    IF ed_ofs&<ed_dn&
      ed_ofs&=ed_dn&
      @ed.seite
    ENDIF
  ELSE
    IF ed_ofs&>0
      ed_ofs&=0
      @ed.seite
    ENDIF
  ENDIF
RETURN
PROCEDURE ed.up(seite!)
  IF ed_ofs&>0
    IF seite!
      di&=MIN(ed_pg&-1,ed_ofs&)
      SUB ed_ofs&,di&
      @ed.seite
    ELSE
      DEC ed_ofs&
      GET pl&,po&,pr&,pu&-zl_h&,part$
      PUT pl&,po&+zl_h&,part$
      yi&=zl_ofs&+zl_h&
      TEXT ed_x&,yi&,leer$
      TEXT ed_x&,yi&,ed$(ed_ofs&+1)
      SHOWM
    ENDIF
  ENDIF
  '  @no.key
RETURN
PROCEDURE ed.down(seite!)
  IF ed_ofs&<ed_dn&
    IF seite!
      di&=MIN(ed_pg&-1,ed_dn&-ed_ofs&)
      ADD ed_ofs&,di&
      @ed.seite
    ELSE
      INC ed_ofs&
      GET pl&,po&+zl_h&,pr&,pu&,part$
      PUT pl&,po&,part$
      yi&=ed_pg&*zl_h&+zl_ofs&
      TEXT ed_x&,yi&,leer$
      TEXT ed_x&,yi&,ed$(ed_ofs&+ed_pg&)
      SHOWM
    ENDIF
  ENDIF
  '  @no.key
RETURN
PROCEDURE ed.seite
  LOCAL zl&
  PBOX pl&-1,y_ol&,pr&+1,y_ul&
  yi&=zl_ofs&
  ni&=ed_ofs&
  FOR zl&=1 TO ed_pg&
    ADD yi&,zl_h&
    INC ni&
    TEXT ed_x&,yi&,ed$(ni&)
  NEXT zl&
  SHOWM
RETURN
'
PROCEDURE spiel.regeln
  LOCAL ti$
  IF taal$="NL"
    ti$="Spelregels"
    RESTORE spiel_regeln_nl
  ELSE
    ti$="Spielregeln"
    RESTORE spiel_regeln_d
  ENDIF
  @zeig.info(ti$)
  '
  spiel_regeln_d:
  DATA "               Ti_FROGs"
  DATA "ist ein WÅrfelspiel fÅr zwei Spieler."
  DATA
  DATA "Ziel dieses Spieles ist es, als Erster"
  DATA "alle Frîsche auf die andere Seite zu"
  DATA "bringen."
  DATA
  DATA "Dabei bestimmt ein WÅrfel die maximale"
  DATA "Weite des nÑchsten Sprunges, und der"
  DATA "Spieler (mit der Maus), welcher Frosch"
  DATA "springen soll."
  DATA
  DATA "Zwischenfelder kînnen nur angesprungen"
  DATA "werden, wenn sie frei sind. Versucht"
  DATA "man es trotzdem, sind die Punkte weg."
  DATA "      ( Pennen wird bestraft! )"
  DATA "Randfelder kînnen immer angesprungen"
  DATA "werden. - Falls dort noch ein Frosch"
  DATA "sitzt, hat er Pech gehabt und wird"
  DATA "eingeklemmt.  D.h. er braucht eine 6,"
  DATA "um wieder frei zu kommen, und springt"
  DATA "dann trotzdem nur ein Feld weit."
  DATA
  DATA "Wenn ein Sprung Åber das Randfeld"
  DATA "hinausgeht, werden die ÅberzÑhligen"
  DATA "Punkte verschenkt."
  DATA
  DATA "' bei 6 weiter' bedeutet: der Spieler"
  DATA "bleibt am Zug, wenn sein WÅrfel eine 6"
  DATA "zeigt (und er nicht pennt)."
  DATA
  DATA "Der zweite Spieler beendet das Spiel,"
  DATA "auch wenn der erste schon all seine"
  DATA "Frîsche am Ziel hat."
  DATA
  DATA "Auch wenn kein Frosch springen kann,"
  DATA "muû einer angeklickt werden, bevor"
  DATA "der andere Spieler dran kommt."
  DATA
  DATA "Falls der zweite Spieler fehlt, kann"
  DATA "der Computer mitspielen. Er beachtet"
  DATA "natÅrlich alle Regeln, spielt aber"
  DATA "knallhart!"
  DATA "                 ---"
  DATA *
  spiel_regeln_nl:
  DATA "               Ti_FROGs"
  DATA "is een dobbelspel voor twee personen."
  DATA
  DATA "Het doel van het spel :"
  DATA "proberen om als eerste al je kikkers"
  DATA "naar de overkant te brengen."
  DATA
  DATA "De dobbelsteen bepaalt"
  DATA "hoe ver je hoogstens kunt springen"
  DATA "en zelf wijs je aan (met de muis)"
  DATA "WELKE van jouw kikkers moet springen."
  DATA
  DATA "Je kunt alleen springen naar een hokje"
  DATA "dat vrij is. Als je naar een hokje"
  DATA "probeert te springen dat bezet is,"
  DATA "ben je de punten kwijt."
  DATA "Goed opletten, dus !"
  DATA
  DATA "MAAR : naar een hokje aan de rand"
  DATA "       kun je altijd springen."
  DATA "Als daar nog een kikker zit, heeft ie"
  DATA "pech gehad, want nu zit ie gevangen."
  DATA "Je tegenstander moet nu eerst 6"
  DATA "gooien om hem weer vrij te krijgen, en"
  DATA "dan gaat ie nïg maar 1 hokje vooruit !"
  DATA
  DATA "Als je bij de rand aan de overkant"
  DATA "nog punten ïver hebt ben je die"
  DATA "gewoon kwijt."
  DATA
  DATA "' 6 -> nog eens' betekent :"
  DATA "als je 6 gooit mag je nog een keer."
  DATA "(behalve als je op een"
  DATA " bezet hokje springt, sufkop !)"
  DATA
  DATA "Als de eerste speler al zijn kikkers"
  DATA "aan de overkant heeft moet de tweede"
  DATA "speler toch nog ÇÇn keer zetten :"
  DATA "misschien wordt het nog gelijkspel."
  DATA
  DATA "Als geen van je kikkers kan springen"
  DATA "moet je er toch eentje aanklikken"
  DATA "vïïr de andere speler verder kan gaan."
  DATA
  DATA "Als er niemand is om tegen te spelen,"
  DATA "wil de computer wel meedoen."
  DATA "Hij houdt zich natuurlijk aan de spel-"
  DATA "regels, maar hij wil wel winnen !"
  DATA
  DATA "                 ---"
  DATA *
RETURN
PROCEDURE bei.6.weiter
  bei_6_nochmal!=NOT bei_6_nochmal!
  @abhaken.bei.6
RETURN
PROCEDURE abhaken.bei.6
  IF bei_6_nochmal!
    MID$(pw2$(4),1)=""
  ELSE
    MID$(pw2$(4),1)=" "
  ENDIF
RETURN
PROCEDURE mitspieler
  mitspieler&=wahl&-4
  @abhaken.mitspieler
RETURN
PROCEDURE abhaken.mitspieler
  FOR ni&=6 TO 7
    IF ni&=mitspieler&+4
      MID$(pw2$(ni&),1)=""
    ELSE
      MID$(pw2$(ni&),1)=" "
    ENDIF
  NEXT ni&
RETURN
'
PROCEDURE spielen
  genug_gespielt!=FALSE
  REPEAT
    @set.bild
    @spiel.vorbereiten
    @set.wahl.neu
    SHOWM
    @no.but
    REPEAT
      @wuerfeln
      ON spieler& GOSUB spieler.spiel,spieler.spiel,computer.spiel
      IF NOT spiel_abbruch!
        @test.auf.spielende
        IF NOT darf_nochmal!
          SWAP spieler&,gegner&
        ENDIF
      ENDIF
    UNTIL spiel_ende! OR spiel_abbruch!
    IF NOT spiel_abbruch!
      @sieger.ehrung
    ENDIF
  UNTIL genug_gespielt!
RETURN
PROCEDURE set.bild
  @clean
  LOCAL li&,ob&,re&,un&
  FOR zl&=1 TO zl_z&
    ob&=yp&(zl&)-vf&
    un&=ob&+frog_ho&+v_di&
    FOR sp&=1 TO sp_z&
      li&=xp&(sp&)-hf&
      re&=li&+frog_br&+h_di&
      IF zl&<zl_z&
        BOUNDARY TRUE
        DEFFILL 1,1
        PBOX li&,ob&,re&,un&
        BOUNDARY FALSE
        DEFFILL 0,1
        PBOX xp&(sp&),yp&(zl&),xp&(sp&)+frog_br&,yp&(zl&)+frog_ho&
      ENDIF
    NEXT sp&
  NEXT zl&
  GET xp&(2),yp&(1),xp&(2)+frog_br&,yp&(1)+frog_ho&,leer$
  '
  BOUNDARY TRUE
  DEFFILL 1,1
  ob&=yp&(zl_z&)-vf&
  un&=ob&+frog_ho&+v_di&
  li&=xp&(1)-hf&
  re&=xp&(sp_z&)-hf&+frog_br&+h_di&
  PBOX li&,ob&,re&,un&
  BOUNDARY FALSE
  DEFFILL 0,1
  PBOX xp&(1),yp&(zl_z&),xp&(sp_z&)+frog_br&,yp&(zl_z&)+frog_ho&
  '
  @set.titel("Ti_FROGs")
  GRAPHMODE 4
  TEXT x_esl&,y_kz&,SPACE$(3+2*hf&)
  GRAPHMODE 3
  TEXT x_esl&+8*hf&,y_kz&,"ESC"
  GRAPHMODE 1
RETURN
PROCEDURE spiel.vorbereiten
  spieler&=1
  gegner&=mitspieler&
  computer!=(mitspieler&=3)
  ARRAYFILL pos&(),0
  ARRAYFILL am_ziel&(),0
  FOR zl&=1 TO fr_z&  !Frîsche setzen und Position merken !<<
    PUT xp&(1),yp&(zl&),frog_1$
    PUT xp&(sp_z&),yp&(zl&),frog_2$
    pos&(zl&,spieler&)=1
    pos&(zl&,gegner&)=sp_z&
  NEXT zl&
  spiel_abbruch!=FALSE
  spiel_ende!=FALSE
  last_chance!=FALSE
RETURN
PROCEDURE wuerfeln
  HIDEM
  sf&=ABS(pos&(zl_z&,spieler&))  !da sitzt der Spieler
  gf&=ABS(pos&(zl_z&,gegner&))   !und da der Gegner
  IF spieler&=1
    frog$=frog_1$
    w_p&=sp_z&    !von rechts
    w_d&=-1       !nach links
  ELSE
    frog$=frog_2$
    w_p&=1        !von links
    w_d&=1        !nach rechts
  ENDIF
  IF ox&
    PUT ox&,oy&,w0$  !alten WÅrfel weg
  ENDIF
  FOR ni&=2 TO sp_z&
    ADD w_p&,w_d&
    wurf&=RANDOM(6)+1
    ox&=xp&(w_p&)
    oy&=yp&(zl_z&)
    GET ox&,oy&,ox&+frog_br&,oy&+frog_ho&,w0$  !Hintergrund retten
    PUT ox&,oy&,wz$(wurf&)  !WÅrfel hin
    SOUND 1,15,1,1,1  !klack
    SOUND 1,0
    PAUSE 3
    IF ni&<sp_z&  !nur der letzte bleibt liegen
      PUT ox&,oy&,w0$  !alten WÅrfel weg
    ENDIF
  NEXT ni&
  IF wurf&=6 AND bei_6_nochmal!
    darf_nochmal!=TRUE
  ELSE
    darf_nochmal!=FALSE
  ENDIF
  SHOWM
RETURN
PROCEDURE spieler.spiel
  LOCAL gezogen!
  REPEAT
    @get.tom
    IF mk&
      @get.position
      IF position!
        @mach.den.zug
        gezogen!=TRUE
      ENDIF
    ELSE IF scan|=1
      @wahl.genug
    ENDIF
  UNTIL gezogen! OR spiel_abbruch!
RETURN
PROCEDURE get.position
  position!=FALSE
  IF mx&>f_li& AND mx&<f_re& AND my&>f_ob& AND my&<f_un&  !Feld
    sp&=0
    zl&=0
    ni&=1  !Spalte suchen
    REPEAT
      IF mx&>xp&(ni&) AND mx&<xp&(ni&)+frog_br&
        sp&=ni&
      ELSE
        INC ni&
      ENDIF
    UNTIL ni&>sp_z& OR sp&
    IF sp&
      ni&=1  !Zeile suchen
      REPEAT
        IF my&>yp&(ni&) AND my&<yp&(ni&)+frog_ho&
          zl&=ni&
        ELSE
          INC ni&
        ENDIF
      UNTIL ni&>fr_z& OR zl& !<<
      IF zl&
        position!=(pos&(zl&,spieler&)=sp&)  !sitzt er dort? (und macht noch mit)
      ENDIF
    ENDIF
  ELSE IF my&<y_kl&
    SELECT mx&
    CASE x_esl& TO x_esr&
      @wahl.genug
    CASE x_til& TO x_tir&
      @wahl.neu
    ENDSELECT
  ENDIF
RETURN
PROCEDURE mach.den.zug
  LOCAL darf_springen!
  sp&=pos&(zl&,spieler&)   !da sitzt der Spieler
  g_sp&=pos&(zl&,gegner&)  !da sitzt der Gegner
  IF sp&=-g_sp&            !eingeklemmt
    IF wurf&=6
      darf_springen!=TRUE
      wurf&=1              !aber nur 1 Feld
      IF spieler&=1
        z_sp&=2
      ELSE
        z_sp&=sp_z&-1
      ENDIF
    ENDIF
  ELSE
    IF spieler&=1
      z_sp&=MIN(sp_z&,sp&+wurf&)  !nicht rechts Åber den Rand
      IF z_sp&=sp_z& OR z_sp&<>pos&(zl&,gegner&)  !Rand oder freies Feld
        darf_springen!=TRUE
      ENDIF
    ELSE
      z_sp&=MAX(1,sp&-wurf&)  !nicht links Åber den Rand
      IF z_sp&=1 OR z_sp&<>pos&(zl&,gegner&)  !Rand oder freies Feld
        darf_springen!=TRUE
      ENDIF
    ENDIF
  ENDIF
  PUT xp&(w_p&),yp&(zl_z&),leer$  !WÅrfel weg
  PUT xp&(sp&),yp&(zl&),frog$,12  !Frosch invertieren
  IF darf_springen!
    @dann.spring
  ELSE
    @dann.bleib
  ENDIF
RETURN
PROCEDURE dann.spring
  WAVE 2569,1,15,800  !zisch
  IF (spieler&=1 AND z_sp&=sp_z&) OR (spieler&>1 AND z_sp&=1)
    pos&(zl&,spieler&)=-z_sp&  !springt nicht mehr mit
    INC am_ziel&(spieler&)
  ELSE
    pos&(zl&,spieler&)=z_sp&   !Position merken
  ENDIF
  PAUSE 8
  PUT xp&(sp&),yp&(zl&),leer$         !Frosch weg
  IF sp&=1 AND g_sp&=-1               !links sitzt noch einer
    PUT xp&(sp&),yp&(zl&),frog_2$     !alten Frosch wieder hin
    PUT xp&(z_sp&),yp&(zl&),frog$     !Frosch an neue Position
  ELSE IF sp&=sp_z& AND g_sp&=-sp_z&  !rechts sitzt noch einer
    PUT xp&(sp&),yp&(zl&),frog_1$     !alten Frosch wieder hin
    PUT xp&(z_sp&),yp&(zl&),frog$     !Frosch an neue Position
  ELSE IF z_sp&=sp_z& AND g_sp&=sp_z&
    PUT xp&(z_sp&),yp&(zl&),frog$,6   !auf ihn
    WAVE 0,0
    @pup
  ELSE IF z_sp&=1 AND g_sp&=1
    PUT xp&(z_sp&),yp&(zl&),frog$,6   !auf ihn
    WAVE 0,0
    @pup
  ELSE
    PUT xp&(z_sp&),yp&(zl&),frog$     !Frosch an neue Position
  ENDIF
  WAVE 0,0  !shut up
RETURN
PROCEDURE dann.bleib
  @pup
  darf_nochmal!=FALSE
  PAUSE 10
  IF sp&=1 AND g_sp&=-1               !links sitzen zwei
    PUT xp&(sp&),yp&(zl&),frog_1$     !1.Frosch hin
    PUT xp&(sp&),yp&(zl&),frog_2$,6   !2.Frosch drauf
  ELSE IF sp&=sp_z& AND g_sp&=-sp_z&  !rechts sitzen zwei
    PUT xp&(sp&),yp&(zl&),frog_1$     !1.Frosch hin
    PUT xp&(sp&),yp&(zl&),frog_2$,6   !2.Frosch drauf
  ELSE
    PUT xp&(sp&),yp&(zl&),frog$       !Frosch wieder hin
  ENDIF
RETURN
PROCEDURE pup
  LOCAL per%,dif%
  per%=2400
  dif%=60
  PAUSE 2
  REPEAT
    SOUND 1,15,#per%,0
    ADD per%,dif%
    DEC dif%
  UNTIL per%>4000
  SOUND 1,0,0,0,0  !a Ruh is
  PAUSE 10
RETURN
PROCEDURE test.auf.spielende
  IF spieler&=1
    IF am_ziel&(spieler&)=fr_z&  !alle am Ziel !<<
      darf_nochmal!=FALSE        !geht ja nicht
      @gong
      last_chance!=TRUE          !fÅr den zweiten Spieler
    ENDIF
  ELSE
    IF am_ziel&(spieler&)=fr_z&  !alle am Ziel !<<
      spiel_ende!=TRUE
    ELSE IF last_chance! AND NOT darf_nochmal!  !merde
      spiel_ende!=TRUE                          !rien ne va plus
    ENDIF
  ENDIF
RETURN
PROCEDURE gong
  LOCAL level%
  FOR level%=15 DOWNTO 0
    SOUND 1,level%,8,5,1
  NEXT level%
RETURN
'
PROCEDURE computer.spiel
  PAUSE zeit&(aus_zeit&)
  @suche.beste.zeile
  @mach.den.zug
RETURN
PROCEDURE suche.beste.zeile
  '  Spielweise:
  '    nutzt Angriffsmîglichkeiten
  '    geht aber kein Risiko ein
  LOCAL best_zl&,wert_max&,bon&
  ARRAYFILL wert&(),0
  FOR zl&=1 TO zl_z&
    sp&=pos&(zl&,spieler&)    !da sitzt er selbst
    IF sp&>0                  !noch im Spiel
      bon&=1                    !fÅr's Mitmachen
      z_sp&=MAX(1,sp&-wurf&)    !da kommt er hin
      g_sp&=pos&(zl&,gegner&)   !da sitzt der Gegner
      IF z_sp&=1 AND g_sp&=1    !das paût
        ADD bon&,99               !einklemmen  (=>100)
      ELSE IF z_sp&<>g_sp&      !frei
        INC bon&                  !fÅr's freie Feld (=>2)
        IF sp&=sp_z&              !noch am Start
          IF g_sp&<0                !shit, eingeklemmt
            IF wurf&=6                !GlÅck gehabt
              ADD bon&,200              !nun aber raus
            ENDIF
          ELSE                      !je nÑher, desto Vorsicht
            ADD bon&,g_sp&*2          !bleibt bis 3 < 100 (2 ZÅge erforderlich)
            ADD bon&,91               !=>95-97-99/101..129
          ENDIF
        ELSE                      !unterwegs
          IF z_sp&=1                !Ziel
            IF (sp&-wurf&)=1
              ADD bon&,30             !+30 (paût genau)
            ELSE
              ADD bon&,10+sp&-wurf&   !+6..11 (nichts verschenken)
            ENDIF
          ELSE IF sp&>7             !ein Sprung reicht nicht
            IF z_sp&<8
              ADD bon&,12+sp&         !+20..21 (mach voran)
            ELSE
              ADD bon&,4              !+4 (bringt nicht viel)
            ENDIF
          ELSE
            ADD bon&,9+sp&-z_sp&      !+10..14
          ENDIF
          IF sp&<g_sp&              !Gegner schon vorbei
            ADD bon&,2
          ENDIF
          IF z_sp&>g_sp&            !nur nicht hudeln
            INC bon&
          ENDIF
          IF g_sp&=1                !Gegner noch zuhause
            ADD bon&,38-z_sp&         !+30..36 (je nÑher, desto Attacke)
          ENDIF
        ENDIF
      ENDIF
      ADD wert&(zl&),bon&
      IF wert&(zl&)>wert_max&
        wert_max&=wert&(zl&)
        best_zl&=zl&
      ENDIF
    ENDIF
  NEXT zl&
  zl&=best_zl&
RETURN
'
PROCEDURE sieger.ehrung
  LOCAL fertig!
  IF computer!
    IF am_ziel&(1)=fr_z& AND am_ziel&(3)=fr_z&
      IF taal$="NL"
        RESTORE spiel_unentschieden_nl
      ELSE
        RESTORE spiel_unentschieden_d
      ENDIF
      @get.kommentar(2,sp_u$)
    ELSE IF am_ziel&(1)=fr_z&
      IF taal$="NL"
        RESTORE spiel_gewonnen_nl
      ELSE
        RESTORE spiel_gewonnen_d
      ENDIF
      @get.kommentar(6,sp_g$)
    ELSE
      IF taal$="NL"
        RESTORE spiel_verloren_nl
      ELSE
        RESTORE spiel_verloren_d
      ENDIF
      @get.kommentar(3,sp_v$)
    ENDIF
  ELSE  !Mitspieler
    @dreiklang.rauf
    REPEAT
      @get.tom
      IF mk&
        IF my&<y_kl&
          SELECT mx&
          CASE x_esl& TO x_esr&
            fertig!=TRUE
            genug_gespielt!=TRUE
          CASE x_til& TO x_tir&
            fertig!=TRUE
          ENDSELECT
        ENDIF
      ELSE IF scan|=1
        fertig!=TRUE
        genug_gespielt!=TRUE
      ENDIF
    UNTIL fertig!
  ENDIF
  '
  spiel_unentschieden_nl:
  DATA 1,
  DATA " Het was je bijna gelukt ! ",,*
  DATA 2,
  DATA " Dat ging nät niet door, hä ? ",,*
  DATA 3,
  DATA "En waar hebben we nu"
  DATA " de hele tijd voor gespeeld ? ",,*
  DATA 4,
  DATA "Weet jij nog"
  DATA " waar het om begonnen was ? ",,*
  DATA 5,
  DATA " Heeft een van ons tweeân "
  DATA "even niet goed opgelet ?",,*
  '
  spiel_unentschieden_d:
  DATA 1,
  DATA " Du hast es fast geschafft! ",,*
  DATA 2,
  DATA " Das hat wohl nicht "
  DATA "so ganz geklappt",,*
  DATA 3,
  DATA "Und wozu haben wir nun"
  DATA " die ganze Zeit gespielt? ",,*
  DATA 4,
  DATA "Weiût Du, wozu wir"
  DATA " eigentlich spielen? ",,*
  DATA 5,
  DATA "Hat da einer von uns"
  DATA " etwa nicht aufgepaût? ",,*
  '
  spiel_gewonnen_nl:
  DATA 1,
  DATA " Jij hebt gewonnen."
  DATA "Proficiat !",,*
  DATA 2,
  DATA "Wat had je weer"
  DATA " een hoop geluk ! ",,*
  DATA 3,
  DATA " Ik heb zeker ään momentje "
  DATA "niet goed opgelet ...",,*
  DATA 4,
  DATA " Neem me niet kwalijk "
  DATA "dat ik verloren heb.",,*
  DATA 5,
  DATA " Bah! Jij speelt volgens mij "
  DATA "alleen om te winnen !",,*
  DATA 6,
  DATA "Waarom laat je mij"
  DATA " ook niet een keer winnen ? ",,*
  DATA 7,
  DATA " Dat vind ik niet eerlijk ! "
  DATA "Jij wint gewoon.",,*
  DATA 8,
  DATA "Ja, met veel geluk"
  DATA " kan iederään winnen ! ",,*
  DATA 9,
  DATA "Maar eigenlijk had ik"
  DATA " toch bijna gewonnen ... ",,*
  DATA 10,
  DATA "Moet je weer"
  DATA " per se winnen ? ",,*
  DATA 11,
  DATA "Ik heb verloren !"
  DATA " Jij was gewoon beter. ",,*
  DATA 12,
  DATA " Ja, op deze manier is er "
  DATA "geen lol meer aan !",,*
  DATA 13,
  DATA "Ik weet niet zeker, of ik"
  DATA " zï nog wel verder wil spelen. ",,*
  DATA 14,
  DATA " Ik begin te denken, dat je mij "
  DATA "gewoon niet wilt laten winnen.",,*
  DATA 15,
  DATA "Okay, jij mag ook"
  DATA " wel een keertje winnen. ",,*
  DATA 16,
  DATA "Ik was bang, dat je zou gaan"
  DATA " huilen, als je niet zou winnen. ",,*
  DATA 17,
  DATA " Als jij gespeeld had zoals ik, "
  DATA "dan had je ook verloren.",,*
  DATA 18,
  DATA "Je hebt geluk, dat ik"
  DATA " vandaag niet zo in vorm ben ! ",,*
  '
  spiel_gewonnen_d:
  DATA 1,
  DATA "Du hast"
  DATA "(leider)"
  DATA " gewonnen! ",,*
  DATA 2,
  DATA "Da hast Du aber"
  DATA " viel GlÅck gehabt ",,*
  DATA 3,
  DATA " Ich hab wohl einen Moment "
  DATA "nicht richtig aufgepaût",,*
  DATA 4,
  DATA "Entschuldige bitte,"
  DATA " daû ich verloren habe. ",,*
  DATA 5,
  DATA "Pfui!"
  DATA "Du spielst ja"
  DATA " um zu gewinnen. ",,*
  DATA 6,
  DATA "Warum lÑût Du mich"
  DATA " nicht mal gewinnen? ",,*
  DATA 7,
  DATA " Das find ich aber unfair! "
  DATA "Du gewinnst ja einfach.",,*
  DATA 8,
  DATA "Na mit viel GlÅck"
  DATA " kann ja jeder gewinnen! ",,*
  DATA 9,
  DATA " Eigentlich hÑtte ich ja "
  DATA "fast gewonnen.",,*
  DATA 10,
  DATA " Muût Du unbedingt "
  DATA "gewinnen?",,*
  DATA 11,
  DATA " Du verlierst wohl "
  DATA "nicht gern?",,*
  DATA 12,
  DATA " Du verdirbst einem "
  DATA "ja jeden Spaû!",,*
  DATA 13,
  DATA "Ich frage mich,"
  DATA "ob ich mit Dir"
  DATA " noch spielen soll. ",,*
  DATA 14,
  DATA " Ich glaube, Du willst mich "
  DATA "nicht gewinnen lassen.",,*
  DATA 15,
  DATA " Na gut, Du muût ja "
  DATA "auch mal gewinnen.",,*
  DATA 16,
  DATA "Ich konnte Dir"
  DATA " einfach nicht wehtun. ",,*
  DATA 17,
  DATA " HÑttest Du wie ich gespielt, "
  DATA "hÑttest Du auch verloren.",,*
  DATA 18,
  DATA " Du hast GlÅck, daû es mir "
  DATA "heut' nicht so gut geht.",,*
  '
  spiel_verloren_nl:
  DATA 1,
  DATA "Hoera !"
  DATA " Jij hebt verloren ! ",,*
  DATA 2,
  DATA " Dat wist ik van te voren al "
  DATA "dat jij zou verliezen.",,*
  DATA 3,
  DATA "Had jij soms gedacht"
  DATA " dat je kon winnen ?!? ",,*
  DATA 4,
  DATA "Sorry,"
  DATA " volgende beter. ",,*
  DATA 5,
  DATA " Dacht je soms ... ? "
  DATA "Mooi niet !",,*
  DATA 6,
  DATA "Volhouden,"
  DATA " jij wint ook nog wel een keer ! ",,*
  DATA 7,
  DATA "Zo, daar heb je wel"
  DATA " je buik van vol hä !? ",,*
  DATA 8,
  DATA " Ja, als je zï speelt,"
  DATA " win ik natuurlijk.",,*
  DATA 9,
  DATA " Je doet toch nog wel mee ? ",,*
  DATA 10,
  DATA " Volgende keer verlies ik, "
  DATA "misschien ...",,*
  '
  spiel_verloren_d:
  DATA 1,
  DATA "Hurra!"
  DATA " Du hast verloren! ",,*
  DATA 2,
  DATA " Das war mir klar, "
  DATA "daû Du verlierst.",,*
  DATA 3,
  DATA "Hast Du etwas"
  DATA " anderes erwartet? ",,*
  DATA 4,
  DATA "War doch klar,"
  DATA " daû ich gewinne. ",,*
  DATA 5,
  DATA " Du hast wohl gedacht..? "
  DATA "War aber nicht!",,*
  DATA 6,
  DATA " Wolltest Du etwa "
  DATA "gewinnen ???",,*
  DATA 7,
  DATA " Na, das ging wohl "
  DATA "in die Hose!?",,*
  DATA 8,
  DATA " Ja, wenn Du so spielst, "
  DATA "gewinne ich natÅrlich.",,*
  DATA 9,
  DATA " Du wÅrfelst aber auch!? ",,*
  DATA 10,
  DATA " Du muût mich auch mal "
  DATA "verlieren lassen.",,*
RETURN
PROCEDURE get.kommentar(rz&,VAR km$)
  ' ( rz& ist nur etwa ein Drittel der Zahl der zugehîrigen Kommentare )
  LOCAL zp&,zz&,kr&,test$
  '  Zufallsposition zp& aus rz&...
  zp&=RANDOM(rz&)*2+1
  '  und Teil rechts davon ermitteln
  kr&=LEN(km$)-zp&-1
  '  entsprechende Zahl lesen
  zz&=VAL(MID$(km$,zp&,2))
  '  und ans Ende schieben, um schnelle Wiederholung zu vermeiden
  km$=LEFT$(km$,zp&-1)+RIGHT$(km$,kr&)+MID$(km$,zp&,2)
  '  READ-Pointer fÅr pop.info stellen
  REPEAT
    READ test$
  UNTIL VAL(test$)=zz&
  '  ... bis die Zahl gefunden ist
  @pop.info(0,0,TRUE,TRUE,60)
RETURN
PROCEDURE dreiklang.rauf
  LOCAL level%
  SOUND 1,15,1,4,4
  SOUND 1,15,5,4,4
  SOUND 1,15,8,4,4
  FOR level%=15 DOWNTO 0
    SOUND 1,level%,8,5,5
  NEXT level%
RETURN
'
' === Ti ===
