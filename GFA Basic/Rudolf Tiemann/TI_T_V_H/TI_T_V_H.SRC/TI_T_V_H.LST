' ============================================================
'    Ti_T_V_H
' D:
'    Dieses Listing darf ausschlieûlich privat benutzt werden.
'    Wenn Sie mehr wollen, wenden Sie sich an den Autor.
'    Wenn Sie das Programm verÑndern, schicken Sie dem Autor
'    bitte ein Belegexemplar.
' NL:
'    De listing mag alleen strikt privÇ gebruikt worden.
'    Wilt u meer neem dan kontakt op met de auteur.
'    Ook wanneer u voor eigen gebruik veranderingen aanbrengt
'    wordt hij graag op de hoogte gehouden.            GfA gg.
'
INLINE rat_spr%,74
' D:
'    Ratte als Sprite (funktioniert in allen Auflîsungen)
'    Wenn das LST-File mit Merge geladen wird,
'    muû das INLINE mit HELP nachgeladen werden!
' NL:
'    Rat (muisje ?) als Sprite (werkt in alle resoluties)
'    Als het LST-file met Merge geladen wordt,
'    moet de INLINE met HELP nageladen worden !
' ============================================================
'       Label und VormenÅ zur Wahl der Sprache:
1.wahl:
DATA
DATA "  V.:  3.O / O6.12.91  "
DATA "(public domain)"
DATA "Ω"
DATA "Rudolf Tiemann"
DATA "Tel.: O6733-62O5"
DATA "Donnersbergstr.14"
DATA "65O9 Gau-Odernheim"
DATA "(West Germany)"
DATA
DATA *
DATA "",""
DATA "Deutsch","032"
DATA "Nederlands","049"
DATA "",""
DATA "    Escape    ","001"
DATA "",""
DATA *,""
'
prg_daten:
DATA "Ti_T_V_H.PRG"
DATA "=44669 Bytes ΩTi"
' D:
'    ->^^^^^^<- hier drÅber muû nach dem 1.Compilieren
'    linksbÅndig die genaue Grîûe eingetragen werden,
'    dann folgt das endgÅltige 2.Compilieren
'    (wichtig fÅr den Linkvirentest)
' NL:
'    ->^^^^^^<- hierboven moet na de eerste keer compileren
'    links-aangeschoven de exacte grootte aangegeven worden.
'    Pas daarna kan definitief gecompileerd worden.
'    (i.v.m. Linkvirustest)
'
'   > Compiler-Anweisungen:
$S&  !2-Byte-Select-Parameter
$S<  !Select optimieren auf LÑnge
$P>  !Procedures: als GFA-Routinen
$%3  !IntDiv immer als Integer
$*%  !LongMul nicht mit MULS
$B+  !Meldung statt Bomben
$E$  !Fehler-Texte  (fÅr Routine 'shit')
$C+  !bei C:-Aufrufen Register auf Stack retten und restaurieren
'     auûerdem bei 'low resolution' verwenden! (Compiler-Fehler ???)
$I+  !Interrupt zulassen
' $U+  !hinter jedem Befehl C&S&A, EVERY, AFTER prÅfen
'
' ===========================================================
'
@pre.set
'
neu_start:
ON ERROR GOSUB shit
DO
  @1.wahl
LOOP
END
'
' ===========================================================
'
PROCEDURE pre.set
  '  Die Positionen werden gewîhnlich so angegeben,
  '  daû sie fÅr die niedrige Auflîsung stimmen.
  '  Sie werden vom Programm mittels der Faktoren
  '  hf& und vf& an die aktuelle Auflîsung angepaût.
  '
  '  Variablen mit zwei oder drei Zeichen+Suffix sind
  '  LOCAL deklariert oder haben nur lokale Bedeutung
  '  z.B. Laufvariable  ni&  etc.
  '   Ausnahmen:  Adreû-Variablen mit Suffix % (local)
  '  Globale Variablen haben mindestens vier Zeichen.
  '   Ausnahmen:  alf&, hf&, vf&, mx&, my&, mk&
  '
  MENU KILL
  DEFMOUSE 2
  SHOWM
  old_484|=PEEK(&H484)             !Einstellung retten
  SPOKE &H484,BCLR(PEEK(&H484),0)  !T-Klick aus
  SPOKE &H484,BSET(PEEK(&H484),1)  !Key-rep ein
  SPOKE &H484,BCLR(PEEK(&H484),2)  !Klingel aus
  alf&=XBIOS(4)   !0 1 2
  hf&=2+(alf&<1)  !1 2 2 Horizontalfaktor
  vf&=2+(alf&<2)  !1 1 2 Vertikalfaktor
  h_max&=WORK_OUT(0)
  v_max&=WORK_OUT(1)
  CLIP 0,0 TO h_max&,v_max&  !Clipping richtig(!) setzen
  CLS
  y_kzl&=7*vf&         !y Kopfzeile
  y_kln&=y_kzl&+2+vf&  !y Kopflinie
  h_br&=h_max&+1       !horizontal Breite
  v_ho&=v_max&+1       !vertikal Hîhe
  h_mid&=h_max&\2      !h-
  v_mid&=v_max&\2      !v-Mitte
  y_rel&=4*vf&
  top_pal$=""          !Farbpalette des Desktop
  @get.palette(top_pal$)  !retten
  check!=TRUE          !fÅr Linvirentest
  ratte$=SPACE$(74)
  BMOVE rat_spr%,V:ratte$,74
  '  programmspezifisch:
  @pre.set.special
  @set.farben
  @set.grafik.normal
  @set.1.wahl
  DEFMOUSE 0
RETURN
PROCEDURE pre.set.special
  DIM bild%(32255/4)    !Platz fÅr 2.Bildschirm reservieren
  scr_1%=XBIOS(3)       !Adresse des logischen (=physikalischen) Bildschirms
  scr_2%=(VARPTR(bild%(0))+255) AND NOT &HFF  !Adr.: 2.Bildschirm (\256)
  sp_z&=3               !Spaltenzahl
  zl_z&=8               !Zeilenzahl
  sp_mod&=sp_z&+1
  zug_max&=2^(zl_z&+1)  !128
  '
  DIM platz&(sp_z&,zl_z&)
  DIM hoehe&(sp_z&)
  DIM x_pl&(sp_z&)
  DIM y_pl&(zl_z&)
  DIM platte$(zl_z&)
  DIM zug_of&(zug_max&)
  DIM zug_to&(zug_max&)
  '
  fd_xd&=100*hf&        !Spaltenbreite
  fd_xofs&=h_mid&-(fd_xd&*(sp_z&+2)\2)
  pl_br&=96*hf&         !Plattenbreite
  pl_xdi&=-pl_br&\2
  xd&=(fd_xd&-pl_br&)\2
  pl_xofs&=fd_xofs&+xd&
  fd_yd&=16*vf&         !Zeilenhîhe
  pl_ydi&=-fd_yd&\2
  pl_ho&=fd_yd&-2       !Plattenhîhe
  unten&=185*vf&
  '  Platten-Positionen
  xi&=fd_xofs&+xd&
  FOR ni&=1 TO sp_z&
    ADD xi&,fd_xd&
    x_pl&(ni&)=xi&
  NEXT ni&
  yi&=unten&
  FOR ni&=1 TO zl_z&
    SUB yi&,fd_yd&
    y_pl&(ni&)=yi&
  NEXT ni&
  '
  bn_l&=4+2*hf&         !ButtonlÑnge
  x_esc&=bn_l&*8+1      !ESC
  x_hlp&=h_max&-x_esc&  !HELP
  x_eaw&=10*hf&
  x_haw&=h_br&-x_eaw&-109
  y_kaw&=19*vf&
  y_std&=21*vf&  !21*vf&+2
  y_pwo&=34*vf&
  '  Defaults
  level&=5
  start&=1  !Start-Stapel
RETURN
PROCEDURE get.palette(VAR pal$)
  pal$=""
  FOR ni&=0 TO 15
    pal$=pal$+MKI$(XBIOS(7,ni&,-1))
  NEXT ni&
RETURN
PROCEDURE set.farben
  IF alf&=2
    VSETCOLOR 0,7,7,7  !weiû
  ELSE
    VSETCOLOR 0,6,6,6  !dunkelweiû
    VSETCOLOR 1,0,0,0  !schwarz
    VSETCOLOR 2,7,0,0  !rot
    VSETCOLOR 3,3,4,5  !stahlblau
  ENDIF
RETURN
'
PROCEDURE test.virus
  LOCAL pad$,prg$,pln$,it$,prg_len%,dat_len%,bnr&
  pad$=CHR$(GEMDOS(25)+65)+":"+DIR$(0)
  IF RIGHT$(pad$,1)<>"\"
    pad$=pad$+"\"
  ENDIF
  RESTORE prg_daten
  READ prg$,pln$
  prg$=pad$+prg$
  prg_len%=VAL(MID$(pln$,2))
  IF EXIST(prg$)
    OPEN "I",#1,prg$
    dat_len%=LOF(#1)
    CLOSE #1
    IF dat_len%<prg_len%
      it$="[3][ | | ???  ERROR  ???     | ][  EXIT  ]"
      @show.alert(1,it$,bnr&)
      @short.exit
    ELSE IF dat_len%>prg_len%
      it$="[3][ | |  !!!  LINKVIRUS  !!!      | ][  KILL  |EXIT]"
      @show.alert(1,it$,bnr&)
      IF bnr&=1
        @kill.virus
      ENDIF
      @short.exit
    ENDIF
  ELSE
    @show.warnung
  ENDIF
RETURN
PROCEDURE kill.virus
  LOCAL prg_adr%,m_frei%
  it$="[3][ | MALLOC-ERROR!      | ][  shit  ]"
  m_frei%=(prg_len%+255) AND &HFFFF00  !durch 256 teilbar
  RESERVE -m_frei%
  prg_adr%=MALLOC(m_frei%)
  IF prg_adr%
    OPEN "I",#1,prg$
    BGET #1,prg_adr%,prg_len%
    CLOSE #1
    '  Null ans Ende schreiben, kînnte gelîscht sein
    POKE prg_adr%+prg_len%-1,0
    BSAVE prg$,prg_adr%,prg_len%
    prg_adr%=MFREE(prg_adr%)
    IF prg_adr%
      @show.alert(1,it$,bnr&)
    ENDIF
  ELSE
    @show.alert(1,it$,bnr&)
  ENDIF
  RESERVE  !wie vorher
RETURN
PROCEDURE show.warnung
  IF taal$="NL"
    it$="[3][ |  De test op een Link-virus |  kon niet (!)|"
    it$=it$+"  uitgevoerd worden. | ][  zeer verdacht !  ]"
  ELSE  !D
    it$="[3][ |  Der Linkvirentest       |   konnte nicht(!)|"
    it$=it$+" durchgefÅhrt werden| ][  sehr verdÑchtig!  ]"
  ENDIF
  @show.alert(1,it$,bnr&)
RETURN
PROCEDURE show.alert(bn&,VAR al$,ret&)
  @no.but
  @no.key
  DEFMOUSE 0
  SHOWM
  ret&=FORM_ALERT(bn&,al$)
  @no.but
  @no.key
RETURN
'
PROCEDURE ausgang
  ON ERROR                !damit's ein Ende hat
  SOUND 1,0,0,0,0         !Gib AIDA
  WAVE 0,0                !keine Chance
  ~XBIOS(6,L:V:top_pal$)  !alte Palette
  @set.grafik.normal
  @short.exit
RETURN
PROCEDURE short.exit
  SPOKE &H484,old_484|    !alte Einstellung
  CLS
  @no.but
  DEFMOUSE 0
  SHOWM
  EDIT
RETURN
'
PROCEDURE white.box(li&,ob&,re&,un&)
  @set.grafik.normal
  PBOX li&,ob&,re&,un&
RETURN
PROCEDURE clean
  '  fÅllt den Bildschirm (ohne Kopfzeile) mit "Hintergrund"
  ~FORM_DIAL(3,0,0,0,0,0,0,WORK_OUT(0),WORK_OUT(1))
RETURN
PROCEDURE zent(yit&,it$)
  '  zentriert den Text an der gewÅnschten y-Position
  TEXT h_mid&-LEN(it$)*4,yit&,it$
RETURN
PROCEDURE show.titel(it$)
  LOCAL lit&,xit&
  @white.box(-1,-1,h_br&,y_kln&)
  lit&=LEN(it$)
  IF lit&
    xit&=h_mid&-lit&*4
    GRAPHMODE 4
    TEXT xit&-8,y_kzl&,SPACE$(lit&+2)  !mit Rand
    GRAPHMODE 3
    TEXT xit&,y_kzl&,it$
    GRAPHMODE 1
  ENDIF
RETURN
PROCEDURE shit
  LOCAL it$,lit&,bnr&
  ON ERROR  !aus
  '
  ~XBIOS(5,L:scr_1%,L:scr_1%,-1)  !programmspezifisch
  '
  it$=ERR$(ERR)  !Original-Fehlermeldung
  lit&=RINSTR(it$,"[")
  '  "CONT"  und  "STOP"  statt  "Return"  schont den Reset-Knopf
  it$=LEFT$(it$,lit&)+"  CONT  |STOP]"
  @show.alert(2,it$,bnr&)
  IF bnr&=1
    RESUME neu_start
  ELSE
    @ausgang
  ENDIF
RETURN
'
PROCEDURE test.wahl(VAR pt_&,pw_&)
  LOCAL test$,dummy$
  pt_&=-1  !Info-Zeilen zÑhlen
  REPEAT
    INC pt_&
    READ test$
  UNTIL test$="*"
  pw_&=-1  !Wahl-Zeilen zÑhlen
  REPEAT
    INC pw_&
    READ test$,dummy$
  UNTIL test$="*"
RETURN
PROCEDURE read.wahl(VAR pt_&,pw_&,pt_$(),pw_$(),pk_$())
  LOCAL dummy$
  ni&=0
  WHILE ni&<pt_&
    INC ni&
    READ pt_$(ni&)
  WEND
  READ dummy$  !*=Info-Ende
  ni&=0
  WHILE ni&<pw_&
    INC ni&
    READ pw_$(ni&),pk_$(ni&)
  WEND
RETURN
'
PROCEDURE pop.wahl(li&,ob&,hoz!,vez!,mk2&,VAR pt_&,az_&,pt_$(),aw_$(),cd_$(),pw_&)
  '  li& / ob&   = links/oben
  '  hoz!/vez!   = horizontal/vertikal zentriert (relativ zur Position)
  '  pt_&/pt_$() = Infotext
  '  az_&/aw_$() = Auswahlzeilen
  '  lcd&/cd_$() = LÑnge/Scancodes (bzw. Textart)
  '         mk2& = Default fÅr rechten Mausknopf
  '         pw_& = gewÑhlt (RÅckmeldung)
  '
  LOCAL ai&,aw&,re&,un&,th&,tb&,td&,lzl&,lcd&,ax&,ay&,aw$,mi&,cd$,pop_pic$
  '
  th&=8*vf&                          !Texthîhe
  td&=9*vf&                          !Textdistanz (vertikal)
  tb&=8                              !Textbreite
  HIDEM
  SGET pop_pic$                      !Hintergrund retten
  @search.max.len(re&,az_&,aw_$())
  lzl&=re&*4+4                       !Info-LÑnge merken
  @search.max.len(re&,pt_&,pt_$())
  @pop.center
  @pop.box
  mi&=(li&+re&)\2
  li&=mi&-lzl&-1
  re&=mi&+lzl&
  ay&=ob&-td&\2+vf&
  ni&=0
  WHILE ni&<pt_&                     !Infozeilen
    ADD ay&,td&
    INC ni&
    lzl&=LEN(pt_$(ni&))
    IF lzl&
      ax&=mi&-lzl&*4                 !zentriert
      TEXT ax&,ay&,pt_$(ni&)
    ENDIF
  WEND
  IF ni&                             !wenn Infozeilen:
    ADD ay&,td&\2                    !1/2 Zeile frei
    DRAW li&-tb&,ay& TO re&+tb&,ay&  !Trennlinie
  ELSE                               !sonst:
    ADD ay&,td&\4                    !1/4 Zeile frei
  ENDIF
  ob&=ay&+td&\2-2*vf&                !Auswahl oben merken
  ni&=0
  WHILE ni&<az_&                     !Auswahlzeilen
    INC ni&
    ADD ay&,td&
    lcd&=LEN(cd_$(ni&))
    IF lcd&
      IF lcd&>2                      !Auswahl:
        DEFTEXT ,0                   !normal
      ELSE IF lcd&>0                 !Kommentar:
        DEFTEXT ,VAL(cd_$(ni&))      !~Textstil
      ELSE                           !Default:
        DEFTEXT ,4                   !kursiv
      ENDIF
      ax&=mi&-LEN(aw_$(ni&))*4       !zentrieren
      TEXT ax&,ay&,aw_$(ni&)
    ENDIF
  WEND
  un&=ay&+td&\2-2*vf&                !Auswahl unten merken
  GRAPHMODE 3                        !XOR
  DEFFILL 1,1                        !voll
  pw_&=0                             !gewÑhlt
  ay&=0                              !alt
  @no.but
  @no.key
  SHOWM
  REPEAT
    @get.tom
    IF scan|                         !Taste
      cd$=RIGHT$("00"+STR$(scan|),3)
    ELSE IF mk&=2                    !MK2
      pw_&=mk2&                      !Default-Wahl
      mk&=0                          !fÅr Anzeige
    ENDIF
    '                                !innerhalb
    IF mx&>li& AND mx&<re& AND my&>ob& AND my&<un&
      aw&=(my&-ob&)\td&+1
      IF mk&=1 AND LEN(cd_$(aw&))>2  !wÑhlbar   ( mk&=1 nur innerhalb! )
        pw_&=aw&                     !gewÑhlt
      ENDIF
      my&=aw&*td&+ob&-td&
      IF my&<>ay&                    !neu
        IF ay&                       !da war noch was
          PBOX li&,ay&,re&,ay&+th&   !alt weg
          ay&=0
        ENDIF
        IF LEN(cd_$(aw&))>2          !wÑhlbar
          PBOX li&,my&,re&,my&+th&   !neu hin
          ay&=my&                    !und merken
        ENDIF
        SHOWM
      ENDIF
    ELSE                             !auûerhalb
      IF ay&                         !da war was
        PBOX li&,ay&,re&,ay&+th&     !weg
      ENDIF
      ay&=0
    ENDIF
    IF scan|                         !Taste
      ai&=1
      REPEAT                         !suchen
        IF LEN(cd_$(ai&))>2          !wÑhlbar
          IF INSTR(cd_$(ai&),cd$)    !gefunden
            pw_&=ai&                 !gewÑhlt
          ENDIF
        ENDIF
        INC ai&
      UNTIL ai&>az_& OR pw_&
    ENDIF
  UNTIL pw_&                         !bis was gewÑhlt ist!
  IF mk&=0                           !Tastenwahl zeigen
    IF ay&                           !da war noch was
      PBOX li&,ay&,re&,ay&+th&       !alt weg
    ENDIF
    my&=pw_&*td&+ob&-td&
    PBOX li&,my&,re&,my&+th&         !neu hin
    PAUSE 10                         !kurz warten
  ENDIF
  @set.grafik.normal
  SPUT pop_pic$
  @no.but
RETURN
PROCEDURE search.max.len(VAR sl&,sz&,st$())
  ni&=0
  WHILE ni&<sz&
    INC ni&
    sl&=MAX(sl&,LEN(st$(ni&)))
  WEND
RETURN
'
PROCEDURE pop.info(li&,ob&,hoz!,vez!,sec%)
  LOCAL pt_&,az_&,ai&,re&,un&,td&,tb&,lzl&,ax&,ay&,mi&,az$,pop_pic$
  HIDEM
  SGET pop_pic$
  td&=9*vf&                          !Textdistanz (vertikal)
  tb&=8                              !Textbreite
  DIM az_$(22)                       !local array
  '  "pop.info" liest die Zeilen selbst ein.
  '  Der DATA-Pointer muû deshalb vorher von
  '  der aufrufenden Routine gestellt sein.
  REPEAT
    INC az_&
    READ az_$(az_&)
    lzl&=LEN(az_$(az_&))
    re&=MAX(re&,lzl&)                !lÑngsten Eintrag finden
  UNTIL az_$(az_&)="*"
  @pop.center
  DEC az_&
  @pop.box
  mi&=(li&+re&)\2
  ay&=ob&
  FOR ai&=1 TO az_&
    az$=az_$(ai&)
    lzl&=LEN(az$)
    ax&=mi&-lzl&*4
    ADD ay&,td&
    TEXT ax&,ay&,az$
  NEXT ai&
  ERASE az_$()                       !kann weg
  SPRITE ratte$,re&-10,un&-8
  @wart.mal(sec%*200)                !Beamtenmikado
  SPRITE ratte$,re&,un&
  VSYNC
  @set.grafik.normal
  SPRITE ratte$
  SPUT pop_pic$
  SHOWM
RETURN
PROCEDURE wart.mal(wt%)
  LOCAL ax&,ay&
  @no.key
  @no.but
  IF wt%<0
    wt%=12000   !Default max. 1 min warten
  ENDIF
  ADD wt%,TIMER
  ax&=MOUSEX
  ay&=MOUSEY
  REPEAT        !Beamtenmikado
    @get.tom
  UNTIL mk& OR scan| OR TIMER>wt% OR ABS(mx&-ax&)>20 OR ABS(my&-ay&)>20
  @no.but
RETURN
PROCEDURE pop.center
  MUL re&,tb&
  ADD re&,4
  un&=(pt_&+az_&)*td&
  '  Wenn hoz! (vez!) = TRUE, gibt li& (ob&)
  '  die relative Abweichung von der Mitte an,
  '  andernfalls die absolute Position
  '  der linken oberen Ecke.
  '  re& und un& wird berechnet und hÑngt
  '  von der Textbreite bzw. Zeilenzahl ab.
  '  Die Umrahmung (s. 'pop.box') geht jeweils
  '  um 7*hf& bzw. 7*vf& Åber diese Ecken hinaus.
  IF hoz!
    ADD li&,(h_br&-re&)\2
  ENDIF
  IF vez!
    ADD ob&,(v_ho&-un&)\2
  ENDIF
  ADD un&,ob&
  ADD re&,li&
RETURN
PROCEDURE pop.box
  @set.grafik.normal
  DEC li&
  PBOX li&-7*hf&,ob&-7*vf&,re&+7*hf&,un&+7*vf&
  BOX li&-5*hf&,ob&-5*vf&,re&+5*hf&,un&+5*vf&
  INC li&
  BOUNDARY FALSE
RETURN
PROCEDURE set.grafik.normal
  GRAPHMODE 1
  BOUNDARY TRUE
  COLOR 1
  DEFFILL 1,0,0
  DEFLINE 1,1,0,0
  DEFTEXT 1,0,0,7*vf&-1  !6/13
RETURN
PROCEDURE get.tom
  '  Taste oder Maustaste abliefern (nicht warten)
  MOUSE mx&,my&,mk&
  KEYTEST key%
  IF key%
    scan|=AND(key%,&HFF0000)\&HFFFF
    @no.key
    mk&=0
  ELSE
    scan|=0
  ENDIF
RETURN
PROCEDURE no.key
  '  Tastaturpuffer lîschen
  LPOKE XBIOS(14,1)+6,0
RETURN
PROCEDURE no.but
  WHILE MOUSEK  !fÑngt ÅberschÅssige Mausklicks ab (meistens, Sch... GEM)
    REPEAT
      ~EVNT_BUTTON(0,0,0)
      MOUSE mx&,my&,mk&
    UNTIL mk&=0
  WEND
RETURN
'
'  ===  hier beginnt das eigentliche Programm  ===
'
PROCEDURE set.1.wahl
  RESTORE 1.wahl                                   !DATA-Pointer setzen
  @test.wahl(pt_1&,pw_1&)                          !zÑhlen
  DIM pt_1$(pt_1&),pw_1$(pw_1&),pk_1$(pw_1&)       !dimesionieren
  RESTORE 1.wahl                                   !DATA-Pointer neu setzen
  @read.wahl(pt_1&,pw_1&,pt_1$(),pw_1$(),pk_1$())  !Arrays fÅllen
RETURN
'
PROCEDURE 1.wahl
  @show.titel(" T i _ T _ V _ H ")
  @clean
  @pop.wahl(0,y_rel&,TRUE,TRUE,0,pt_1&,pw_1&,pt_1$(),pw_1$(),pk_1$(),wahl&)
  SELECT wahl&
  CASE 2,3
    @set.sprache(wahl&-1)
    IF check!  !nur beim ersten Durchgang / alleen de eerste keer
      @check.etc
    ENDIF
    @wahl.main
  CASE 5
    @last.info
    @ausgang
  ENDSELECT
RETURN
PROCEDURE set.sprache(nr&)
  LOCAL neu!
  IF nr&=2
    neu!=taal$<>"NL"
    taal$="NL"
    titel$="Torens van Hanoi"
  ELSE
    neu!=taal$<>"D"
    taal$="D"
    titel$="TÅrme von Hanoi"
  ENDIF
  IF alf&>0
    titel$=" "+titel$+" "
  ENDIF
  IF neu!
    @set.wahl.main
    @set.wahl.genug
    @set.wahl.help
  ENDIF
RETURN
PROCEDURE check.etc
  @test.virus  !=> short.exit ?
  @gen.spielfeld
  check!=FALSE
RETURN
PROCEDURE gen.spielfeld
  LOCAL li&,ob&,re&,un&,xd&
  VSYNC  !   work     show
  ~XBIOS(5,L:scr_2%,L:TRUE,-1)       !hide
  @clean
  @show.titel("")
  li&=h_mid&-154*hf&
  re&=h_mid&+154*hf&
  ob&=y_pl&(zl_z&)-27*vf&
  un&=y_pl&(1)+fd_yd&+8*vf&+2
  PBOX li&-3*hf&,ob&-3*vf&,re&+3*hf&,un&+3*vf&
  BOX li&,ob&,re&,un&
  ob&=unten&
  un&=ob&+8*vf&
  DEFFILL 1,1
  PBOX x_pl&(1),ob&,x_pl&(1)+pl_br&,un&
  PBOX x_pl&(2),ob&,x_pl&(2)+pl_br&,un&
  PBOX x_pl&(3),ob&,x_pl&(3)+pl_br&,un&
  DEFFILL 1,0
  PBOX h_mid&-24-2*hf&,y_std&-10*vf&,h_mid&+24+2*hf&,y_std&+4*vf&
  BOX h_mid&-24,y_std&-8*vf&,h_mid&+24,y_std&+2*vf&
  SGET spielfeld$
  IF alf&=2
    DEFFILL 1,2,4
  ELSE
    DEFFILL 2,1
  ENDIF
  HIDEM
  li&=x_pl&(1)
  re&=x_pl&(1)+pl_br&
  '
  GET li&,y_pl&(1),re&,y_pl&(1)+pl_ho&,platte$(0)  !leere Platte
  scheibe$=platte$(0)
  '
  FOR ni&=1 TO zl_z&
    ob&=y_pl&(ni&)
    un&=ob&+pl_ho&
    xd&=(ni&-1)*6*hf&
    PRBOX li&+xd&,ob&,re&-xd&,un&
    GET li&,ob&,re&,un&,platte$(ni&)
  NEXT ni&
  VSYNC  !   work     show
  ~XBIOS(5,L:scr_1%,L:scr_2%,-1)     !swap
  BMOVE scr_2%,scr_1%,32000          !copy
  VSYNC
  ~XBIOS(5,L:TRUE,L:scr_1%,-1)       !show
  SHOWM
RETURN
PROCEDURE last.info                              !~NL~D~
  IF taal$="NL"
    RESTORE last_info_nl
  ELSE
    RESTORE last_info_d
  ENDIF
  @pop.info(0,0,TRUE,TRUE,1)
  last_info_nl:
  DATA " tot uw dienst "
  DATA *
  last_info_d:
  DATA " servus "
  DATA *
RETURN
'
PROCEDURE set.wahl.main
  @da.is.main
  @test.wahl(pt_m&,pw_m&)
  ERASE pt_m$(),pw_m$(),pk_m$()  !wegen Sprachwechsel
  DIM pt_m$(pt_m&),pw_m$(pw_m&),pk_m$(pw_m&)
  @da.is.main
  @read.wahl(pt_m&,pw_m&,pt_m$(),pw_m$(),pk_m$())
  level_ofs&=1
  start_ofs&=10
  MID$(pw_m$(start_ofs&+1),3)=CHR$(4)   !
  MID$(pw_m$(start_ofs&+2),3)=CHR$(2)   !wegen LST-File
  MID$(pw_m$(start_ofs&+3),3)=CHR$(3)   !
  '  separat abhaken, damit die Wahl auch nach
  '  einem Wechsel der Sprache beachtet wird
  @abhaken.level(level&)
  @abhaken.start(start&)
RETURN
PROCEDURE da.is.main                             !~NL~D~
  IF taal$="NL"
    RESTORE wahl_main_nl
  ELSE
    RESTORE wahl_main_d
  ENDIF
  '  ohne Infozeilen
  wahl_main_nl:
  DATA *
  DATA "INFO","023"
  DATA "Regels","019"
  DATA "Speelwijze :","1"
  DATA "  3 schijven","004 111"
  DATA "  4 schijven","005 106"
  DATA "  5 schijven","006 107"
  DATA "  6 schijven","007 108"
  DATA "  7 schijven","008 103"
  DATA "  8 schijven","009 104"
  DATA "Startplaats :","1"
  DATA "  1  ","075"
  DATA "  2  ","080"
  DATA "  3  ","077"
  DATA "Demo","032"
  DATA "SPELEN","031"
  DATA " ------------ ","2"
  DATA "Escape","001"
  DATA *,""
  '
  wahl_main_d:
  DATA *
  DATA "INFO","023"
  DATA "Regeln","019"
  DATA "Spielweise:","1"
  DATA "  3 Platten","004 111"
  DATA "  4 Platten","005 106"
  DATA "  5 Platten","006 107"
  DATA "  6 Platten","007 108"
  DATA "  7 Platten","008 103"
  DATA "  8 Platten","009 104"
  DATA "Startplatz:","1"
  DATA "  1  ","075"
  DATA "  2  ","080"
  DATA "  3  ","077"
  DATA "Demo","032"
  DATA "SPIELEN","031"
  DATA " ------------ ","2"
  DATA "Escape","001"
  DATA *,""
RETURN
PROCEDURE set.wahl.genug
  @da.is.genug
  @test.wahl(pt_g&,pw_g&)
  ERASE pt_g$(),pw_g$(),pk_g$()  !wegen Sprachwechsel
  DIM pt_g$(pt_g&),pw_g$(pw_g&),pk_g$(pw_g&)
  @da.is.genug
  @read.wahl(pt_g&,pw_g&,pt_g$(),pw_g$(),pk_g$())
RETURN
PROCEDURE da.is.genug                            !~NL~D~
  IF taal$="NL"
    RESTORE wahl_genug_nl
  ELSE
    RESTORE wahl_genug_d
  ENDIF
  '
  wahl_genug_nl:
  DATA " Genoeg ? "
  DATA *
  DATA "   Ja   ","001 036 028 114"
  DATA "Nee","049 057"
  DATA *,""
  '
  wahl_genug_d:
  DATA "  Genug?  "
  DATA *
  DATA "ja","001 036 028 114"
  DATA "  nein  ","049 057"
  DATA *,""
RETURN
PROCEDURE set.wahl.help
  @da.is.help
  @test.wahl(pt_h&,pw_h&)
  ERASE pt_h$(),pw_h$(),pk_h$()  !wegen Sprachwechsel
  DIM pt_h$(pt_h&),pw_h$(pw_h&),pk_h$(pw_h&)
  @da.is.help
  @read.wahl(pt_h&,pw_h&,pt_h$(),pw_h$(),pk_h$())
RETURN
PROCEDURE da.is.help                             !~NL~D~
  IF taal$="NL"
    RESTORE wahl_help_nl
  ELSE
    RESTORE wahl_help_d
  ENDIF
  '
  wahl_help_nl:
  DATA "   0 <-> 0   "
  DATA *
  DATA "Terug","020"
  DATA "Vooruit","047"
  DATA "",""
  DATA "  Escape  ","001"
  DATA *,""
  '
  wahl_help_d:
  DATA "   0 <-> 0   "
  DATA *
  DATA "ZurÅck","021"
  DATA "VorwÑrts","047"
  DATA "",""
  DATA "  Escape  ","001"
  DATA *,""
RETURN
'
PROCEDURE wahl.main
  REPEAT
    @show.startbild
    @zent(y_std&," "+STR$(zug_min&)+" ")
    @pop.wahl(0,y_pwo&,TRUE,FALSE,17,pt_m&,pw_m&,pt_m$(),pw_m$(),pk_m$(),wahl&)
    SELECT wahl&
    CASE 1
      @prg.info
    CASE 2
      @spiel.regeln
    CASE 4 TO 9
      @abhaken.level(wahl&-level_ofs&)
    CASE 11 TO 13
      @abhaken.start(wahl&-start_ofs&)
    CASE 14
      @zeig.demo
    CASE 15
      @spielen
    ENDSELECT
  UNTIL wahl&=17
RETURN
PROCEDURE show.startbild
  SPUT spielfeld$
  @show.titel(titel$)
  FOR ni&=1 TO 8
    IF ni&<=level&
      PUT x_pl&(start&),y_pl&(ni&),platte$(ADD(ni&,sub8level&))
    ELSE
      PUT x_pl&(start&),y_pl&(ni&),platte$(0)
    ENDIF
  NEXT ni&
RETURN
PROCEDURE prg.info                               !~NL~D~
  IF taal$="NL"
    RESTORE prg_info_nl
  ELSE
    RESTORE prg_info_d
  ENDIF
  @show.titel(" I N F O ")
  @pop.info(0,y_rel&,TRUE,TRUE,60)
  '
  prg_info_nl:
  DATA
  DATA "Ti_T_V_H  is  'public domain',"
  DATA "loopt in alle 3 ST-resoluties en"
  DATA "'heeft iets' tegen Linkvirussen."
  DATA "Het programma is in GFA-BASIC 3.0"
  DATA "geschreven en gecompileerd en mag,"
  DATA "nee moet verder gegeven worden - maar"
  DATA "natuurlijk uitsluitend kosteloos !"
  DATA "En om te zorgen dat het ook"
  DATA "kosteloos blijft, stuurt U de auteur"
  DATA "a.u.b. geen (!) geld."
  DATA "Veel plezier !"
  DATA "De nederlandse vertaling is van"
  DATA "Philip van Rijthoven"
  DATA "Tel.: O8O-782457"
  DATA "Nelson Krugerstraat 58"
  DATA "NL 6543 MX Nijmegen"
  DATA "(Danke!)"
  DATA *
  '
  prg_info_d:
  DATA
  DATA "Ti_T_V_H  ist  'public domain',"
  DATA "lÑuft in allen 3 ST-Auflîsungen"
  DATA "und hat 'was gegen Linkviren."
  DATA "Das Programm ist in GFA-BASIC 3.0"
  DATA "geschrieben und compiliert und darf"
  DATA "und soll weitergegeben werden - aber"
  DATA "natÅrlich ausschlieûlich kostenlos!"
  DATA "Und damit es auch kostenlos bleibt,"
  DATA "schicken Sie dem Autor bitte"
  DATA "kein (!) Geld."
  DATA
  DATA "Viel Spaû!"
  DATA *
RETURN
PROCEDURE spiel.regeln                           !~NL~D~
  LOCAL tit$
  IF taal$="NL"
    RESTORE spiel_regeln_nl
  ELSE
    RESTORE spiel_regeln_d
  ENDIF
  READ tit$
  @show.titel(tit$)
  @pop.info(0,y_pwo&,TRUE,FALSE,60)
  '
  spiel_regeln_nl:
  DATA "Spelregels"
  DATA "De toren moet van de"
  DATA "startplaats naar een andere"
  DATA "stapel verplaatst worden."
  DATA "De schijven moeten"
  DATA "ÇÇn voor ÇÇn"
  DATA "verplaatst worden"
  DATA "en een grotere mag nooit"
  DATA " op een kleinere liggen. "
  DATA "Met de linker muisknop"
  DATA "oppakken"
  DATA "en weer neerzetten."
  DATA "Er zijn minstens"
  DATA "( zie boven )"
  DATA "zetten nodig."
  DATA *
  spiel_regeln_d:
  DATA "Spielregeln"
  DATA " Der Turm soll von einem "
  DATA "Platz auf einen anderen"
  DATA "umgestapelt werden."
  DATA "Dabei muû jede Platte"
  DATA "einzeln bewegt werden"
  DATA "und darf nie auf einer"
  DATA "kleineren liegen."
  DATA "Die linke Maustaste"
  DATA "nimmt eine Platte"
  DATA "oder legt sie ab."
  DATA "Man braucht mindestens"
  DATA " ( siehe oben )"
  DATA "ZÅge."
  DATA *
RETURN
PROCEDURE abhaken.level(nr&)
  MID$(pw_m$(level&+level_ofs&),1)=" "
  level&=nr&
  sub8level&=SUB(8,level&)
  MID$(pw_m$(level&+level_ofs&),1)=CHR$(8)
  zug_min&=2^level&-1
  zug_max&=2^(level&+1)
RETURN
PROCEDURE abhaken.start(nr&)
  MID$(pw_m$(start&+start_ofs&),1)=" "
  start&=nr&
  MID$(pw_m$(start&+start_ofs&),1)=CHR$(8)
RETURN
'
'  ===  hier beginnt das Spiel  ===
'
PROCEDURE zeig.demo                              !~NL~D~
  LOCAL aus!
  HIDEM
  @da.is.demo
  bis_zug&=zug_min&
  FOR ni&=1 TO bis_zug&
    READ zug_of&(ni&),zug_to&(ni&)
  NEXT ni&
  @demo.vorbereiten
  REPEAT
    @zug.vorwaerts
  UNTIL aus!
  @merke.neuen.startplatz
  IF taal$="NL"
    RESTORE demo_nl
  ELSE
    RESTORE demo_d
  ENDIF
  SHOWM
  @pop.info(0,y_pwo&,TRUE,FALSE,60)
  '
  demo_nl:
  DATA "Te snel ?"
  DATA "Dat doen we expres."
  DATA " Probeer het zelf maar en "
  DATA "doe het lekker langzaam !"
  DATA *
  '
  demo_d:
  DATA "Zu schnell?"
  DATA "Das ist Absicht."
  DATA " Probier es selbst und "
  DATA "mach langsamer!"
  DATA *
RETURN
PROCEDURE da.is.demo
  IF ODD(level&)              !3~5~7
    SELECT start&
    CASE 1
      RESTORE demo_7_1_3
    CASE 2
      RESTORE demo_7_2_1
    CASE 3
      RESTORE demo_7_3_1
    ENDSELECT
  ELSE                        !4~6~8
    SELECT start&
    CASE 1
      RESTORE demo_8_1_3
    CASE 2
      RESTORE demo_8_2_1
    CASE 3
      RESTORE demo_8_3_1
    ENDSELECT
  ENDIF
  '
  demo_7_1_3:
  DATA 1,3,1,2,3,2,1,3,2,1,2,3,1,3,1,2,3,2,3,1,2,1,3,2,1,3,1,2,3,2,1,3
  DATA 2,1,2,3,1,3,2,1,3,2,3,1,2,1,2,3,1,3,1,2,3,2,1,3,2,1,2,3,1,3,1,2
  DATA 3,2,3,1,2,1,3,2,1,3,1,2,3,2,3,1,2,1,2,3,1,3,2,1,3,2,3,1,2,1,3,2
  DATA 1,3,1,2,3,2,1,3,2,1,2,3,1,3,1,2,3,2,3,1,2,1,3,2,1,3,1,2,3,2,1,3
  DATA 2,1,2,3,1,3,2,1,3,2,3,1,2,1,2,3,1,3,1,2,3,2,1,3,2,1,2,3,1,3,2,1
  DATA 3,2,3,1,2,1,3,2,1,3,1,2,3,2,3,1,2,1,2,3,1,3,2,1,3,2,3,1,2,1,2,3
  DATA 1,3,1,2,3,2,1,3,2,1,2,3,1,3,1,2,3,2,3,1,2,1,3,2,1,3,1,2,3,2,1,3
  DATA 2,1,2,3,1,3,2,1,3,2,3,1,2,1,2,3,1,3,1,2,3,2,1,3,2,1,2,3,1,3
  demo_7_2_1:
  DATA 2,1,2,3,1,3,2,1,3,2,3,1,2,1,2,3,1,3,1,2,3,2,1,3,2,1,2,3,1,3,2,1
  DATA 3,2,3,1,2,1,3,2,1,3,1,2,3,2,3,1,2,1,2,3,1,3,2,1,3,2,3,1,2,1,2,3
  DATA 1,3,1,2,3,2,1,3,2,1,2,3,1,3,1,2,3,2,3,1,2,1,3,2,1,3,1,2,3,2,1,3
  DATA 2,1,2,3,1,3,2,1,3,2,3,1,2,1,2,3,1,3,1,2,3,2,1,3,2,1,2,3,1,3,2,1
  DATA 3,2,3,1,2,1,3,2,1,3,1,2,3,2,3,1,2,1,2,3,1,3,2,1,3,2,3,1,2,1,3,2
  DATA 1,3,1,2,3,2,1,3,2,1,2,3,1,3,1,2,3,2,3,1,2,1,3,2,1,3,1,2,3,2,3,1
  DATA 2,1,2,3,1,3,2,1,3,2,3,1,2,1,2,3,1,3,1,2,3,2,1,3,2,1,2,3,1,3,2,1
  DATA 3,2,3,1,2,1,3,2,1,3,1,2,3,2,3,1,2,1,2,3,1,3,2,1,3,2,3,1,2,1
  demo_7_3_1:
  DATA 3,1,3,2,1,2,3,1,2,3,2,1,3,1,3,2,1,2,1,3,2,3,1,2,3,1,3,2,1,2,3,1
  DATA 2,3,2,1,3,1,2,3,1,2,1,3,2,3,2,1,3,1,3,2,1,2,3,1,2,3,2,1,3,1,3,2
  DATA 1,2,1,3,2,3,1,2,3,1,3,2,1,2,1,3,2,3,2,1,3,1,2,3,1,2,1,3,2,3,1,2
  DATA 3,1,3,2,1,2,3,1,2,3,2,1,3,1,3,2,1,2,1,3,2,3,1,2,3,1,3,2,1,2,3,1
  DATA 2,3,2,1,3,1,2,3,1,2,1,3,2,3,2,1,3,1,3,2,1,2,3,1,2,3,2,1,3,1,2,3
  DATA 1,2,1,3,2,3,1,2,3,1,3,2,1,2,1,3,2,3,2,1,3,1,2,3,1,2,1,3,2,3,2,1
  DATA 3,1,3,2,1,2,3,1,2,3,2,1,3,1,3,2,1,2,1,3,2,3,1,2,3,1,3,2,1,2,3,1
  DATA 2,3,2,1,3,1,2,3,1,2,1,3,2,3,2,1,3,1,3,2,1,2,3,1,2,3,2,1,3,1
  demo_8_1_3:
  DATA 1,2,1,3,2,3,1,2,3,1,3,2,1,2,1,3,2,3,2,1,3,1,2,3,1,2,1,3,2,3,1,2
  DATA 3,1,3,2,1,2,3,1,2,3,2,1,3,1,3,2,1,2,1,3,2,3,1,2,3,1,3,2,1,2,1,3
  DATA 2,3,2,1,3,1,2,3,1,2,1,3,2,3,2,1,3,1,3,2,1,2,3,1,2,3,2,1,3,1,2,3
  DATA 1,2,1,3,2,3,1,2,3,1,3,2,1,2,1,3,2,3,2,1,3,1,2,3,1,2,1,3,2,3,1,2
  DATA 3,1,3,2,1,2,3,1,2,3,2,1,3,1,3,2,1,2,1,3,2,3,1,2,3,1,3,2,1,2,3,1
  DATA 2,3,2,1,3,1,2,3,1,2,1,3,2,3,2,1,3,1,3,2,1,2,3,1,2,3,2,1,3,1,3,2
  DATA 1,2,1,3,2,3,1,2,3,1,3,2,1,2,1,3,2,3,2,1,3,1,2,3,1,2,1,3,2,3,1,2
  DATA 3,1,3,2,1,2,3,1,2,3,2,1,3,1,3,2,1,2,1,3,2,3,1,2,3,1,3,2,1,2,1,3
  DATA 2,3,2,1,3,1,2,3,1,2,1,3,2,3,2,1,3,1,3,2,1,2,3,1,2,3,2,1,3,1,2,3
  DATA 1,2,1,3,2,3,1,2,3,1,3,2,1,2,1,3,2,3,2,1,3,1,2,3,1,2,1,3,2,3,2,1
  DATA 3,1,3,2,1,2,3,1,2,3,2,1,3,1,3,2,1,2,1,3,2,3,1,2,3,1,3,2,1,2,3,1
  DATA 2,3,2,1,3,1,2,3,1,2,1,3,2,3,2,1,3,1,3,2,1,2,3,1,2,3,2,1,3,1,2,3
  DATA 1,2,1,3,2,3,1,2,3,1,3,2,1,2,1,3,2,3,2,1,3,1,2,3,1,2,1,3,2,3,1,2
  DATA 3,1,3,2,1,2,3,1,2,3,2,1,3,1,3,2,1,2,1,3,2,3,1,2,3,1,3,2,1,2,1,3
  DATA 2,3,2,1,3,1,2,3,1,2,1,3,2,3,2,1,3,1,3,2,1,2,3,1,2,3,2,1,3,1,2,3
  DATA 1,2,1,3,2,3,1,2,3,1,3,2,1,2,1,3,2,3,2,1,3,1,2,3,1,2,1,3,2,3
  demo_8_2_1:
  DATA 2,3,2,1,3,1,2,3,1,2,1,3,2,3,2,1,3,1,3,2,1,2,3,1,2,3,2,1,3,1,2,3
  DATA 1,2,1,3,2,3,1,2,3,1,3,2,1,2,1,3,2,3,2,1,3,1,2,3,1,2,1,3,2,3,2,1
  DATA 3,1,3,2,1,2,3,1,2,3,2,1,3,1,3,2,1,2,1,3,2,3,1,2,3,1,3,2,1,2,3,1
  DATA 2,3,2,1,3,1,2,3,1,2,1,3,2,3,2,1,3,1,3,2,1,2,3,1,2,3,2,1,3,1,2,3
  DATA 1,2,1,3,2,3,1,2,3,1,3,2,1,2,1,3,2,3,2,1,3,1,2,3,1,2,1,3,2,3,1,2
  DATA 3,1,3,2,1,2,3,1,2,3,2,1,3,1,3,2,1,2,1,3,2,3,1,2,3,1,3,2,1,2,1,3
  DATA 2,3,2,1,3,1,2,3,1,2,1,3,2,3,2,1,3,1,3,2,1,2,3,1,2,3,2,1,3,1,2,3
  DATA 1,2,1,3,2,3,1,2,3,1,3,2,1,2,1,3,2,3,2,1,3,1,2,3,1,2,1,3,2,3,2,1
  DATA 3,1,3,2,1,2,3,1,2,3,2,1,3,1,3,2,1,2,1,3,2,3,1,2,3,1,3,2,1,2,3,1
  DATA 2,3,2,1,3,1,2,3,1,2,1,3,2,3,2,1,3,1,3,2,1,2,3,1,2,3,2,1,3,1,3,2
  DATA 1,2,1,3,2,3,1,2,3,1,3,2,1,2,1,3,2,3,2,1,3,1,2,3,1,2,1,3,2,3,1,2
  DATA 3,1,3,2,1,2,3,1,2,3,2,1,3,1,3,2,1,2,1,3,2,3,1,2,3,1,3,2,1,2,3,1
  DATA 2,3,2,1,3,1,2,3,1,2,1,3,2,3,2,1,3,1,3,2,1,2,3,1,2,3,2,1,3,1,2,3
  DATA 1,2,1,3,2,3,1,2,3,1,3,2,1,2,1,3,2,3,2,1,3,1,2,3,1,2,1,3,2,3,2,1
  DATA 3,1,3,2,1,2,3,1,2,3,2,1,3,1,3,2,1,2,1,3,2,3,1,2,3,1,3,2,1,2,3,1
  DATA 2,3,2,1,3,1,2,3,1,2,1,3,2,3,2,1,3,1,3,2,1,2,3,1,2,3,2,1,3,1
  demo_8_3_1:
  DATA 3,2,3,1,2,1,3,2,1,3,1,2,3,2,3,1,2,1,2,3,1,3,2,1,3,2,3,1,2,1,3,2
  DATA 1,3,1,2,3,2,1,3,2,1,2,3,1,3,1,2,3,2,3,1,2,1,3,2,1,3,1,2,3,2,3,1
  DATA 2,1,2,3,1,3,2,1,3,2,3,1,2,1,2,3,1,3,1,2,3,2,1,3,2,1,2,3,1,3,2,1
  DATA 3,2,3,1,2,1,3,2,1,3,1,2,3,2,3,1,2,1,2,3,1,3,2,1,3,2,3,1,2,1,3,2
  DATA 1,3,1,2,3,2,1,3,2,1,2,3,1,3,1,2,3,2,3,1,2,1,3,2,1,3,1,2,3,2,1,3
  DATA 2,1,2,3,1,3,2,1,3,2,3,1,2,1,2,3,1,3,1,2,3,2,1,3,2,1,2,3,1,3,1,2
  DATA 3,2,3,1,2,1,3,2,1,3,1,2,3,2,3,1,2,1,2,3,1,3,2,1,3,2,3,1,2,1,3,2
  DATA 1,3,1,2,3,2,1,3,2,1,2,3,1,3,1,2,3,2,3,1,2,1,3,2,1,3,1,2,3,2,3,1
  DATA 2,1,2,3,1,3,2,1,3,2,3,1,2,1,2,3,1,3,1,2,3,2,1,3,2,1,2,3,1,3,2,1
  DATA 3,2,3,1,2,1,3,2,1,3,1,2,3,2,3,1,2,1,2,3,1,3,2,1,3,2,3,1,2,1,2,3
  DATA 1,3,1,2,3,2,1,3,2,1,2,3,1,3,1,2,3,2,3,1,2,1,3,2,1,3,1,2,3,2,1,3
  DATA 2,1,2,3,1,3,2,1,3,2,3,1,2,1,2,3,1,3,1,2,3,2,1,3,2,1,2,3,1,3,2,1
  DATA 3,2,3,1,2,1,3,2,1,3,1,2,3,2,3,1,2,1,2,3,1,3,2,1,3,2,3,1,2,1,3,2
  DATA 1,3,1,2,3,2,1,3,2,1,2,3,1,3,1,2,3,2,3,1,2,1,3,2,1,3,1,2,3,2,3,1
  DATA 2,1,2,3,1,3,2,1,3,2,3,1,2,1,2,3,1,3,1,2,3,2,1,3,2,1,2,3,1,3,2,1
  DATA 3,2,3,1,2,1,3,2,1,3,1,2,3,2,3,1,2,1,2,3,1,3,2,1,3,2,3,1,2,1
RETURN
PROCEDURE demo.vorbereiten
  @vorbereitung.1.teil
  GRAPHMODE 4
  TEXT 1,y_kzl&,SPACE$(bn_l&)
  GRAPHMODE 3
  TEXT 8*hf&+1,y_kzl&,"DEMO"
  GRAPHMODE 1
  @zent(y_std&," "+STR$(zug&)+" ")
  @vorbereitung.2.teil
RETURN
'
PROCEDURE spielen
  LOCAL abbruch!,fertig!
  @spiel.vorbereiten
  REPEAT
    @get.tom
    IF scan|
      @taste
    ELSE IF my&<y_kln&
      @button
    ELSE IF mk&=1
      @platte.nehmen  !> bewegen > ablegen
    ENDIF
  UNTIL fertig! OR abbruch!
  IF NOT abbruch!
    @show.kommentar
  ENDIF
RETURN
'
PROCEDURE spiel.vorbereiten
  @vorbereitung.1.teil
  bis_zug&=0
  @set.bis.zug
  GRAPHMODE 4
  TEXT 1,y_kzl&,SPACE$(bn_l&)
  TEXT x_hlp&+1,y_kzl&,SPACE$(bn_l&)
  GRAPHMODE 3
  TEXT 8*hf&+5,y_kzl&,"ESC"
  TEXT x_hlp&+8*hf&+1,y_kzl&,"HELP"
  GRAPHMODE 1
  @zent(y_std&," "+STR$(zug&)+" ")
  @vorbereitung.2.teil
  SHOWM
RETURN
PROCEDURE vorbereitung.1.teil
  VSYNC  !   work     show
  ~XBIOS(5,L:scr_2%,L:TRUE,-1)       !hide
  @show.startbild
  ARRAYFILL platz&(),0
  ARRAYFILL hoehe&(),0
  FOR ni&=1 TO level&
    platz&(start&,ni&)=ni&+sub8level&
  NEXT ni&
  zug&=0
  hoehe&(start&)=level&
RETURN
PROCEDURE vorbereitung.2.teil
  VSYNC
  ~XBIOS(5,L:scr_1%,L:scr_2%,-1)     !swap
  BMOVE scr_2%,scr_1%,32000          !copy
  VSYNC
  ~XBIOS(5,L:TRUE,L:scr_1%,-1)       !show
RETURN
PROCEDURE set.bis.zug
  MID$(pt_h$(1),10)=LEFT$(STR$(bis_zug&)+"  ",3)
RETURN
PROCEDURE taste
  IF scan|=1
    @wahl.genug
  ELSE IF scan|=98
    @wahl.help
  ELSE
    @pup
  ENDIF
RETURN
PROCEDURE button
  IF mx&<x_esc&
    @wahl.genug
  ELSE IF mx&>x_hlp&
    @wahl.help
  ENDIF
RETURN
PROCEDURE wahl.genug
  @pop.wahl(x_eaw&,y_kaw&,FALSE,FALSE,2,pt_g&,pw_g&,pt_g$(),pw_g$(),pk_g$(),wahl&)
  abbruch!=(wahl&=1)
  SHOWM
RETURN
PROCEDURE wahl.help
  LOCAL aus!
  REPEAT
    @pop.wahl(x_haw&,20*vf&,FALSE,FALSE,4,pt_h&,pw_h&,pt_h$(),pw_h$(),pk_h$(),wahl&)
    SELECT wahl&
    CASE 1
      IF zug&>0
        @zug.rueckwaerts
      ELSE
        @pup
        aus!=TRUE
      ENDIF
    CASE 2
      IF zug&<bis_zug&
        @zug.vorwaerts
      ELSE
        @pup
        aus!=TRUE
      ENDIF
    DEFAULT
      aus!=TRUE
    ENDSELECT
  UNTIL aus!
  SHOWM
RETURN
'
PROCEDURE zug.rueckwaerts
  stapel&=zug_to&(zug&)
  @platte.weg
  stapel&=zug_of&(zug&)
  @platte.hin
  DEC zug&
  @show.zugzahl
  aus!=(zug&=0)
RETURN
PROCEDURE zug.vorwaerts
  INC zug&
  stapel&=zug_of&(zug&)
  @platte.weg
  stapel&=zug_to&(zug&)
  @platte.hin
  @show.zugzahl
  aus!=(zug&=bis_zug&)
RETURN
PROCEDURE platte.weg
  hoch&=hoehe&(stapel&)                     !alten Stapel abbauen
  DEC hoehe&(stapel&)
  @platte.zeigen                            !leer
  SWAP platten_nr&,platz&(stapel&,hoch&)    !Plattennummer holen
  SWAP scheibe$,platte$(platten_nr&)        !Scheibe holen
RETURN
PROCEDURE platte.hin
  INC hoehe&(stapel&)                       !neuen Stapel aufbauen
  hoch&=hoehe&(stapel&)
  @platte.zeigen                            !voll
  SWAP scheibe$,platte$(platten_nr&)        !Scheibe weglegen
  SWAP platten_nr&,platz&(stapel&,hoch&)    !Plattennummer weglegen
RETURN
PROCEDURE platte.zeigen
  VSYNC  !   work     show
  ~XBIOS(5,L:scr_2%,L:TRUE,-1)              !hide
  PUT x_pl&(stapel&),y_pl&(hoch&),scheibe$
  VSYNC
  ~XBIOS(5,L:scr_1%,L:scr_2%,-1)            !swap
  PUT x_pl&(stapel&),y_pl&(hoch&),scheibe$
  VSYNC
  ~XBIOS(5,L:TRUE,L:scr_1%,-1)              !show
RETURN
PROCEDURE show.zugzahl
  VSYNC  !   work     show
  ~XBIOS(5,L:scr_2%,L:TRUE,-1)              !hide
  @zent(y_std&," "+STR$(zug&)+" ")
  VSYNC
  ~XBIOS(5,L:scr_1%,L:scr_2%,-1)            !swap
  @zent(y_std&," "+STR$(zug&)+" ")
  VSYNC
  ~XBIOS(5,L:TRUE,L:scr_1%,-1)              !show
RETURN
'
PROCEDURE platte.nehmen
  stapel&=((mx&-fd_xofs&)\fd_xd&) MOD sp_mod&
  IF stapel&
    IF hoehe&(stapel&)  !wenn eine da ist
      @platte.bewegen  !> ablegen
    ELSE
      @pup
    ENDIF
  ELSE
    @pup
  ENDIF
RETURN
PROCEDURE platte.bewegen
  LOCAL abgelegt!,alt_stapel&,ax&,ay&,nx&,ny&
  @no.but
  HIDEM
  @platte.weg
  nx&=mx&+pl_xdi&
  ny&=my&+pl_ydi&
  ax&=nx&
  ay&=ny&
  alt_stapel&=stapel&
  @platte.hin.xor.weg
  REPEAT
    MOUSE mx&,my&,mk&
    nx&=mx&+pl_xdi&
    ny&=my&+pl_ydi&
    IF mk&=1
      stapel&=((mx&-fd_xofs&)\fd_xd&) MOD sp_mod&
      IF stapel&
        hoch&=hoehe&(stapel&)
        IF platten_nr&>platz&(stapel&,hoch&)  !nur kleinere auf grîûere
          @platte.hin.xor.weg
          @platte.ablegen
        ELSE
          @pup
        ENDIF
      ELSE
        @pup
      ENDIF
    ELSE IF nx&<>ax& OR ny&<>ay&
      @platte.xor.schieben
      ax&=nx&
      ay&=ny&
    ENDIF
  UNTIL abgelegt!
  SHOWM
RETURN
PROCEDURE platte.hin.xor.weg
  VSYNC  !   work     show
  ~XBIOS(5,L:scr_2%,L:TRUE,-1)       !hide
  PUT ax&,ay&,scheibe$,6
  VSYNC
  ~XBIOS(5,L:scr_1%,L:scr_2%,-1)     !swap
  PUT ax&,ay&,scheibe$,6
  VSYNC
  ~XBIOS(5,L:TRUE,L:scr_1%,-1)       !show
RETURN
PROCEDURE platte.xor.schieben
  VSYNC  !   work     show
  ~XBIOS(5,L:scr_2%,L:TRUE,-1)       !hide
  PUT ax&,ay&,scheibe$,6
  PUT nx&,ny&,scheibe$,6
  VSYNC
  ~XBIOS(5,L:scr_1%,L:scr_2%,-1)     !swap
  PUT ax&,ay&,scheibe$,6
  PUT nx&,ny&,scheibe$,6
  VSYNC
  ~XBIOS(5,L:TRUE,L:scr_1%,-1)       !show
RETURN
PROCEDURE platte.ablegen
  @platte.hin
  IF stapel&<>alt_stapel&  !ZurÅcklegen zÑhlt nicht als Zug
    INC zug&
    @merke.zug
    @test.ob.fertig
  ENDIF
  abgelegt!=TRUE
  @no.but
RETURN
PROCEDURE merke.zug
  IF zug&<bis_zug&  !fÅr HELP vorwÑrts testen
    IF alt_stapel&<>zug_of&(zug&) OR stapel&<>zug_to&(zug&)
      '  wenn ein anderer Zug gemacht wird,
      '  sind die weiteren ZÅge ungÅltig!
      bis_zug&=zug&
    ENDIF
  ELSE
    bis_zug&=zug&
  ENDIF
  @set.bis.zug
  zug_of&(zug&)=alt_stapel&  !Bewegung merken
  zug_to&(zug&)=stapel&
  @show.zugzahl
RETURN
PROCEDURE test.ob.fertig
  IF hoehe&(stapel&)=level& AND stapel&<>start&
    fertig!=TRUE
    @merke.neuen.startplatz
  ELSE IF zug&=zug_max&
    fertig!=TRUE
  ENDIF
RETURN
PROCEDURE merke.neuen.startplatz
  '  FÅr  wahl.main  neuen Startplatz ohne Umbau
  '  abhaken, weil die Platten jetzt dort liegen!
  MID$(pw_m$(start&+start_ofs&),1)=" "
  start&=stapel&  !da liegen jetzt die Platten
  MID$(pw_m$(start&+start_ofs&),1)=CHR$(8)
RETURN
'
PROCEDURE show.kommentar
  LOCAL wert&
  IF zug&<zug_max&
    @sirene(3)
  ELSE
    @pup
  ENDIF
  IF zug&=zug_min&
    wert&=level&
    @abhaken.level(MIN(8,SUCC(level&)))
  ELSE IF zug&=zug_max&
    wert&=22+(level&=3)
  ELSE IF zug&<zug_min&*1.3
    wert&=11
  ELSE IF zug&<zug_min&*1.6
    wert&=12
  ELSE
    wert&=13
  ENDIF
  @da.is.kommentar
  @test.wahl(pt_k&,pw_k&)
  DIM pt_k$(pt_k&),pw_k$(pw_k&),pk_k$(pw_k&)  !local array
  @da.is.kommentar
  @read.wahl(pt_k&,pw_k&,pt_k$(),pw_k$(),pk_k$())
  '
  pk_k$(1)="001 057 028 114"  !Esc, Space, Return oder Enter
  IF pt_k$(2)="#"
    pt_k$(2)=STR$(zug_max&)
  ELSE IF pt_k$(4)="#"
    pt_k$(4)=STR$(zug_min&)
  ENDIF
  @pop.wahl(0,y_rel&,TRUE,TRUE,1,pt_k&,pw_k&,pt_k$(),pw_k$(),pk_k$(),wahl&)
  ERASE pt_k$(),pw_k$(),pk_k$()  !kann weg
RETURN
PROCEDURE da.is.kommentar                        !~NL~D~
  LOCAL test$
  IF taal$="NL"
    RESTORE kommentar_nl
  ELSE
    RESTORE kommentar_d
  ENDIF
  REPEAT
    READ test$
  UNTIL VAL(test$)=wert&
  '  ... bis die Zahl gefunden ist
  '
  kommentar_nl:
  DATA 3,
  DATA " Het kan niet beter ! "
  DATA "Maar nu met"
  DATA "vier schijven !"
  DATA ,*," Ja Pa ",,*
  DATA 4,
  DATA " Het kan niet beter ! "
  DATA "Maar nu met"
  DATA "vijf schijven !"
  DATA ,*," Ja Pa ",,*
  DATA 5,
  DATA " Het kan niet beter ! "
  DATA "Maar nu met"
  DATA "zes schijven !"
  DATA ,*," Ja Pa ",,*
  DATA 6,
  DATA " Het kan niet beter ! "
  DATA "Maar nu met"
  DATA "zeven schijven !"
  DATA ,*," Ja Pa ",,*
  DATA 7,
  DATA " Het kan niet beter ! "
  DATA "Maar nu met"
  DATA "acht schijven !"
  DATA ,*," Ja Pa ",,*
  DATA 8,
  DATA " Het kan niet beter ! "
  DATA "Ga maar"
  DATA "iets anders spelen."
  DATA ,*," Ja Pa ",,*
  DATA 11,
  DATA " Helemaal niet slecht "
  DATA "- maar het kon in "
  DATA "#"
  DATA "zetten."
  DATA ,*,"  Hmm  ",,*
  DATA 12,
  DATA "Heel goed !"
  DATA " voor een slome "
  DATA "beginneling."
  DATA ,*," Gheeuhw ",,*
  DATA 13,
  DATA "Miserabel!"
  DATA " Maar 't is gelukt. "
  DATA "Tegen niemand"
  DATA "vertellen !"
  DATA ,*," Zucht ",,*
  DATA 21,
  DATA "#"
  DATA " pogingen is wel genoeg ! "
  DATA "Hou er maar mee op."
  DATA "Je hebt zeker je dag"
  DATA "niet vandaag ?"
  DATA ,*," dat is't ",,*
  DATA 22,
  DATA "#"
  DATA " pogingen is wel genoeg ! "
  DATA "Kun je jezelf"
  DATA "niet beter eerst eens"
  DATA "met 3 schijven"
  DATA "gaan uitsloven ?"
  DATA ,*,"  Hmm  ",,*
  '
  kommentar_d:
  DATA 3,
  DATA " Besser geht es nicht! "
  DATA "Nun versuch's mal"
  DATA "mit 4 Platten!"
  DATA ,*," na klar ",,*
  DATA 4,
  DATA " Besser geht es nicht! "
  DATA "Versuch's doch mal"
  DATA "mit 5 Platten!"
  DATA ,*," na klar ",,*
  DATA 5,
  DATA " Besser geht es nicht! "
  DATA "Versuch's doch mal"
  DATA "mit 6 Platten!"
  DATA ,*," na klar ",,*
  DATA 6,
  DATA " Besser geht es nicht! "
  DATA "Versuch's doch mal"
  DATA "mit 7 Platten!"
  DATA ,*," na klar ",,*
  DATA 7,
  DATA " Besser geht es nicht! "
  DATA "Versuch's doch mal"
  DATA "mit 8 Platten!"
  DATA ,*," na klar ",,*
  DATA 8,
  DATA " Besser geht es nicht! "
  DATA "Spiel doch mal"
  DATA "was anderes!"
  DATA ,*," na klar ",,*
  DATA 11,
  DATA "Schon ganz gut"
  DATA "-  aber .."
  DATA "#"
  DATA " hÑtten auch genÅgt. "
  DATA ,*," Ach! ",,*
  DATA 12,
  DATA "Sehr gut"
  DATA "- fÅr einen "
  DATA " verschlafenen "
  DATA "AnfÑnger."
  DATA ,*," grrr! ",,*
  DATA 13,
  DATA "Miserabel!"
  DATA "Aber geschafft."
  DATA " Sag's niemandem! "
  DATA ,*,"  ja  ",,*
  DATA 21,
  DATA "#"
  DATA " Versuche sind genug! "
  DATA "Laû es lieber!"
  DATA "Du hast wohl einen"
  DATA "schlechten Tag ? !"
  DATA ,*," sicher ",,*
  DATA 22,
  DATA "#"
  DATA " Versuche sind genug! "
  DATA "Willst Du dich"
  DATA "nicht erst mal"
  DATA "mit 3 Platten"
  DATA "quÑlen?"
  DATA ,*," Hmm ",,*
RETURN
'
PROCEDURE pup
  LOCAL per%,dif%
  per%=2400
  dif%=60
  PAUSE 2
  REPEAT
    SOUND 1,15,#per%,0
    ADD per%,dif%
    DEC dif%
  UNTIL per%>4000
  SOUND 1,0,0,0,0  !a Ruh is
RETURN
PROCEDURE sirene(nz&)
  LOCAL ni&,sd&
  ni&=nz&
  WHILE ni&>0
    FOR sd&=1 TO 8
      SOUND 1,15,sd&,4,1
    NEXT sd&
    PAUSE 5
    DEC ni&
  WEND
  SOUND 1,0,0,0,0
RETURN
'
' === Ti ===
