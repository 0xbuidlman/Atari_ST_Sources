                    It can be done after all!


This  is  a  small  bit  of  text  to explain the working of the 
various files contained in this ZIP archive. The files contained 
therein  enable  you  to  get  at  the address of procedures and 
functions  in  GFA Basic 3.0 and higher at run time, albeit only 
in  the  compiled  version.  The  idea is to link an object file 
generated by a C compiler to your GFA Basic program.

The GFA program (GET_ADDR.GFA) is an example of how to implement 
it.  Because of the nature of the method of getting the address, 
it will only work in the compiled version, which is present also 
in the archive.

The  method is fairly straightforward and simple. An object file 
containing  the  C code to return the address of a GFA procedure 
or  function  is  compiled,  and it is linked to the GFA program 
after  its compilation. Then, when the GFA program is run, the C 
function is called from the program to return the desired value. 
If  you do not own a C compiler, the relevant GET_ADDR.O file is 
contained within this archive.

The  only  problem is, that the .O file as it stands can only be 
used  to  return the value of ONE GFA function or procedure, and 
its  name  must  be  known  at  the time you compile the C code. 
However,  there  is  a  way to around this. You can patch the .O 
file  with  the  name  of the GFA routine you want it to return. 
Thusly,  you can link several .O files to your GFA Basic program 
to return values of as many GFA functions or procedures as there 
are  .O  files.  To  make this work properly though, you need to 
give  the  C  function you call a new name for every address you 
want  determined. I have provided a small program (SET_O.GFA) to 
do  this  for  you. This program will only work with the .O file 
that is in this archive!

To  clarify  this  with  an  example, suppose you have three GFA 
functions or procedures you want to know the address of:

PROCEDURE proc1
' Some GFA code
RETURN

PROCEDURE proc2
'  .......
RETURN

FUNCTION func1
' .........
ENDFUNC

Now,  to  be able to get at the addresses of all three, you need 
three  copies  of  the .O file, and you must patch them with the 
names proc1, proc2 and func1. Furthermore, you must create three 
dummy functions in your GFA program:

FUNCTION paddr1
$X paddr1
ENDFUNC

FUNCTION paddr2
$X paddr2
ENDFUNC

FUNCTION faddr1
$X faddr1
ENDFUNC

What  you  call these functions, is irrelevant, but you must use 
the  same  names  to  patch the .O files with, and you must make 
sure  that  they  do  not  have  the  same  8  characters at the 
beginning!  Incorrect  names  are  for  instance proc_addr_1 and 
proc_addr_2.  If  you do this, it will result in an error during 
linking.

To  link  to  various .O files to your GFA program, call the GFA 
linker  with  the  names  of the .O files as parameters, or type 
these  names  in  in the MENUX program on the GFA compiler disk, 
using option "C."

Both  the  GFA  and  the C source code is well documented, and I 
think  you'll  be  able  to figure out how it all works. This is 
just  a basic explanation and implementation, so you can improve 
various bits of it. For instance, make a better SET_O, or make a 
C  function to return more than one GFA address. I leave this to 
you. Good luck!


I can be contacted at:

        Peter Kocourek
        Schouwweg 4
        2243 BA Wassenaar
        The Netherlands

        Electronically in FidoNet at address 2:282/301.17
        or at Atari's BBS in the Netherlands (+31 34 73 77 584)

