$B+ C+ U+ I+
version$="V4.64"
@stad_degas
> PROCEDURE stad_degas
  @init
  ~FORM_DIAL(0,0,0,0,0,0,0,max_x&,max_y&)
stad_degas:
  DO
    @clean_memory
    @form_do(stadegas%,dummy&)
    SELECT dummy&
    CASE bwim&
      ALERT 0,"Convert:|1) AIM to Image Lab|2) Image Lab to AIM ",0," AIM | B&W | Cancel ",dummy&
      SELECT dummy&
      CASE 1
        IF @fileselect("Convert AIM","IM")
          IF EXIST(@no_ext$("HD"))
            OPEN "I",#1,@no_ext$("HD")
            SEEK #1,22
            max&=INP&(#1)
            may&=INP&(#1)
            CLOSE
          ELSE
            max&=256
            may&=256
          ENDIF
          OPEN "I",#1,file$
          @ofo("B&W",2,0)
          PRINT #2,"B&W256";
          OUT& #2,max&,may&
          @copy(1,2,MUL(max&,may&))
          CLOSE
        ENDIF
      CASE 2
        IF @fileselect("Convert Image Lab","B&W")
          OPEN "I",#1,file$
          IF INPUT$(6,#1)="B&W256"
            max&=INP&(#1)
            may&=INP&(#1)
            IF OR(max&<>256,may&<>256)
              @create_hd(max&,1)
            ENDIF
            @ofo("IM",2,0)
            @copy(1,2,MUL(max&,may&))
          ELSE
            ALERT 3,"Not an Image-Lab file!",1," Cancel ",dummy&
          ENDIF
          CLOSE
        ENDIF
      ENDSELECT
    CASE rawconv&
      @convert_raw
    CASE pi3pac&
      ALERT 0,"Convert TO or FROM Stad? ",0,"To|From|Cancel",dummy&
      SELECT dummy&
      CASE 1
        @read_degas_doodle_dali
        IF NOT fout!
          ALERT 0,"Save as a Stad picture? ",1,"Yes|No",dummy&
          IF dummy&=1
            @pack_it(buffer%)
          ENDIF
          CLOSE
        ENDIF
      CASE 2
        IF @fileselect("Convert Stad","PAC")
          @depack(buffer%)
          IF NOT fout!
            @save_degas_doodle_dali(buffer%)
          ENDIF
        ENDIF
        CLOSE
      ENDSELECT
    CASE iffimg&
      @iff_naar_img.tiff(0)
    CASE paciff&
      @form_do(macstad%,dummy&)
      SELECT dummy&
      CASE imgtox&
        @img_iff
      CASE macto&
        @mac_iff
      CASE stadto&
        @stad_iff
      CASE picto2&
        @pic_to_x
      ENDSELECT
    CASE exit&
      @form_do(exitstad%,dummy&)
      IF dummy&=info&
        DO
          @form_do(greetin2%,dummy&)
          IF dummy&=hiddenop&
            '
            @enable(greetin2%,hiddenop&,3)
            '
            ALERT 0,"Oops, I forgot to add one! ",1," Cancel ",dummy&
            '
          ENDIF
        LOOP UNTIL dummy&=greetiok&
      ELSE
        exit!=dummy&=yesleave&
      ENDIF
    CASE xtiff&
      @x_to_tiff
    CASE settings&
      DO
        @form_do(setting%,dummy&)
        growshrink!=BTST(OB_STATE(setting%,on&),0)
        show_picture!=BTST(OB_STATE(setting%,showon&),0)
        IF dummy&=menu&
          ~MENU_BAR(menutree%,1)
          '
          DO
          LOOP UNTIL AND(EVNT_MULTI(&X10000,0,0,0,0,0,0,0,0,0,0,0,0,0,div_buffer%,0,dummy2&,dummy2&,dummy2&,dummy2&,dummy2&,dummy2&),&X10000)
          '
          ALERT 0," ***** Stadegas ***** | |Another production|from F. van Heusden!",1," Ok ",dummy2&
          ~MENU_TNORMAL(menutree%,INT{ADD(div_buffer%,6)},1)
          ~MENU_BAR(menutree%,0)
        ENDIF
      LOOP UNTIL dummy&=bpok&
    ENDSELECT
  LOOP UNTIL exit!
  @stoppen
RETURN
> PROCEDURE init
  ON ERROR GOSUB fout
  ON BREAK GOSUB breek
  RESERVE -16384                ! Ruimte voor RSC
  max_x&=WORK_OUT(0)
  max_y&=WORK_OUT(1)
  GEMSYS 109             ! WIND_NEW, sluit en wist alle windows
  INTIN(0)=1
  VDISYS 102,1,0
  number_of_bitplanes&=INTOUT(4)
  ~GRAF_HANDLE(tekst_x&,tekst_y&,dummy&,dummy&)
  CLIP 0,0 TO max_x&,max_y&
  DEFMOUSE 0
  growshrink!=TRUE
  show_picture!=TRUE
  DIM dummy&(255)
  dr$=CHR$(ADD(GEMDOS(25),65))+":"+DIR$(0)+"\*."
  default_name$="*.*"
  phys%=XBIOS(3)
  pixel_h&=372
  pixel_w&=372
  minrun|=3     ! Inits
  maxrun|=128   ! voor
  maxdat|=128   ! PackBits compressie
  DIM buf|(256)
  INLINE grow%,48
  INLINE or%,50
  INLINE counter%,36
  INLINE unstad%,176
  INLINE get_1_bit%,48
  INLINE pset_4%,72
  INLINE dither_rgb%,68
  INLINE high_low%,64
  INLINE high_med%,48
  INLINE pset_2%,50
  INLINE ptst_4%,60
  INLINE palet_to_rgb%,58
  INLINE ptst_2%,44
  INLINE compare%,26
  INLINE dither_bw%,60
  INLINE zoek_beste_rgb%,114
  INLINE scr_dump%,562
  INLINE invert%,20
  INLINE true_color_tiff_header%,380
  INLINE tiff_header%,350
  INLINE tiff_color_map_header%,362
  INLINE read_tiny%,222
  INLINE div_buffer%,256
  ~FSETDTA(div_buffer%)
  ' /* resource set indicies for STADEGAS */
  '
  LET stadegas&=0    ! /* form/dialog */
  LET settings&=1    ! /* TEXT in tree STADEGAS */
  LET pi3pac&=2      ! /* BUTTON in tree STADEGAS */
  LET xtiff&=3       ! /* BUTTON in tree STADEGAS */
  LET rawconv&=4     ! /* BUTTON in tree STADEGAS */
  LET bwim&=5        ! /* BUTTON in tree STADEGAS */
  LET iffimg&=6      ! /* BUTTON in tree STADEGAS */
  LET paciff&=7      ! /* BUTTON in tree STADEGAS */
  LET fvhsoft&=11    ! /* TEXT in tree STADEGAS */
  LET exit&=21       ! /* BUTTON in tree STADEGAS */
  LET version&=22    ! /* TEXT in tree STADEGAS */
  '
  LET tiff&=1        ! /* form/dialog */
  LET degas&=2       ! /* BUTTON in tree TIFF */
  LET img&=3         ! /* BUTTON in tree TIFF */
  LET ifftiff&=4     ! /* BUTTON in tree TIFF */
  LET macpaint&=5    ! /* BUTTON in tree TIFF */
  LET msxtiff&=6     ! /* BUTTON in tree TIFF */
  LET stad&=7        ! /* BUTTON in tree TIFF */
  LET cancel&=14     ! /* BUTTON in tree TIFF */
  '
  LET msx&=2         ! /* form/dialog */
  LET screen5&=2     ! /* BUTTON in tree MSX */
  LET screen6&=3     ! /* BUTTON in tree MSX */
  LET screen7&=4     ! /* BUTTON in tree MSX */
  LET screen8&=5     ! /* BUTTON in tree MSX */
  LET cancemsx&=6    ! /* BUTTON in tree MSX */
  '
  LET setting&=3     ! /* form/dialog */
  LET on&=4          ! /* BUTTON in tree SETTING */
  LET off&=5         ! /* BUTTON in tree SETTING */
  LET bpok&=6        ! /* BUTTON in tree SETTING */
  LET showon&=9      ! /* BUTTON in tree SETTING */
  LET showoff&=10    ! /* BUTTON in tree SETTING */
  LET menu&=11       ! /* BUTTON in tree SETTING */
  '
  LET greetin2&=4    ! /* form/dialog */
  LET greetiok&=10   ! /* BUTTON in tree GREETIN2 */
  LET hiddenop&=11   ! /* TEXT in tree GREETIN2 */
  '
  LET tostad&=5      ! /* form/dialog */
  LET doodle&=2      ! /* BUTTON in tree TOSTAD */
  LET dali&=3        ! /* BUTTON in tree TOSTAD */
  LET cancelpa&=4    ! /* BUTTON in tree TOSTAD */
  LET art&=5         ! /* BUTTON in tree TOSTAD */
  LET degaspac&=6    ! /* BUTTON in tree TOSTAD */
  LET tiny&=11       ! /* BUTTON in tree TOSTAD */
  LET tinytxt&=12    ! /* BOXTEXT in tree TOSTAD */
  '
  LET iffimgpc&=6    ! /* form/dialog */
  LET paintbru&=2    ! /* BUTTON in tree IFFIMGPC */
  LET toimg&=3       ! /* BUTTON in tree IFFIMGPC */
  LET iff&=4         ! /* BUTTON in tree IFFIMGPC */
  LET canceiip&=5    ! /* BUTTON in tree IFFIMGPC */
  '
  LET nottiff&=7     ! /* form/dialog */
  LET cancelnt&=6    ! /* BUTTON in tree NOTTIFF */
  '
  LET exitstad&=8    ! /* form/dialog */
  LET yesleave&=5    ! /* BUTTON in tree EXITSTAD */
  LET info&=6        ! /* BUTTON in tree EXITSTAD */
  LET noleave&=7     ! /* BUTTON in tree EXITSTAD */
  '
  LET macstad&=9     ! /* form/dialog */
  LET imgtox&=2      ! /* BUTTON in tree MACSTAD */
  LET macto&=3       ! /* BUTTON in tree MACSTAD */
  LET stadto&=4      ! /* BUTTON in tree MACSTAD */
  LET picto2&=9      ! /* BUTTON in tree MACSTAD */
  '
  LET s1s&=10        ! /* form/dialog */
  LET cancelim&=4    ! /* BUTTON in tree S1S */
  '
  LET menutree&=11   ! /* menu tree */
  '
  LET palet&=12      ! /* form/dialog */
  LET aa&=6          ! /* FTEXT in tree PALET */
  LET bb&=7          ! /* FTEXT in tree PALET */
  LET cc&=8          ! /* FTEXT in tree PALET */
  LET ignorepa&=10   ! /* BUTTON in tree PALET */
  LET usevalue&=11   ! /* BUTTON in tree PALET */
  '
  LET ifftox&=13     ! /* form/dialog */
  LET ifftoimg&=2    ! /* BUTTON in tree IFFTOX */
  LET iffttiff&=4    ! /* BUTTON in tree IFFTOX */
  LET iffraw&=6      ! /* BUTTON in tree IFFTOX */
  LET iffrawtx&=7    ! /* BOXTEXT in tree IFFTOX */
  LET cancelif&=8    ! /* BUTTON in tree IFFTOX */
  '
  LET tifftox&=14    ! /* form/dialog */
  LET tiffiff&=5     ! /* BUTTON in tree TIFFTOX */
  LET canctiff&=6    ! /* BUTTON in tree TIFFTOX */
  LET tiffaim&=7     ! /* BUTTON in tree TIFFTOX */
  LET tiffraw&=8     ! /* BUTTON in tree TIFFTOX */
  LET tiffimgt&=9    ! /* BOXTEXT in tree TIFFTOX */
  LET tiffimg&=10    ! /* BUTTON in tree TIFFTOX */
  LET tiffpac&=11    ! /* BUTTON in tree TIFFTOX */
  '
  LET raw&=15        ! /* form/dialog */
  LET rawtobw&=4     ! /* BUTTON in tree RAW */
  LET rawaim&=5      ! /* BUTTON in tree RAW */
  LET rawiff&=6      ! /* BUTTON in tree RAW */
  LET rawtoimg&=7    ! /* BUTTON in tree RAW */
  LET rawneo&=8      ! /* BUTTON in tree RAW */
  LET rawtops&=9     ! /* BUTTON in tree RAW */
  LET rawtiff&=16    ! /* BUTTON in tree RAW */
  LET rawtospc&=18   ! /* BUTTON in tree RAW */
  LET ifftoraw&=22   ! /* BUTTON in tree RAW */
  LET tiffraw2&=25   ! /* BUTTON in tree RAW */
  LET aimraw&=26     ! /* BUTTON in tree RAW */
  LET neoraw&=28     ! /* BUTTON in tree RAW */
  LET bwtoraw&=30    ! /* BUTTON in tree RAW */
  LET pcxtoraw&=32   ! /* BUTTON in tree RAW */
  LET gif2raw&=35    ! /* BUTTON in tree RAW */
  LET canceraw&=36   ! /* BUTTON in tree RAW */
  '
  LET raw2iff&=16    ! /* form/dialog */
  LET gray8&=3       ! /* BUTTON in tree RAW2IFF */
  LET gray16&=4      ! /* BUTTON in tree RAW2IFF */
  LET gray64&=5      ! /* BUTTON in tree RAW2IFF */
  LET gray256&=6     ! /* BUTTON in tree RAW2IFF */
  LET grayxres&=8    ! /* FBOXTEXT in tree RAW2IFF */
  LET grayyres&=9    ! /* FBOXTEXT in tree RAW2IFF */
  LET rwifgrok&=10   ! /* BUTTON in tree RAW2IFF */
  LET rwifgrca&=11   ! /* BUTTON in tree RAW2IFF */
  LET rwifgraa&=18   ! /* FTEXT in tree RAW2IFF */
  LET rwifgrab&=19   ! /* FTEXT in tree RAW2IFF */
  LET rwifgrac&=20   ! /* FTEXT in tree RAW2IFF */
  '
  LET selectps&=17   ! /* form/dialog */
  LET pstofile&=2    ! /* BUTTON in tree SELECTPS */
  LET printps&=4     ! /* BUTTON in tree SELECTPS */
  LET cancelps&=6    ! /* BUTTON in tree SELECTPS */
  '
  LET floydste&=18   ! /* form/dialog */
  LET intensit&=2    ! /* FBOXTEXT in tree FLOYDSTE */
  LET okfloyd&=3     ! /* BUTTON in tree FLOYDSTE */
  '
  LET rawctiff&=19   ! /* form/dialog */
  LET c512&=3        ! /* BUTTON in tree RAWCTIFF */
  LET c4096&=4       ! /* BUTTON in tree RAWCTIFF */
  LET c262144&=5     ! /* BUTTON in tree RAWCTIFF */
  LET c1677721&=6    ! /* BUTTON in tree RAWCTIFF */
  LET p16&=9         ! /* BUTTON in tree RAWCTIFF */
  LET p32&=10        ! /* BUTTON in tree RAWCTIFF */
  LET p256&=11       ! /* BUTTON in tree RAWCTIFF */
  LET analsub&=15    ! /* BUTTON in tree RAWCTIFF */
  LET analmedi&=16   ! /* BUTTON in tree RAWCTIFF */
  LET random&=17     ! /* BUTTON in tree RAWCTIFF */
  LET error&=18      ! /* BUTTON in tree RAWCTIFF */
  LET colorxre&=20   ! /* FBOXTEXT in tree RAWCTIFF */
  LET coloryre&=21   ! /* FBOXTEXT in tree RAWCTIFF */
  LET okclrifr&=22   ! /* BUTTON in tree RAWCTIFF */
  LET caclrifr&=23   ! /* BUTTON in tree RAWCTIFF */
  LET extended&=24   ! /* BUTTON in tree RAWCTIFF */
  '
  LET rawforma&=20   ! /* form/dialog */
  LET straw&=2       ! /* BUTTON in tree RAWFORMA */
  LET msraw&=4       ! /* BUTTON in tree RAWFORMA */
  LET qrt&=6         ! /* BUTTON in tree RAWFORMA */
  '
  LET imgoptio&=21   ! /* form/dialog */
  LET cruncon&=4     ! /* BUTTON in tree IMGOPTIO */
  LET cruncoff&=5    ! /* BUTTON in tree IMGOPTIO */
  LET pixelh&=7      ! /* FBOXTEXT in tree IMGOPTIO */
  LET pixelw&=8      ! /* FBOXTEXT in tree IMGOPTIO */
  LET gemok&=9       ! /* BUTTON in tree IMGOPTIO */
  LET gemcance&=10   ! /* BUTTON in tree IMGOPTIO */
  '
  '
  IF RSRC_LOAD("STADEGAS.RSC")=0
    ALERT 0,"STADEGAS.RSC not found! ",1," Exit ",dummy&
    END
  ENDIF
  ~RSRC_GADDR(0,stadegas&,stadegas%)
  ~RSRC_GADDR(0,tiff&,tiff%)
  ~RSRC_GADDR(0,msx&,msx%)
  ~RSRC_GADDR(0,setting&,setting%)
  ~RSRC_GADDR(0,greetin2&,greetin2%)
  ~RSRC_GADDR(0,tostad&,tostad%)
  ~RSRC_GADDR(0,iffimgpc&,iffimgpc%)
  ~RSRC_GADDR(0,nottiff&,nottiff%)
  ~RSRC_GADDR(0,exitstad&,exitstad%)
  ~RSRC_GADDR(0,macstad&,macstad%)
  ~RSRC_GADDR(0,s1s&,s1s%)
  ~RSRC_GADDR(0,menutree&,menutree%)
  ~RSRC_GADDR(0,palet&,palet%)
  ~RSRC_GADDR(0,ifftox&,ifftox%)
  ~RSRC_GADDR(0,tifftox&,tifftox%)
  ~RSRC_GADDR(0,raw&,raw%)
  ~RSRC_GADDR(0,raw2iff&,raw2iff%)
  ~RSRC_GADDR(0,selectps&,selectps%)
  ~RSRC_GADDR(0,floydste&,floydste%)
  ~RSRC_GADDR(0,rawctiff&,rawctiff%)
  ~RSRC_GADDR(0,rawforma&,rawforma%)
  ~RSRC_GADDR(0,imgoptio&,imgoptio%)
  old_scr_dump%=LPEEK(&H502)
  IF number_of_bitplanes&=1
    SLPOKE &H502,scr_dump%
  ENDIF
  CHAR{{OB_SPEC(stadegas%,version&)}}=version$
RETURN
> PROCEDURE clean_memory
  CLOSE
  CLR compressie|,macintosh!,pic$,img!,dummy$,no_press!,compressie|,color_map!
  CLR ham!,ehb!,interlaced!,error!,median!,mode|,dummy|,dummy!,bytes&,teller_&
  CLR rt1%,rt2%,gt1%,gt2%,bt1%,bt2%,fout!,not_more_then_1!,tags&,dummy&,tiff!
  CLR end!,pcx!,start_of_picture!,motorola!,unused%
  ERASE buffer%(),buffer2%(),img_header&(),pat|(),kleur|(),dta%(),buffer3%()
  ERASE palet$(),c&(),c!(),color&(),n0&(),n1&(),rood&(),groen_geel&(),blauw&()
  ERASE kleur_tabel%(),teller_tabel%(),scan_line|(),one_plane|(),buffer3|()
  ERASE verschil%(),r%(),g%(),b%(),r|(),g|(),b|(),buffer|(),copy_buffer%()
  ERASE data_buffer%(),kleur|(),buffer2%(),buffer1|(),buffer2|(),screen|()
  ERASE spcpal&(),line|(),look_up!()
  ~FRE(0)
RETURN
> PROCEDURE stoppen
  ~RSRC_FREE()
  SLPOKE &H502,old_scr_dump%
  CLOSE
  ~FORM_DIAL(3,0,0,0,0,0,0,max_x&,max_y&)
  RESERVE
  ON ERROR
  END
RETURN
> PROCEDURE form_do(tree%,VAR dummy&)
  ~FORM_CENTER(tree%,x&,y&,w&,h&)
  IF growshrink!
    ~FORM_DIAL(1,0,0,0,0,x&,y&,w&,h&)
  ENDIF
  ~OBJC_DRAW(tree%,0,255,x&,y&,w&,h&)
  dummy&=AND(FORM_DO(tree%,0),511)
  HIDEM
  @disable(tree%,dummy&,0)
  IF growshrink!
    ~FORM_DIAL(2,0,0,0,0,x&,y&,w&,h&)
  ENDIF
  DEFFILL 0,0
  IF no_rebuild!
    PBOX x&,y&,ADD(x&,w&),ADD(y&,h&)
    CLR no_rebuild!
  ELSE
    PBOX 0,0,max_x&,19
    DEFFILL 1,2,4
    PBOX 0,19,max_x&,max_y&
  ENDIF
RETURN
> FUNCTION fileselect(text$,extensie$)
a&=INSTR(default_name$,".")
IF a&
  default_name$=LEFT$(default_name$,a&)+extensie$
ELSE
  default_name$=default_name$+"."+extensie$
ENDIF
FILESELECT #text$,dr$+extensie$,default_name$,file$
HIDEM
e&=FSFIRST(file$,&X10011)
IF e&
  IF file$<>""
    ALERT 3,"That file does not exists! ",1,"Cancel",e&
  ENDIF
  RETURN 0
ELSE
  DO WHILE AND(BYTE{ADD(div_buffer%,21)},16)
    e&=FSNEXT()
  LOOP
  e%=FSFIRST(file$,&X100111)
  dr$=LEFT$(file$,RINSTR(file$,"\"))
  default_name$=CHAR{ADD(div_buffer%,30)}
  lof%={ADD(div_buffer%,26)}
  file$=dr$+default_name$
  dr$=dr$+"*."
  RETURN TRUE
ENDIF
ENDFUNC
> FUNCTION no_ext$(dummy$)
dummy4&=INSTR(file$,".",RINSTR(file$,"\"))
IF dummy4&
RETURN LEFT$(file$,dummy4&)+dummy$
ELSE
RETURN file$+"."+dummy$
ENDIF
ENDFUNC
> PROCEDURE fout
{INTIN}=&H1068000C            ! 4200Hz, 12
VDISYS 5,2,0,61     !  V_SOUND, werkt alleen bij NVDI (helaas :-/ )
ALERT 1,"Error: "+STR$(ERR)+"|Report this bug |to me please!",ADD(2,FATAL),"Exit|Continue",dummy&
CLOSE
ON ERROR GOSUB fout
IF FATAL
END
ELSE IF dummy&=1
~RSRC_FREE()
END
ELSE
RESUME stad_degas
ENDIF
RETURN
> PROCEDURE pack_it(buffer%)
HIDEM
PRINT "(Please wait)";
~C:counter%(L:buffer%,L:V:dummy&(0))
min_1&=32767
min_2&=32767
CLR max&
FOR lus&=0 TO 255
IF dummy&(lus&)>max&
  max&=dummy&(lus&)
  pack_byte|=BYTE(lus&)
ELSE IF dummy&(lus&)<min_1&
  min_1&=dummy&(lus&)
  special_byte|=BYTE(lus&)
ELSE IF dummy&(lus&)<min_2&
  min_2&=dummy&(lus&)
  id_byte|=BYTE(lus&)
ENDIF
NEXT lus&
'
@ofo("PAC",1,0)
OUT% #1,CVL("pM85")                                   ! Header
OUT #1,id_byte|,pack_byte|,special_byte|
'
FOR lus&=0 TO 31999
adres%=ADD(lus&,buffer%)
byte|=BYTE{adres%}
SELECT byte|
CASE id_byte|,special_byte|    ! Mag niet direct gedumpt worden
  OUT #1,special_byte|,byte|
  dummy%=adres%
  IF BYTE{ADD(adres%,1)}=byte|
    CLR dummy&
    DO WHILE AND(BYTE{dummy%}=byte|,AND(lus&<31999,dummy&<255))
      INC dummy%
      INC lus&
      INC dummy&
    LOOP
    IF BYTE{dummy%}<>byte|
      DEC dummy%
      DEC lus&
      DEC dummy&
    ENDIF
    OUT #1,BYTE(dummy&)
  ELSE
    OUT #1,0                        ! 1 Byte
  ENDIF
CASE pack_byte|
  dummy%=adres%
  IF BYTE{ADD(adres%,1)}=pack_byte|
    CLR dummy&
    DO WHILE AND(BYTE{dummy%}=pack_byte|,AND(lus&<31999,dummy&<255))
      INC dummy%
      INC lus&
      INC dummy&
    LOOP
    IF BYTE{dummy%}<>pack_byte|
      DEC dummy%
      DEC lus&
      DEC dummy&
    ENDIF
    OUT #1,id_byte|,BYTE(dummy&)
  ELSE
    OUT #1,pack_byte|      ! Slechts 1x, dus direkt op disk!
  ENDIF
DEFAULT
  IF AND(byte|=BYTE{ADD(adres%,1)},lus&<31999)
    dummy%=adres%
    CLR dummy&
    DO WHILE AND(BYTE{dummy%}=byte|,AND(lus&<31999,dummy&<255))
      INC dummy%
      INC lus&
      INC dummy&
    LOOP
    IF BYTE{dummy%}<>byte|
      DEC dummy%
      DEC lus&
      DEC dummy&
    ENDIF
    IF dummy&<2
      ' Minder dan 3 bytes, dus direkt (commando+byte|+n is al 3!)
      FOR lus_&=0 TO dummy&
        OUT #1,byte|
      NEXT lus_&
    ELSE
      OUT #1,special_byte|,byte|,BYTE(dummy&)    ! Copy 'y',x times
    ENDIF
  ELSE
    OUT #1,byte|      ! Gewoon direct dumpen
  ENDIF
ENDSELECT
NEXT lus&
RETURN
> PROCEDURE read_degas_doodle_dali
@form_do(tostad%,dummy&)
IF dummy&<>cancelpa&
SELECT dummy&
CASE degaspac&
  ALERT 0,"Select picture type: ",0," PI? | PC3 | Cancel ",dummy&
  SELECT dummy&
  CASE 1
    dummy$="PI?"
  CASE 2
    dummy$="PC3"
  CASE 3
    fout!=TRUE
  ENDSELECT
CASE doodle&
  dummy$="DOO"
CASE dali&
  dummy$="SD2"
CASE art&
  dummy$="ART"
CASE tiny&
  dummy$="TN?"
ENDSELECT
IF NOT fout!
  IF @fileselect("Convert "+dummy$,dummy$)
    @p_3(file$,buffer%,fout!)
  ELSE
    fout!=TRUE
  ENDIF
ENDIF
ELSE
fout!=TRUE
ENDIF
RETURN
> PROCEDURE save_degas_doodle_dali(buffer%)
@enable(tostad%,tiny&,3)
@enable(tostad%,tinytxt&,3)
@form_do(tostad%,dummy&)
@disable(tostad%,tiny&,3)
@disable(tostad%,tinytxt&,3)
may&=199
IF dummy&<>cancelpa&
SELECT dummy&
CASE degaspac&
  ALERT 0,"Resolution: ",0," Low | Medium | High ",dummy&
  HIDEM
  SELECT dummy&
  CASE 3
    @ofo("PI3",1,0)
    OUT& #1,2,&H777
    PRINT #1,STRING$(30,0);
    BPUT #1,buffer%,32000
  CASE 1
    @ofo("PI1",1,0)
    OUT% #1,0                   ! low-res, zwart
    OUT& #1,&H222,&H444,&H666,&H888
    FOR lus&=1 TO 11
      OUT& #1,0
    NEXT lus&
    DIM buffer|(1280)
    DIM buffer2|(319)
    DIM data_buffer%(8000)
    buffer1%=V:buffer|(0)
    buffer2%=ADD(buffer1%,640)
    buffer3%=V:buffer2|(0)
    buffer4%=V:data_buffer%(0)
    PRINT AT(1,1);"Converting... "
    FOR y&=0 TO may&
      @counter(15,1,y&)
      ~C:grow%(L:buffer%,L:buffer1%,W:639,W:0)
      ADD buffer%,80
      ~C:grow%(L:buffer%,L:buffer2%,W:639,W:0)
      ADD buffer%,80
      ~C:high_low%(L:buffer1%,L:buffer2%,L:buffer3%)
      ~C:pset_4%(L:buffer3%,L:buffer4%)
      ADD buffer4%,160
    NEXT y&
    BPUT #1,V:data_buffer%(0),32000
    PRINT AT(15,1);"Done!"
  CASE 2
    @ofo("PI2",1,0)
    DIM buffer|(1280)
    DIM buffer2|(639)
    DIM data_buffer%(8000)
    buffer1%=V:buffer|(0)
    buffer2%=ADD(buffer1%,640)
    buffer3%=V:buffer2|(0)
    buffer4%=V:data_buffer%(0)
    PRINT AT(1,1);"Converting... "
    FOR y&=0 TO may&
      @counter(15,1,y&)
      ~C:grow%(L:buffer%,L:buffer1%,W:639,W:0)
      ADD buffer%,80
      ~C:grow%(L:buffer%,L:buffer2%,W:639,W:0)
      ADD buffer%,80
      ~C:high_med%(L:buffer1%,L:buffer2%,L:buffer3%)
      ~C:pset_2%(L:buffer3%,L:buffer4%)
      ADD buffer4%,160
    NEXT y&
    OUT& #1,1,&H0,&H444,&H888
    FOR lus&=1 TO 13
      OUT& #1,0
    NEXT lus&
    BPUT #1,V:data_buffer%(0),32000
    PRINT AT(15,1);"Done!"
  ENDSELECT
CASE doodle&
  BSAVE @no_ext$("DOO"),buffer%,32000
CASE dali&
  @ofo("SD2",1,0)
  OUT% #1,0
  OUT& #1,&H777
  PRINT #1,STRING$(122,0);
  BPUT #1,buffer%,32000
CASE art&
  @ofo("ART",1,0)
  BPUT #1,buffer%,32000
  FOR lus&=1 TO 16
    OUT& #1,&H777
    PRINT #1,STRING$(30,0);
  NEXT lus&
ENDSELECT
ENDIF
RETURN
> PROCEDURE p_3(file$,VAR buffer%,fout!)  ! Lees ART/PI123/PC3/SD2/DOO
HIDEM
OPEN "I",#1,file$
DIM buffer%(7999)
buffer%=V:buffer%(0)
dummy$=RIGHT$(file$,3)
IF OR(lof%=32000,dummy$="ART")
yep:
BGET #1,buffer%,MIN(32000,SUB(lof%,LOC(#1)))
ELSE IF dummy$="SD2"
RELSEEK #1,128
GOTO yep
ELSE IF OR(LEFT$(dummy$,2)="PI",dummy$="PC3")
ld_pix:
SELECT AND(INP&(#1),2)
CASE 0                              ! PI1
  DIM kleur%(15)
  FOR lus&=0 TO 15
    dummy&=INP&(#1)
    rood&=AND(SHR(dummy&,8),&X111)
    groen_geel&=AND(SHR(dummy&,4),&X111)
    blauw&=AND(dummy&,&X111)
    kleur%(lus&)=ADD(ADD(SHL(rood&,21),SHL(groen_geel&,13)),SHL(blauw&,5))
  NEXT lus&
  DIM buffer|(1280)
  buffer1%=V:buffer|(0)
  buffer2%=ADD(buffer1%,320)
  FOR y&=0 TO 199
    line$=INPUT$(160,#1)
    ~C:ptst_4%(L:V:line$,L:buffer1%)
    ~C:palet_to_rgb%(L:buffer1%,L:buffer2%,L:V:kleur%(0),W:319)
    ~C:dither_rgb%(L:buffer2%,L:buffer%,W:19)
    ADD buffer%,80
  NEXT y&
  buffer%=V:buffer%(0)
CASE 1                              ! PI2
  DIM kleur%(15)
  FOR lus&=0 TO 15
    dummy&=INP&(#1)
    rood&=AND(SHR(dummy&,8),&X111)
    groen_geel&=AND(SHR(dummy&,4),&X111)
    blauw&=AND(dummy&,&X111)
    kleur%(lus&)=ADD(ADD(SHL(rood&,21),SHL(groen_geel&,13)),SHL(blauw&,5))
  NEXT lus&
  DIM buffer|(2560)
  buffer1%=V:buffer|(0)
  buffer2%=ADD(buffer1%,640)
  FOR y&=0 TO 199
    line$=INPUT$(160,#1)
    ~C:ptst_2%(L:V:line$,L:buffer1%)
    ~C:palet_to_rgb%(L:buffer1%,L:buffer2%,L:V:kleur%(0),W:639)
    ~C:dither_rgb%(L:buffer2%,L:buffer%,W:39)
    ADD buffer%,80
    dummy!=NOT dummy!
    IF dummy!
      DELETE buffer|(640)
    ELSE
      INSERT buffer|(640)=0
    ENDIF
    ~C:dither_rgb%(L:buffer2%,L:buffer%,W:39)
    ADD buffer%,80
  NEXT y&
  buffer%=V:buffer%(0)
CASE 2                              ! PI3
  RELSEEK #1,32
  IF dummy$="PI3"
    GOTO yep
  ELSE                         ! PC3
    teller%=SUB(lof%,LOC(#1))
    DIM buffer2%(ADD(SHR(teller%,2),1))
    dummy%=V:buffer2%(0)
    BGET #1,dummy%,teller%
    screen%=buffer%
    FOR dummy&=0 TO 399
      dummy4&=80
      CLR dummy5&
      DO WHILE dummy4&
        dummy2&=BYTE{dummy%}
        INC dummy%
        SELECT dummy2&
        CASE 0 TO 127
          INC dummy2&
          SUB dummy4&,dummy2&
          BMOVE dummy%,ADD(screen%,dummy5&),dummy2&
          ADD dummy%,dummy2&
          ADD dummy5&,dummy2&
        CASE 129 TO 255
          dummy2&=ADD(XOR(dummy2&,255),2)
          SUB dummy4&,dummy2&
          dummy3&=BYTE{dummy%}
          INC dummy%
          FOR lus&=1 TO dummy2&
            BYTE{ADD(screen%,dummy5&)}=dummy3&
            INC dummy5&
          NEXT lus&
        ENDSELECT
      LOOP
      ADD screen%,80
    NEXT dummy&
  ENDIF
ENDSELECT
ELSE IF LEFT$(dummy$,2)="TN"
DIM data_buffer%(SHR(lof%,2))
BGET #1,V:data_buffer%(0),lof%
dummy&=BYTE{V:data_buffer%(0)}
dummy%=C:read_tiny%(L:V:data_buffer%(0),L:buffer%)
CLOSE
ADD dummy&,MUL(dummy&>2,3)
IF dummy&<>2
  OPEN "O",#1,@no_ext$("$$$")
  OUT& #1,dummy&
  BPUT #1,dummy%,32
  BPUT #1,buffer%,32000
  CLOSE
  OPEN "I",#1,@no_ext$("$$$")
  GOTO ld_pix
ENDIF
ELSE
ALERT 3,"That fileformat is not |supported (yet)!",1," Cancel ",dummy&
no_press!=TRUE
fout!=TRUE
ENDIF
CLOSE
@kill(@no_ext$("$$$"))
IF NOT fout!
@put_on_screen(buffer%,640,400,1)
ENDIF
RETURN
> PROCEDURE stad_iff           ! STad naar IFF/IMG/PCX
IF @fileselect("Convert Stad","PAC")
@depack(buffer%)
IF NOT fout!
  @form_do(iffimgpc%,dummy&)
  IF dummy&<>canceiip&
    SELECT dummy&
    CASE iff&
      @create_iff(buffer%,640,400,1)
    CASE toimg&
      @create_img(buffer%,640,400,1)
    CASE paintbru&
      @create_pcx(buffer%,640,400,1)
    ENDSELECT
  ENDIF
ENDIF
ENDIF
CLOSE
RETURN
> PROCEDURE depack(VAR dummy%)             ! Depack STAD
PRINT "EPlease wait while depacking..."
DIM buffer%(SHR(lof%,2))
BLOAD file$,V:buffer%(0)
'
DIM buffer2%(7999)
IF C:unstad%(L:V:buffer%(0),L:V:buffer2%(0))=0
ALERT 3,"Can't handle this |Stad picture!",1,"Cancel",dummy&
fout!=TRUE
ELSE
dummy%=V:buffer2%(0)
@put_on_screen(dummy%,640,400,1)
ENDIF
RETURN
> PROCEDURE create_img(adres%,max&,may&,planes&)  ! Create IMG
img!=TRUE
@form_do(imgoptio%,dummy&)
IF dummy&=gemok&
pixel_h&=VAL(CHAR{{OB_SPEC(imgoptio%,pixelh&)}})
pixel_w&=VAL(CHAR{{OB_SPEC(imgoptio%,pixelw&)}})
@ofo("IMG",1,0)
OUT& #1,1,8,planes&,1,pixel_h&,pixel_w&,max&,may&
bytes_per_line&=SHR(ADD(max&,7),3)
IF AND(OB_STATE(imgoptio%,cruncoff&),1)
  PRINT "EWriting... "
  FOR lus&=1 TO may&
    @counter(12,1,lus&)
    FOR dummy&=1 TO planes&
      dummy2&=bytes_per_line&
      DO WHILE dummy2&>255
        OUT #1,128,255
        BPUT #1,adres%,255
        ADD adres%,255
        SUB dummy2&,255
      LOOP
      IF dummy2&
        OUT #1,128,dummy2&
        BPUT #1,adres%,dummy2&
        ADD adres%,dummy2&
      ENDIF
    NEXT dummy&
  NEXT lus&
ELSE
  @crunch_scherm(adres%,max&,may&,planes&,1)
ENDIF
ENDIF
CLOSE
RETURN
> PROCEDURE img_iff               ! IMG -> IFF/PCX
IF @fileselect("Convert GEM Image","IMG")
@form_do(iffimgpc%,dummy&)
IF dummy&<>canceiip&
  SELECT dummy&
  CASE iff&
    @img_to_iff
  CASE toimg&
    ALERT 3,"You don't need to do that! ",1,"Cancel",dummy&
  CASE paintbru&
    @get_img(file$,buffer%)
    IF buffer%<>-1
      @create_pcx(buffer%,max&,may&,planes&)
    ENDIF
  ENDSELECT
ENDIF
ENDIF
RETURN
> PROCEDURE create_iff(buffer%,max&,may&,planes&)  ! Create IFF
@ofo("IFF",1,0)
OUT% #1,CVL("FORM"),0,CVL("ILBM"),CVL("BMHD"),20
OUT& #1,max&,may&            ! X-res,Y-res
OUT% #1,0
OUT #1,planes&,0                ! Bitpl., mask
IF NOT macintosh!
ALERT 0,"Pack this screen? ",1,"Yes|No",dummy&
IF dummy&=1
  compressie|=1
ELSE
  CLR compressie|
ENDIF
ELSE
CLR dummy&
ENDIF
OUT #1,compressie|,0           ! Compressie, Reserved
OUT& #1,0                     ! Transpartant kleur
OUT #1,ADD(5,ABS(MUL(planes&<>4,5))),11
OUT& #1,max&,may&             ! X-res,Y-res
bytes_per_line&=SHR(ADD(max&,7),3)
total_bytes%=bytes_per_line&*may&*planes&
IF NOT color_map!
LET colors%=2^planes&
ENDIF
OUT% #1,CVL("CAMG"),4,0
OUT% #1,CVL("CMAP"),MUL(colors%,3)
ALERT 0,"Invert colors? ",0,"Yes|No",a&
IF color_map!
CLR color_map!
FOR lus%=0 TO SUB(colors%,1)
  IF a&=1
    OUT #1,XOR(255,kleur|(lus%,0)),XOR(255,kleur|(lus%,1)),XOR(255,kleur|(lus%,2))
  ELSE
    OUT #1,kleur|(lus%,0),kleur|(lus%,1),kleur|(lus%,2)
  ENDIF
NEXT lus%
ELSE IF colors%>2
mul=256/colors%
FOR lus%=0 TO SUB(colors%,1)
  dummy|=lus%*mul
  IF a&=1
    dummy|=XOR(255,dummy|)
  ENDIF
  OUT #1,dummy|,dummy|,dummy|
NEXT lus%
ELSE
IF a&=2
  OUT #1,255,255,255
ENDIF
OUT #1,0,0,0
IF a&=1
  OUT #1,255,255,255
ENDIF
ENDIF
OUT% #1,CVL("BODY")             ! body
dummy2%=LOC(#1)
OUT% #1,total_bytes%
HIDEM
IF AND(dummy&=1,NOT macintosh!)
@crunch_scherm(buffer%,max&,may&,planes&,1)
total_bytes%=SUB(LOC(#1),ADD(dummy2%,4))
SEEK #1,dummy2%
OUT% #1,total_bytes%
SEEK #1,LOF(#1)
ELSE
BPUT #1,buffer%,total_bytes%
ENDIF
IF NOT macintosh!
@put_on_screen(buffer%,max&,may&,planes&)
ENDIF
length%=SUB(LOC(#1),8)
SEEK #1,4
OUT% #1,length%
SEEK #1,LOF(#1)
CLOSE
RETURN
> PROCEDURE get_img(file$,VAR buffer%)
HIDEM
OPEN "I",#1,file$
DIM img_header&(8)
BGET #1,V:img_header&(0),16
pattern_run&=img_header&(3)
DIM pat|(pattern_run&)
planes&=img_header&(2)
max&=img_header&(6)
may&=img_header&(7)
PRINT "EColors: ";2^planes&
IF AND(not_more_then_1!,planes&<>1)
@form_do(s1s%,dummy&)
ELSE
PRINT "Resolution: ";max&;"x";may&
bytes_per_line&=SHR(ADD(max&,7),3)
CLR x&,y&,dummy&
SEEK #1,SHL(img_header&(1),1)
total_bytes%=MUL(MUL(bytes_per_line&,may&),planes&)
PRINT "Total bytes: ";total_bytes%
PRINT "Reading image..."
IF @check_enough_memory(total_bytes%)
  DIM buffer%(ADD(SHR(total_bytes%,2),1))
  buffer%=V:buffer%(0)
  DO UNTIL y&=>may&
    dummy2%=MUL(y&,bytes_per_line&)
    com1|=INP(#1)
    SELECT com1|
    CASE 0
      com2|=INP(#1)
      SELECT com2|
      CASE 0
        com3|=INP(#1)                 ! 255
        dummy&=INP(#1)
      DEFAULT
        BGET #1,V:pat|(1),pattern_run&
        FOR lus&=1 TO com2|
          FOR dummy1&=1 TO pattern_run&
            BYTE{ADD(buffer%,ADD(dummy2%,SHR(x&,3)))}=pat|(dummy1&)    ! Div,8
            ADD x&,8
          NEXT dummy1&
        NEXT lus&
      ENDSELECT
    CASE 128
      com2|=INP(#1)
      BGET #1,ADD(buffer%,ADD(dummy2%,SHR(x&,3))),com2|
      ADD x&,SHL(com2|,3)
    DEFAULT
      col|=MUL(255,SHR(com1|,7))
      FOR lus&=1 TO AND(com1|,127)
        BYTE{ADD(buffer%,ADD(dummy2%,SHR(x&,3)))}=col|
        ADD x&,8
      NEXT lus&
    ENDSELECT
    IF x&>SUB(max&,1)
      CLR x&
      IF dummy&
        FOR lus&=1 TO SUB(dummy&,1)
          BMOVE ADD(buffer%,dummy2%),ADD(buffer%,MUL(ADD(y&,lus&),bytes_per_line&)),SHR(max&,3)
        NEXT lus&
        ADD y&,dummy&
        CLR dummy&
      ELSE
        INC y&
        @counter(18,4,y&)
      ENDIF
    ENDIF
  LOOP
  buffer%=V:buffer%(0)
  @put_on_screen(buffer%,max&,may&,planes&)
ELSE
  buffer%=-1
  ALERT 3,"Not enough memory for |this operation!",1," Cancel ",dummy&
ENDIF
ENDIF
CLOSE
RETURN
> PROCEDURE press
IF NOT no_press!
x&=SUB(MUL(14,tekst_x&),1)
y&=SUB(tekst_y&,1)
GET 0,0,x&,y&,pic$
PRINT AT(1,1);"pPress a key...q"
GET 0,0,x&,y&,dummy$
SHOWM
CLR old_x&,old_y&
DO
  dummy2&=EVNT_MULTI(&X11,1,&X1,&X1,0,0,0,0,0,0,0,0,0,0,div_buffer%,dummy&,new_x&,new_y&,dummy&,dummy&,dummy&,dummy&)
  IF AND(new_x&<SUB(max_x&,x&),new_y&<SUB(max_y&,y&))
    PUT old_x&,old_y&,pic$
    old_x&=new_x&
    old_y&=new_y&
    GET new_x&,new_y&,ADD(new_x&,x&),ADD(new_y&,y&),pic$
    PUT new_x&,new_y&,dummy$
    SHOWM
  ENDIF
LOOP UNTIL dummy2&=1
PUT old_x&,old_y&,pic$
ENDIF
RETURN
> PROCEDURE iff_naar_img.tiff(dummy!)       ! IFF naar IMG/TIFF/RAW
IF NOT dummy!
dummy!=@fileselect("Convert IFF","IFF")
ENDIF
IF dummy!
CLS
OPEN "I",#1,file$
type%=INP%(#1)
~INP%(#1)
SELECT type%
CASE "FORM"
  ok!=TRUE
  type%=INP%(#1)
  SELECT type%
  CASE "ILBM","ACBM"
    DO
      type%=INP%(#1)
      s_lengte%=INP%(#1)
      SELECT type%
      CASE "BMHD"
        bm_width&=INP&(#1)                ! Breedte bitmap
        bm_height&=INP&(#1)               ! Lengte bitmap
        bm_x&=INP&(#1)                    ! X-positie v. bitmap
        bm_y&=INP&(#1)                    ! Y-positie v. bitmap
        PRINT "Resolution: ";bm_width&;"x";bm_height&
        bm_nplanes&=INP(#1)               ! bitplanes
        PRINT "Colors: ";2^bm_nplanes&
        bm_masking|=INP(#1)               ! masking vlag
        '                                   ! 0=geen
        '                                   ! 1=na elke regel een mask regel
        mask_line!=(bm_masking|=1)
        IF mask_line!
          PRINT "Mask-data will be ignored."
        ENDIF
        '                                   ! 2=pixels in kleur 'bm_transparentcolor&' zijn transparant
        '                                   ! 3=pixels buiten omtrek zijn transparant
        bm_compression|=INP(#1)           ! Compressie vlag (1=gecomprimeerd)
        IF bm_compression|=1
          PRINT "This picture is compressed."
        ENDIF
        bm_pad1|=INP(#1)                  ! gereserveerd; 0 maken
        bm_transparantcolor&=INP&(#1)     ! Transparante kleur
        bm_xaspect|=INP(#1)               ! Verhouding pixelgrootte voor X
        bm_yaspect|=INP(#1)               ! Verhouding pixelgrootte voor Y
        bm_pagewidth&=INP&(#1)            ! Breedte v/d grafische bladzijde
        bm_pageheight&=INP&(#1)           ! Hoogte  v/d grafische bladzijde
      CASE "CAMG"
        camg%=INP%(#1)
        ham!=BTST(camg%,11)
        ehb!=BTST(camg%,10)
        interlaced!=BTST(camg%,3)
        IF ham!       ! Ham?
          PRINT "Commodore Amiga viewport mode: Ham"
        ELSE IF ehb!
          PRINT "Commodore Amiga viewport mode: EHB"
        ENDIF
        IF interlaced!     ! Interlaced?
          PRINT "Interlaced" ! Interlaced!
        ENDIF
      CASE "CMAP"
        color_map!=TRUE
        kleuren&=DIV(s_lengte%,3)
        IF kleuren&<>2^bm_nplanes&
          ALERT 0,"Unknown palet-type.|A gray-scale palet will be |used.",1," Ok ",dummy&
          kleuren&=MIN(2^bm_nplanes&,256)
          DIM kleur|(255,2)
          FOR lus&=0 TO SUB(kleuren&,1)
            kleur|(lus&,0)=BYTE(lus&)
            kleur|(lus&,1)=BYTE(lus&)
            kleur|(lus&,2)=BYTE(lus&)
          NEXT lus&
          RELSEEK #1,s_lengte%
        ELSE
          DIM kleur|(255,2)
          FOR lus&=0 TO SUB(kleuren&,1)
            kleur|(lus&,0)=INP(#1)
            kleur|(lus&,1)=INP(#1)
            kleur|(lus&,2)=INP(#1)
          NEXT lus&
        ENDIF
      CASE "BODY"                 ! Is ook meteen het einde van de IFF!
        bytes_per_line&=SHR(ADD(bm_width&,7),3)
        bytes_per_line%=MUL(bytes_per_line&,ADD(bm_nplanes&,ABS(mask_line!)))
        bp_l%=SHR(ADD(bm_width&,7),3)
        total_bytes%=MUL(bytes_per_line%,bm_height&)
        IF @check_enough_memory(total_bytes%)
          dummy%=SUB(lof%,LOC(#1))
          DIM buffer%(ADD(SHR(total_bytes%,2),1))
          adr%=V:buffer%(0)
          CLR teller%
          IF bm_compression|=1                           ! Gecomprimeerd d.m.v. PackBits
            DIM buffer2%(SHR(dummy%,2))
            BGET #1,V:buffer2%(0),dummy%
            dummy%=V:buffer2%(0)
            @depack_packbits(dummy%,adr%,total_bytes%)
          ELSE                                  ! Niet gecomprimeerd, dus meteen inladen
            BGET #1,adr%,MIN(s_lengte%,total_bytes%)
          ENDIF
          adr%=V:buffer%(0)
          @put_on_screen(adr%,bm_width&,bm_height&,bm_nplanes&)
          end!=TRUE
        ELSE
          ALERT 3,"Not enough memory for |this operation!",1," Cancel ",dummy&
          CLR ok!
        ENDIF
      DEFAULT
        RELSEEK #1,s_lengte%
      ENDSELECT
      ADD total%,s_lengte%
    LOOP UNTIL OR(EOF(#1),end!)
  DEFAULT
    RELSEEK #1,length%
  ENDSELECT
DEFAULT
  ALERT 3,"Not an IFF-Picture! ",1," Cancel ",dummy&
  CLR ok!
ENDSELECT
CLOSE
'
IF ok!
  IF OR(bm_nplanes&<3,NOT color_map!)
    @enable(ifftox%,iffraw&,3)
    @enable(ifftox%,iffrawtx&,3)
  ELSE
    @disable(ifftox%,iffraw&,3)
    @disable(ifftox%,iffrawtx&,3)
  ENDIF
  @form_do(ifftox%,dummy&)
  SELECT dummy&
  CASE ifftoimg&
    @create_img(adr%,bm_width&,bm_height&,bm_nplanes&)
  CASE iffttiff&,iffraw&
    IF bm_nplanes&>1
      @ofo("$$$",1,0)
      DIM buffer|(SUB(bm_width&,1),bm_nplanes&)
      PRINT "ECalculating... ";
      '
      ERASE buffer2%()
      CLR teller_&
      buffer2%=SUB(FRE(0),16384)
      number&=DIV(buffer2%,bm_width&)
      buffer2%=MUL(number&,bm_width&)
      DIM buffer2%(SHR(buffer2%,2))
      buffer2%=V:buffer2%(0)
      '
      FOR y&=0 TO SUB(bm_height&,1)
        IF EVEN(y&)
          PRINT AT(16,1);SUB(bm_height&,y&);", ";SUB(number&,teller_&);" "
        ENDIF
        dummy%=ADD(adr%,MUL(y&,bytes_per_line%))
        FOR lus&=0 TO SUB(bm_nplanes&,1)
          ~C:grow%(L:ADD(dummy%,MUL(lus&,bytes_per_line&)),L:V:buffer|(0,lus&),W:SUB(bm_width&,1),W:0)
        NEXT lus&
        IF bm_nplanes&>1
          BMOVE V:buffer|(0,0),buffer2%,bm_width&
          FOR lus&=SUB(bm_nplanes&,1) DOWNTO 1
            ~C:or%(L:V:buffer|(0,lus&),L:buffer2%,W:SUB(bm_width&,1),W:lus&)
          NEXT lus&
        ENDIF
        INC teller_&
        IF teller_&=number&
          buffer2%=V:buffer2%(0)
          BPUT #1,buffer2%,MUL(bm_width&,teller_&)
          CLR teller_&
        ELSE
          ADD buffer2%,bm_width&
        ENDIF
      NEXT y&
      IF teller_&
        BPUT #1,V:buffer2%(0),MUL(bm_width&,teller_&)
      ENDIF
      CLOSE
      PRINT AT(1,2);"Converting..."
      ERASE buffer%()
      OPEN "I",#1,@no_ext$("$$$")
      SELECT dummy&
      CASE iffttiff&
        @make_tiff(LOF(#1),bm_width&,bm_height&,8,color_map!,0,1)
      CASE iffraw&
        @create_raw(bm_width&,bm_height&)
        FOR y&=bm_height& DOWNTO 1
          PRINT AT(15,2);y&;" "
          FOR x&=1 TO bm_width&
            dummy&=WORD(INP(#1))
            OUT #2,kleur|(dummy&,0),kleur|(dummy&,1),kleur|(dummy&,2)
          NEXT x&
        NEXT y&
      ENDSELECT
      CLOSE
      @kill(@no_ext$("$$$"))
    ELSE
      PRINT "EConverting..."
      @make_tiff(adr%,bm_width&,bm_height&,1,0,0,2)
    ENDIF
  ENDSELECT
ENDIF
ENDIF
RETURN
> PROCEDURE depack_packbits(dummy%,adr%,total_bytes%) ! Dummy%=in, adr%=uit
teller%=total_bytes%
PRINT AT(1,12);"Depacking:"
DO
com1|=BYTE{dummy%}
INC dummy%
SELECT com1|
CASE 0 TO 127               ! Copy com1|+1 bytes immediately
  INC com1|
  BMOVE dummy%,adr%,com1|
  ADD dummy%,com1|
  ADD adr%,com1|
  SUB teller%,com1|
CASE 128 TO 255             ! Copy a byte-com1|+1 times
  com1|=SUB(257,com1|)
  com2|=BYTE{dummy%}
  INC dummy%
  SUB teller%,com1|
  FOR lus&=1 TO com1|
    BYTE{adr%}=com2|
    INC adr%
  NEXT lus&
  IF AND(EVEN(teller%),ODD(com1|))
    PRINT AT(12,12);teller%;"  "
  ENDIF
ENDSELECT
LOOP UNTIL teller%<=0
RETURN
> PROCEDURE open_mac
OPEN "I",#1,file$
ALERT 0,"Skip MAC-header? ",ADD(2,INP&(#1)<>0),"Yes|No",dummy&
CLS
SEEK #1,0
IF dummy&=1
PRINT AT(1,2);"File-Name: ";INPUT$(INP&(#1),#1)
SEEK #1,128
ENDIF
RELSEEK #1,512
total_bytes%=SUB(lof%,LOC(#1))
RETURN
> PROCEDURE mac_iff            ! MACpaint naar IFF/IMG/PCX
macintosh!=TRUE
IF @fileselect("Convert MAC-Paint","MAC")
@open_mac
DIM buffer%(ADD(SHR(total_bytes%,2),1))
buffer%=V:buffer%(0)
BGET #1,buffer%,total_bytes%
compressie|=1
LET colors%=1
@form_do(iffimgpc%,dummy&)
IF dummy&<>canceiip&
  CLOSE
  DIM buffer2%(12959)
  adr%=V:buffer2%(0)
  SELECT dummy&
  CASE iff&
    PRINT "Creating IFF"
    @create_iff(buffer%,576,720,1)
  CASE toimg&
    PRINT "Creating GEM Image (IMG)"
    @depack_packbits(buffer%,adr%,51840)
    @put_on_screen(adr%,576,720,1)
    @create_img(adr%,576,720,1)
  CASE paintbru&
    PRINT "Creating PaintBrush (PCX)"
    @depack_packbits(buffer%,adr%,51840)
    @put_on_screen(adr%,576,720,1)
    CLOSE
    @create_pcx(adr%,576,720,1)
  ENDSELECT
ENDIF
ENDIF
CLOSE
RETURN
> PROCEDURE put_on_screen(adres%,x&,y&,planes&)
LOCAL lus&,dummy%,dummy&,dummy2&,dummy3&,dummy4&,dummy1&
IF show_picture!
CLS
dummy%=phys%
dummy3&=SHR(ADD(max_x&,7),3)
dummy4&=SHR(ADD(x&,7),3)
dummy2&=MIN(dummy4&,dummy3&)
dummy1&=ADD(2,SHL(SUB(number_of_bitplanes&,1),1))
HIDEM
IF number_of_bitplanes&=1
  FOR lus&=0 TO MIN(SUB(y&,1),max_y&)
    BMOVE adres%,dummy%,dummy2&
    ADD adres%,MUL(dummy4&,planes&)
    ADD dummy%,dummy3&
  NEXT lus&
ELSE
  FOR lus&=0 TO MIN(SUB(y&,1),max_y&)
    FOR lus2&=1 TO dummy2& STEP 2
      INT{dummy%}=INT{adres%}
      ADD dummy%,dummy1&
      ADD adres%,2
    NEXT lus2&
    ADD adres%,ADD(SUB(dummy4&,dummy2&),MUL(dummy4&,SUB(planes&,1)))
    ADD dummy%,SUB(dummy3&,dummy2&)
  NEXT lus&
ENDIF
@press
ENDIF
RETURN
> PROCEDURE x_to_tiff
ALERT 0,"Convert TO or FROM|a TIFF picture?"+SPACE$(7),1,"To|From|Cancel",dummy&
SELECT dummy&
CASE 1
DO
  @clean_memory
  @form_do(tiff%,dummy&)
  EXIT IF dummy&=cancel&
  CLS
  SELECT dummy&
  CASE stad&
    dummy$="PAC"
  CASE degas&
    dummy$="P?3"
  CASE macpaint&
    dummy$="MAC"
  CASE img&
    dummy$="IMG"
  CASE ifftiff&
    dummy$="IFF"
  CASE gif&
    dummy$="GIF"
  CASE msxtiff&
    dummy$="SC?"
  ENDSELECT
  IF @fileselect("Convert "+dummy$,dummy$)
    SELECT dummy&
    CASE stad&                                ! STAD
      @depack(buffer%)
      IF NOT fout!
        ALERT 0,"Save TIFF picture? ",0,"Yes|No",dummy&
        IF dummy&=1
          @make_tiff(buffer%,640,400,1,0,0,2)
        ENDIF
      ENDIF
    CASE degas&                               ! Degas
      dummy$="P?3"
      @p_3(file$,buffer%,fout!)
      IF NOT fout!
        ALERT 0,"Save TIFF picture? ",0,"Yes|No",dummy&
        IF dummy&=1
          @make_tiff(buffer%,640,400,1,0,0,2)
        ENDIF
      ENDIF
    CASE macpaint&                                ! MAC-Paint
      @open_mac
      ALERT 0,"Save TIFF picture? ",0,"Yes|No",dummy&
      IF dummy&=1
        @make_tiff(total_bytes%,576,720,1,0,TRUE,1)
      ENDIF
    CASE img&                              ! IMG
      not_more_then_1!=TRUE
      @get_img(file$,buffer%)
      IF AND(buffer%<>-1,planes&=1)
        ALERT 0,"Save TIFF picture? ",0,"Yes|No",dummy&
        IF dummy&=1
          @make_tiff(buffer%,max&,may&,1,0,0,2)
        ENDIF
      ENDIF
    CASE ifftiff&                             ! IFF
      @iff_naar_img.tiff(TRUE)
    CASE msxtiff&                             ! MSX screen 5-8
      @form_do(msx%,dummy&)
      may&=212
      max&=512
      planes&=4
      DIM kleur|(255,2)
      kleur|(2,0)=1
      kleur|(2,1)=6
      kleur|(2,2)=1
      kleur|(3,0)=3
      kleur|(3,1)=7
      kleur|(3,2)=3
      kleur|(4,0)=1
      kleur|(4,1)=1
      kleur|(4,2)=7
      kleur|(5,0)=2
      kleur|(5,1)=3
      kleur|(5,2)=7
      kleur|(6,0)=5
      kleur|(6,1)=1
      kleur|(6,2)=1
      kleur|(7,0)=2
      kleur|(7,1)=6
      kleur|(7,2)=7
      kleur|(8,0)=7
      kleur|(8,1)=1
      kleur|(8,2)=1
      kleur|(9,0)=7
      kleur|(9,1)=3
      kleur|(9,2)=3
      kleur|(10,0)=6
      kleur|(10,1)=6
      kleur|(10,2)=1
      kleur|(11,0)=6
      kleur|(11,1)=6
      kleur|(11,2)=4
      kleur|(12,0)=1
      kleur|(12,1)=4
      kleur|(12,2)=1
      kleur|(13,0)=6
      kleur|(13,1)=2
      kleur|(13,2)=5
      kleur|(14,0)=5
      kleur|(14,1)=5
      kleur|(14,2)=5
      kleur|(15,0)=7
      kleur|(15,1)=7
      kleur|(15,2)=7
      SELECT dummy&
      CASE screen5&
        max&=256
      CASE screen6&
        planes&=2
      CASE screen8&
        FOR lus&=0 TO 255
          kleur|(lus&,0)=AND(lus&,&X11100000)
          kleur|(lus&,1)=AND(SHL(lus&,3),&X11100000)
          kleur|(lus&,2)=AND(SHL(lus&,6),&X11000000)
        NEXT lus&
        max&=256
        planes&=8
      ENDSELECT
      IF dummy&<>cancemsx&
        kleuren&=SUB(2^planes&,1)
        OPEN "I",#1,file$
        PRINT AT(1,24);"This picture was saved using the '"
        IF INP(#1)
          RELSEEK #1,6
          PRINT "BSAVE ,S";
        ELSE
          RELSEEK #1,3
          PRINT "COPY";
        ENDIF
        PRINT "'-command. ";AT(1,1);
        @make_tiff(SUB(lof%,LOC(#1)),max&,may&,planes&,TRUE,0,1)
      ENDIF
    ENDSELECT
  ENDIF
LOOP
CASE 2
IF @fileselect("Convert TIFF","TIF")
  @tiff_to_aim(file$)
ENDIF
ENDSELECT
CLOSE
RETURN
> PROCEDURE make_tiff(buffer%,max&,may&,planes&,color_map!,compression!,put_direct|)
HIDEM
dummy&=2^planes&
@ofo("TIF",2,0)
bytes_per_line&=SHR(ADD(MUL(max&,planes&),7),3)
bytes%=MUL(bytes_per_line&,may&)
'
INT{ADD(tiff_header%,18)}=max&
INT{ADD(tiff_header%,30)}=may&
INT{ADD(tiff_header%,42)}=planes&
IF compression!
INT{ADD(tiff_header%,54)}=32773  ! PackBits
INT{ADD(tiff_color_map_header%,54)}=32773
ELSE
INT{ADD(tiff_header%,54)}=1      ! 'Geen'
INT{ADD(tiff_color_map_header%,54)}=1
ENDIF
INT{ADD(tiff_color_map_header%,18)}=max&
INT{ADD(tiff_color_map_header%,30)}=may&
INT{ADD(tiff_color_map_header%,42)}=planes&
'
IF color_map!
INT{ADD(tiff_color_map_header%,66)}=3        ! Palet-color
{ADD(tiff_color_map_header%,78)}=ADD(362,SHL(MUL(dummy&,3),1)) ! SHL ivm words!
{ADD(tiff_color_map_header%,134)}=MUL(dummy&,3)
BPUT #2,tiff_color_map_header%,362
FOR lus&=0 TO SUB(dummy&,1)
  OUT& #2,SHL(kleur|(lus&,0),8),SHL(kleur|(lus&,1),8),SHL(kleur|(lus&,2),8)
NEXT lus&
ELSE
INT{ADD(tiff_header%,66)}=0
BPUT #2,tiff_header%,350
ENDIF
'
' als copy_direct!, dan buffer% aantal bytes
SELECT put_direct|
CASE 1                ! Copieer van file 1 naar file 2
@copy(1,2,buffer%)
CASE 2                ! Bits staan al goed opgeschoven klaar
BPUT #2,buffer%,bytes%
' case 3: shrink de bytes naar de goede positie
ENDSELECT
CLOSE
RETURN
> PROCEDURE out(a&)
OUT #1,AND(a&,255),SHR(a&,8)
RETURN
> PROCEDURE create_pcx(dummy%,max&,may&,planes&)
HIDEM
@ofo("PCX",1,0)
OUT #1,10,0,1,1                      ! 10 = ZSoft .PCX
'              ! Version 2.5 of PC Paintbrush
'                        ! PCX run length encoding
'                     ! Number of bits to represent a pixel (per plane)
OUT% #1,0                             ! Xmin, Ymin
@out(SUB(max&,1))                      ! Xmax
@out(SUB(may&,1))                      ! Ymax
@out(75)                ! HDpi
@out(75)                ! VDpi
FOR a%=&HFF8240 TO &HFF825E STEP 2               ! 16 kleuren
lus&=AND(32767,DPEEK(a%))
OUT #1,AND(SHR(lus&,8),&X1111),AND(SHR(lus&,4),&X1111),AND(lus&,&X1111)
NEXT a%
OUT #1,0,BYTE(planes&)                   ! Reserved, Bitplanes
bytes_per_line&=SHR(ADD(max&,7),3)
@out(bytes_per_line&)                       ! Bytes per line
@out(2)                        ! How to interpret palette 2 grayscale
@out(max&)                      ! Pixels horizontaal
@out(may&)                      ! Pixels verticaal
PRINT #1,STRING$(54,0);     ! Blank to fill out to 128 bytes
max_runcount|=63
PRINT AT(1,1);"Compressing... "
FOR lus&=0 TO SUB(may&,1)
@crunch_line(dummy%,bytes_per_line&)
ADD dummy%,bytes_per_line&
@counter(16,1,lus&)
NEXT lus&
CLOSE
RETURN
> PROCEDURE crunch_line(adres%,bytes_per_line&)
LET runcount|=1
last|=BYTE{adres%}
DEC bytes_per_line&
FOR scrindex&=1 TO bytes_per_line&
INC adres%
this|=BYTE{adres%}
IF this|=last|
  INC runcount|
  IF runcount|=max_runcount|
    @put_crunched_data(last|,runcount|)
    CLR runcount|
  ENDIF
ELSE
  IF runcount|
    @put_crunched_data(last|,runcount|)
  ENDIF
  last|=this|
  LET runcount|=1
ENDIF
NEXT scrindex&
IF runcount|
@put_crunched_data(last|,runcount|)
ENDIF
RETURN
> PROCEDURE put_crunched_data(byte|,count|)
' Als COUNT|=1 -> count|-1 =0, 0= kopier direkt!
' Anders gewoon copier -x+1 de volgende byte
IF AND(count|=1,AND(byte|,&HC0)<>&HC0)
OUT #1,byte|
ELSE
OUT #1,OR(count|,&HC0),byte|
ENDIF
RETURN
> PROCEDURE tiff_to_aim(file$)
planes&=1
compression&=1
CLR palet!
OPEN "I",#1,file$
motorola!=19789=INP&(#1)
~@winp        ! Versie
begin_of_the_commands%=@linp
number_of_tags&=@winp
PRINT "ENumber of tags: ";number_of_tags&
SEEK #1,ADD(begin_of_the_commands%,2)
DO
command&=@winp
LET data_type&=@winp
IF AND(command&=0,data_type&=0)
  start_of_picture!=TRUE
ELSE
  aantal_datas%=@linp
  SELECT data_type&
  CASE 1,2                    ! Byte/Ascii (0 terminated)
    mul|=1
  CASE 3                      ! Short (16 bit)
    mul|=2
  CASE 4                      ! Long  (32 bit)
    mul|=4
  CASE 5                      ! Real  (64 bit)
    mul|=8
  DEFAULT
    error!=TRUE
  ENDSELECT
  length%=MUL(aantal_datas%,mul|)
  ERASE data_buffer%()
  IF @check_enough_memory(length%)
    DIM data_buffer%(ADD(SHR(length%,2),1))
    LET data_buffer%=V:data_buffer%(0)
    dummy!=TRUE
  ELSE
    LET data_buffer%=div_buffer%
    CLR dummy!
  ENDIF
  IF length%<5                              ! Anders offset naar data
    IF length%<4
      {data_buffer%}=ADD(SHL(@winp,16),@winp)
    ELSE
      {data_buffer%}=@linp
    ENDIF
  ELSE
    offset%=@linp
    IF dummy!
      loc%=LOC(#1)
      SEEK #1,offset%
      BGET #1,data_buffer%,length%
      SEEK #1,loc%
    ELSE
      PRINT "Not enough memory to read data from this tag!"
    ENDIF
  ENDIF
  @command(command&)
ENDIF
LOOP UNTIL OR(start_of_picture!,tags&=number_of_tags&)
SEEK #1,strip_offsets%                          ! 0 bytes
IF OR(number_of_tags&<>tags&,error!)
ALERT 1,"Warning!| |This TIFF-image may |be damaged! ",0," Stop |Continue",dummy&
ELSE
@press
dummy&=2
ENDIF
IF AND(OR(compression&=1,compression&=-32763),dummy&=2)
IF samples_per_pixel%=3
  dummy&=tiffraw&
ELSE
  IF planes&=1
    @disable(tifftox%,tiffimg&,3)
    @disable(tifftox%,tiffimgt&,3)
    IF AND(max&=640,may&=400)
      @disable(tifftox%,tiffpac&,3)
      @disable(tifftox%,tiffpac&,3)
    ELSE
    pac_disable:
      @enable(tifftox%,tiffpac&,3)
      @enable(tifftox%,tiffpac&,3)
    ENDIF
  ELSE
    @enable(tifftox%,tiffimg&,3)
    @enable(tifftox%,tiffimgt&,3)
    GOTO pac_disable                          ! Gatver! Goto! Yuck!
  ENDIF
  @form_do(tifftox%,dummy&)
ENDIF
IF dummy&<>canctiff&
  step&=DIV(8,planes&)
  PRINT "EConverting, please wait..."
  SELECT compression&
  CASE 0,1
    ' Doe niets
  CASE 2
    ' Depack CCITT
  CASE 5
    ' Depack LZW
  CASE -32763
    PRINT AT(1,2);"Please wait, depacking... "
    @ofo("$$$",3,0)
    DIM buffer2%(32)
    adr%=V:buffer2%(0)
    teller%=MUL(may&,DIV(max&,step&))
    DO UNTIL EOF(#1)
      com1|=INP(#1)
      SELECT com1|
      CASE 0 TO 127               ! Copy com1|+1 bytes immediately
        INC com1|
        BGET #1,adr%,com1|
        BPUT #3,adr%,com1|
        SUB teller%,com1|
        IF AND(EVEN(teller%),ODD(com1|))
          PRINT AT(29,2);teller%;"  "
        ENDIF
      CASE 129 TO 255             ! Copy a byte-com1|+1 times
        com1|=SUB(257,com1|)
        com2|=INP(#1)
        FOR lus&=1 TO com1|
          OUT #3,com2|
        NEXT lus&
        SUB teller%,com1|
      CASE 128
        INC unused%
      ENDSELECT
    LOOP UNTIL teller%=0
    ERASE buffer2%()
    PRINT "Done!"
    PRINT AT(1,2);"K";AT(1,1);"    Saving"
    CLOSE #3
    CLOSE #1
    OPEN "I",#1,@no_ext$("$$$")
  ENDSELECT
  SELECT dummy&
  CASE tiffpac&
    PRINT "EConverting to Stad..."
    DIM buffer%(7999)
    BGET #1,V:buffer%(0),32000
    CLOSE
    @put_on_screen(V:buffer%(0),640,400,1)
    @pack_it(V:buffer%(0))
  CASE tiffimg&
    bytes_per_line&=SHR(ADD(max&,7),3)
    bytes%=MUL(bytes_per_line&,may&)
    IF @check_enough_memory(bytes%)
      DIM buffer%(SHR(bytes%,2))
      BGET #1,V:buffer%(0),bytes%
      CLOSE
      IF photometric_interpretation%=1
        ~C:invert%(L:V:buffer%(0),L:SHR(bytes%,2))
      ENDIF
      @put_on_screen(V:buffer%(0),max&,may&,1)
      @create_img(V:buffer%(0),max&,may&,1)
    ELSE
      img!=TRUE
      DIM buffer%(SHR(bytes_per_line&,2))
      DIM buffer2%(SHR(bytes_per_line&,1))
      @ofo("IMG",2,0)
      OUT& #1,1,8,1,1,pixel_h&,pixel_w&,max&,may&
      FOR y&=1 TO may&
        @counter(28,1,y&)
        adres%=V:buffer%(0)
        buffer2%=V:buffer2%(0)
        BGET #1,adres%,bytes_per_line&
        IF photometric_interpretation%=1
          ~C:invert%(L:adres%,L:SHR(bytes_per_line&,2))
        ENDIF
        CLR teller&
        @packrow(adres%,bytes_per_line&,2)
        buffer2%=V:buffer2%(0)
        BPUT #2,buffer2%,teller&
      NEXT y&
    ENDIF
  CASE tiffraw&                            ! RAW
    PRINT "ECreating 24Bits TRUE-Color RAW-file"
    @create_raw(max&,may&)
    '
    ' True-Color = tiff class 2?
    '
    IF AND(photometric_interpretation%=2,samples_per_pixel%=3)       ! =true color
      @copy(1,2,MUL(MUL(max&,may&),3))
    ELSE                    ! =color map oid
      bytes_per_line&=SHR(ADD(MUL(max&,planes&),7),3)
      DIM buffer%(SHR(bytes_per_line&,2)),buffer|(max&)
      buffer%=V:buffer%(0)
      buffer2%=V:buffer|(0)
      max_&=SUB(max&,1)
      FOR y&=1 TO may&
        @counter(28,1,y&)
        IF planes&<8
          BGET #1,buffer%,bytes_per_line&
          ~C:grow%(L:buffer%,L:buffer2%,W:max_&,W:SUB(planes&,1))
        ELSE
          BGET #1,buffer2%,max&
        ENDIF
        adres%=buffer2%
        FOR x&=0 TO max_&           ! vanaf buffer2%
          byte|=BYTE{adres%}
          INC adres%
          IF palet!
            OUT #2,kleur|(byte|,0),kleur|(byte|,1),kleur|(byte|,2)
          ELSE
            OUT #2,byte|,byte|,byte|      ! Geen palet?!?! Hoe kan dat nou?
          ENDIF
        NEXT x&
      NEXT y&
    ENDIF
    CLOSE
  CASE tiffaim&                            ! AIM
    IF palet!
      @choose_palet_interpretation(rood&,groen_geel&,blauw&,div&)
    ENDIF
    @ofo("IM",2,0)
    IF planes&=8
      IF palet!
        FOR y&=1 TO may&
          @counter(28,1,y&)
          FOR x&=1 TO max&
            OUT #2,FN grayscale(INP(#1))
          NEXT x&
        NEXT y&
      ELSE
        @copy(1,2,MUL(max&,may&))
      ENDIF
      dummy2&=max&
    ELSE
      bytes_per_line&=SHR(MUL(SHL(SHR(ADD(max&,7),3),3),planes&),3)
      DIM buffer%(SHR(bytes_per_line&,2))
      buffer%=V:buffer%(0)
      dummy2&=max&
      buffer2%=SUB(FRE(0),16384)
      number&=DIV(buffer2%,dummy2&)
      buffer2%=MUL(number&,dummy2&)
      DIM buffer2%(SHR(buffer2%,2))
      buffer2%=V:buffer2%(0)
      DEC number&
      max_&=SUB(max&,1)
      FOR y&=1 TO may&
        IF EVEN(y&)
          PRINT AT(28,1);SUB(may&,y&);", ";SUB(number&,teller_&);"  "
        ENDIF
        BGET #1,buffer%,bytes_per_line&
        IF AND(photometric_interpretation%=1,planes&=1)
          ~C:invert%(L:buffer%,L:SHR(bytes_per_line&,2))
        ENDIF
        ~C:grow%(L:buffer%,L:buffer2%,W:max_&,W:SUB(planes&,1))
        FOR dummy%=buffer2% TO ADD(buffer2%,max_&)
          BYTE{dummy%}=FN grayscale(BYTE{dummy%})
        NEXT dummy%
        INC teller_&
        IF teller_&=number&
          buffer2%=V:buffer2%(0)
          BPUT #2,buffer2%,MUL(dummy2&,teller_&)
          CLR teller_&
        ELSE
          ADD buffer2%,dummy2&
        ENDIF
      NEXT y&
      IF teller_&
        BPUT #2,V:buffer2%(0),MUL(dummy2&,teller_&)
      ENDIF
    ENDIF
    CLOSE
    @create_hd(dummy2&,1)
  CASE tiffiff&                                     ! IFF
    bytes_per_line&=SHR(MUL(SHL(SHR(ADD(max&,7),3),3),planes&),3)
    '
    @ofo("IFF",2,0)
    OUT% #2,CVL("FORM"),0,CVL("ILBM"),CVL("BMHD"),20
    OUT& #2,max&,may&            ! X-res,Y-res
    OUT% #2,0
    OUT #2,planes&,0                ! Bitpl., mask
    OUT #2,1,0           ! compressie, Reserved
    OUT& #2,0                     ! Transpartant kleur
    OUT #2,ADD(5,ABS(MUL(planes&<>4,5))),11
    OUT& #2,max&,may&             ! X-res,Y-res
    OUT% #2,CVL("CAMG"),4,0
    IF palet!
      OUT% #2,CVL("CMAP")
      OUT% #2,MUL(2^planes&,3)
      FOR lus&=0 TO SUB(2^planes&,1)
        OUT #2,kleur|(lus&,0),kleur|(lus&,1),kleur|(lus&,2)
      NEXT lus&
    ELSE
      ALERT 0,"No pallette-info in this |picture. Add grayscale|pallette?",0,"Yes|No",dummy&
      IF dummy&=1
        OUT% #2,CVL("CMAP")
        OUT% #2,MUL(2^planes&,3)
        kleuren&=SUB(2^planes&,1)
        mul=255/kleuren&
        FOR lus&=0 TO kleuren&
          a&=lus&*mul
          OUT #2,BYTE(a&),BYTE(a&),BYTE(a&)
        NEXT lus&
      ENDIF
    ENDIF
    OUT% #2,CVL("BODY")             ! body
    total_bytes%=LOC(#2)
    OUT% #2,0
    '             #1 is open en staat goed (la me da maar hopu!).
    DIM buffer|(max&)
    buffer%=V:buffer|(0)
    DIM buffer%(SHR(bytes_per_line&,2))
    buffer2%=V:buffer%(0)
    FOR y&=1 TO may&
      @counter(27,1,y&)
      BGET #1,buffer2%,bytes_per_line&
      IF AND(planes&=1,photometric_interpretation%=1)
        ~C:invert%(L:buffer2%,L:SHR(bytes_per_line&,2))
      ENDIF
      ~C:grow%(L:buffer2%,L:buffer%,W:SUB(max&,1),W:SUB(planes&,1))
      @put_one_iff_line(buffer%,buffer2%,max&,2)
    NEXT y&
    '
    dummy%=LOC(#2)
    length%=SUB(dummy%,ADD(total_bytes%,8))
    SEEK #2,total_bytes%
    OUT% #2,length%
    '
    SEEK #2,4
    OUT% #2,dummy%
    SEEK #2,LOF(#2)
    CLOSE
  ENDSELECT
  @kill(@no_ext$("$$$"))
  PRINT AT(28,1);"Done!K"
ENDIF
ELSE
@form_do(nottiff%,dummy&)
ENDIF
CLOSE
RETURN
> PROCEDURE create_hd(max&,dummy&)
@ofo("HD",3,TRUE)
OUT% #3,0
PRINT #3,LEFT$(@no_ext$("IM")+STRING$(16,0),16);
OUT& #3,1,max&,may&,dummy&
PRINT #3,STRING$(34,0);
CLOSE #3
RETURN
> PROCEDURE put_one_iff_line(buffer%,buffer2%,max&,file|)
bytes&=SHR(ADD(max&,7),3)
FOR lus&=1 TO planes&
~C:get_1_bit%(L:buffer%,L:buffer2%,W:lus&,W:SUB(max&,1))
@packrow(buffer2%,bytes&,file|)
NEXT lus&
RETURN
DEFFN grayscale(a|)=DIV(ADD(ADD(MUL(kleur|(a|,0),rood&),MUL(kleur|(a|,1),groen_geel&)),MUL(kleur|(a|,2),blauw&)),div&)
> PROCEDURE choose_palet_interpretation(VAR rood&,groen_geel&,blauw&,div&)
@form_do(palet%,dummy2&)
SELECT dummy2&
CASE usevalue&
rood&=VAL(CHAR{{OB_SPEC(palet%,aa&)}})
groen_geel&=VAL(CHAR{{OB_SPEC(palet%,bb&)}})
blauw&=VAL(CHAR{{OB_SPEC(palet%,cc&)}})
div&=ADD(ADD(rood&,groen_geel&),blauw&)
IF div&=0
  CLR palet!
ENDIF
CASE ignorepa&
CLR palet!
ENDSELECT
RETURN
> FUNCTION winp
IF motorola!
RETURN INP&(#1)
ELSE
RETURN WORD(ADD(INP(#1),SHL(INP(#1),8)))
ENDIF
ENDFUNC
> FUNCTION linp
IF motorola!
RETURN INP%(#1)
ELSE
RETURN ADD(@winp,SHL(@winp,16))
ENDIF
ENDFUNC
> PROCEDURE copy(in_file|,out_file|,length%)
buffer%=MIN(SUB(FRE(0),4352),length%)
DIM copy_buffer%(ADD(SHR(buffer%,2),1))
adres%=V:copy_buffer%(0)
DO WHILE length%
copy%=MIN(length%,buffer%)
BGET #in_file|,adres%,copy%
BPUT #out_file|,adres%,copy%
SUB length%,copy%
LOOP
RETURN
> PROCEDURE command(type&)
dummy!=TRUE
INC tags&
SELECT type&
CASE 253                      ! TiffClass ($FD)
PRINT "TiffClass";
CASE 254                      ! Subfile Type
PRINT "Subfile Type";
CASE 255
PRINT "Old subfile Type";
CASE 256                      ! Image Width
PRINT "Image Width";
@rational
max&=WORD(rational%)
CASE 257                      ! Image Length
PRINT "Image Length";
@rational
may&=WORD(rational%)
CASE 258                      ! BitsPerSample
PRINT "Bits per sample";
@rational
planes&=WORD(rational%)
CASE 259                        ! Compression
PRINT "Compression Type";
@rational
compression&=WORD(rational%)
CASE 262                      ! PhotometricInterpretation
PRINT "Photometric Interpretation";
@rational
photometric_interpretation%=rational%
CASE 263
PRINT "Threshholding";
CASE 264                      ! CellWidth
PRINT "Cell Width";
CASE 265                      ! Cell Length
PRINT "Cell Length";
CASE 266                      ! Fill Order
PRINT "Fill Order";
CASE 269                      ! Document Name
PRINT "Document Name";
CASE 270                      ! Image Description
PRINT "Image Description";
CASE 271                      ! Make                 (make_r_ ?)
PRINT "Maker";
CASE 272                      ! Model
PRINT "Model";
CASE 273                      ! StrippOffsets
PRINT "Strip Offsets";
@rational
strip_offsets%=rational%
CASE 274                      ! Orientation
PRINT "Orientation";
CASE 277                      ! SamplesPerPixel
PRINT "Samples per Pixel";
@rational
samples_per_pixel%=rational%
CASE 278                      ! Rows Per Strip
PRINT "Rows Per Strip";
CASE 279                      ! StripByteCounts
PRINT "Strip Byte Counts";
CASE 280                      ! MinSampleValue
PRINT "(Min.) Samples Per Pixel";
CASE 281                      ! MaxSampleValue
PRINT "(Max.) Samples Per Pixel";
CASE 282                      ! XResolution
PRINT "X-Resolution";
CASE 283                      ! YResolution
PRINT "Y-Resolution";
CASE 284                      ! PlanarConfiguration
PRINT "PlanarConfiguration";
CASE 285                      ! Page Name
PRINT "Page Name";
CASE 286                      ! XPosition
PRINT "X-Position";
CASE 287                      ! YPosition
PRINT "Y-Position";
CASE 288                      ! FreeOffsets
PRINT "Free Offsets";
CASE 289                      ! Free Byte Counts
PRINT "Free Byte Counts";
CASE 290                      ! Gray Response Unit
PRINT "Gray Response Unit";
CASE 291                      ! Gray Response Curve
PRINT "There is a Gray Response Curve in this file."
CLR dummy!
CASE 292                      ! Group3Options
PRINT "Group 3 Options";
CASE 293                      ! Group4Options
PRINT "Group 4 Options";
CASE 296                      ! ResolutionUnit
PRINT "Resolution Unit";
CASE 297                      ! PageNumber
PRINT "Page Number";
CASE 301                      ! ColorResponseCurves
PRINT "There are Color Response Curves in this file."
CLR dummy!
CASE 305                      ! Software
PRINT "Software";
CASE 306                      ! DateTime
PRINT "Date & Time";
CASE 315                      ! Artist
PRINT "Artist";
CASE 316                      ! HostComputer
PRINT "Host Computer";
CASE 317                      ! Predictor
PRINT "Predictor";
CASE 318                      ! WhitePoint
PRINT "White Point";
CASE 319                      ! PrimaryChromaticities
PRINT "Primary Chromaticities";
'
'
'
CASE 309                      ! ScreenPattern <---------- (niet in Tiff-Doc!)
PRINT "ScreenPattern";
'
'
'
CASE 320                      ! ColorMap
PRINT "There is a Color Map in this file."
CLR dummy!
palet!=TRUE
kleuren&=SUB(2^planes&,1)
DIM kleur|(255,2)
FOR lus&=0 TO kleuren&
SELECT mul|
CASE 1
FOR dummy&=0 TO 2
  kleur|(lus&,dummy&)=BYTE{data_buffer%}
  INC data_buffer%
NEXT dummy&
CASE 2
FOR dummy&=0 TO 2
  kleur|(lus&,dummy&)=SHR(AND(INT{data_buffer%},65535),8)
  ADD data_buffer%,2
NEXT dummy&
CASE 4
FOR dummy&=0 TO 2
  kleur|(lus&,dummy&)=SHR({data_buffer%},24)
  ADD data_buffer%,4
NEXT dummy&
ENDSELECT
NEXT lus&
DEFAULT
PRINT "pUnknown TAG found (type: ";type&;")! Data";
ENDSELECT
@rational
RETURN
> PROCEDURE rational
SELECT data_type&
CASE 1
rational%=BYTE{data_buffer%}
CASE 2
rational$=CHAR{data_buffer%}
CASE 3
rational%=WORD{data_buffer%}
CASE 4
rational%={data_buffer%}
CASE 5
' real
ENDSELECT
IF dummy!
CLR dummy!
PRINT " ";
SELECT data_type&
CASE 1                      ! Byte
PRINT "(byte): ";rational%
CASE 2                      ! ASCII-String, 0 terminated
rational%=VAL(rational$)
PRINT "(ascii): ";rational$
CASE 3                      ! Short
PRINT "(short): ";rational%
CASE 4                      ! Long
PRINT "(long): ";rational%
CASE 5                      ! Real
PRINT "(real): ";{data_buffer%};" ";{ADD(data_buffer%,4)}
ENDSELECT
ENDIF
RETURN
> PROCEDURE ofo(ext$,file|,bk!)
naam$=@no_ext$("")
IF bk!
dummy1$=naam$+"BK!"
ELSE
dummy1$=naam$+"BAK"
ENDIF
@kill(dummy1$)
dummy2$=naam$+ext$
IF EXIST(dummy2$)
r&=GEMDOS(67,L:V:dummy2$,0,-1)
IF r&>0
~GEMDOS(67,L:V:dummy2$,1,AND(r&,&X111110))
ENDIF
RENAME dummy2$ AS dummy1$
ENDIF
OPEN "O",#file|,dummy2$
RETURN
> PROCEDURE img_to_iff
PRINT "EReading, Converting and Writing image: ";file$;
OPEN "I",#1,file$
~INP&(#1)
words&=INP&(#1)
planes&=INP&(#1)
PRINT "Colors: ";2^planes&
pattern_run_length&=INP&(#1)
~INP%(#1)                                               ! l*b pixels
max&=INP&(#1)
may&=INP&(#1)
PRINT "Resolution: ";max&;"x";may&
PRINT "Converting..."
SEEK #1,SHL(words&,1)
'
bytes_per_regel&=SHR(ADD(max&,7),3)
copy|=1
DIM buffer%(SHR(bytes_per_regel&,2))
buffer_in%=V:buffer%(0)
DIM buffer2%(SHR(bytes_per_regel&,1))
buffer_uit%=V:buffer2%(0)
'
y&=MUL(may&,planes&)
@ofo("IFF",2,0)
OUT% #2,CVL("FORM"),0,CVL("ILBM"),CVL("BMHD"),20
OUT& #2,max&,may&            ! X-res,Y-res
OUT% #2,0
OUT #2,planes&,0                ! Bitpl., mask
OUT #2,1,0           ! Compressie, Reserved
OUT& #2,0                     ! Transpartant kleur
OUT #2,ADD(5,ABS(MUL(planes&<>4,5))),11
OUT& #2,max&,may&             ! X-res,Y-res
bytes_per_line&=SHR(ADD(max&,7),3)
OUT% #2,CVL("BODY")             ! body
total_bytes%=LOC(#2)
OUT% #2,0
'
dummy%=buffer_uit%
DO
byte|=INP(#1)
SELECT byte|
CASE 0
byte2|=INP(#1)
SELECT byte2|
CASE 0
IF INP(#1)=&HFF
  copy|=INP(#1)
ELSE
  PRINT "(Error in IMG!)"
ENDIF
DEFAULT
IF pattern_run_length&>1
  pattern$=INPUT$(pattern_run_length&,#1)
  aantal&=MUL(pattern_run_length&,WORD(byte2|))
  '
  ADD bytes&,aantal&
  '
  FOR lus&=2 TO pattern_run_length&
    EXIT IF MID$(pattern$,1,1)<>MID$(pattern$,lus&,1)
  NEXT lus&
  IF lus&=ADD(pattern_run_length&,1)
    pattern|=ASC(MID$(pattern$,1,1))
    DO
      dummy|=MIN(127,aantal&)
      BYTE{dummy%}=-SUB(dummy|,1)
      INC dummy%
      BYTE{dummy%}=pattern|
      INC dummy%
      SUB aantal&,dummy|
    LOOP WHILE aantal&
  ELSE
    buffer%=buffer_in%
    FOR lus&=1 TO WORD(byte2|)
      BMOVE V:pattern$,buffer%,pattern_run_length&
      ADD buffer%,pattern_run_length&
    NEXT lus&
    buffer%=buffer_in%
    DO
      dummy|=MIN(128,aantal&)
      BYTE{dummy%}=SUB(dummy|,1)
      INC dummy%
      BMOVE buffer%,dummy%,dummy|
      ADD buffer%,dummy|
      ADD dummy%,dummy|
      SUB aantal&,dummy|
    LOOP WHILE aantal&
  ENDIF
ELSE
  ADD bytes&,WORD(byte2|)
  pattern|=INP(#1)
  DO
    dummy|=MIN(127,byte2|)
    BYTE{dummy%}=-SUB(dummy|,1)
    INC dummy%
    BYTE{dummy%}=pattern|
    INC dummy%
    SUB byte2|,dummy|
  LOOP WHILE byte2|
ENDIF
ENDSELECT
CASE 128                      ! Copy direct
aantal&=INP(#1)
buffer%=buffer_in%
BGET #1,buffer%,aantal&
ADD bytes&,aantal&
DO
dummy|=MIN(128,aantal&)
BYTE{dummy%}=SUB(dummy|,1)
INC dummy%
BMOVE buffer%,dummy%,dummy|
ADD dummy%,dummy|
ADD buffer%,dummy|
SUB aantal&,dummy|
LOOP WHILE aantal&
DEFAULT
pattern|=ABS(MUL(255,BTST(byte|,7)))
aantal&=AND(byte|,127)
BYTE{dummy%}=-SUB(aantal&,1)
INC dummy%
BYTE{dummy%}=pattern|
INC dummy%
ADD bytes&,aantal&
ENDSELECT
IF bytes&=>bytes_per_regel&
IF bytes&>bytes_per_regel&
PRINT "(Error in IMG!)"
ENDIF
FOR lus&=1 TO WORD(copy|)
BPUT #2,buffer_uit%,SUB(dummy%,buffer_uit%)
DEC y&
NEXT lus&
dummy%=buffer_uit%
copy|=1
PRINT AT(15,4);y&;"  "
CLR bytes&
ENDIF
LOOP WHILE y&
dummy%=LOC(#2)
length%=SUB(dummy%,ADD(total_bytes%,8))
SEEK #2,total_bytes%
OUT% #2,length%
'
SEEK #2,4
OUT% #2,dummy%
SEEK #2,LOF(#2)
CLOSE
PRINT AT(1,4);"Done!";SPACE$(20)
RETURN
> PROCEDURE crunch_scherm(buffer%,x&,y&,planes&,file|)
IF img!
maxrun|=255
maxdat|=255
ELSE
maxrun|=128
maxdat|=128
ENDIF
'
DIM buffer3|(SHL(max&,1)),buffer2|(SHL(max&,1))
buffer3%=V:buffer2|(0)
'
rowsize&=SHR(ADD(x&,7),3)
CLR vorige_teller&
copy&=1
'
FOR lus&=0 TO SUB(y&,1)
FOR lus_&=0 TO SUB(planes&,1)
CLR teller&
buffer2%=V:buffer3|(0)
source%=ADD(buffer%,MUL(ADD(lus&,lus_&),rowsize&))
@packrow(source%,rowsize&,1)
'
IF img!
IF teller&=vorige_teller&
  ongelijk!=C:compare%(L:buffer3%,L:V:buffer3|(0),W:SUB(teller&,1))
ELSE
  ongelijk!=TRUE
ENDIF
IF OR(ongelijk!,copy&=255)
  IF copy&>1      ! copy is altijd op z'n minst 1
    OUT #1,0,0,255,BYTE(copy&)     ! Copy scanline x times
    copy&=1
  ENDIF
  BPUT #1,buffer3%,vorige_teller&
ELSE
  INC copy&
ENDIF
vorige_teller&=teller&
buffer2%=V:buffer3|(0)
BMOVE buffer2%,buffer3%,teller&
ENDIF
'
NEXT lus_&
PRINT AT(1,1);SUB(y&,lus&);" "
NEXT lus&
IF img!
IF copy&>1
OUT #1,0,0,255,BYTE(copy&)
ENDIF
BPUT #1,buffer3%,vorige_teller&
ENDIF
RETURN
> FUNCTION getbyte
byte|=BYTE{source%}
INC source%
RETURN byte|
ENDFUNC
> PROCEDURE outdump(aantal&)
IF img!
BYTE{buffer2%}=128                  ! Copy direct
INC buffer2%
BYTE{buffer2%}=BYTE(aantal&)
INC buffer2%
BMOVE V:buf|(0),buffer2%,aantal&
ADD buffer2%,aantal&
ADD teller&,ADD(aantal&,2)
ELSE
OUT #file|,SUB(aantal&,1)
BPUT #file|,V:buf|(0),aantal&
ENDIF
RETURN
> PROCEDURE outrun(aantal&,pattern|)
IF img!
IF AND(OR(pattern|=0,pattern|=255),aantal&<128)
BYTE{buffer2%}=OR(AND(pattern|,128),aantal&)          ! Bit_run
INC buffer2%
INC teller&
ELSE
BYTE{buffer2%}=0                        ! Pattern_run
INC buffer2%
BYTE{buffer2%}=BYTE(aantal&)
INC buffer2%
BYTE{buffer2%}=pattern|
INC buffer2%
ADD teller&,3
ENDIF
ELSE
OUT #file|,BYTE(SUB(0,SUB(aantal&,1))),pattern|
ENDIF
RETURN
> PROCEDURE packrow(source%,rowsize&,file|)
CLR mode!
CLR rstart&
c|=@getbyte
lastc|=c|
buf|(0)=lastc|
nbuf&=1
'
DEC rowsize&
'
DO WHILE rowsize&
c|=@getbyte
buf|(nbuf&)=c|
INC nbuf&
IF NOT mode!            !  case DUMP
IF nbuf&>maxdat|
@outdump(SUB(nbuf&,1))
buf|(0)=c|
nbuf&=1
CLR rstart&
ELSE IF c|=lastc|
IF SUB(nbuf&,rstart&)=>minrun|
IF rstart&>0
  @outdump(rstart&)
ENDIF
mode!=TRUE
ELSE IF rstart&=0
mode!=TRUE
ENDIF
ELSE
rstart&=SUB(nbuf&,1)
ENDIF
ELSE IF OR(c|<>lastc|,SUB(nbuf&,rstart&)>maxrun|)
@outrun(SUB(SUB(nbuf&,1),rstart&),lastc|)
buf|(0)=c|
nbuf&=1
CLR rstart&
CLR mode!
ENDIF
lastc|=c|
DEC rowsize&
LOOP
IF mode!
@outrun(SUB(nbuf&,rstart&),lastc|)
ELSE
@outdump(nbuf&)
ENDIF
RETURN
> PROCEDURE kill(dummy$)
IF EXIST(dummy$)
KILL dummy$
ENDIF
RETURN
> PROCEDURE disable(dummy%,dummy&,bit|)
OB_STATE(dummy%,dummy&)=BCLR(OB_STATE(dummy%,dummy&),bit|)
RETURN
> PROCEDURE enable(dummy%,dummy&,bit|)
OB_STATE(dummy%,dummy&)=BSET(OB_STATE(dummy%,dummy&),bit|)
RETURN
> PROCEDURE breek
ON BREAK CONT
ALERT 0,"Yeah, you can stop |that way too!",3," Exit | Stop |Continue",dummy&
SELECT dummy&
CASE 1
@stoppen
CASE 2
~RSRC_FREE()
RESERVE
RUN
CASE 3
OUT 2,7
ENDSELECT
ON BREAK GOSUB breek
RETURN
> PROCEDURE counter(x&,y&,lus&)
PRINT AT(x&,y&);SUB(may&,lus&);" ";
RETURN
DEFFN check_enough_memory(bytes%)=SUB(FRE(0),5120)>bytes%
'
> PROCEDURE convert_raw
DO
@clean_memory
@form_do(raw%,dummy&)
SELECT dummy&
CASE gif2raw&
@gif_2_raw
CASE pcxtoraw&
IF @fileselect("Convert PCX","PCX")
OPEN "I",#1,file$
IF INP(#1)=10
version&=INP(#1)
compressie!=INP(#1)=1
bitsperpixel&=INP(#1)
xmin&=@winp
ymin&=@winp
xmax&=@winp
ymax&=@winp
RELSEEK #1,4          ! DPI
RELSEEK #1,49         ! Palet & reserved=0
planes&=INP(#1)
IF AND(bitsperpixel&=8,planes&=3)
  PRINT "EConverting...";
  bytesperline&=@winp
  RELSEEK #1,60       ! palet-info, screensize en filler (54 bytes)
  DIM buffer1|(SHL(bytesperline&,1)) ! In (ev. packed)
  max&=SUB(xmax&,xmin&)
  may&=SUB(ymax&,ymin&)
  DIM buffer2|(SUB(max&,1),2)
  DIM buffer3|(max&)
  @create_raw(max&,may&)
  FOR y&=1 TO may&
    @counter(15,1,y&)
    FOR lus_&=0 TO 2                    ! 3 bytes per pixel
      FOR lus&=1 TO 8                   ! 8 bits per R, G en B
        buffer%=V:buffer1|(0)
        IF compressie!
          dummy&=bytesperline&
          DO
            dummy|=INP(#1)
            IF AND(dummy|,&X11000000)=&X11000000
              byte|=INP(#1)
              FOR n&=1 TO WORD(AND(dummy|,&X111111))
                BYTE{buffer%}=byte|
                INC buffer%
                DEC bytesperline&
              NEXT n&
            ELSE
              BYTE{buffer%}=dummy|
              INC buffer%
              DEC bytesperline&
            ENDIF
          LOOP WHILE dummy&
        ELSE
          BGET #1,buffer%,bytesperline&
        ENDIF
        IF lus&=1
          ~C:grow%(L:buffer%,L:V:buffer2|(0,lus_&),W:SUB(max&,1),W:0)
        ELSE
          ~C:grow%(L:buffer%,L:V:buffer3|(0),W:SUB(max&,1),W:0)
          ~C:or%(L:V:buffer3|(0),L:V:buffer3|(0,lus_&),W:SUB(max&,1),W:lus&)
        ENDIF
      NEXT lus&
    NEXT lus_&
    FOR lus&=0 TO SUB(max&,1)
      OUT #2,buffer2|(lus&,0),buffer2|(lus&,1),buffer2|(lus&,2)
    NEXT lus&
  NEXT y&
ELSE
  ALERT 0,"Not a 24-Bits PCX-file! ",1," Cancel ",dummy&
ENDIF
ELSE
ALERT 0,"Not a PCX-file! ",1," Cancel ",dummy&
ENDIF
CLOSE
ENDIF
CASE bwtoraw&
IF @fileselect("Convert B&W","B&W")
OPEN "I",#1,file$
IF INPUT$(6,#1)="B&W256"
PRINT "EConverting...";
max&=INP&(#1)
may&=INP&(#1)
@create_raw(max&,may&)
DIM buffer|(SUB(max&,1))
buffer%=V:buffer|(0)
FOR y&=1 TO may&
  @counter(15,1,y&)
  BGET #1,buffer%,max&
  FOR x&=0 TO SUB(max&,1)
    byte|=BYTE{ADD(buffer%,x&)}
    OUT #2,byte|,byte|,byte|
  NEXT x&
NEXT y&
ELSE
ALERT 3,"Not a valid 256|grayscales picture! ",1," Cancel ",dummy&
ENDIF
CLOSE
ENDIF
CASE ifftoraw&
@iff_naar_img.tiff(0)
CASE tiffraw2&
IF @fileselect("Convert TIFF","TIF")
@tiff_to_aim(file$)
ENDIF
CASE neoraw&
IF @fileselect("Convert NEO+RST","RST")
IF EXIST(@no_ext$("NEO"))
may&=199
PRINT "EConverting...";
OPEN "I",#1,@no_ext$("NEO")   ! Picture file
OPEN "I",#2,file$             ! Raster-file
DIM palet$(200)
DO WHILE NOT EOF(#2)
  y&=INP&(#2)
  palet$(y&)=INPUT$(32,#2)
LOOP
RELSEEK #1,6     ! Naar palet-begin van NEO-pict.
dummy$=INPUT$(32,#1)
FOR y&=0 TO may&
  IF palet$(y&)=""
    palet$(y&)=dummy$
  ELSE
    dummy$=palet$(y&)
  ENDIF
NEXT y&
DIM buffer%(8000),buffer|(1280),kleur%(15)
buffer2%=V:buffer|(0)
buffer3%=ADD(buffer2%,320)
buffer4%=V:kleur%(0)
buffer%=V:buffer%(0)
SEEK #1,128
BGET #1,buffer%,32000
CLOSE
@create_raw(320,200)
FOR y&=0 TO may&
  @counter(15,1,y&)
  FOR lus&=0 TO 15
    dummy&=CVI(MID$(palet$(y&),ADD(SHL(lus&,1),1),2))
    rood&=AND(SHR(dummy&,8),&X111)
    groen_geel&=AND(SHR(dummy&,4),&X111)
    blauw&=AND(dummy&,&X111)
    kleur%(lus&)=ADD(ADD(SHL(rood&,21),SHL(groen_geel&,13)),SHL(blauw&,5))
  NEXT lus&
  ~C:ptst_4%(L:buffer%,L:buffer2%)
  ~C:palet_to_rgb%(L:buffer2%,L:buffer3%,L:buffer4%,W:319)
  BPUT #2,buffer3%,960
NEXT y&
CLOSE
ELSE
ALERT 3,"The file '"+LEFT$(default_name$,INSTR(default_name$,"."))+"NEO' |does not exist!",1," Cancel ",dummy&
ENDIF
ENDIF
CASE aimraw&
ALERT 0,"Convert:|1) Grayscale AIM (.IM) |2) Color AIM (.COL)",0," IM | COL | Cancel ",dummy&
IF dummy&<>3
CLS
SELECT dummy&
CASE 1
max&=256
may&=256
ok!=@fileselect("Convert AIM .IM","IM")
CASE 2
max&=128
may&=128
ok!=@fileselect("Convert AIM .COL","COL")
ENDSELECT
IF ok!
IF EXIST(@no_ext$("HD"))
  OPEN "I",#1,@no_ext$("HD")
  RELSEEK #1,22
  max&=INP&(#1)
  may&=INP&(#1)
  CLOSE
ENDIF
DEC max&
DEC may&
SELECT dummy&
CASE 1                  ! IM
  DIM buffer|(max&,may&)
  BLOAD file$,V:buffer|(0,0)
  IF @check_enough_memory(49152)
    DIM data_buffer%(7999)
    LET data_buffer%=V:data_buffer%(0)
    dummy1%=V:buffer|(0,0)
    dummy1&=ADD(MIN(max&,WORK_OUT(0)),1)
    dummy2&=ADD(MIN(may&,WORK_OUT(1)),1)
    FOR lus&=1 TO dummy2&
      ~C:dither_bw%(L:dummy1%,L:data_buffer%,W:SUB(SHR(dummy1&,4),1))
      ADD dummy1%,ADD(max&,1)
      ADD data_buffer%,SHR(ADD(dummy1&,7),3)
    NEXT lus&
    @put_on_screen(V:data_buffer%(0),dummy1&,dummy2&,1)
  ENDIF
CASE 2                  ! COL
  DIM buffer|(max&,may&,3)
  BLOAD file$,V:buffer|(0,0,0)
ENDSELECT
PRINT AT(1,1);"Converting... "
@create_raw(ADD(max&,1),ADD(may&,1))
FOR y&=0 TO may&
  @counter(15,1,y&)
  SELECT dummy&
  CASE 1                ! IM
    FOR x&=0 TO max&
      OUT #2,buffer|(x&,y&),buffer|(x&,y&),buffer|(x&,y&)
    NEXT x&
  CASE 2                ! COL
    FOR x&=0 TO max&
      OUT #2,buffer|(x&,y&,1),buffer|(x&,y&,2),buffer|(x&,y&,3)
    NEXT x&
  ENDSELECT
NEXT y&
ENDIF
ENDIF
CLOSE
CASE canceraw&
EXIT IF TRUE
DEFAULT
IF @fileselect("Convert RAW","RAW")
SELECT dummy&
CASE rawtiff&
@open_raw
@ofo("TIF",2,0)
INT{ADD(true_color_tiff_header%,18)}=max&
INT{ADD(true_color_tiff_header%,30)}=may&
BPUT #2,true_color_tiff_header%,374
@copy(1,2,bytes%)
CLOSE #2
CASE rawtobw&
@enable(palet%,ignorepa&,3)
@choose_palet_interpretation(rood&,groen_geel&,blauw&,div&)
@disable(palet%,ignorepa&,3)
PRINT "EConverting..."
@open_raw                         ! Open RAW
@ofo("B&W",2,0)
PRINT #2,"B&W256";
OUT& #2,max&,may&
FOR y&=1 TO may&
  @counter(15,1,y&)
  FOR x&=1 TO max&
    OUT #2,DIV(ADD(ADD(MUL(INP(#1),rood&),MUL(INP(#1),groen_geel&)),MUL(INP(#1),blauw&)),div&)
  NEXT x&
NEXT y&
CLOSE
CASE rawtops&           ! RAW to PostScript!
@form_do(selectps%,dummy&)
IF dummy&<>cancelps&
  ok!=TRUE
  IF dummy&=printps&
    DO WHILE BIOS(8,0)=0
      ALERT 1,"Your printer is not |receiving data!",1," Retry | Cancel ",dummy2&
    LOOP UNTIL dummy2&=2
    IF dummy2&=2
      CLR ok!
    ENDIF
  ENDIF
  IF ok!
    @enable(palet%,ignorepa&,3)
    @choose_palet_interpretation(rood&,groen_geel&,blauw&,div&)
    @disable(palet%,ignorepa&,3)
    PRINT "EConverting..."
    @open_raw
    SELECT dummy&
    CASE pstofile&
      @ofo("PS",2,0)
    CASE printps&
      OPEN "O",#2,"PRN:"
    ENDSELECT
    PRINT #2,"%!PS-Adobe-1.0
";
    PRINT #2,"%%Title: "+default_name$;"
";
    PRINT #2,"%%Creator: Stadegas, "+version$;"
";
    PRINT #2,"%%CreationDate: "+DATE$+"  "+TIME$;"
";
    PRINT #2,"%%Pages: 1
";
    PRINT #2,"%%EndComments
";
    PRINT #2,"/picstr "+STR$(max&)+" string def
";
    PRINT #2,"50 140 translate
";
    PRINT #2,STR$(SHR(max&,1))+" "+STR$(SHR(may&,1))+" scale
";
    PRINT #2,STR$(max&)+" "+STR$(may&)+" 8
";
    PRINT #2,"["+STR$(max&)+" 0 0 -"+STR$(max&)+" 0 "+STR$(max&)+"]
";
    PRINT #2,"{currentfile
";
    PRINT #2,"picstr readhexstring pop}
";
    PRINT #2,"image
";
    CLR dummy$
    FOR y&=1 TO may&
      @counter(15,1,y&)
      FOR x&=1 TO max&
        byte|=DIV(ADD(ADD(MUL(INP(#1),rood&),MUL(INP(#1),groen_geel&)),MUL(INP(#1),blauw&)),div&)
        dummy$=dummy$+HEX$(byte|,2)
        IF LEN(dummy$)=64
          PRINT #2,dummy$;"
";
          CLR dummy$
        ENDIF
      NEXT x&
    NEXT y&
    IF LEN(dummy$)
      PRINT #2,dummy$;"
";
    ENDIF
    PRINT #2,"showpage
";CHR$(4);"
";
    CLOSE
  ENDIF
ENDIF
CASE rawiff&
@raw__iff
CASE rawtoimg&
@open_raw
dummy1&=MUL(max&,3)
DIM buffer|(2,SUB(max&,1))
bytes_per_line&=SHR(ADD(max&,7),3)
DIM buffer%(SHR(MUL(bytes_per_line&,may&),2))
PRINT "E";AT(9,5);"Converting..."
@dither_rgb(SUB(max&,1))
buffer2%=V:buffer%(0)
@put_on_screen(buffer2%,max&,may&,1)
@create_img(buffer2%,max&,may&,1)
CASE rawneo&
DIM buffer|(320)
DIM buffer%(8000)
@redu_raw(file$,320,200)
PRINT AT(1,5);"Pass 2: Converting... "
buffer1%=V:buffer|(0)
buffer2%=V:buffer%(0)
file$=LEFT$(file$,RINSTR(file$,"."))
@ofo("RST",2,0)
@ofo("NEO",3,1)
max_&=max&
may_&=may&
PRINT AT(1,6);"Resolution: ";max_&;"x";may_&
max&=SUB(max_&,1)
may&=SUB(may_&,1)
max.&=MIN(max&,319)
may.&=MIN(may&,199)
'
ALERT 0,"Use STE-palet? ",SUB(2,ABS(STE?))," Yes | No | Cancel ",dummy&
HIDEM
IF dummy&<>3
  ste!=(dummy&=1)
  DIM palet$(200)
  IF ste!
    DIM kleuren_teller&(4096),kleuren_tabel|(4096),color&(ADD(max&,3)),c!(4096)
    DIM look_up&(4096)
    FOR x&=0 TO 4095
      look_up&(x&)=@ste_palet_color(x&)
    NEXT x&
  ELSE
    DIM look_up&(512)
    FOR x&=0 TO 511
      look_up&(x&)=ADD(ADD(AND(SHL(x&,2),&X11100000000),AND(SHL(x&,1),&X1110000)),AND(x&,&X111))
    NEXT x&
    DIM kleuren_teller&(512),kleuren_tabel|(512),color&(ADD(max&,3)),c!(512)
  ENDIF
  '
  DIM n0&(15),n1&(15)
  '
  FOR lus&=0 TO 15
    palet$=palet$+MKI$(DPEEK(ADD(&HFF8240,SHL(lus&,1))))
  NEXT lus&
  PRINT AT(1,7);"Colors:"
  FOR y&=0 TO may.&
    PRINT AT(23,5);SUB(may.&,y&);" "
    IF ste!
      min_s&=4095
    ELSE
      min_s&=511
    ENDIF
    CLR max_s&,t&
    FOR x&=0 TO max&
      IF ste!
        c&=ADD(ADD(SHL(AND(INP(#1),&X11110000),4),AND(INP(#1),&X11110000)),SHR(INP(#1),4))
      ELSE
        c&=ADD(ADD(AND(SHL(INP(#1),1),&X111000000),AND(SHR(INP(#1),2),&X111000)),SHR(INP(#1),5))
      ENDIF
      INC kleuren_teller&(c&)
      max_s&=MAX(c&,max_s&)
      min_s&=MIN(c&,min_s&)
      LET color&(x&)=c&
    NEXT x&
    '
    FOR x&=min_s& TO max_s&
      IF kleuren_teller&(x&)
        INC t&
      ENDIF
    NEXT x&
    IF t&<17                      ! (16+1)
      IF t&<16
        t&=1
        palet$=MKI$(0)
      ELSE
        CLR t&,palet$
      ENDIF
      FOR x&=min_s& TO max_s&
        IF kleuren_teller&(x&)
          kleuren_tabel|(x&)=BYTE(t&)
          kleuren_teller&(x&)=0
          INC t&
          palet$=palet$+MKI$(look_up&(x&))
        ELSE
          kleuren_tabel|(x&)=0
        ENDIF
      NEXT x&
    ELSE
      CLR palet$
      ARRAYFILL n0&(),0
      ARRAYFILL n1&(),0
      FOR lus&=min_s& TO max_s&
        FOR n&=0 TO 15
          IF kleuren_teller&(lus&)>n0&(n&)
            INSERT n0&(n&)=kleuren_teller&(lus&)
            INSERT n1&(n&)=lus&
            EXIT IF TRUE
          ENDIF
        NEXT n&
        c!(lus&)=kleuren_teller&(lus&)
      NEXT lus&
      IF n1&(0)                       ! <>0, dus niet zwart
        FOR n&=1 TO 15
          IF n1&(n&)=0
            SWAP n1&(n&),n1&(0)
            EXIT IF TRUE
          ENDIF
        NEXT n&
      ENDIF
      FOR n&=0 TO 15
        kleuren_tabel|(n1&(n&))=BYTE(n&)
        c!(n1&(n&))=0
        palet$=palet$+MKI$(look_up&(n1&(n&)))
      NEXT n&
      FOR lus&=min_s& TO max_s&
        IF c!(lus&)
          IF kleuren_teller&(lus&)
            min&=32767
            FOR n&=0 TO 15
              dummy&=@licht(lus&,n1&(n&))
              IF dummy&<min&
                min&=dummy&
                min_&=n&
                EXIT IF dummy&=0
              ENDIF
            NEXT n&
            kleuren_tabel|(lus&)=min_&
            kleuren_teller&(lus&)=0
          ENDIF
          c!(lus&)=0
        ENDIF
      NEXT lus&
    ENDIF
    FOR x&=0 TO max.&
      buffer|(x&)=kleuren_tabel|(color&(x&))
    NEXT x&
    ~C:pset_4%(L:buffer1%,L:buffer2%)
    ADD buffer2%,160
    '
    palet$(y&)=palet$
    '
    IF y&=0
      OUT% #3,0               ! 0
      OUT& #3,0               ! Resolutie
      PRINT #3,LEFT$(palet$+STRING$(52,0),52);!Kleuranimatiespul, unknown, X/Y linksboven
      OUT& #3,320             ! Breedte
      OUT& #3,200             ! Hoogte
      PRINT #3,STRING$(66,0); ! Reserved
    ENDIF
    PRINT AT(9,7);t&;"  "
  NEXT y&
  BPUT #3,V:buffer%(0),32000
  CLR palet$
  FOR y&=0 TO 199
    IF palet$(y&)<>palet$
      palet$=palet$(y&)
      OUT& #2,y&
      PRINT #2,LEFT$(palet$+STRING$(32,0),32);
    ENDIF
  NEXT y&
  CLOSE
ELSE
  CLOSE
  @kill(@no_ext$("RST"))
  @kill(@no_ext$("NEO"))
ENDIF
@kill(@no_ext$("$$$"))
CASE rawtospc&
@raw_to_spc
CASE rawaim&
ALERT 0,"Convert to:|1) Grayscale AIM (.IM) |2) Color AIM (.COL)",0," IM | COL | Cancel ",dummy&
IF dummy&<>3
  @open_raw
  IF dummy&=2
    PRINT FRE(0)
    IF NOT @check_enough_memory(bytes%)
      ALERT 3,"Not enough memory for |this operation!",1," Cancel ",dummy&
    ELSE
      PRINT "EConverting..."
      @create_hd(max&,4)
      dummy&=MUL(may&,4)
      DEC max&
      DEC may&
      DIM p|(2,max&,may&)
      BGET #1,V:p|(0,0,0),bytes%
      CLOSE
      @ofo("COL",2,0)
      FOR y&=0 TO may&
        PRINT AT(15,1);dummy&;" "
        DEC dummy&
        FOR x&=0 TO max&
          OUT #2,p|(0,x&,y&)
        NEXT x&
      NEXT y&
      FOR n&=0 TO 2
        FOR y&=0 TO may&
          PRINT AT(15,1);dummy&;" "
          DEC dummy&
          FOR x&=0 TO max&
            OUT #2,p|(n&,x&,y&)
          NEXT x&
        NEXT y&
      NEXT n&
    ENDIF
  ELSE
    @enable(palet%,ignorepa&,3)
    @choose_palet_interpretation(rood&,groen_geel&,blauw&,div&)
    @disable(palet%,ignorepa&,3)
    PRINT "EConverting..."
    @create_hd(max&,1)
    @ofo("IM",2,0)
    FOR y&=1 TO may&
      @counter(15,1,y&)
      FOR x&=1 TO max&
        OUT #2,DIV(ADD(ADD(MUL(INP(#1),rood&),MUL(INP(#1),groen_geel&)),MUL(INP(#1),blauw&)),div&)
      NEXT x&
    NEXT y&
  ENDIF
ENDIF
ENDSELECT
ENDIF
ENDSELECT
CLOSE
LOOP
RETURN
> PROCEDURE raw__iff
ALERT 0,"Convert to Grayscale |or color-IFF?",2," Gray | Color | Cancel ",dummy&
IF dummy&=1
DO
@open_raw
CLOSE
CHAR{{OB_SPEC(raw2iff%,grayxres&)}}=STR$(max&,4)
CHAR{{OB_SPEC(raw2iff%,grayyres&)}}=STR$(may&,4)
@form_do(raw2iff%,dummy&)
EXIT IF dummy&=rwifgrca&
new_x&=VAL(CHAR{{OB_SPEC(raw2iff%,grayxres&)}})
new_y&=VAL(CHAR{{OB_SPEC(raw2iff%,grayyres&)}})
rood&=VAL(CHAR{{OB_SPEC(raw2iff%,rwifgraa&)}})
groen_geel&=VAL(CHAR{{OB_SPEC(raw2iff%,rwifgrab&)}})
blauw&=VAL(CHAR{{OB_SPEC(raw2iff%,rwifgrac&)}})
div&=ADD(ADD(rood&,groen_geel&),blauw&)
IF AND(OB_STATE(raw2iff%,gray8&),1)
planes&=3
and|=&X11100000
ELSE IF AND(OB_STATE(raw2iff%,gray16&),1)
planes&=4
and|=&X11110000
ELSE IF AND(OB_STATE(raw2iff%,gray64&),1)
planes&=6
and|=&X11111100
ELSE IF AND(OB_STATE(raw2iff%,gray256&),1)
planes&=8
and|=255
ENDIF
move|=BYTE(SUB(8,planes&))
ok!=TRUE
IF OR(new_x&<16,new_y&<16)
CLR ok!
ALERT 3,"New resolution not |large enough!",1," Cancel ",dummy&
ELSE IF OR(new_x&>max&,new_y&>may&)
CLR ok!
ALERT 3,"New resolution larger |than original!",1," Cancel ",dummy&
ELSE IF div&=0
CLR ok!
ALERT 3,"At least one of the R, G and B |factors must be more then 1!",1," Cancel ",dummy&
ENDIF
LOOP UNTIL ok!
IF dummy&=rwifgrok&
@redu_raw(file$,new_x&,new_y&)
PRINT AT(1,5);"Pass 2: Analyzing..."
'
bytes_per_line&=SHR(ADD(MUL(max&,planes&),7),3)
@ofo("IFF",2,0)
OUT% #2,CVL("FORM"),0,CVL("ILBM"),CVL("BMHD"),20
OUT& #2,max&,may&            ! X-res,Y-res
OUT% #2,0
OUT #2,BYTE(planes&),0                ! Bitpl., mask
OUT #2,1,0           ! compressie, Reserved
OUT& #2,0                     ! Transpartant kleur
OUT #2,10,11
OUT& #2,max&,may&             ! X-res,Y-res
OUT% #2,CVL("CAMG"),4,0
OUT% #2,CVL("CMAP")
OUT% #2,MUL(2^planes&,3)
FOR lus&=0 TO SUB(2^planes&,1)
IF planes&=8
lus|=BYTE(lus&)
ELSE
lus|=BYTE(SUB(SHL(ADD(lus&,1),move|),1))
ENDIF
OUT #2,lus|,lus|,lus|
NEXT lus&
OUT% #2,CVL("BODY")             ! body
total_bytes%=LOC(#2)
OUT% #2,0
'
DEC max&
DIM scan_line|(max&)
buffer%=V:scan_line|(0)
DIM one_plane|(max&)
buffer2%=V:one_plane|(0)
'
PRINT AT(1,5);"Pass 2: Converting... "
FOR y&=1 TO may&
@counter(23,5,y&)
FOR x&=0 TO max&
scan_line|(x&)=SHR(DIV(ADD(ADD(MUL(INP(#1),rood&),MUL(INP(#1),groen_geel&)),MUL(INP(#1),blauw&)),div&),move|)
NEXT x&
@put_one_iff_line(buffer%,buffer2%,ADD(max&,1),2)
NEXT y&
'
sluiten:
dummy%=LOC(#2)
length%=SUB(dummy%,ADD(total_bytes%,4))
SEEK #2,total_bytes%
OUT% #2,length%
SEEK #2,4
OUT% #2,SUB(dummy%,8)
SEEK #2,LOF(#2)
CLOSE
@kill(@no_ext$("$$$"))
PRINT AT(1,7);"Done!"
ENDIF
ELSE IF dummy&=2
DO
@open_raw
CLOSE
CHAR{{OB_SPEC(rawctiff%,colorxre&)}}=STR$(max&,4)
CHAR{{OB_SPEC(rawctiff%,coloryre&)}}=STR$(may&,4)
@form_do(rawctiff%,dummy&)
EXIT IF dummy&=caclrifr&
new_x&=VAL(CHAR{{OB_SPEC(rawctiff%,colorxre&)}})
new_y&=VAL(CHAR{{OB_SPEC(rawctiff%,coloryre&)}})
error!=AND(OB_STATE(rawctiff%,error&),1)
extended!=AND(OB_STATE(rawctiff%,extended&),1)
IF AND(OB_STATE(rawctiff%,p16&),1)
planes&=4
palet|=1
ELSE IF AND(OB_STATE(rawctiff%,p32&),1)
planes&=5
palet|=2
ELSE IF AND(OB_STATE(rawctiff%,p256&),1)
planes&=8
palet|=3
ENDIF
move|=BYTE(SUB(8,planes&))
IF AND(OB_STATE(rawctiff%,c512&),1)
color|=1
and|=&X11100000
ELSE IF AND(OB_STATE(rawctiff%,c4096&),1)
color|=2
and|=&X11110000
ELSE IF AND(OB_STATE(rawctiff%,c262144&),1)
color|=3
and|=&X11111100
ELSE IF AND(OB_STATE(rawctiff%,c1677721&),1)
color|=4
and|=255
ENDIF
median!=AND(OB_STATE(rawctiff%,analmedi&),1)
random!=AND(OB_STATE(rawctiff%,random&),1)
ok!=TRUE
IF OR(new_x&<16,new_y&<16)
CLR ok!
ALERT 3,"New resolution not |large enough!",1," Cancel ",dummy&
ELSE IF OR(new_x&>max&,new_y&>may&)
CLR ok!
ALERT 3,"New resolution larger |than original!",1," Cancel ",dummy&
ELSE IF AND(random!,NOT extended!)
ALERT 3,"You haven't selected the |extended button, the output |will look awfull!| Continue?",2," Yes | No | Cancel ",dummy2&
SELECT dummy2&
CASE 2
CLR ok!
CASE 3
dummy&=caclrifr&
ENDSELECT
ENDIF
LOOP UNTIL ok!
IF dummy&=okclrifr&
@redu_raw(file$,new_x&,new_y&)
PRINT AT(1,5);"Pass 2: Analyzing..."
IF median!
kleuren&=255
LET colors&=256
ELSE
LET colors&=2^planes&
kleuren&=SUB(colors&,1)
ENDIF
DIM kleur|(kleuren&,2)
DIM verschil%(kleuren&,3),r%(255),g%(255),b%(255)
DIM r|(255),g|(255),b|(255)
FOR lus&=0 TO 255
r|(lus&)=BYTE(lus&)
g|(lus&)=r|(lus&)
b|(lus&)=g|(lus&)
NEXT lus&
pixels%=MUL(max&,may&)
IF random!
dummy!=TRUE
extended!=TRUE
FOR y&=0 TO kleuren&
FOR x&=0 TO 2
  kleur|(y&,x&)=RANDOM(256)
NEXT x&
r%(y&)=ADD(ADD(SHL(kleur|(y&,0),16),SHL(kleur|(y&,1),8)),kleur|(y&,2))
NEXT y&
ELSE
FOR y&=0 TO SUB(may&,1)
@counter(22,5,y&)
IF median!
  FOR x&=0 TO SUB(max&,1)
    r|=AND(INP(#1),and|)
    g|=AND(INP(#1),and|)
    b|=AND(INP(#1),and|)
    ADD total_r%,r|
    ADD total_g%,g|
    ADD total_b%,b|
    max|=MAX(r|,g|,b|)
    IF max|
      gray|=DIV(MUL(MUL(MAX(r|,1),MAX(g|,1)),MAX(b|,1)),MUL(max|,4080))
      ADD gray|,SUB(SHL(DIV(ADD(ADD(r|,g|),b|),47),4),1)
    ELSE
      CLR gray|
    ENDIF
    ADD verschil%(gray|,0),r|
    ADD verschil%(gray|,1),g|
    ADD verschil%(gray|,2),b|
    INC verschil%(gray|,3)
    INC r%(r|)
    INC g%(g|)
    INC b%(b|)
  NEXT x&
ELSE
  FOR x&=0 TO SUB(max&,1)
    r|=AND(INP(#1),and|)
    g|=AND(INP(#1),and|)
    b|=AND(INP(#1),and|)
    ADD total_r%,r|
    ADD total_g%,g|
    ADD total_b%,b|
    gray|=DIV(ADD(ADD(r|,g|),b|),3)
    gray_|=SHR(gray|,move|)
    ADD verschil%(gray_|,0),SUB(r|,gray|)
    ADD verschil%(gray_|,1),SUB(g|,gray|)
    ADD verschil%(gray_|,2),SUB(b|,gray|)
    INC verschil%(gray_|,3)
    INC r%(r|)
    INC g%(g|)
    INC b%(b|)
  NEXT x&
ENDIF
NEXT y&
'
IF extended!
middle_r|=DIV(total_r%,pixels%)
middle_g|=DIV(total_g%,pixels%)
middle_b|=DIV(total_b%,pixels%)
a&=-1+2^INT(LOG(colors&)/LOG(2)+1)
DO
  a&=SHR(a&,1)
  FOR j&=1 TO SUB(colors&,a&)
    FOR i&=j& TO 1 STEP SUB(0,a&)
      i_&=SUB(i&,1)
      ia&=ADD(i_&,a&)
      EXIT IF r%(ia&)>=r%(i_&)
      SWAP r%(ia&),r%(i_&)
      SWAP r|(ia&),r|(i_&)
    NEXT i&
    FOR i&=j& TO 1 STEP SUB(0,a&)
      i_&=SUB(i&,1)
      ia&=ADD(i_&,a&)
      EXIT IF g%(ia&)>=g%(i_&)
      SWAP g%(ia&),g%(i_&)
      SWAP g|(ia&),g|(i_&)
    NEXT i&
    FOR i&=j& TO 1 STEP SUB(0,a&)
      i_&=SUB(i&,1)
      ia&=ADD(i_&,a&)
      EXIT IF b%(ia&)>=b%(i_&)
      SWAP b%(ia&),b%(i_&)
      SWAP b|(ia&),b|(i_&)
    NEXT i&
  NEXT j&
LOOP UNTIL a&=1
dummy2&=SQR(colors&)
ENDIF
'
FOR y&=0 TO kleuren&
lus&=y&*(255/kleuren&)
IF verschil%(y&,3)
  FOR x&=0 TO 2
    IF OR(median!,random!)
      dummy&=verschil%(y&,x&)/verschil%(y&,3)
    ELSE
      dummy&=ADD(lus&,verschil%(y&,x&)/verschil%(y&,3))
    ENDIF
    IF dummy&<0
      kleur|(y&,x&)=0
    ELSE IF dummy&>255
      kleur|(y&,x&)=255
    ELSE
      kleur|(y&,x&)=BYTE(dummy&)
    ENDIF
  NEXT x&
ELSE
  IF extended!
    dummy!=TRUE
    SELECT mode|
    CASE 0 TO 2
      kleur|(y&,mode|)=255
    DEFAULT
      kleur|(y&,0)=r|(dummy2&)
      kleur|(y&,1)=g|(dummy2&)
      kleur|(y&,2)=b|(dummy2&)
      dummy2&=AND(ADD(dummy2&,1),kleuren&)
    ENDSELECT
    INC mode|
  ENDIF
ENDIF
IF extended!
  r%(y&)=ADD(ADD(SHL(kleur|(y&,0),16),SHL(kleur|(y&,1),8)),kleur|(y&,2))
ENDIF
NEXT y&
ENDIF
IF NOT dummy!
CLR extended!
ELSE
PRINT AT(22,5);"Extended Dithering used! (";mode|;" extended palet-entrys)"
ENDIF
SEEK #1,0
~INP%(#1)
'
bytes_per_line&=SHR(ADD(MUL(max&,planes&),7),3)
@ofo("IFF",2,0)
OUT% #2,CVL("FORM"),0,CVL("ILBM"),CVL("BMHD"),20
OUT& #2,max&,may&            ! X-res,Y-res
OUT% #2,0
OUT #2,BYTE(planes&),0                ! Bitpl., mask
OUT #2,1,0           ! compressie, Reserved
OUT& #2,0                     ! Transpartant kleur
OUT #2,10,11
OUT& #2,max&,may&             ! X-res,Y-res
OUT% #2,CVL("CAMG"),4,0
OUT% #2,CVL("CMAP")
OUT% #2,MUL(colors&,3)
FOR lus&=0 TO kleuren&
OUT #2,kleur|(lus&,0),kleur|(lus&,1),kleur|(lus&,2)
NEXT lus&
OUT% #2,CVL("BODY")             ! body
total_bytes%=LOC(#2)
OUT% #2,0
'
DEC max&
DIM scan_line|(max&)
buffer%=V:scan_line|(0)
DIM one_plane|(max&)
buffer2%=V:one_plane|(0)
'
PRINT AT(1,6);"Pass 3: Converting... "
buffer3%=V:r%(0)
FOR y&=1 TO may&
@counter(23,6,y&)
IF OR(OR(error!,extended!),random!)
CLR rood_error&,groen_error&,blauw_error&
FOR x&=0 TO max&
  true_r|=INP(#1)
  r|=AND(true_r|,and|)
  true_g|=INP(#1)
  g|=AND(true_g|,and|)
  true_b|=INP(#1)
  b|=AND(true_b|,and|)
  IF NOT error!
    '               IF extended!
    scan_line|(x&)=C:zoek_beste_rgb%(L:buffer3%,W:b|,W:ADD(SHL(g|,8),r|),W:colors&)
  ELSE IF random!
    '   IF extended!
    scan_line|(x&)=C:zoek_beste_rgb%(L:buffer3%,W:b|,W:ADD(SHL(g|,8),r|),W:colors&)
  ELSE
    IF extended!
      gray|=C:zoek_beste_rgb%(L:buffer3%,W:AND(MAX(MIN(ADD(b|,blauw_error&))),and|),W:ADD(SHL(AND(MAX(MIN(ADD(g|,groen_error&))),and|),8),AND(MAX(MIN(ADD(r|,rood_error&))),and|)),W:colors&)
      scan_line|(x&)=gray|
      rood_error&=WORD(SUB(true_r|,kleur|(gray|,0)))
      groen_error&=WORD(SUB(true_g|,kleur|(gray|,1)))
      blauw_error&=WORD(SUB(true_b|,kleur|(gray|,2)))
    ELSE
      gray|=SHR(DIV(ADD(MAX(MIN(ADD(r|,rood_error&),255),0),ADD(MAX(MIN(ADD(g|,groen_error&),255),0),MAX(MIN(ADD(b|,blauw_error&),255),0))),3),move|)
      scan_line|(x&)=gray|
      rood_error&=WORD(SUB(true_r|,kleur|(gray|,0)))
      groen_error&=WORD(SUB(true_g|,kleur|(gray|,1)))
      blauw_error&=WORD(SUB(true_b|,kleur|(gray|,2)))
    ENDIF
  ENDIF
NEXT x&
ELSE
'
' Hoezo onzinnig? :-)
'
IF EVEN(y&)
  PRINT AT(40,13);"p!q"
ELSE
  PRINT AT(40,13);" "
ENDIF
'
'
FOR x&=0 TO max&
  r|=INP(#1)
  g|=INP(#1)
  b|=INP(#1)
  max|=MAX(r|,g|,b|)
  IF max|
    gray|=DIV(MUL(MUL(MAX(r|,1),MAX(g|,1)),MAX(b|,1)),MUL(max|,4080))
    scan_line|(x&)=ADD(gray|,SHL(DIV(ADD(ADD(r|,g|),b|),48),4))
  ELSE
    scan_line|(x&)=0
  ENDIF
NEXT x&
ENDIF
@put_one_iff_line(buffer%,buffer2%,ADD(max&,1),2)
NEXT y&
GOTO sluiten                      ! Gatver! Wat ongestructureerd!
ENDIF
ENDIF
RETURN
> PROCEDURE dither_rgb(max&)
no_rebuild!=TRUE
DO
@form_do(floydste%,dummy&)
floyd_steinberg_intensity&=VAL(CHAR{{OB_SPEC(floydste%,intensit&)}})
LOOP UNTIL floyd_steinberg_intensity&
DIM scan_line|(max&)
buffer1%=V:buffer|(0,0)
dummy2&=SUB(SHR(max&,4),1)
FOR y&=1 TO may&
@counter(23,5,y&)
BGET #1,buffer1%,dummy1&
@floyd_steinberg_dithering(max&)
buffer2%=ADD(V:buffer%(0),MUL(SUB(y&,1),bytes_per_line&))
NEXT y&
CLOSE
RETURN
> PROCEDURE redu_raw(file$,max_res&,may_res&)
PRINT "EPass 1: resizing picture to fit..."
@open_raw
IF OR(max&>max_res&,may&>may_res&)
PRINT "Old resolution: ";max&;"x";may&
xredu&=INT(max&/max_res&+0.9)
yredu&=INT(may&/may_res&+0.9)
redu&=MAX(xredu&,yredu&)
color_div&=redu&*redu&
mx_&=INT(max&/redu&)
mx&=mx_&*redu&
DIM rood&(mx&),groen_geel&(mx&),blauw&(mx&)
may&=INT(may&/redu&)
my&=may&*redu&
PRINT "New resolution: ";mx_&;"x";may&
PRINT "Reduction: ";redu&
skip&=MUL(SUB(max&,mx&),3)
'
@ofo("$$$",2,0)
FOR y&=1 TO may&
PRINT AT(36,1);SUB(may&,y&);" "
ARRAYFILL rood&(),0
ARRAYFILL groen_geel&(),0
ARRAYFILL blauw&(),0
FOR y_&=1 TO redu&
FOR x&=1 TO mx_&
FOR x_&=1 TO redu&
  ADD rood&(x&),INP(#1)
  ADD groen_geel&(x&),INP(#1)
  ADD blauw&(x&),INP(#1)
NEXT x_&
NEXT x&
IF skip&
RELSEEK #1,skip&
ENDIF
NEXT y_&
FOR x&=1 TO mx_&
OUT #2,BYTE(DIV(rood&(x&),color_div&))
OUT #2,BYTE(DIV(groen_geel&(x&),color_div&))
OUT #2,BYTE(DIV(blauw&(x&),color_div&))
NEXT x&
NEXT y&
CLOSE
OPEN "I",#1,@no_ext$("$$$")
max&=mx_&
ENDIF
' Max& en May& zijn nu al goed.
RETURN
> FUNCTION ste_palet_color(a&)
@rgb(a&,rood&,groen_geel&,blauw&)
RETURN ADD(ADD(SHL(@ste(rood&),8),SHL(@ste(groen_geel&),4)),@ste(blauw&))
ENDFUNC
> FUNCTION ste(a&)
RETURN ADD(SHL(a&,1),AND(SHL(a&,3),&X1000))
ENDFUNC
> FUNCTION licht(a&,b&)
@rgb(a&,r1&,g1&,b1&)
@rgb(b&,r2&,g2&,b2&)
RETURN ADD(ADD(SUB(r1&,r2&)^2,SUB(g1&,g2&))^2,SUB(b1&,b2&)^2)
ENDFUNC
> PROCEDURE rgb(a&,VAR rood&,groen_geel&,blauw&)
IF ste!
rood&=SHR(a&,8)
groen_geel&=AND(SHR(a&,4),&X1111)
blauw&=AND(a&,&X1111)
ELSE
rood&=SHR(a&,6)
groen_geel&=AND(SHR(a&,3),&X111)
blauw&=AND(a&,&X111)
ENDIF
RETURN
> PROCEDURE pic_to_x
IF @fileselect("Convert PIC","PIC")
OPEN "I",#1,file$
IF INP&(#1)=CVI("SC")
max&=INP&(#1)
may&=INP&(#1)
@form_do(iffimgpc%,dummy&)
SELECT dummy&
CASE toimg&
@ofo("IMG",2,0)
DIM buffer|(255)
buffer%=V:buffer|(0)
PRINT "EConverting a Handy Scanner Cameron-picture (PIC) to a GEM Image (IMG)..."
PRINT "Resolution: ";max&;"x";may&
OUT& #2,1,8,1,1,pixel_h&,pixel_w&,max&,may&
dummy%=phys%
SUB lof%,LOC(#1)
DO
SELECT INP(#1)
CASE 0
aantal&=INP(#1)
BGET #1,buffer%,aantal&
SUB lof%,ADD(aantal&,2)
OUT #2,128,aantal&
BPUT #2,buffer%,aantal&
DEFAULT
SUB lof%,3
pattern|=INP(#1)
aantal&=INP(#1)
IF AND(OR(pattern|=0,pattern|=255),aantal&<128)
OUT #2,OR(AND(pattern|,128),aantal&)
ELSE
OUT #2,0,aantal&,pattern|
ENDIF
ENDSELECT
LOOP WHILE lof%
DEFAULT
IF dummy&<>canceiip&
bytes%=MUL(SHR(ADD(max&,7),3),may&)
IF @check_enough_memory(bytes%)
DIM buffer%(SHR(bytes%,2))
buffer%=V:buffer%(0)
dummy%=bytes%
DO WHILE dummy%
x|=INP(#1)
n|=INP(#1)
SELECT x|
CASE 0
BGET #1,buffer%,n|
SUB dummy%,n|
DEFAULT
FOR lus&=1 TO WORD(x|)
  BYTE{buffer%}=n|
  INC buffer%
NEXT lus&
SUB dummy%,x|
ENDSELECT
LOOP
buffer%=V:buffer%(0)
@put_on_screen(buffer%,max&,may&,1)
SELECT dummy&
CASE paintbru&
@create_pcx(buffer%,max&,may&,1)
CASE iff&
@create_iff(buffer%,max&,may&,1)
ENDSELECT
ELSE
ALERT 3,"Not enough memory for |this operation!",1," Cancel ",dummy&
ENDIF
ENDIF
ENDSELECT
ELSE
ALERT 3,"Not a 'Handy Scanner- |Cameron' picture!",1," Cancel ",dummy&
ENDIF
ENDIF
CLOSE
RETURN
> PROCEDURE open_raw
LOCAL dummy&
OPEN "I",#1,file$
max&=INP&(#1)
may&=INP&(#1)
bytes%=MUL(MUL(max&,may&),3)
IF bytes%<>SUB(lof%,4)
SEEK #1,0                   ! 2 longs?
max&=WORD(INP%(#1))
may&=WORD(INP%(#1))
bytes%=MUL(MUL(max&,may&),3)
IF bytes%<>SUB(lof%,8)        ! ascii?
SEEK #1,0
CLR dummy$
DO
byte|=INP(#1)
dummy$=dummy$+CHR$(byte|)
LOOP UNTIL byte|=10
dummy&=INSTR(dummy$," ")
IF dummy&
max&=VAL(LEFT$(dummy$,dummy&))
may&=VAL(MID$(dummy$,ADD(dummy&,1)))
bytes%=MUL(MUL(max&,may&),3)
IF bytes%<>SUB(lof%,LEN(dummy$))
GOTO other                            ! Yuck
ENDIF
ELSE
other:
SEEK #1,0
max&=@winp
may&=@winp
bytes%=MUL(MUL(max&,may&),3)
IF bytes%<>SUB(lof%,4)
PRINT "An error will occure!"
' Ander alternatieven (MS-Long e.d.)
ENDIF
ENDIF
ENDIF
ENDIF
RETURN
> PROCEDURE create_raw(max&,may&)
no_rebuild!=TRUE
@form_do(rawforma%,dummy2&)
@ofo("RAW",2,0)
SELECT dummy2&
CASE straw&
OUT& #2,max&,may&
CASE msraw&
OUT #2,AND(max&,255),SHR(max&,8),AND(may&,255),SHR(may&,8)
CASE qrt&
PRINT #2,STR$(max&);" ";STR$(may&);"
";
ENDSELECT
RETURN
'
> PROCEDURE floyd_steinberg_dithering(max&)
DIM ac0%(ADD(max&,2))
LET direction!=NOT direction!
IF direction!                           ! rechts -> links
FOR x&=max& DOWNTO 0
intens%=DIV(MUL(ADD(ADD(MUL(buffer|(0,x&),3),MUL(buffer|(1,x&),5)),SHL(buffer|(2,x&),1)),floyd_steinberg_intensity&),500)
x_&=ADD(x&,1)
e2%=ADD(intens%,ac0%(x_&))
e1%=SUB(e2%,768)
IF ABS(e1%)<ABS(e2%)
error%=e1%
scan_line|(x&)=0
ELSE
error%=e2%
scan_line|(x&)=255
ENDIF
ADD ac0%(x&),DIV(MUL(7,error%),16)
NEXT x&
ELSE
FOR x&=0 TO max&
intens%=DIV(MUL(ADD(ADD(MUL(buffer|(0,x&),3),MUL(buffer|(1,x&),5)),SHL(buffer|(2,x&),1)),floyd_steinberg_intensity&),500)
x_&=ADD(x&,1)
e2%=ADD(intens%,ac0%(x_&))
e1%=SUB(e2%,768)
IF ABS(e1%)<ABS(e2%)
error%=e1%
scan_line|(x&)=0
ELSE
error%=e2%
scan_line|(x&)=255
ENDIF
ADD ac0%(ADD(x_&,1)),DIV(MUL(7,error%),16)
NEXT x&
ENDIF
buffer2%=ADD(V:buffer%(0),MUL(SUB(y&,1),bytes_per_line&))
IF EVEN(buffer2%)
~C:get_1_bit%(L:V:scan_line|(0),L:buffer2%,W:1,W:max&)
ELSE
~C:get_1_bit%(L:V:scan_line|(0),L:ADD(buffer2%,1),W:1,W:max&)
BMOVE ADD(buffer2%,1),buffer2%,bytes_per_line&
ENDIF
ERASE ac0%()
RETURN
'
> PROCEDURE gif_2_raw
DIM powers&(8),prefix&(4096),suffix&(4096),outcode&(1024)
DIM maxcodes&(12),powers2&(16)
'
DIM kleur|(255,3)
RESTORE gif_2_raw_data
FOR a&=1 TO 8
powers&(a&)=2^(a&-1)
NEXT a&
gif_2_raw_data:
DATA 4,8,16,&H20,&h40,&H80,&H100,&h200,&H400,&H800,&H1000,8192
FOR a&=0 TO 11
READ maxcodes&(a&)
NEXT a&
DATA 1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384
FOR a&=0 TO 14
READ powers2&(a&)
NEXT a&
IF @fileselect("Convert GIF","GIF")
OPEN "I",#1,file$
@ofo("RAW",2,0)
a$=INPUT$(6,#1)
PRINT "EReading image: ";file$
PRINT "Header: ";a$
totalx&=@winp
totaly&=@winp
PRINT "Resolution: ";totalx&,totaly&
a&=INP(#1)
bitspixel&=ADD(AND(a&,7),1)
background&=INP(#1)
PRINT "Nul: ";INP(#1)
PRINT "Colors: ";2^bitspixel&
PRINT "Background: ";background&
IF WORK_OUT(13)=2
mono!=TRUE
ELSE
CLR mono!
ENDIF
FOR a&=0 TO SUB(2^bitspixel&,1)
FOR n&=0 TO 2
kleur|(a&,n&)=INP(#1)
NEXT n&
kleur|(a&,3)=DIV(ADD(ADD(kleur|(a&,0),kleur|(a&,1)),kleur|(a&,2)),3)
IF AND(a&<WORK_OUT(13),NOT mono!)
SETCOLOR a&,kleur|(a&,0),kleur|(a&,1),kleur|(a&,2)
ENDIF
NEXT a&
'
DO WHILE INP(#1)<>ASC(",")
PRINT "pGIF-Extension-block: q";
PRINT "Type: ";INP(#1)            ! Command-Type
PRINT "Data: ";
aantal|=INP(#1)
DO WHILE aantal|
PRINT INPUT$(aantal|,#1);
aantal|=INP(#1)
LOOP
LOOP
'
xstart&=@winp
ystart&=@winp
xlength&=@winp
ylength&=@winp
PRINT "Resolution: ";xlength&;"x";ylength&
xend&=xstart&+xlength&-1
yend&=ystart&+ylength&-1
a&=INP(#1)
IF AND(a&,128)=8
PRINT "Loading local color-map..."
FOR a&=0 TO SUB(2^bitspixel&,1)
FOR n&=0 TO 2
kleur|(a&,n&)=INP(#1)
NEXT n&
kleur|(a&,3)=DIV(ADD(ADD(kleur|(a&,0),kleur|(a&,1)),kleur|(a&,2)),3)
IF a&<WORK_OUT(13) AND (NOT mono!)
SETCOLOR a&,kleur|(a&,0),kleur|(a&,1),kleur|(a&,2)
ENDIF
NEXT a&
ELSE IF AND(a&,64)=64
PRINT "Interlaced, you need ";MUL(xlength&,ylength&);"bytes free memory."
interlaced!=TRUE
IF NOT @check_enough_memory(MUL(xlength&,ylength&))
ALERT 0,"Not enough memory! ",1," Exit ",dummy&
END
ELSE
DIM screen|(SUB(xlength&,1),SUB(ylength&,1))
ENDIF
ELSE
CLR interlaced!
ENDIF
PRINT #2,STR$(xlength&);" ";STR$(ylength&);"
";                  ! Resolutie
bytebuffer&=INP(#1)
codesize&=bytebuffer&
PRINT "Codesize: ";codesize&
clearcode&=powers2&(codesize&)
PRINT "Clearcode: ";clearcode&
eofcode&=clearcode&+1
PRINT "Eofcode: ";eofcode&
firstfree&=clearcode&+2
PRINT "Firstfree: ";firstfree&
freecode&=firstfree&
INC codesize&
initcodesize&=codesize&
maxcode&=maxcodes&(SUB(codesize&,2))
PRINT "Maxcode: ";maxcode&
bitmask&=2^bitspixel&-1
PRINT "Bitmask: ";bitmask&
'
bytebuffer&=INP(#1)
blocklength&=ADD(bytebuffer&,1)
bitsin&=7
CLR outcount&,num&,pass&
x&=xstart&
y&=ystart&
'
DEC ylength&
t%=TIMER
DO
'
CLR code&                                 ! code&=@readcode
FOR aa&=0 TO SUB(codesize&,1)                             ! ------+
INC bitsin&                                             !       |
IF bitsin&=8                                            !       |
tempchar&=INP(#1)                                     !       |
CLR bitsin&                                           !       |
INC num&                                              !       |
IF num&=blocklength&                                  !       |
blocklength&=tempchar&                              !      \|/
tempchar&=INP(#1)                                   !   Read-Code
CLR num&                                            !      /|\
ENDIF                                                 !       |
ENDIF                                                   !       |
ADD code&,SHL(AND(SHR(tempchar&,bitsin&),1),aa&)        !       |
NEXT aa&                                                  ! ------+
'
IF code&<>eofcode&
IF code&=clearcode&
codesize&=initcodesize&
maxcode&=maxcodes&(SUB(codesize&,2))
freecode&=firstfree&
'
CLR curcode&
FOR aa&=0 TO SUB(codesize&,1)
INC bitsin&
IF bitsin&=8
tempchar&=INP(#1)
CLR bitsin&
INC num&
IF num&=blocklength&
blocklength&=tempchar&
tempchar&=INP(#1)
CLR num&
ENDIF
ENDIF
ADD curcode&,SHL(AND(SHR(tempchar&,bitsin&),1),aa&)
NEXT aa&
'
oldcode&=curcode&
finchar&=AND(curcode&,bitmask&)
@plot(finchar&)
ELSE
curcode&=code&
incode&=code&
IF code&>=freecode&
curcode&=oldcode&
outcode&(outcount&)=finchar&
INC outcount&
ENDIF
IF curcode&>bitmask&
DO
outcode&(outcount&)=suffix&(curcode&)
INC outcount&
curcode&=prefix&(curcode&)
LOOP UNTIL curcode&<=bitmask&
ENDIF
finchar&=AND(curcode&,bitmask&)
outcode&(outcount&)=finchar&
FOR i&=outcount& DOWNTO 0
@plot(outcode&(i&))
NEXT i&
CLR outcount&
prefix&(freecode&)=oldcode&
suffix&(freecode&)=finchar&
oldcode&=incode&
INC freecode&
IF freecode&>=maxcode&
IF codesize&<12
INC codesize&
maxcode&=SHL(maxcode&,1)
ENDIF
ENDIF
ENDIF
ENDIF
LOOP UNTIL code&=eofcode&
IF interlaced!
PRINT "Writing picture..."
FOR y&=0 TO ylength&
PRINT AT(1,18);SUB(ylength&,y&);"K";
FOR x&=0 TO SUB(xlength&,1)
kleur|=screen|(x&,y&)
OUT #2,kleur|(kleur|,0),kleur|(kleur|,1),kleur|(kleur|,2)
NEXT x&
NEXT y&
ENDIF
CLOSE
PRINT CHR$(13);"Took: ";SUB(TIMER,t%)/200;" seconds."
PRINT "Done!"
ENDIF
not_load:
ERASE powers&(),prefix&(),suffix&(),outcode&(),maxcodes&(),powers2&(),codemask&(),kleur|(),screen|()
RETURN
> PROCEDURE plot(a&)
PSET x&,y&,SUB(1,a&)
IF interlaced!
screen|(x&,y&)=BYTE(a&)
ELSE
OUT #2,kleur|(a&,0),kleur|(a&,1),kleur|(a&,2)
ENDIF
INC x&
IF x&=xlength&
PRINT AT(18,1);SUB(ylength&,y&);"K";
CLR x&
IF interlaced!
SELECT pass&
CASE 0
ADD y&,8
IF y&=>ylength&
y&=4
INC pass&
ENDIF
CASE 1
ADD y&,8
IF y&=>ylength&
y&=2
INC pass&
ENDIF
CASE 2
ADD y&,4
IF y&=>ylength&
y&=1
INC pass&
ENDIF
CASE 3
ADD y&,2
ENDSELECT
ELSE
INC y&
ENDIF
ENDIF
RETURN
'
> PROCEDURE raw_to_spc
@redu_raw(file$,320,200) ! Had eigenlijk 320x199 moeten zijn.
DIM screen|(31999),line|(319),spcpal&(199,47),look_up!(319)
PRINT AT(1,5);"Pass 2: Converting... "
FOR x&=0 TO 319
IF AND(MOD(x&,20),251)=1
look_up!(x&)=TRUE
ENDIF
NEXT x&
FOR y&=1 TO SUB(may&,1)
PRINT AT(23,5);SUB(may&,y&);" ";
FOR x&=0 TO SUB(max&,1)
c&=ADD(ADD(AND(SHL(INP(#1),3),&X11100000000),AND(SHR(INP(#1),1),&X1110000)),SHR(INP(#1),5))
@putspec(x&,y&,c&)
NEXT x&
~C:pset_4%(L:V:line|(0),L:ADD(V:screen|(0),MUL(y&,160)))
ARRAYFILL line|(),0
NEXT y&
CLOSE
@ofo("SPU",1,0)
BPUT #1,V:screen|(0),32000
FOR y&=1 TO 199
PRINT AT(1,1);y&
FOR x&=0 TO 47
IF spcpal&(y&,x&)=-1
OUT& #1,0
ELSE
OUT& #1,spcpal&(y&,x&)
ENDIF
NEXT x&
NEXT y&
CLOSE
RETURN
> PROCEDURE putspec(x&,y&,c&)
IF y&
IF x&=0
FOR i&=1 TO 14
spcpal&(y&,i&)=-1
NEXT i&
FOR i&=17 TO 30
spcpal&(y&,i&)=-1
NEXT i&
FOR i&=33 TO 46
spcpal&(y&,i&)=-1
NEXT i&
CLR minpal&
maxpal&=16
ENDIF
IF look_up!(x&)
INC minpal&
INC maxpal&
ENDIF
diff&=&H777
FOR i&=minpal& TO SUB(maxpal&,1)
dummy&=spcpal&(y&,i&)
EXIT IF dummy&=c&
IF dummy&=-1
spcpal&(y&,i&)=c&
EXIT IF TRUE
ELSE
CLR d&
c1&=c&
FOR coldif&=3 DOWNTO 0
m&=SUB(AND(c1&,7),AND(dummy&,7))
ADD d&,MUL(m&,m&)
c1&=SHR(c1&,4)
dummy&=SHR(dummy&,4)
NEXT coldif&
IF d&<diff&
diff&=d&
idif&=i&
ENDIF
ENDIF
NEXT i&
IF i&<maxpal&
c&=AND(i&,15)
ELSE
c&=AND(idif&,15)
ENDIF
IF c&<15
line|(x&)=c&
ENDIF
ENDIF
RETURN
